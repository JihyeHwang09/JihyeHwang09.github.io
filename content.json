{"meta":{"title":"꿈꾸는 지구별 개발자, Phang","subtitle":"꿈꾸는 지구별 개발자, Phang's IT Blog","description":"Phang's IT Blog using Hexo","author":"Phang","url":"https://JihyeHwang09.github.io"},"pages":[],"posts":[{"title":"React 9일차","slug":"react9","date":"2019-02-28T14:33:59.000Z","updated":"2019-02-28T14:45:41.319Z","comments":true,"path":"2019/02/28/react9/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/28/react9/","excerpt":"","text":"제어되지 않는 컴포넌트제어되지 않는 컴포넌트는 진리의 원천(유일한 진리의 원천x)을 DOM에 두기 때문에,React를 사용한 코드와 사용하지 않은 코드를 통합하는 작업을 좀 더 쉽게 만들어줄 수 있습니다. 기본값 지정하기 value 속성을 이용하면, 제어되는 컴포넌트가 됨 defaultValue를 이용하면, 기본값을 주면서도 사용자가 편집 가능 (기본값도 지울 수 있음)제어되지 않는 컴포넌트 만드는 법 &lt;input type=&quot;checkbox&quot;&gt;와 &lt;input type=&quot;radio&quot;&gt; 엘리먼트는&#39;defaultChecked&#39; 어트리뷰트(제어되지 않는 컴포넌트이면서도 체크된 상태로 기본값 주고 싶을 때) &lt;select&gt;와 &lt;textarea&gt;는 ‘defaultValue’ 어트리뷰트를 지원합니다. The file input Tag cf) input type을 file로 주고, 속성을 multiple 주면 파일 여러 개 업로드 가능 입력받은 파일과 상호작용하기 위해서는 File API를 사용해야만 합니다.아래 예제는 submit 이벤트 핸들러 내에서 파일에 접근하기 위해 DOM node를 가리키는 ref를 생성하는 방법을 보여줍니다: 바로 아래 예제는 예전 ref 사용법임 cf) 비관적 업데이트 vs 낙관적 업데이트비관적 업데이트 - 사용자가 좀 기다려야함.낙관적 업데이트 - 서버와 통신에 실패했을 때 처리가 어려움 성능 최적화 리액트 개발 시 중요한 이슈 react는 setState가 일어난 컴포넌트의 모든 자식 컴포넌트를 다시 호출한다.–&gt; ( 모든 자식 컴포넌트의 render 메소드를 호출한다.)-&gt; 매번 새로 계산해야 한다.-&gt; 이 계산을 하는 게 느릴 수 있다.props와 state는 둘 다 객체임props와 state의 속성이 바뀌지 않았다면 render메소드를 다시 호출할 필요가 xrender함수는 순수함수(같은 입력 -&gt; 같은 출력) 불변성(PureComponent 실습 코드)key를 이용해서 상태를 초기화하는 예제 불변성을 유지할 수 있게하는 라이브러리immutable.jsimmutable.js 예시 코드 immer immer가 점점 뜨고 있음. 페이스북도 immer 사용을 권장 immer는 내장 객체와 내장 배열을 사용. -&gt; 이 라이브러리를 이용하면, 기존의 메소드를 사용하면서도 불변성을 유지할 수 있다. 비교조정 (Reconciliation) 피하기 shouldComponentUpdate 를 재정의하여 이러한 모든 것을 가속할 수 있습니다.이 함수의 기본 구현체는 ‘true’를 반환하고 React는 업데이트를 수행합니다. 123shouldComponentUpdate(nextProps, nextState) &#123; return true;&#125; 일부 상황에서 컴포넌트를 업데이트할 필요가 없는 경우shouldComponentUpdate 에서’false’ 를 반환하여이 컴포넌트 및 하위에서 호출하는 render()를 포함한 전체 렌더링 프로세스를 스킵할 수 있습니다. PureComponent에 shouldComponent가 내장되어 있는 것임 직접 shouldComponentUpdate를 세밀하게 만져도 된다. 비교조정 (Reconciliation) React는 선언적 API를 제공하기 때문에 갱신이 될 때에 정확히 무엇이 바뀌었는지를 걱정할 필요가 없습니다. 동기 다른 타입을 가진 두 엘리먼트는 다른 트리를 만들어 낼 것이다. ex) ‘div를 table로 고쳐줘라.’ 라고 하면, 엘리먼트의 타입을 바꾸라고 했으므로-&gt; 그 하위 트리는 비교를 수행하지 않고 싹 새로 그린다. 개발자가 제공한 key prop을 이용해,여러 번의 렌더링 속에서도 변경되지 말아야 할 자식 엘리먼트가 무엇인지를 알아낼 수 있을 것이다. -&gt; ‘엘리먼트 타입’이나 ‘key’가 바뀌면 -&gt; 더 이상 비교하지 않고, 새로 그린다. 비교를 할 때는 맨 위 엘리먼트부터 비교한다. 비교 알고리즘 (Diffing Algorithm) 두 트리를 비교할 때 React는 가장 먼저 두 루트 엘리먼트를 비교합니다. 이후의 동작은 루트 엘리먼트들의 타입에 따라 다릅니다. 다른 타입의 엘리먼트인 경우12345678910루트 엘리먼트들의 타입이 다르다면, React는 이전 트리를 버리고 트리를 완전히 새로 구축합니다.트리를 버릴 때, 이전 DOM 노드들은 모두 파괴됩니다.또한 컴포넌트 인스턴스의 componentWillUnmount() 라이프 사이클 훅이 실행됩니다.새 트리가 구축될 때, 새 DOM 노드들이 DOM 안에 삽입됩니다.그에 따라 컴포넌트 인스턴스의 componentWillMount() 훅이 실행되고,그 다음 componentDidMount() 훅이 실행됩니다.이전 트리에 연결되어 있던 **모든 state가 유실됩니다.**루트 엘리먼트 아래에 있는 모든 컴포넌트가 언마운트되고 그 state 또한 파괴됩니다. React의 상태는 화면에 그려질 때만 존재할 수 있다 같은 타입의 DOM 엘리먼트인 경우12같은 타입의 두 React DOM 엘리먼터를 비교할 때,React는 양쪽의 속성을 살펴본 뒤 같은 것들은 유지시키고 변경된 속성만을 갱신합니다. -&gt; DOM을 파괴하는 게 X두 요소를 비교하여 React는 DOM 노드에서 className만 수정되고있다는 사실을 알게됩니다. 1하나의 DOM 노드를 처리한 뒤에, React는 뒤이어 해당 노드의 자식들을 재귀적으로 처리합니다 -&gt; 하위 요소들에 대해서 똑같은 작업을 수행 같은 타입의 컴포넌트 엘리먼트인 경우 같은 타입의 컴포넌트 엘리먼트인 경우는 prop이 바뀔 뿐 state가 날아가지 않습니다. cf) componentWillReceiveProps()는 요즘은 사용하지 않습니다. 자식에 대한 재귀적 처리키12만약 자식이 키를 갖고 있다면,React는 그 키를 이용해 원래 트리의 자식과 새 트리의 자식 간이 일치하는 지를 결정할 수 있습니다. 같은 자료면 같은 키를 써야합니다. 같은 자료인데 키를 바꾸면 리액트는 다른 자료라고 인식합니다. 키가 바뀌면 상태가 다 날아갑니다. 내가 상태를 강제로 초기화하고 라이프사이클 훅을 싶을 때도 키를 사용할 수 있습니다. 엘리먼트 타입이나 상태가 바뀌면 상태가 다 날아간다는 걸 기억하세요!","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"익스프레스(Express)로 시간 절약","slug":"node-express-for-saving-time","date":"2019-02-26T15:03:46.000Z","updated":"2019-02-27T14:31:18.321Z","comments":true,"path":"2019/02/27/node-express-for-saving-time/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/27/node-express-for-saving-time/","excerpt":"","text":"익스프레스(Express)로 시간 절약 앞서 노드만을 사용해 단순한 웹 서버를 만드는 방법을 배웠다. 이 장에서는 익스프레스(Express)를 사용해 그 서버를 다시 만든다. 익스프레스의 기본에 대해 이해해 보자. 스캐폴딩(Scaffolding) 프로젝트는 대개 템플릿 코드가 일정량 필요하다. 프로젝트의 엉성한 뼈대(템플릿)를 만들어놓고,새 프로젝트를 시작할 때마다 이 템플릿을 복사하는 방법이 훨씬 간단하다. 루비 온 레일즈(Ruby on Rails)에서는 자동으로 스캐폴딩을 생성하는 프로그램을 만들어이 개념을 한 단계 진화시켰다. 익스프레스(Express)는 루비 온 레일즈(Ruby on Rails)의 아이디어를 받아들여, 프로젝트를 시작할 때 스캐폴딩을 생성하는 유틸리티를 제공한다. 메도라크 여행사 웹사이트 이 책 전체에서 사용하는 예제는 오리건 주를 찾아오는 사람을 대상을 서비스를 제공하는가상의 여행사 메도라크(들종다리)의 웹사이트이다. REST 서비스도 제공할 예정이다. 초기 단계 프로젝트에 사용할 새 디렉터리를 만든다. 이 디렉터리는 프로젝트의 루트 디렉터리이다. 이 책에서 ‘프로젝트 디렉터리’, ‘앱 디렉터리’, ‘프로젝트 루트’라고 말하면그건 이 디렉터리를 가리키는 것이다. Tip!프로젝트를 진행하다 보면 회의록이나 문서 같은 파일이 생기게 마련인데,이런 파일들과 웹 앱 파일을 분리해서 보관하자.-&gt; 서브디렉터리를 하나 만들어 프로젝트 루트로 지정하자.예를 들어, 메도라크 여행사 웹사이트 프로젝트와 관련된 파일을 ~/projects/meadowlark 안에 두되,프로젝트 루트(프로젝트 디렉터리)는 ~projects/meadowlark/site로 지정한다. npm은 프로젝트 의존성과 메타데이터를 package.json 파일에 보관해서 관리한다.이 파일을 만드는 가장 쉬운 방법은 npm init이다.이 명령을 내리면, 몇 가지 질문을 거쳐 package.json 파일을 생성한다.(진입점(entry point)을 묻는 질문에는 meadowlark.js 또는 프로젝트 이름을 쓰면 된다. ) Tip! package.json에 저장소 URL을 지정하지 않거나 README.md 파일을 작성하지 않으면npm을 실행할 때마다 경고가 나올 것임사실 package.json 파일에 들어있는 메타데이터는 프로젝트를 npm 저장소에 올리지 않는다면 필요 없는 것이지만,간단한 작업을 해서 경고를 없애는 것도 좋다. 익스프레스를 설치한다.1npm install --save express npm install을 실행하면, 지정한 패키지를 node_modules 디렉터리에 설치한다. –save 플래그를 지정하면 package.json 파일을 업데이트한다. node_modules 디렉터리는 언제든 npm에서 다시 생성할 수 있으니 저장소에 저장할 필요가 없다. 실수로 node_modules 디렉터리를 저장소에 추가하는 일이 없도록 다음과 같이 .gitignore 파일을 만들어 두자. 12// .gitignorenode_modules; meadowlark.js 파일을 만든다. 이 파일이 프로젝트의 진입점 이 책 전체에서 이 파일을 ‘앱 파일’이라고 부를 예정 1234567891011121314151617181920212223242526const express = require(\"express\");const app = express();app.set(\"port\", process.env.PORT || 3000);// 커스텀 404 페이지app.use(function(req, res) &#123; res.type(\"text/plain\"); res.status(404); res.send(\"404 - Not Found\");&#125;);// 커스텀 500 페이지app.use(function(err, req, res, next) &#123; console.error(err.statck); res.type(\"text/plain\"); res.status(500); res.send(\"500 - Server Error\");&#125;);app.listen(app.get(\"port\"), function() &#123; console.log( \"Express started on http://localhost:\" + app.get(\"port\") + \";press Ctrl-C to terminate.\" );&#125;); 기초적인 익스프레스 서버가 만들어졌다. 터미널에 아래의 명령어를 입력하여 meadowlark.js로 서버를 시작해보자.http://localhost3000에 접속할 수 있다. 1node meadowlark.js 아직 익스프레스에 아무런 라우트(Route)도 지정하지 않았으므로 페이지가 존재하지 않음을 나타내는 범용 404 페이지가 나타난다. NOTE애플리케이션 포트는 app.set(port, process.env.PORT || 3000)으로 지정했다.이렇게 하면, 서버를 시작하기 전에 환경 값을 설정해 포트를 오버라이드 할 수 있다.이 예제를 실행했을 때, 앱이 포트 3000에서 실행되지 않는다면,PORT 환경 변수가 설정됐는지 체크해보자. TIPHTTP 요청의 상태 코드와 리다이렉션 여부를 보여주는 브라우저 플러그인을 설치하길 권한다.이런 플러그인을 설치하면, 대개 간과할 수 있는리다이렉션 문제나 부정확한 상태 코드를 찾아내기 쉽다.크롬에서는 아이마(Ayima)의 Redirect Path가 좋다.브라우저 대부분에서 개발자 도구의 네트워크 섹션에서 상태 코드를 볼 수 있다. 홈페이지와 어바웃 페이지 라우트를 추가해보자. 다음과 같이 404 핸들러 앞에 새 라우트를 2개 추가한다. 123456789101112// app.get 메서드: 라우트를 추가하는 메서드// 이 메서드는 매개변수로 경로, 함수를 받는다.app.get(\"/\", function(req, res) &#123; res.type(\"text/plain\"); // 노드의 저수준 메서드 res.end 대신 익스프레스의 확장 메서드 res.send를 사용함 res.send(\"Meadowlark Travel\");&#125;);app.get(\"/about\", function(req, res) &#123; res.type(\"text/plain\"); res.send(\"About Meadowlark Travel\");&#125;); 이제 다시 아래의 명령어를 입력하여 서버를 다시 시작하면,홈페이지와 어바웃 페이지가 정상적으로 작동한다. 1node meadowlark.js app.VERB: 라우트를 추가하는 메서드 여기에서 VERB는 (소문자인) HTTP 동사(대개 ‘get’과 ‘post’)의 플레이스 홀더이다. 이 메서드는 매개변수로 경로와 함수를 받는다.경로 매개변수는 라우트를 정의한다. 기본적으로 대소문자를 구분하지 X 맨 뒤의 슬래시(/)는 무시한다. 매칭할 때는 쿼리스트링을 무시한 채 매칭한다.-&gt; About 페이지의 라우트는 /about, /About(대소문자를 구분하지 않기 때문에),/about/(맨 뒤의 슬래시 무시),/about?foo=bar(쿼리스트링 무시),/about/?foo=bar(맨 뒤의 슬래시 무시, 쿼리스트링 무시)등에 대해 모두 작동한다. 함수 배개변수는 라우트가 일치할 때 호출되는 함수이다.이 함수로 전달되는 매개변수는 요청/응답 객체이다.지금은 평문(plaintext)로 상태 코드 200을 반환한다.(익스프레스의 기본 상태 코드는 200이므로 명시하지 않아도 된다.) 노드의 저수준 메서드 res.end 대신 익스프레스의 확장 메서드 res.send를 사용함노드의 res.writeHead를 res.set과 res.status로 교체익스프레스는 Content-Type 헤더를 설정하는 편리한 메서드 res.type을 제공한다.물론 res.writeHead와 res.end를 써도 되지만 그럴 필요 X 커스덤 404와 500 페이지는 반드시 조금 다르게 처리해야 한다.app.get 대신 app.use를 썼다.app.use는 익스프레스에서 미들웨어(middleware)를 추가할 때 쓰는 메서드일단은 지금은 라우트와 일치하지 않는 모든 것을 처리하는 폴백(catch-all) 핸들러라고 생각하자.중요한 요점은 익스프레스에서는 라우트와 미들웨어를 추가하는 순서가 중요하다. 404핸들러를 라우트 앞에 두었다면, Home 페이지와 About 페이지는 동작하지 않고,404 에러가 일어났을 것이다.지금은 라우트 구조가 매우 단순하지만, 와일드 카드를 지원하므로 순서 문제가 생길 수 있다.ex) About 페이지에 /about/contact나 /about/directions 같은 서브페이지를 추가한다면 어떻게 될까?다음 코드는 원하는 대로 작동하지 않을 것이다. 123456789app.get(\"/about*\", function(req, res) &#123; // 콘텐츠를 전송하는 코드...&#125;);app.get(\"/about/contact\", function(req, res) &#123; // 콘텐츠를 전송하는 코드...&#125;);app.get(\"/about/directions\", function(req, res) &#123; // 콘텐츠를 전송하는 코드...&#125;); 위 예제에서는 첫 번째 핸들러 /about에서 와일드 카드를 썼으므로‘/about/contact’와 ‘/about/directions’ 핸들러는 절대 일치되는 일이 없다. 익스프레스는 콜백 함수가 받는 매개변수 숫자를 통해 404와 500 핸들러를 구별할 수 있다.","categories":[{"name":"back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"노드로 만드는 단순한 웹 서버","slug":"node-web-serever","date":"2019-02-26T14:48:22.000Z","updated":"2019-02-26T15:25:38.283Z","comments":true,"path":"2019/02/26/node-web-serever/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/26/node-web-serever/","excerpt":"","text":"노드로 만드는 단순한 웹 서버 지금 만드는 앱이 곧 서버이다.노드는 웹 서버를 만드는 작업을 아주 단순하게, 코드 몇 줄로도 가능하게 만들었다. Hello World 노드가 어떻게 동작하며, 프로그래머가 그 과정을 얼마나 컨트롤할 수 있는지 예제로 알아보자. 1234567891011121314151617// hello-world.jsconst http = require(\"http\");// http.createServer 메서드는 함수를 매개변수로 받는다.// 호출 시기: HTTP 요청이 있을 때마다 이 함수를 호출한다.http .createServer(function(req, res) &#123; // 단순히 콘텐츠 타입을 평범한 텍스트로 지정하고, // 문자열 'Hello world!'를 보낸다. // Content-Type: 응답 정보의 타입, 캐릭터셋(인코딩 정보) -&gt; 해석 -&gt; 표시 res.writeHead(200, &#123; \"Content-Type\": \"text/plain\" &#125;); res.end(\"Hello world!\"); &#125;) .listen(3000);console.log(\"Server started on localhost:3000; press Ctrl_C to terminate....\"); 이 서버는 HTML을 전송하지 않고 평범한 텍스트 메시지 ‘Hello World!’를 브라우저에 전송한다. 이벤트 기반 프로그래밍 이벤트 기반 프로그래밍에서는 프로그래머가 어떤 이벤트를 사용할 수 있는지,거기에 어떻게 응답해야 하는지 이해해야 한다.즉, 사용자가 뭔가를 클릭하면 프로그래머가 ‘클릭 이벤트’를 처리하는 식이다. 라우팅(Rounting) 라우팅이란 요청받은 콘텐츠를 클라이언트에 보내는 메커니즘이다. 웹 기반 클라이언트/서버 애플리케이션에서는 클라이언트가 원하는 콘텐츠를 URL에 표시,-&gt; 경로와 쿼리스트링에 표시한다. Hello World! 예제를 좀 더 확장하여홈페이지, 어바웃 페이지, 404(찾을 수 없음) 페이지만 들어 있는 정말 기본적인 웹사이트를 만들어보자. 아직은 이전 예제를 그대로 써서, HTML을 보내지 않고 평범한 텍스트를 보내자. 123456789101112131415161718192021222324252627282930const http = require(\"http\");http .createServer(function(req, res) &#123; // url에서 쿼리스트링과 옵션인 마지막 슬래시를 지우고 소문자로 바꿔서 정규화한다. let path = req.url.replace(/\\/?(?:\\?.*)?$/, \"\").toLowerCase(); switch (path) &#123; // (http://localhost:3000)으로 이동 case \"\": res.writeHead(200, &#123; \"Content-Type\": \"text/plain\" &#125;); // res.end()는 응답 프로세스를 종료한다. res.end(\"Homepage\"); // 쿼리스트링은 무시하므로 (http://localhost:3000/?foo=bar)를 치면, // 홈페이지로 이동한다. break; // (http://localhost:3000/about)으로 이동 case \"/about\": res.writeHead(200, &#123; \"Content-Type\": \"text/plain\" &#125;); res.end(\"About\"); break; default: // (http://localhost:3000/foo)같은 기타 URL은 404 페이지로 이동 res.writeHead(404, &#123; \"Content-Type\": \"text/plain\" &#125;); res.end(\"Not Found\"); break; &#125; &#125;) .listen(3000);console.log(\"Server started on localhost:3000; press Ctrl_C to terminate....\"); 정적 자원 전송 이제 진짜 HTML과 로고 이미지를 전송해보자. ex)주식 가격 표시기는 페이지를 새로 고칠 때마다 가격을 반영하여 바뀌지만,HTML이나 로고 이미지 같은 것들은 바뀌지 않는다. -&gt; 이를 &#39;정적 자원&#39;이라고 부른다. tip!개발 도중 혹은 작은 프로젝트를 진행할 때는 노드에서 정적 자원을 전송해도 별 문제가 없다.But, 큰 프로젝트를 진행할 때는 엔진X 같은 프록시 서버나 CDN을 사용한다. 노드는 파일을 열고 내용을 읽어서 콘텐츠를 브라우저에 전송하는 작업을 직접해야 한다. 프로젝트에 이 목적으로 사용할 public 디렉터리를 만들자. 그 디렉터리에 homte.html, about.html, 404.html을 만든다. 서브 디렉터리 img를 만든 다음 img/logo.jpg 이미지도 만든다. 12&lt;!-- home.html --&gt;&lt;h1&gt;home&lt;/h1&gt; 12&lt;!-- about.html --&gt;&lt;h1&gt;about&lt;/h1&gt; 1&lt;h1&gt;404 Not Found!!!&lt;/h1&gt; hello-world.js를 아래와 같이 수정한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// hello-world.jsconst http = require(\"http\");fs = require(\"fs\");// 보조함수인 serverStaticFile에서 필요한 작업을 대부분 수행한다.function serverStaticFile(res, path, contentType, responseCode) &#123; if (!responseCode) responseCode = 200; // fs.readFile: 파일을 읽는 비동기적 메서드 // 동기적 버전인 fs.readFileSync도 있지만, 생각을 비동기적으로 바꾸는 것을 추천 // fs.readFile을 호출해 파일 콘텐츠를 읽는다. // fs.readFile은 파일을 읽은 뒤 콜백 함수를 실행한다. // 파일이 존재하지 않거나 권한 문제 때문에 파일을 읽을 수 없다면, err 변수가 만들어지며, // 함수는 서버 에러를 나타내는 HTTP 상태 코드 500을 반환한다. fs.readFile(__dirname + path, function(err, data) &#123; if (err) &#123; res.writeHead(500, &#123; \"Content-Type\": \"text/plain\" &#125;); res.end(\"500, - Internal Error\"); // 파일을 성공적으로 읽으면, // 지정한 응답 코드, 콘텐츠 타입, 파일을 클라이언트에 보낸다. &#125; else &#123; res.writeHead(responseCode, &#123; \"Content-Type\": contentType &#125;); res.end(data); &#125; &#125;);&#125;http .createServer(function(req, res) &#123; // url에서 쿼리스트링과 옵션인 마지막 슬래시를 지욱 소문자로 바꿔서 정규화한다. let path = req.url.replace(/\\/?(?:\\?.*)?$/, \"\").toLowerCase(); switch (path) &#123; case \"\": serverStaticFile(res, \"/public/home.html\", \"text/html\"); // res.end()는 응답 프로세스를 종료한다. break; case \"/about\": serverStaticFile(res, \"/public/about.html\", \"text/html\"); break; case \"/img/logo.jpg\": serverStaticFile(res, \"/public/img/logo.jpg\", \"image/jpeg\"); break; default: serverStaticFile(res, \"/public/404.html\", \"text/html\", 404); break; &#125; &#125;) .listen(3000);console.log(\"Server started on localhost:3000; press Ctrl_C to terminate....\"); 이 예제의 라우팅은 매우 단순하다.http://localhost:3000/about으로 이동하면, public/about.html 파일이 전송된다.경로나 파일을 원하는 대로 바꿀 수 있다. ex) 요일마다 다른 About 페이지를 표시하고 싶다면, public/about_mon.html, public/about_tue.html 등을 만들고, 사용자가 localhost:3000/about으로 이동할 때 적절한 페이지를 전송하게끔 라우팅 프로그램을 만들 수 있다. Tip!__dirname은 실행 중인 스크립트가 들어있는 디렉터리로 해석된다.-&gt; 스크립트가 /home/sites/app.js에 들어 있다면,__dirname은 /home/sites로 해석된다.이 전역 변수를 사용하지 않으면, 앱을 다른 디렉터리에서 실행했을 때,분석하기 어려운 에러가 일어나곤 한다. 익스프레스(Express)로 출발 Express는 이미 존재하고, 시간을 소비해서 구현해야 할 기반 구조는 이미 만들어져 있다.","categories":[{"name":"back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"React 8일차","slug":"react8","date":"2019-02-24T16:21:02.000Z","updated":"2019-02-24T16:28:27.785Z","comments":true,"path":"2019/02/25/react8/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/25/react8/","excerpt":"","text":"JSX 더 알아보기 문법 설탕(syntatic sugar): 무언가를 문법적으로 쉽게 만든 것 .createElement()의 반환값은 객체다.가 중요 React 엘리먼트의 타입 지정하기&lt;div/&gt;&lt;Div/&gt;는 리액트에서 다르게 동작대문자로 시작하는 타입은 해당 JSX 태그가 React 컴포넌트임을 가리킨다. 그러니까, &lt;Foo /&gt;와 같은 JSX 표현을 사용하려면 Foo가 반드시 스코프 내에 존재해야 합니다. React가 스코프 안에 있어야합니다 JSX는 React.createElement를 호출하는 코드로 컴파일되기 때문에,React 라이브러리가 JSX 코드의 스코프 안에 항상 존재해야만 합니다. -&gt; 리액트 코드를 작성할 때 항상 import React from ‘react’;를 써줘야함 JSX 타입을 위한 점 표기법 사용하기사용자 정의 컴포넌트는 ‘대문자’로 시작해야합니다엘리먼트 타입이 소문자로 시작한다는 것은 그것이 or 와 같은 내장 컴포넌트라는 것을 뜻합니다.이 컴포넌트들은 결과적으로 ‘div’혹은 ‘span’와 같은 ‘문자열의 형태’로 React.createElement에 전달됩니다.-&gt; JSX에서 소문자 태그는 그 소문자 이름인 태그가 렌더링됨 와 같이’ 대문자’로 시작하는 타입은 React.createElement(Foo)와 같이 컴파일되며,따라서 여러분의 JavaScript 파일에 정의되어있거나 혹은 다른 파일에서 import 된 컴포넌트여야 합니다.대문자 -&gt; 대문자 실행 중에 타입 선택하기 대문자로 시작하는 변수는 JSX 타입이 될 수 있습니다. cf) 컴포넌트를 변수에 담고, 컴포넌트를 반환하기도 함컴포넌트를 받아서 컴포넌트를 반환하는 고차 컴포넌트도 있다. JSX 안애서 prop 사용하기 {}로 둘러싸면 값이 잘 넘어간다 문자열 리터럴Props의 기본값은 “True”속성 펼치기12345678910111213141516171819const Button = props =&gt; &#123; // other는 객체 // Button은 kind만 알면 되므로 const &#123; kind, ...other &#125; = props; const className = kind === \"primary\" ? \"PrimaryButton\" : \"SecondaryButton\"; //props안에 있는(kind빼고) other에 있는것들을 펼쳐서 버튼에 넣어줌. onClick이 버튼 태그에 등록됨 // button쓰듯이 사용자 정의 컴포넌트인 &lt;Button /&gt;을 사용하고 시ㅠ어서 return &lt;button className=&#123;className&#125; &#123;...other&#125; /&gt;;&#125;;const App = () =&gt; &#123; return ( &lt;div&gt; &lt;Button kind=\"primary\" onClick=&#123;() =&gt; console.log(\"clicked!\")&#125;&gt; Hello World! &lt;/Button&gt; &lt;/div&gt; );&#125;; JSX에서 자식 다루기문자열 리터럴여는 태그와 닫는 태그 사이에 문자열을 써넣을 수 있고, 이 때 props.children는 그냥 문자열이 됩니다.이런 식으로 많은 내장 HTML 엘리먼트를 사용할 수 있습니다: JSX를 자식으로 사용하기 여러 형태의 자식을 섞어서 쓸 수 있습니다. React 컴포넌트는 엘리먼트로 이루어진 배열 역시 반환할 수 있습니다. JavaScript 표현식을 자식으로 사용하기함수를 자식으로 사용하기 컴포넌트 안에 함수를 사용할 수 있다. 1234567891011121314151617// Calls the children callback numTimes to produce a repeated componentfunction Repeat(props) &#123; let items = []; for (let i = 0; i &lt; props.numTimes; i++) &#123; items.push(props.children(i)); &#125; return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;&#125;function ListOfTenThings() &#123; return ( &lt;Repeat numTimes=&#123;10&#125;&gt; &lt;!-- &#123;&#125;안에 함수를 넘겨서 화면을 그릴 수 있다 --&gt; &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125; &lt;/Repeat&gt; );&#125; 진리값, null, undefined는 무시됩니다. 이 성질은 React 엘리먼트를 조건부 렌더링하고 싶을 때 유용하게 사용할 수있습니다. 아래 JSX는 showHeader가 true일 때에만 를 렌더링합니다: 1234&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125; &lt;Content /&gt;&lt;/div&gt; &amp;&amp;연산자는 왼쪽이 truthy -&gt; 오른쪽 반환오른쪽이 falsy이면 -&gt; 왼쪽 반환 한 가지 주의해야 할 점은 0과 같은 몇몇 “falsy” 값들이 여전히 React에 의해 렌더링될 수 있다는 것입니다. 0이나 NaN은 리액트가 그린다. -&gt; 리액트 안에서 truthy, falsy 성질을 이용할 때는 주의! Proptypes를 이용한 타입 체크 타입스크립트가 뭔지는 알아야함 -&gt; 면접 질문 나올수도-&gt; 코드 실행하기 전 타입 관련 문제를 찾아낼 수 있는 기술.사용자가 점점 증가하는 추세 정적 타입 체크Ref와 DOM prop으로 넘기지 않는 2가지 - Ref와 key 부모에서 Ref와 key를 prop으로 넘겨줘도 리액트가 가로챔 어쩔수 없이 DOM객체를 직접 만져야 할 때가 있다ex) 외부 라이브러리를 가져다 쓸 때 가끔은 전형적인 데이터 흐름 밖에서 자식을 명령형으로 변경해야 할 필요가 있습니다. Ref 생성하기 Ref는 참조의 약자 123456789101112// DOM객체를 가리키는 화살표를 만들고 싶을 때// 1. Ref 객체를 만든다class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); &#125; render() &#123; // 2. Ref 객체를 넣어준다 return &lt;div ref=&#123;this.myRef&#125; /&gt;; &#125;&#125; Ref 사용하기 1번 연결시킨 뒤에는 .current속성을 이용해서 연결된 DOM노드를 가져올 수 있다 12// current속성을 이용해서 진짜 DOM객체를 가져온다const node = this.myRef.current; HTML 엘리먼트에 ref 어트리뷰트가 사용되면,ref의 current 속성은 DOM 엘리먼트 객체를 가리킵니다. 클래스 컴포넌트에 ref 어트리뷰트가 사용되면,ref의 current 속성은 해당 컴포넌트로부터 생성된 인스턴스를 가리킵니다. DOM 엘리먼트에 ref 사용하기 노트 필기 클래스 컴포넌트에 ref 사용하기12345678910111213141516class AutoFocusTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.textInput = React.createRef(); &#125; componentDidMount() &#123; // this.textInput.current는 클래스 인스턴스 // -&gt; this.textInput.current.focusTextInput(); &#125; render() &#123; return &lt;CustomTextInput ref=&#123;this.textInput&#125; /&gt;; &#125;&#125; -&gt; 클래스 인스턴스에 직접 접근할 수 있는 방법이 있고, 그 방법이 ref다. React에서 this가 가리키는게 무엇인지를 아는 게 중욧!!!! Ref와 함수형 컴포넌트 함수형 컴포넌트는 인스턴스를 가질 수 없기 때문에 ref 어트리뷰트 역시 사용할 수 없습니다 create-react-app-npx: npm을 다운받아서 바로 실행해줌npx명령을 실행하면 항상 패키지를 새로 다운 받는다 -&gt; 항상 최신 버전의 npm을 사용할 수 있다 npm start- 개발 서버 npm run build my-app├── README.md├── node_modules├── package.json├── .gitignore├── public│ ├── favicon.ico│ ├── index.html│ └── manifest.json└── src├── App.css├── App.js├── App.test.js├── index.css├── index.js├── logo.svg└── serviceWorker.js src - 변환 과정을 거쳐서 사용자에게. 압축이나 트랜스파일링 등 pulic - 변환 과정을 거치지 X Internet Explorer 9, 10, and 11는 지원 x(polyfills 사용해야함) 표준 명세에 적혀있다고 해서 실제 기능으로 사용할 수 있는 게 x Styles and AssetsAdding a Stylesheetbase64 010101로 되어있는 정보를 url에 넣고 싶다-&gt; url은 문자열만 담을 수 있으므로 base64 인코딩을 이용해서 변환 Adding Images, Fonts, and Files Create React App은 자동으로 깃 저장소로 만들어줌 -&gt; git init 안하고 바로 커밋 가능","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 7일차","slug":"react7","date":"2019-02-23T16:58:24.000Z","updated":"2019-02-24T16:20:01.216Z","comments":true,"path":"2019/02/24/react7/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/24/react7/","excerpt":"","text":"리스트와 키 React element가 들어있지 않은 배열로부터 React element가 들어있는 배열을 만들 수 있다.-&gt; 화면에 바로 그릴 수 있다. 기본적인 목록 컴포넌트 Warning: 에러는 아니지만, 코드에 문제가 있으니 확인해야 한다. map 메소드를 사용할 때는 key를 써줘야 한다. 키 키를 지정해주면 어떤 아이템이 바뀌었는지, 추가되었는지, 삭제 되었는지를 React에게 알려줄 수 있습니다. 어떤 자료가 있고, 그 자료의 식별자가 있다면 -&gt; 그 식별자를 key로 사용하는 게 좋다. 대부분의 경우 데이터의 ID를 키로 사용한다. eX1) 유저정보 userId나 userName(사이트에 가입하는 그 아이디)를 key로 사용한다. 최후의 수단으로 배열의 index를 key로 사용하는 방법을 사용한다. 항목 간 순서가 바뀔 수 있는 경우 키에 배열의 인덱스를 사용하지 않는 게 좋다. ex) todolist를 예로 들면, setState를 사용해서 변경해주면 순서가 뒤죽박죽이 될 수 있으므로key에 index를 사용하지 않는 게 좋다. (삭제, 위로, 아래로 등을 누르면 순서가 섞여버릴 수 있음) React에게 배열을 그려달라고 하려면, 거기에 key를 꼭 넣어줘야 한다.그 안에 있는 요소 각각에 key를 넣어야 한다. key를 사용하지 않으면, 여러 가지 문제가 발생할 수 있다. 주의할 점 key로 쓰는 값은 서로 다른 key를 붙여야 한다.(같은 key값을 가지면 안된다.) 3개의 li에 1, 1, 2를 붙이면 x! (cf) 주민등록번호가 같은 사람이 없음) 키로 컴포넌트 추출하기 키는 바로 바깥쪽의 배열에 대해서만 의미를 가집니다. map에서 바로 반환되는 element안에 key를 넣어줘야 한다.-&gt;map 메소드 안에 적어야 한다. mistakes에 적어주기 키는 형제 중에서 고유한 값이어야한다. key라는 이름은 아래쪽(자식 컴포넌트)에서 props로 받아서 사용할 수 없다. key와 ref는 React가 특별하게 취급하는 이름이기 때문에 자식 Component에서 prop으로 받아서 사용할 수 없다. mistakes에 적어주기 클래스는 인스턴스를 만들려고 사용하는 것이다. Game컴포넌트는 클래스이므로 React가 알아서new Game()해서 인스턴스를 생성해서 Game컴포넌트에 붙여놓는다.Game instance에 state라는 속성이 저장된다. Game컴포넌트에서 this.setState, this.props에서 쓰이는 this가 이 클래스의 인스턴스를 가리킨다. 실제로 클래스의 인스턴스가 생성되고, 개발자가 this를 쓰면,그 인스턴스를 만지는 것이다. 화면이 어떻게 표시되는지에 따라서, 그에 따른 state를 가질 수 있다. 화면에 표시되지 않는 Component의 state가 살아있을 수 없다. (메모리에서 사라짐.) new Game()해서 인스턴스가 생성되서 React의 기억에 촥~ 달라붙는다. Game이라는 노드가 사라지면, React의 기억에서그 노드에 달려있던 인스턴스의 state도 같이 날아간다.(메모리에서 사라진다.) 함수형 컴포넌트는 인스턴스를 만들어서 붙여놓을 수 때문에 상태를 가질 수 없는 것이다.ex)function Option(props) {}는 인스턴스를 만들 수 없다. 이 내용은 엄청나게 어려우므로 흘려들을 것: 함수형 컴포넌트도 상태를 기록할 수 있는 저장소가 있고,여기에 상태를 저장하는 방식으로 기능이 추가되고 있는 것 같다. -&gt; 아직 추가된 건 X 중요! Component가 그려져야 상태를 가질 수 있다. -&gt; ‘React의 기억’이 바뀌면, 상태가 날아갈 수 있다. React는 key값이 바뀌면, 상태가 다 날아간다. key가 배열안에서만 사용되는 게 X 상태 초기화를 위해 key를 바꿔주는 기법도 많이 사용된다. 폼 HTML 폼(form) 요소는 그 자체가 내부 상태를 가진다.ex) 체크박스 - 체크 여부를 알아서 기억함 input태그 - 자기가 알아서 기억하고, 지가 알아서 변경도 한다. select태그 text area form element에 각각의 상태 저장소가 있고, React Component에 상태 저장소가 있다.각각이 따로 상태를 가지고 있다는 걸 기억 -&gt; 각각 따로 상태를 가지고 있는 게 좋을 때도 있고, 좋지 않을 때도 있다. React에서는 form element가 상태를 가지지 못하도록 만드는 기능이 있다. 사용자가 입력한 상태를 읽어와서 사용자에게 feedback을 잘 할 수 있어야 한다. 사용자가 숫자를 입력해야 하는 field에 알파벳을 입력하고 있으면,경고를 주는 등의 feedback을 잘 할 수 있어야 한다. -&gt; 상태를 공유하기 위해 위쪽으로 상태를 끌어올리는 게 좋다. form이 내부에서 상태를 가지는 게 아니라, 위쪽으로 끌어올려서 제어할 수 있게 한다. 제어되는 컴포넌트 (Controlled Components)vs uncontrolled Componets 많이 사용되는 용어! 따로 정리해두기(TIL에) 서로 다른 2가지의 상태 저장소가 있고, 업데이트하는 방법도 다르다. 우리가 했던 todolist 예제에서는 상태 저장소가 2개가 있었던 것임 공유되는 상태를 끌어올리는 게 좋다. input에 그 자체의 상태를 없애버리고,사용자에게 피드백을 보여주는 컴포넌트에서는 input태그의 상태가 필요-&gt; 가장 가까운 공통 조상이 상태를 가지는 게 좋다. 상태를 전부 다 React에서 관리하게 할 수 있다. input 태그를 만들 때, value prop에 문자열을 넘겨주면,제어되는 컴포넌트가 되서 자체적인 상태를 가지지 않는 컴포넌트가 된다. 화면을 바꾼다. -&gt; input필드 안에 있는 내용을 바꾸려면, React에 있는 상태를 바꿔준다. input에 입력이 일어났을 때, 무언가 처리를 하고싶다면, onChange속성을 사용한다. input 이벤트와 change 이벤트의 차이점 찾아보기(DOM에서는 다름) React에서는 사용자의 입력이 일어날 때마다 뭔가를 해주고 싶다면-&gt; &lt;input&gt;, &lt;select&gt;, &lt;textarea&gt; 등에서 onChange속성을 사용하면, React가 알아서 잘 붙여준다. React에서는 value로 제어되는 컴포넌트로 만들어준 후, onChange로 e.target.value에는 지금 선택된 옵션의 value값이 들어있다. 제어되는 컴포넌트(Controlled Componentes)제어되는 컴포넌트? input,select, textarea가 화면을 그리는 기능만을 갖게 만들어주는 것이다.그 자체로는 상태가 변경되지도 않고 제어되지 않게 만드는 것이다. 제어되는 컴포넌트는 React의 상태를 바꿔야 화면이 바뀌게 되는 것이다. 제어되는 컴포넌트를 사용하는 이유 사용자의 입력을 아주 세밀하게 컨트롤 사용자가 입력할 때마다 바로바로 feedback을 주고 싶을 때 사용 만드는 방법: value상태, handleChange함수 하나를 만들어야 한다. 여러 input 제어하기 실제로는 form 전부를 제어되게 만드는 게 귀찮고 복잡한 과정임 전부 제어되는 컴포넌트가 되게 하면서도 편하게 코딩할 수 있게 만드는 라이브러리를 사용-&gt; formik 라이브러리를 사용 formik 라이브러리를 사용 제어되는 입력 필드의 Null 값 이 부분은 강사님이 그냥 넘어가심 제어되는 컴포넌트에 대한 대안책 제어되지 않는 컴포넌트를 잘 사용하려면 React의 세계로 DOM객체를 가져와야 한다. React에서 만지는 객체는 DOM객체가 아니다. 이 작업을 querySelector로 할 수가 없다. cf) ref라는 속성이 DOM객체를 가져올 때 사용하는 속성이다. State 끌어올리기 화씨, 섭씨 예제가 복잡해서 넘어가심 기억할 것!! 여러 자식들이 공유하는 상태가 필요할 때 자식 컴포넌트들끼리 통신해야 할 때 -&gt; 부모로 상태를 끌어올려서 관리하는 게 좋다. 합성(조합) (composition) vs 상속 (inheritance)다른 컴포넌트를 담기 ex) 쇼핑몰 프로젝트 헤더나 푸터는 어느 페이지에나 나타난다.- 종종 컴포넌트에 어떤 자식이 들어올 지 미리 알 수 없는 경우가 있습니다.이는 범용의 “박스” 역할을 하는 Sidebar 나 Dialog 같은 컴포넌트에서 많이 나타나는 패턴입니다. 이러한 경우, children이라는 특별한 prop을 통해 자식 요소를 출력에 그대로 전달하는 방법을 사용해보세요. children이라는 prop은 React가 특별히 관리하는 prop이다. 1234567function FancyBorder(props) &#123; return ( &lt;div className=&#123;\"FancyBorder FancyBorder-\" + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125; 12345678910function WelcomeDialog() &#123; return ( // FancyBorder에 chidren이라고 넘기지 않았지만, // 그 안에 있는 h1과 p가 children이 됨 &lt;FancyBorder color=\"blue\"&gt; &lt;h1 className=\"Dialog-title\"&gt;Welcome&lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt;Thank you for visiting our spacecraft!&lt;/p&gt; &lt;/FancyBorder&gt; );&#125; 기억할 것props.children이라는 특별한 prop이 있다.prop으로 element를 넘길 수 있다. -&gt; 부모로부터 받은 element를 화면에서 그려줄 수 있다. 컴포넌트를 만들고 싶은데, 빈칸을 만들고 싶을 때 ex) 레이아웃은 만들어 두고, 컨텐츠 영역만 갈아끼우고 싶을 때 사용 특수화 (Specialization) ex) 로그인 dialog, 경고 dialog 등특수한 경우인 컴포넌트를 만들어야 하는 경우 -&gt; React에서는 상속이 아닌 합성, 조합을 사용한다. cf) 상속에서 부모는 좀 더 일반적이고 포괄적인 경우, 자식은 특수한 경우.라서 보통은 상속을 이용하는데, React에서는 상속을 이용하지 X!.상속을 쓰지 말라고 React팀에서도 얘기하고 있음 할일 목록 실습 React에서는 컴포넌트 하나에 파일 하나를 만든다. 하나의 파일에 컴포넌트 여러 개 두는 경우 거의 없다. React코드는 항상 맨 윗줄에 이 코드가 있어야 한다.import React from ‘react’ className이라는 라이브러리를 사용하면 class 이름을 동적으로 생성할 수 있다.className 라이브러리(npm 페이지) 사용법: 이 class를 포함시킬 것인지 포함시키지 않을 것인지 true, false로 객체로 넘긴다.classNames(‘foo’, { bar: true }); // =&gt; ‘foo bar’ SandBox에서 npm추가하는 법 좌측 Add Dependendy에 키워드로 검색","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 6일차","slug":"react6","date":"2019-02-22T16:54:23.000Z","updated":"2019-02-24T16:29:43.127Z","comments":true,"path":"2019/02/23/react6/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/23/react6/","excerpt":"","text":"조건부 렌더링&amp;&amp; 논리 연산자를 사용해 if를 인라인으로 넣기 React는 문자열, 숫자는 잘 그려주는데, true, false, null 등은 화면에 안 그려준다. &amp;&amp;는 앞의 코드가 falsy이면 앞의 걸 반환하고, 앞의 코드가 true이면 뒤의 걸 반환한다. 12345678910111213141516171819202122function Mailbox(props) &#123; // unreadMessages.length는 안 읽는 메시지가 있으면 true, 안 읽은 메시지가 없으면 false가 됨 // &amp;&amp;는 앞의 코드가 falsy이면 앞의 걸 반환하고, 앞의 코드가 true이면 뒤의 걸 반환한다. // 앞의 코드가 falsy라서 false를 반환하면, React는 아무것도 화면에 그리지 않기 때문에 if - else의 느낌으로 사용할 수 있다. //if ~else를 React에서 사용할 수 있으나 복잡한 UI를 그리기에 불편해서 이렇게 &amp;&amp;를 이용함 const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; ( &lt;h2&gt;You have &#123;unreadMessages.length&#125; unread messages.&lt;/h2&gt; )&#125; &lt;/div&gt; );&#125;const messages = [\"React\", \"Re: React\", \"Re:Re: React\"];ReactDOM.render( &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;, document.getElementById(\"root\")); 조건부 연산자를 사용해 if-else 인라인으로 넣기123456789// if ~else 느낌으로 삼항 연산자를 쓸 수 있다.render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in. &lt;/div&gt; );&#125; 컴포넌트가 렌더링 되지 못하도록 방지123456789// 경고 메시지가 있으면 그려라.// 경고 메시지가 없으면, 아무것도 그리지 말고function WarningBanner(props) &#123; if (!props.warn) &#123; return null; &#125; return &lt;div className=\"warning\"&gt;Warning!&lt;/div&gt;;&#125;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 5일차","slug":"react5","date":"2019-02-21T15:16:28.000Z","updated":"2019-02-24T16:29:39.039Z","comments":true,"path":"2019/02/22/react5/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/22/react5/","excerpt":"","text":"이벤트 제어하기 함수 안에서 함수를 정의할 수 있다. onClick={handleClick}의 {}안에 함수를 정의해도 되고, 밖에서 정의하고 안에 함수 이름을 써줘도 됨 123456789101112function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault(); console.log(\"The link was clicked.\"); &#125; return ( &lt;a href=\"#\" onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125; Event Pooling Note: If you want to access the event properties in an asynchronous way, you should call event.persist() on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code. 비동기식으로 이벤트 객체의 속성에 접근하기를 원한다면, 당신은 호출해야 한다.event.persist()라는 메소드를 호출해야 한다. 합성 이벤트를 pool에서 제거한다. await와 await 사이의 코드는 동기식으로 작동한다. React에서는 비동기 함수를 이벤트 리스너에 그냥 등록하는 건 위험하다. 이벤트 객체는 React에서 쓸 때 조심해야 한다. 비동기식으로 이벤트 객체의 속성에 접근하려면, event.persist() 메소드를 호출해야 한다. 미리 속성을 빼오면 괜찮다. 자세한 방법은 다음에 강사님이 알려주실 예정 React를 사용할 때, (일반적인 경우) 리스너를 추가하기 위해 DOM 요소가 생성된 후addEventListener 를 호출할 필요가 없습니다.대신 요소를 처음 렌더링할 때 리스너를 같이 넘겨주세요. React가 addEvnetListener를 호출해 주는 것이다. JSX 콜백에서 this 의 의미에 대해 주의해야합니다.자바스크립트에서 클래스 메서드는 기본적으로 바인딩 되지 않습니다.만약 this.handleClick 바인드를 잊은채로 onClick 에 전달하면,this 는 함수가 실제로 호출될 때 undefined 로 취급됩니다. 이건 React에서만 해당되는 동작이 아닙니다.자바스크립트의 함수의 동작 방식 자체가 이렇습니다.일반적으로 onClick={this.handleClick} 처럼 () 없이 메서드를 참조하면,그 메서드를 bind 해야합니다. 만약 bind 를 호출하는 게 귀찮은 경우,이 문제를 해결할 수 있는 두 가지 방법이 있습니다.만약 실험적 기능인 퍼블릭 클래스 필드 문법 을 사용하고 있다면,콜백을 올바르게 바인딩하기 위해 클래스 필드를 사용할 수 있습니다. this와 관련된 문제들이 있고, 여러 가지 해결 방법이 있는데,onClick이나 onSubmit, onMouseMouve 등에는 화살표 함수를 사용한다.this가 가리키는 게 잘 고정된다. 여러 가지 해결 방법은 각각의 성능 상의 장단점이 있다. 중요한 내용: React는 특별한 객체를 사용한다.-&gt; 주의해야 할 부분이 있다. 특히 이벤트 리스너를 사용할 때, this 때문에 문제가 많이 발생하므로 문제를 해결하기 위해서 화살표 함수를 사용하자.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 3일차","slug":"react3","date":"2019-02-20T15:21:09.000Z","updated":"2019-02-26T15:21:40.869Z","comments":true,"path":"2019/02/21/react3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/21/react3/","excerpt":"","text":"요소(element) 렌더링요소는 React 앱에서 가장 작은 단위의 재료입니다. 요소는 화면에 표시하고자 하는 내용을 서술합니다. React는 element를 받아서 화면에 그려주는 기능을 하는 라이브러리 브라우저 DOM 요소와 달리, React 요소는 순수한 객체이며 생성 비용이 저렴합니다. 생성 비용? ex) video태그, img태그 등은 비용이 많이 든다. (자바스크립트 실행 속도가 느려질 수 있다. 이 태그를 만들어내는 데 계산이 오래 걸리기 때문에, cpu 메모리가 많이 사용된다.) React DOM이라는 라이브러리가 개발자 대신에 알아서 DOM 요소 객체를 생성해서 appendChild 등을 해서 HTML문서에 넣어준다. DOM에서 요소 렌더링하기 React로 구축한 어플리케이션은 보통 하나의 루트 DOM 노드를 가진다. React 요소를 루트 DOM 노드에 렌더링하고 싶다면, ReactDOM.render() 에 둘 다 넘겨주면 됩니다. ReactDOM 라이브러리에 첫 번째 인수로 element를 넘겨주고, 두 번째 인수로 어디에 그려줄 것인지를 써준다. 우리는 2가지 라이브러리를 사용하는 것이다. React 라이브러리 ReactDOM 라이브러리 cf) 브라우저 DOM에 그리고 싶을 때 - ReactDOM라이브러리를 사용 모바일 앱에 그리고 싶을 때 - React Native를 사용(사용법은 많이 다름) 렌더링된 요소 업데이트React 요소는 변경 불가능 합니다. 한번 요소를 만들었다면, 그 자식이나 어트리뷰트를 변경할 수 없습니다. 중요!! 불변성(Immutability) 변경할 수 없다. 값을 변경하고 싶을 때는 값을 새로 만든다. React 요소는 사실 그냥 객체이기 때문에 변경 불가능하다는 의미는, 진짜 변경할 수 없다는 게 아니라 변경하고 싶으면, 처음부터 싹 새로 만든다는 의미이다. React는 화면을 조금이라도 바꾸고 싶으면, element를 처음부터 다 다시 그린다. 상태가 조금이라도 바뀌면, render메소드가 다 호출되고, React element가 맨 위에 있는 부모부터 가장 아래에 있는 자식까지 다~~~ 다시 그려지는 방식이다. 개발자가 React element를 직접 변경할 일은 없다.요소는 영화의 단일 프레임에 비유할 수 있습니다. 즉, 요소는 특정 시점의 UI를 표현할 뿐입니다. 이제까지 배운 것만 가지고 UI를 갱신할 수 있는 유일한 방법은 새로운 요소를 만들어서 이 요소를 ReactDOM.render() 로 전달하는 것입니다. 보통 실무에서는 setState로 상태를 변경한다. 12345678910111213// 실무에서 활용되는 방법은 Xfunction tick() &#123; // toLocaleTimeString()는 사용자가 사용하는 시간으로 만들어주는 메소드 const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById(\"root\"));&#125;// tick이라는 함수가 1초에 한 번씩 실행됨setInterval(tick, 1000); 이 예제는 setInterval() 콜백을 이용해 매 초마다 ReactDOM.render() 를 호출하고 있습니다. Note: 실무에서, 대부분의 React 어플리케이션은 ReactDOM.render() 를 한 번만 호출합니다. 다음 섹션에서는 이러한 코드가 어떻게 상태를 갖는 컴포넌트 로 캡슐화 되는 지 배울 것입니다. 서로가 서로를 기반으로 만들어져 있기 때문에, 이 주제를 건너뛰지 않는 걸 권장합니다. React는 꼭 필요한 부분만 갱신합니다 상식으로 알고 있을 내용: DOM Tree에서 변경된 부분을 브라우저가 보라색으로 보여준다. 컴포넌트와 props 컴포넌트를 통해 UI를 독립적이고 재사용 가능한 부분으로 분리하고, 각 부분을 독립적으로 생각할 수 있습니다. 개념상 컴포넌트는 자바스크립트 함수와 비슷합니다. “props”이라 불리는 임의의 입력을 받아들이고, 화면에 무엇이 표시되어야 하는지를 서술하는 React 요소를 반환합니다. 컴포넌트 렌더링 함수는 긴 코드뭉치에 이름을 붙인 것임 그 함수의 이름만 기억해서 그 긴 코드를 실행시키는 것임 긴 엘리먼트를 생성하는 컴포넌트에 이름을 붙여서 사용할 수 잇는 것임 123// 컴포넌트 안에 많은 엘리먼트들이 들어있지만 모든 내용을 개발자가 기억하고 사용하는 게 X// 사용자 정의 컴포넌트의 이름을 그 기능을 잘 나타내주는 이름으로 붙여주어 사용한다.const element = &lt;Welcome name=\"Sara\" /&gt;; 컴포넌트 조립하기 제일 위에 있는 컴포넌트를 App이라고 부르는 게 관례이다. 컴포넌트 추출Props는 읽기전용입니다 props는 무슨 일이 있어도 수정하지 말 것 props는 부모로부터 데이터를 받으면 props에 들어있는 거고, props를 수정하지 않아야 한다. 123function sum(a, b) &#123; return a + b;&#125; 입력을 변경하지 않고, 동일한 입력에 대해 항상 동일한 결과를 반환하는 함수를 순수함수(pure function)라고 한다. 12345// 계좌에서 돈을 인출할 때// 이 함수는 입력을 변경하기 때문에 순수하지 않다.function withdraw(account, amount) &#123; account.total -= amount;&#125; render 메소드 안에서는 같은 입력이 들어왔을 때, 같은 출력이 나가게 만들어줘야 한다. ex) render 메소드 안에 Math.random()을 사용하지 X!! React에서 render 메소드가 호출되는 것을 개발자가 컨트롤할 수 없다. render 메소드 안에 Math.random()을 사용하면, 화면이 다시 그려질 때마다 출력이 계속 달라지기 때문에 화면이 예상치 못한 순간에 이상하게 나오는 버그가 발생할 수 있다.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 2일차","slug":"react2","date":"2019-02-20T14:49:25.000Z","updated":"2019-02-20T14:58:25.225Z","comments":true,"path":"2019/02/20/react2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/20/react2/","excerpt":"","text":"JSX 소개 JSX로 만든 엘리먼트는 변수에 담을 수 있고, 함수의 매개변수로도 사용할 수 있다. 왜 JSX인가?JSX에 표현식 포함하기 JSX 안에 자바스크립트 표현식 을 중괄호로 묶어서 포함시킬 수 있다. 예를 들어, 2 + 2, user.firstName, formatName(user) 를유효한 표현식으로 표현하면 아래와 같이 표현한다. 123456789101112function formatName(user) &#123; return user.firstName + \" \" + user.lastName;&#125;const user = &#123; firstName: \"Harper\", lastName: \"Perez\"&#125;;const element = &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;;ReactDOM.render(element, document.getElementById(\"root\")); 가독성을 좋게 하기 위해 JSX를 여러줄로 나눴습니다. 필수는 아니지만,이 작업을 수행할 때는 자동 세미콜론 삽입의 함정을 피하기 위해 괄호로 묶는 것이 좋다. JSX 또한 표현식이다 컴파일이 끝나면, JSX 표현식이 일반적인 자바스크립트 함수 호출이 되고,결과적으로 자바스크립트 객체로 평가된다. 이 말은 if 문이나 for 문 내에서 JSX를 사용할 수 있다. -&gt; 변수에 할당하거나 매개변수로 전달하거나 함수에서 반환할 수 있음을 의미한다. 123456function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125; JSX 어트리뷰트 정의 어트리뷰트에서 따옴표를 사용해서 문자열 리터럴을 정의할 수 있다. 1const element = &lt;div tabIndex=\"0\" /&gt;; 어트리뷰트에 중괄호를 사용하면, 자바스크립트 표현식을 포함시킬 수 있습니다. 1const element = &lt;img src=&#123;user.avtarUrl&#125; /&gt;; 어트리뷰트에 자바스크립트 표현식을 포함시킬 때 중괄호를 따옴표로 묶지 말아야 한다. 따옴표 (문자열 값인 경우) 또는 중괄호 (표현식인 경우) 중 하나를 사용해야 하며,하나의 어트리뷰트에 둘 다 사용할 수 있는 것이 아니다. 123이렇게 하면, user.avatarUrl에 들어있는 값이 넘어가는 게 아니라 문자열이 넘어감const element = &lt;img src=\"&#123;user.avatarUrl&#125;\"&gt;&lt;/img&gt;;const element = &lt;img src=\"user.avatarUrl\"&gt;&lt;/img&gt;; 경고:HTML에서 사용하던 어트리뷰트 이름을 JSX에서 그대로 사용할 수 없다.JSX는 HTML보다는 자바스크립트에 가깝기 때문에,React DOM은 HTML 어트리뷰트 이름 대신 camelCase 어트리뷰트 이름 컨벤션을 사용합니다. ex1) React에서는 tabIndex를 camelCase로 써준다.React 라이브러리를 통해 tabindex라고 변환되어 HTML에 들어가는 것이다. ex2) HTML에서는 label for를 React에서는 label htmlFor로 써야한다.예를 들어, JSX에서 class 는 className 이 되며, tabindex 는 tabIndex 가 됩니다. JSX 자식 정의 만약 태그가 비어있다면, XML 처럼 /&gt; 를 이용해 닫아주어야 한다. React에서는 HTML에서 여는 태그만 있는 태그들을 꼭 닫아주는 태그도 써줘야 한다.ex) img, link 1const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;; JSX 태그는 자식을 가질 수 있다. 123456const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;); JSX 인젝션 공격 예방 사용자가 입력한 내용을 JSX 내에 포함시켜도 안전하다. React에 XSS(cross-site-scripting)공격에 대한 보안 기능이 내장되어 있기 때문이다. 123const title = response.potentiallyMaliciousInput;// This is safe:const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;; 기본적으로, React DOM은 렌더링 되기 전에 JSX 내에 포함된 모든 값을 이스케이프 한다. 따라서 어플리케이션에 명시적으로 작성되지 않은 내용은 절대 삽입할 수 없습니다. 모든 것은 렌더링 되기 전에 문자열로 변환된다.이렇게 하면 XSS (cross-site-scripting) 공격을 막을 수 있다. JSX 객체 표현 사용자의 브라우저는 자바스크립트 코드만 해석할 수 있으므로JSX 코드를 자바스크립트 코드로 컴파일한 후 전달해야 한다. Babel은 JSX를 React.createElement() 호출로 컴파일한다. 아래 두 예제는 동일하다. 1const element = &lt;h1 className=\"greeting\"&gt;Hello, world!&lt;/h1&gt;; 12345const element = React.createElement( \"h1\", &#123; className: \"greeting\" &#125;, \"Hello, world!\"); React.createElement() 는 버그 없는 코드를 작성하는 데S도움을 주는 몇 가지 체크를 하긴 하지만,기본적으로는 아래와 같은 객체를 생성한다. 12345678910111213// Note: this structure is simplifiedconst element = &#123; type: \"h1\", props: &#123; className: \"greeting\", children: \"Hello, world\" &#125;&#125;;S- 이 객체를 \"React\"요소라고 부른다.- React요소는 화면에서 보고자 하는 내용에 대한 설명 내지 서술로 생각할 수 있다.- React는 이 객체를 읽어들이고 이를 사용하여 DOM을 만들어낸 뒤 최신 상태로 유지한다.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"Node.js 철학","slug":"node-js-design-pattern1","date":"2019-02-18T15:01:17.000Z","updated":"2019-02-18T15:27:38.684Z","comments":true,"path":"2019/02/19/node-js-design-pattern1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/19/node-js-design-pattern1/","excerpt":"","text":"1.1 Node.js 철학 본 포스팅은 도서 &lt;Node.js 디자인 패턴&gt;을 공부하며 정리한 내용입니다. 1.1.1 경량 코어 Node.js 코어 자체는 몇 가지 원칙에 근거한 기반을 가지고 있다. 코어를 최소의 기능 세트로 하고,나머지를 사용자의 몫(사용자 영역)으로 해서, 핵심 모듈의 바깥 영역 모듈들을 생태계에 맡기는 것이 이 원칙들 중에 하나이다. -&gt; 장점: 유지 보수 측면에서 편리할 뿐만 아니라전체 생태계의 발전에 긍정적인 문화적 영향을 가져올 수 있다. 1.1.2 경량 모듈 Node.js는 모듈 개념을 프로그램 코드를 구성하는 기본 수단으로 사용한다. 어플리케이션과 패키지라고 하는 재사용 가능한 라이버리를 만들기 위한 조립용 블록 Node.js에서 가장 널리 퍼친 원칙 중 하나 코드 크기 뿐만 아니라 범위적인 면세어도 작은 모듈을 설계하는 것 유닉스 철학에 뿌리를 두는 두 가지 계율 작은 것이 아름답다각 프로그램이 각기 한 가지 역할을 잘 하도록 만든다 작은 모듈이 가지는 장점 재사용성 이해하기 쉽고 사용하기 쉽다. 테스트 및 유지보수가 훨씬 간단하다. 브라우저와 완벽한 공유가 가능하다. 더 작고 집중된 모듈을 사용하면 작은 코드 조각이라도 모두가 공유하거나 재사용할 수 있다. DRY(Don’t Repeat Yourself, 같은 것을 반복하지 말라.)원칙에 대한 새로운 적용이다. 1.1.3 작은 외부 인터페이스 Node.js 모듈은 대개 최소한의 기능을 노출하는 특성이 있다.-&gt; 가장 큰 이점: API의 사용이 보다 명확해지고 잘못된 사용에 덜 노출된다.cf) 대부분의 경우 컴포넌트 사용자는기능을 확장하거나 부가적인 고급 기능의 활용이 필요 없는,매우 제한되고 집중된 기능에만 관심이 있다. Node.js에서 가장 일반적인 패턴 함수나 생성자와 같이 하나의 핵심 기능을 표현하는 동시에,더 많은 고급 기능이나 보조 기능은 노출된 함수나 생성자의 속성이 되도록 하는 것 이를 통해, 사용자는 중요한 내용과 부수적인 내용을 구분할 수 있다. Node.js 모듈의 또 다른 특성 확장 용도보다는 실제 사용하도록 만들어진다는 것이다. 얻는 효과 유스케이스를 줄인다. 구현을 단순화 유지 관리를 용이하게 한다. 가용성을 높인다. 1.1.4 간결함과 실용주의-KISS(Keep It Simple, Stupid)원칙 단순함이야말로 궁극의 정교함이다. 디자인은 구현과 인터페이스 모두에서 단순해야 한다.구현이 인터페이스보다 단순해야 하는 것이 더 중요하다. 단순함은 설계에서 가장 중요한 고려 사항이다. 단순한 설계 &gt; 완벽한 모든 기능을 가진 소프트웨어 이유? 구현하는데 소요되는 노력과 자원을 적게 사용하여 더 빨리 보급할 수 있다. 적응과 유지보수 및 이해가 쉽다. -&gt; 커뮤니티의 기여도를 높이고, 소프트웨어 자체가 성장하고 향상될 수 있도록 한다. 복잡하지 않고 실용적인 접근법(대부분의 경우)이 원칙적이고 완벽한 디자인보다 더 선호된다.","categories":[{"name":"back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"문자열 심화 & 객체 기본","slug":"js-zerocho4","date":"2019-02-18T13:27:34.000Z","updated":"2019-02-18T14:10:16.846Z","comments":true,"path":"2019/02/18/js-zerocho4/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/18/js-zerocho4/","excerpt":"","text":"본 포스팅은&lt;ZeroCho님의 인프런 - 웹 게임 개발 자바스크립트 &gt;강의를 들으면서 정리한 내용임을 알려드립니다. 문자열 심화 - index와 length123456\"함수야놀자\"[2];// \"야\"\"함수야놀자\"[0];//\"함\"\"함수야놀자\"[3];//\"놀\" 123함수야 놀자1 2 3 4 5 &lt;-- 사람0 1 2 3 4 &lt;-- 컴퓨터(자바스크립트) .length를 이용하면, 길이를 쉽게 구할 수 있다.아래의 예시를 보자. 123456let 단어 = \"함수야놀자\";// undefined단어[2];//\"야\"단어.length;//5 객체 객체는 함수, 배열, 그리고 함수도 배열도 아닌 객체로 구성된다. 함수function(){} 배열 함수도 배열도 아닌 객체 숫자 문자 불린(true, false) null undefined 1234ex)동물 사람 원숭이 사람은 동물, 원숭이는 동물이라고 할 수 있지만,사람을 원숭이라고 하거나 원숭이를 사람이라고 할 수 없다. -&gt; 함수는 객체이고, 배열은 객체라고 할 수 있으나객체를 배열이라고 하거나 배열을 객체라고 할 수 없다. 12345678910111213141516let 이름 = \"제로초\";let 키 = \"174\";let 몸무게 = \"68\";let 아이큐 = \"300\";let 통장잔고 = \"0\";이름;// \"제로초\"키;// \"174\"몸무게;// \"68\"아이큐;//\"300\"통장잔고;//\"0\" 123let 이름 = \"네로\";이름;// \"네로\" 이름에 “제로초”와 “네로”를 각각 저장하고 싶은데값이 “제로초”에서 “네로”로 바뀌었다. 만약 객체가 없다면,아래 예제와 같은 식으로 계속해서변수를 무제한으로 만들어야 하는 경우가 생긴다. 123let 이름2 = \"네로\";let 키2 = \"160\";let 몸무게2 = \"54\"; 객체는 값들을 그룹화할 때 쓰면 좋다. 1234567891011121314// 제로초라는 변수에 객체&#123;&#125;를 저장한다.let 제로초 = &#123;&#125;;let 제로초 = &#123; 이름: \"제로초\", 키: 174, 몸무게: 68&#125;;let 네로 = &#123;&#125;;let 네로 = &#123; 이름: \"네로\", 키: 160, 몸무게: 58&#125;; 123456789// 제로초를 호출하면,// 변수 제로초에 저장된 객체의 값을 가져온다.제로초;// &#123;이름: \"제로초\", 키: 174, 몸무게: 68&#125;//네로를 호출하면,// 변수 네로에 저장된 객체의 값을 가져온다.네로;// &#123;이름: \"네로\", 키: 160, 몸무게: 58&#125; 객체의 값 자리에는 모든 값 형태를 넣을 수 있다.함수도 넣을 수 있다. 함수가 들어있는 속성(프로퍼티)를 메서드라고 한다. 123456let 제로초 = &#123; 이름: \"제로초\", 먹다: function 먹다() &#123; console.log(\"냠냠\"); &#125;&#125;; 객체의 형태1234객체 = &#123;속성(프로퍼티): 값,속성(메서드): 함수,&#125;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"문자열","slug":"문자열","permalink":"https://JihyeHwang09.github.io/tags/문자열/"},{"name":"객체","slug":"객체","permalink":"https://JihyeHwang09.github.io/tags/객체/"}]},{"title":"끝말잇기 구현","slug":"js-zerocho3","date":"2019-02-17T14:19:42.000Z","updated":"2019-02-17T15:08:28.960Z","comments":true,"path":"2019/02/17/js-zerocho3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/17/js-zerocho3/","excerpt":"","text":"본 포스팅은&lt;ZeroCho님의 인프런 - 웹 게임 개발 자바스크립트 &gt;강의를 들으면서 정리한 내용임을 알려드립니다. 끝말잇기 구현 코딩 자체보다는 순서도(알고리즘)가 더 중요하다. 순서도 논리적 사고를 하는 게 중요하다. 손이나 그림판으로 직접 그리면서 연습을 많이 해보자. while문으로 구현123456789101112131415161718// whilelet word = \"제로초초초\";// prompt는 대답을 받아주는 함수// 단어의 길이는 달라질 수 있다. (고정적이지 X)// 단어의 끝자리 인덱스는 항상 단어의 길이 -1이라는 규칙을 이용해서 구할 수 있다.// 전에 입력받은 단어의 마지막 번째 글자와 새로운 단어의 첫 글자가 같은지를 비교한다.while (true) &#123; let answer = prompt(word); if (word[word.length - 1] === answer[0]) &#123; // 맞았을 때 alert(\"딩동댕\"); // 첫 제시어를 저장하는 변수 word에 새로운 단어인 answer를 저장한다. word = answer; &#125; else &#123; // 틀렸을 때 alert(\"땡\"); &#125;&#125; alert, prompt와 console.log는 브라우저가 만들어준 함수이다. for문으로 구현-while문을 for문으로 바꿀 때는처음, 실행, 끝을 판단해야 한다. 12345// while문while (조건) &#123; 실행; 끝;&#125; 1234// for문for (처음; 조건; 끝) &#123; 실행;&#125; cf) while문의 조건을 true, false로바꿀 수 있는 것이 끝 부분이 된다. 123456789101112// 끝은 없으면 비워두면 된다.for (let word = \"제로초초초\"; true; ) &#123; let answer = prompt(word); if (word[word.length - 1] === answer[0]) &#123; // 맞았을 때 alert(\"딩동댕\"); word = answer; &#125; else &#123; // 틀렸을 때 alert(\"땡\"); &#125;&#125;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"React 1일차","slug":"react1","date":"2019-02-15T16:08:36.000Z","updated":"2019-02-15T16:25:34.896Z","comments":true,"path":"2019/02/16/react1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/16/react1/","excerpt":"","text":"React공부 방법에 대한 tip 한글 번역판보다는 영문판이 최신 버전이므로영문판으로 공부하면 가장 최신 버전의 React를 접할 수 있다. 개요React가 무엇인가요? React는 선언적이고, 효율적이며, 유연한 JavaScript 라이브러리이다. 명령형 프로그래밍 ex) Dom API처럼 일일히 속성을 지정해서 값을 넣으라고 명령하는 것 코드를 실행하지 않고 결과를 알아보려면 어렵다. 선언적 프로그래밍 HTML은 이렇게 코드 짰으니까 네가 알아서 그려줘. 순서를 지정해줄 필요 X 코드가 생긴대로 결과물이 나온다는 특징이 있다. 코드가 결과물의 특징을 잘 반영하고 있다는 특징이 있다. -&gt; React는 선언적 프로그래밍이 가능하다. React는 효율적이다. React는 UI를 값으로 다룬다는 특징이 있다. React를 사용하면, “컴포넌트”라 불리는 여러 격리된 코드 조각을 조합해서, 복잡한 UI를 쉽게 만들 수 있다. React의 컴포넌트에는 두 가지 종류가 있다. 일단은 React.Component의 서브클래스부터 보자.: 컴포넌트는 클래스이다. 컴포넌트는 UI를 그려주는 render메소드는 가지고 있다. 1234567891011121314151617181920212223class ShoppingList extends React.Component &#123; //rendor()는 메소드 render() &#123; // UI를 나타내는 값을 만들어준 다음 return해준다. return ( // HTML코드처럼 생겼지만, HTML이 아니다. // 뷰를 만들어내는 특별한 표현식이다. // &lt;div&gt;으로 감싸져 있는 코드는 React div엘리먼트라고 부른다. // 각각의 요소들은 객체로 되어 있다. // 문서 사이에 어떤 컨텐츠를 표시하고 싶다. JSX 안에는 &#123;&#125;를 쓴 다음 그 안에 값을 넣어주면, 그 값이 화면에 그려지게 된다. &lt;div className=\"shopping-list\"&gt; &lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Instagram&lt;/li&gt; &lt;li&gt;WhatsApp&lt;/li&gt; &lt;li&gt;Oculus&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;// 사용 예제: &lt;ShoppingList name=\"Mark\" /&gt; XML과 비슷하게 생긴 위 태그의 사용법을 곧 살펴볼 것이다.우리는 화면을 어떻게 그릴지를 React에게 알려주기 위해 컴포넌트를 사용한다.데이터가 변경되면, React는 컴포넌트를 효율적으로 갱신한다.(즉, 다시 그린다.) 위에서 본 ShoppingList는 React 컴포넌트 클래스이다.컴포넌트는 props (“properties”의 줄임말)이라 불리는 매개변수를 받아서,render 메소드에서 뷰의 계층 구조를 반환한다.(화면을 어떻게 그릴 지에 대한 계층 구조를 반환한다.) cf) 어떻게 그릴 건지를 설명하는 값을 ‘뷰’라고 한다. render 메소드는 무엇을 그릴지에 대한 설명을 반환한다.그러면 React는 그것을 받아 화면에 그려준다.여기서 render가 반환하는 것은 React 엘리먼트로, ‘무엇을 그릴지’에 대한 정보를 담고있는 객체이다.대부분의 React 개발자들은 이러한 구조를 쉽게 표현할 수 있는 JSX라는 특별한 문법을 사용한다.(JavaScript Extended) 라는 JSX 코드는, 빌드 과정에서 React.createElement(‘div’)로 변환된다.위 예제는 사실 아래 코드와 같다: 123456return React.createElement( \"div\", &#123; className: \"shopping-list\" &#125;, React.createElement(\"h1\" /* ... h1 children ... */), React.createElement(\"ul\" /* ... ul children ... */)); 좀 더 알고싶으시다면, API reference에서 createElement()에 대한 자세한 설명을 읽어보자.하지만 이 튜토리얼에서는 이 함수를 직접 사용하지 않을 것이다. 대신, 우리는 JSX를 계속 사용해보자. JSX 안에서는 JavaScript를 자유롭게 활용할 수 있다.JSX 중괄호 안에는 어떤 JavaScript 표현식도 넣을 수 있다.그리고 React 엘리먼트는 JavaScript 객체로, 변수에 담거나 프로그램의 다른 부분으로 넘기는 것이 가능하다. 위 예제의 ShoppingList 컴포넌트는 브라우저에 내장된 DOM 컴포넌트(&lt;div /&gt;, &lt;li /&gt;)만 그려주고 있다.하지만 React 컴포넌트를 조합해서 그리는 것도 가능하다.예를 들어, 우리는 전체 쇼핑 목록을 그리기 위해 와 같이 쓸 수 있다.각각의 React 컴포넌트는 독립적이며 캡슐화되어 있다.이 성질은 우리가 단순한 컴포넌트로부터 복잡한 UI를 만드는 일을 가능하게 해준다. 컴포넌트를 태그 이름처럼 사용할 수 있다. React에서 컴포넌트를 사용하면 큰 HTML을 조각으로 나눠서 &lt;ProductList /&gt;로 사용하면 코드 수를 줄일 수 있다. 2교시 정보가 폭포수처럼 위에서 아래로 흐른다. 이벤트 리스너 다는 방법: onClick, onChange, onSubmit, onMouseMove 등에 함수를 넘겨줘야 한다. Square Component에 alert(this.props.value)를 사용하면, 현재 넘어온 칸에 있는 숫자가 뜬다. Board Component의 name=”Square”을 넣고,Square Component에 alert(this.props.name)를 사용하면, alert으로 “Square”라고 뜬다. JavaScript 클래스를 사용할 때,서브클래스의 생성자를 정의할 때는 반드시 super를 호출해주어야 한다. 생성자를 갖는 모든 React 컴포넌트 클래스는 그 생성자가 반드시 super(props)로 시작해야 한다. Constructor(생성자) 만들 때는 React Component를 생성할 때는 super(props)는 반드시 맨 위에 있어야 한다. super를 맨 윗줄에 안 써주면, 에러가 발생한다. super(props); 어떤 부모 생성자의 코드를 호출하는 것 this.props.value : 부모로부터 내려받은 값this.state.value: 내가 기억하고 있는 값 onClick={() =&gt; this.setState({value: ‘X’})}클릭했을 때, 기억하고 있는 값을 ‘X’를 바꿔준다.setState({})로 {}안의 상태를 바꿔준다. React의 가장 핵심적인 부분 React를 사용하면서, 반드시 setState라는 메소드를 통해서 상태를 변경해야 한다!-&gt; 그래야 상태가 변경될 때마다 화면이 갱신될 수 있다. this.setState의 기능 2가지- 상태 변경 - 화면 갱신 React에서는 상태를 바꾸면, 무조건 화면이 갱신된다. React에서 화면을 다시 그리는 방법이 setState밖에 없다.(상태를 변경해주면 자동으로 화면 갱신하게 만듦) render라는 메소드는 React 라이브러리가 알아서 호출해줌. (개발자가 render메소드를 호출할 일이 없음) setState할 때마다 React 라이브러리가 render메소드를 실행해서 화면이 바뀔 게 있는지 확인한다. 화면을 다시 그려야할 때마다 render메소드가 매번 호출된다. 12345678910111213141516class Square extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: null &#125;; &#125; render() &#123; return ( &lt;button className=\"square\" onClick=&#123;() =&gt; this.setState(&#123; value: \"X\" &#125;)&#125;&gt; &#123;this.state.value&#125; &lt;/button&gt; ); &#125;&#125; Square의 render 메소드 안에 있는 onClick 핸들러 안에서 this.setState를 호출하면,&lt;button&gt;이 클릭될 때마다 화면을 다시 그려야 한다는 사실을 React에게 알려줄 수 있다. 그 뒤, this.state.value는 ‘X’가 될 것이고, 이로 인해 게임판에 X가 표시된다.이제 사각형을 클릭해서, X가 표시되는지 확인해보자. 컴포넌트 안에서 setState를 호출하면, React는 해당 컴포넌트가 품고 있는 자식 컴포넌트까지 모두 새로 그려준다.-&gt; 부모 컴포넌트의 상태가 바뀌면, 자식 컴포넌트가 각각 가지고 render메소드가 다 호출된다. 게임 완성하기상태 끌어올리기 Square Component가 9개 있고, 각각이 상태를 가지고 있다. prop을 통해서 부모 컴포넌트에서 자식 컴포넌트로 상태를 보내는 건 쉽다. 자식 컴포넌트의 상태를 부모 컴포넌트로 끌어 올린다. 상태를 가장 가까운 공통 조상에 저장한다. -&gt; 상태 끌어올리기 여러 자식 컴포넌트에 저장되어 있는 데이터를 읽어와야 할 때,혹은 자식 컴포넌트끼리 통신을 해야 할 필요가 있을 때는부모 컴포넌트에서 상태를 공유하자.부모 컴포넌트에서는 prop을 통해 자식 컴포넌트에게 상태를 내려줄 수 있다.이 방법을 통해 부모 컴포넌트와 자식 컴포넌트가 따로 놀지 않게 만들 수 있다. 상태의 불일치 문제를 피하기 위해서 상태는 하나로 두는 게 좋다. 이제 사각형을 클릭했을 때의 처리를 해주어야 한다.Board 컴포넌트가 게임 상태를 저장하고 있으므로, Square 컴포넌트에서 Board 컴포넌트의 상태를 변경할 방법이 필요하다.컴포넌트의 상태에는 자기 자신만 접근할 수 있으므로,Square 컴포넌트에서 Board 컴포넌트의 상태를 직접 변경할 수 있는 방법은 없다. 이런 경우, 부모 컴포넌트인 Board에서 상태를 바꾸는 함수를 만들어 Square에 내려줌으로써 문제를 해결할 수 있다.이 함수를 Square가 클릭되는 순간 호출해주자.일단 Board 컴포넌트의 renderSquare 메소드를 고쳐보자. (참고: 아래 코드는 아직 동작하지 않습니다.) 부모 컴포넌트의 상태를 직접적으로 바꿀 수 있는 방법은 없다. But 부모 컴포넌트에서 상태를 바꿀 수 있는 함수를 자식 컴포넌트에게 내려준다면, -&gt; 부모 컴포넌트의 상태를 간접적으로 바꿀 수 있다. 부모 컴포넌트에서 각각의 값과 상태를 바꿀 수 있는 함수를 자식 컴포넌트에게 내려줘야 한다. renderSquare함수는 Board 컴포넌트 안에 있는 함수이다. props는 부모로부터 내려주는 함수 button도 컴포넌트. 내장 Dom 컴포넌트라고 부른다. Square, board 등은 사용자 정의 컴포넌트(Custom Component)라고 부른다. setState하면, render 메소드를 실행시킨다. -&gt; 그래서 화면이 다시 그려진다. cf) 제어되는 컴포넌트(Controlled Component): 자기 스스로의 상태를 갖고 있는 컴포넌트 제어되지 않는 컴포넌트: 자기 스스로의 상태를 갖고 있지 않은 컴포넌트 컴포넌트를 사용하는 방법 2가지 클래스로 사용하는 방법 함수로 사용하는 방법 클래스 컴포넌트: class가 부모로부터 내려 받은 값은 this.props에 저장된다. 함수형 컴포넌트: props라는 매개변수에 객체가 들어온다. props객체의 속성에 부모로부터 내려받은 값이 저장되어 있다. render 메소드를 쓰지 않는다. 턴 넘기기Declaring a Winner return만을 이용해서 함수를 종료시키는 기법이 많이 사용된다. 오늘 배운 내용 정리 하나의 컴포넌트로부터 수많은 엘리먼트가 만들어질 수 있다. 컴포넌트와 엘리먼트는 React 엘리먼트는 Dom 객체가 아니다. React 객체는 Dom 객체와 전혀 상관이 없다. ex) React 엘리먼트에 .textContent해서 값을 집어넣고 싶어서 아무 반응이 없다. props는 부모로부터 값을 내려받는 통로이다. 직접 자식 컴포넌트에서 부모 컴포넌트에게 값을 넘겨줄 수 없다. addEventListener를 쓸 필요가 없다. 컴포넌트는 상태를 가질 수 있고, 꼭 setStatus를 통해서만 바꿔야 한다는 약속이 있다. 상태를 처음 만들어줄 때는 생성자 안에서 만들어주는 게 원칙이다. 1234567class Square extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: null, &#125;; &#125; setStatus는 상태 변경, 화면 갱신이라는 2가지 효과가 있다. 부모 컴포넌트에서 상태를 공유하세요. 부모 컴포넌트에서는 prop을 통해 자식 컴포넌트에게 상태를 내려줄 수 있다.이 방법을 통해 부모 컴포넌트와 자식 컴포넌트가 따로 놀지 않게 만들 수 있다. 부모 컴포넌트는 상태를 바꾸는 함수를 만들어서 자식 컴포넌트에게 내려준다. 이 함수를 이용해서 자식 컴포넌트에서 부모 컴포넌트의 상태를 간접적으로 바꿔줄 수 있다.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"2019 상반기 공채 대비 코딩테스트 실전 모의고사 2회","slug":"programmers-second-mock-exam1","date":"2019-02-15T14:45:52.000Z","updated":"2019-02-15T15:03:19.447Z","comments":true,"path":"2019/02/15/programmers-second-mock-exam1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/15/programmers-second-mock-exam1/","excerpt":"","text":"2019 상반기 공채 대비 코딩테스트 실전 모의고사 2회 참고 사이트 빅오표기법 1. 배열 회전 배열의 회전이란 모든 원소를 오른쪽으로 한 칸씩 이동시키고,마지막 원소는 배열의 맨 앞에 넣는 것을 말합니다. 두 배열 arrA와 arrB가 매개변수로 주어질 때,arrA를 회전해 arrB로 만들 수 있으면 true를그렇지 않으면 false를 return 하는 solution 함수를 작성해주세요. 반복문을 사용할 수 있는지 물어보는 문제 아주 기초적인 문제이니 어렵지 않게 풀 수 있었을거에요. Python 코드1234567891011121314151617181920212223# def는 함수 정의# rotate는 함수 이름def rotate(arr): return arr[-1:] + arr[:-1]# python array modules# slice notation(:)# solution이라는 이름을 가진 함수를 정의def solution(arrA, arrB): arrA_len = len(arrA) arrB_len = len(arrB) # 길이가 다른 배열은 회전해도 같아질 수 없으므로, early return if(arrA_len!=arrB_len): return False # arrA를 한칸씩 회전하며, arrB와 같은지 확인 for _ in range(arrA_len): if arrA == arrB: return True arrA = rotate(arrA) return False Python 관련 내 해석12345678# def는 함수 정의# rotate는 함수 이름def rotate(arr): return arr[-1:] + arr[:-1]# python array modules# slice notation(:)# arr[-1:]배열의 끝부터 첫번째까지의 item# arr[-1:]배열의 처음부터 끝까지의 item 12def 함수이름(): # 1. 첫 행 본문 # 2. 함수를 호출했을 때 실행할 코드 블록 파이썬에서는끝에서부터 index를 매길때는 음수를 사용한다. 123456789ex) word = 'Python'word[-1]# last chracter# 출력값 'n'word[-6]# sixth-last character# 출력값 'P' Pytoh에서의 slicestep을 명시하지 않을 경우start:stop[:step] 여기서 [:step]은 써도 되고 안써도 된다. a[start:end] # start부터 end-1까지의 item a[start:] # start부터 리스트 끝까지 item a[:end] # 처음부터 end-1까지의 item a[:] # 리스트의 모든 item step을 명시하는 경우 a[start:end:step]# start부터 end-1까지 step만큼 인덱스 증가시키면서step을 지정할 때 :end에 유의하세요 end는 end부터 포함시키지 않겠다는 의미이지 end가 꼭 포함된다는 의미는 아닙니다. 또 start나 end가 음수가 음수인 경우에는 리스트의 끝에서부터 카운트하겠다는 의미입니다. a[-1] # 맨 뒤의 item a[-2:] # 맨 뒤에서부터 item2개 a[:-n] # 맨 뒤의 item n개 빼고 전부 예제를 보여드릴게요 123456789a = [10,11,12,13,14,15,16,17,18,19]print \"a =\", aprint \"a[0:1]:\", a[0:1]print \"a[0:1]:\", a[0:10]print \"a[0:1]:\", a[0:20]print \"a[0:1]:\", a[0:10:2]print \"a[0:1]:\", a[:-2]print \"a[0:1]:\", a[:-30] 의 결과는 12345678a = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]a[0:1]: [10]a[0:1]: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]a[0:1]: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]a[0:1]: [10, 12, 14, 16, 18]a[0:1]: [10, 11, 12, 13, 14, 15, 16, 17]a[0:1]: []입니다. 1234a[start:end] # start부터 end-1까지의 itema[start:] # start부터 리스트 끝까지 itema[:end] # 처음부터 end-1까지의 itema[:] # 리스트의 모든 item 즉, rotate라는 함수는 arr를 받아서 배열의 끝부터 맨앞까지 검사하는 함수이다. Python -&gt; JavaScript로 바꾸기참고 김승하 선생님 교재 JAVASCRIPT로 만나는 세상- 배열 MDN Array.prototype.slice() 123456789101112131415161718192021222324252627282930const rotate(arr) &#123; // 배열로부터 새로운 값 생성// * slice 메소드// 배열의 일부분에 해당하는 새로운 배열을 반환한다.// 원본 배열에 아무런 영향을 미치지 않는다.// 얕은 복사(shallow copy)를 하므로,// 배열 안에 배열 또는 객체가 들어있을 때는 주의해서 사용해야 한다.// 1. 인덱스 arr의 마지막 번째부터 arr의 맨 앞까지의 요소들을 가지고 새로운 배열을 생성한다.// 2. return arr.slice(-1, 0);&#125;// # solution이라는 이름을 가진 함수를 정의def solution(arrA, arrB): arrA_len = len(arrA) arrB_len = len(arrB) // # 길이가 다른 배열은 회전해도 같아질 수 없으므로, early return if(arrA_len!=arrB_len): return False // # arrA를 한칸씩 회전하며, arrB와 같은지 확인 for _ in range(arrA_len): if arrA == arrB: return True arrA = rotate(arrA) return False 12345678def rotate(arr):return arr[-1:] + arr[:-1]def solution(arrA, arrB):# len()은 리스트에 들어있는 원소 개수# -&gt; 즉, 리스트의 크기를 알려주는 함수arrA_len = len(arrA)arrB_len = len(arrB) 12345678910111213141516171819202122232425262728const rotate(arr)&#123;return arr.slice(-1, 0) +arr(0, -1);&#125;const solution(arrA, arrB)&#123;let arrA_len = arrA.length;let arrB_len = arrB.length;// 첫 번째 base case// 배열의 길이가 다르면, 회전해도 같아질 수 없으므로// return하고 함수를 종료한다.if (arrA_len !== arrB_len) &#123;return false;&#125;// 두 번째 base case// arrA를 한칸씩 회전하면서, arrB와 같은지를 확인한다. // for _ in range(arrA_len): // if arrA == arrB: // return True // arrA = rotate(arrA) // return False for (let i = 0; i &lt; arrA_len; i++)&#123; if (arrA == arrB)&#123; return true; &#125; arrA = rotate(arrA); &#125; return false;&#125;","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://JihyeHwang09.github.io/tags/알고리즘/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"https://JihyeHwang09.github.io/tags/프로그래머스/"},{"name":"코딩테스트","slug":"코딩테스트","permalink":"https://JihyeHwang09.github.io/tags/코딩테스트/"}]},{"title":"반복문(while, for)","slug":"js-zerocho2","date":"2019-02-14T10:30:22.000Z","updated":"2019-02-14T11:12:43.857Z","comments":true,"path":"2019/02/14/js-zerocho2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/14/js-zerocho2/","excerpt":"","text":"본 포스팅은&lt;ZeroCho님의 인프런 - 웹 게임 개발 자바스크립트 &gt;강의를 들으면서 정리한 내용임을 알려드립니다. 반복문while문먼저, while문의 형태를 보자. 12345처음;while (조건) &#123; 실행; 끝;&#125; 1234let 변수 = \"딸기\";while (\"딸기\" === 변수) &#123; console.log(\"딸기 좋아\");&#125; while문의 조건이 true이기 때문에무한반복 된다. 이렇게 무한 반복이 될 경우, 컴퓨터가 먹통이 된다. 그렇다면, 무한 반복이 되는 이 while문을어떻게 프로그래밍에서 사용할 수 있을까?아래의 예문을 보자. 12345let 변수 = 0;while (변수 &lt; 5) &#123; console.log(\"딸기 좋아\"); 조건 = 조건 + 10;&#125; 앞의 예문에서와 같이 while문을 사용하는 예제이다.변수는 변할 수 있는 값을 말하므로 이 변수 값을 바꿔서조건인 (변수 &lt; 5)를 false로 만들 수 있다.변수 값을 바꾸는 방법을 여러 가지가 있는데, 1조건 = 조건 + 10; 이 예제에서는 조건 = 조건 + 10;을 주어while문이 무한반복하지 않도록 만들었다. 반복문의 실행 순서에 대해 알아보자. 1234567let 조건 = 0; // 1while (조건 &lt; 5) &#123; //2 5 console.log(\"딸기 좋아\"); // 3 조건 = 조건 + 10; //4&#125;(\"과일 좋아\"); // 6 자바스크립트 코드의 흐름은 가장 윗 줄부터 차례대로 실행된다.반복문을 만나면, 반복문의 조건이 false가 될 때까지 반복한 후, 빠져나온다.그 후 아래에 있는 코드가 실행된다.반복문의 조건을 검사하여 false가 되는지 검사를 하고,반복문을 빠져나가는 것이다. 1234567let 조건 = 0; // 1while (조건 &lt; 5) &#123; //2 5 8 console.log(\"딸기 좋아\"); // 3 6 조건 = 조건 + 3; //4 7&#125;(\"과일 좋아\"); // 9 변수인 조건의 값이 0부터 시작해서,while문 안의 코드를 반복하다가조건의 값이 6이 되어 5보다 커지므로 그 때 반복문을 빠져나와반복문 바깥, 아래에 있는 “과일 좋아”라는 코드가 실행된다. 반복문을 조건문으로 바꿔보면, 그 실행 흐름을쉽게 이해할 수 있다.아래 예제를 보자. 12345678910111213141516171819let 조건 = 0; // 1if (조건 &lt; 5) &#123; // 2 console.log(\"딸기 좋아\"); // 3 조건 = 조건 + 3; //4 조건:3&#125;if (조건 &lt; 5) &#123; //5 console.log(\"딸기 좋아\"); // 6 조건 = 조건 + 3; // 7 조건: 6&#125;if (조건 &lt; 5) &#123; // 8 // 조건이 6이므로 false가 되어 반복문 빠져나옴 //8 console.log(\"딸기 좋아\"); 조건 = 조건 + 3;&#125;(\"과일 좋아\"); // 9 이렇게 조건문을 쭉 나열한 것을 줄여서 while문이 된 것이다. for문for문의 형태를 보자. 123for (처음; 조건; 끝) &#123; 실행;&#125; for문은 while문보다 코드가 짧다.그만큼 압축되어 들어있다는 것을 의미한다.while문을 for문으로, for문을 while문으로 바꿀 수 있다.while문과 for문을 비교해보자. 12345678// while문let 조건 = 0; // 1while (조건 &lt; 5) &#123; //2 5 8 console.log(\"딸기 좋아\"); // 3 6 조건 = 조건 + 3; // 4 7 조건:3&#125;(\"과일 좋아\"); // 9 12345// for문for (let 조건 = 0; 조건 &lt; 5; 조건 = 조건 + 3) &#123; console.log(\"딸기 좋아\");&#125;(\"과일 좋아\");","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 기초","slug":"js-zerocho1","date":"2019-02-13T09:48:34.000Z","updated":"2019-02-13T11:14:51.496Z","comments":true,"path":"2019/02/13/js-zerocho1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/13/js-zerocho1/","excerpt":"","text":"본 포스팅은&lt;ZeroCho님의 인프런 - 웹 게임 개발 자바스크립트 &gt;강의를 들으면서 정리한 내용임을 알려드립니다. &quot;REPL&quot;: READ EVALUATE PRINT LOOP 연산자 우선순위 대입연산자인 =이 제일 마지막에 실행된다. 소괄호()를 쓰면 연산자 우선순위를 바꿀 수 있다.(수학처럼) 함수1y = f(x) x**2 + x + 5 123function (x, z) &#123; return x + z + 5;&#125; ()부분이 입력값,return 부분이 출력값이라고 생각해도 된다. 123454 + 7 + 3 + 5; // 198 + 1 + 3 + 5; // 1710 + 3 + 3 + 5; // 2113 + 4 + 3 + 5; // 2512 + 4 + 3 + 5; // 24 바뀌는 부분만 첫째, 둘째로 넣고,나머지 공통되는 부분인 +3 + 5를 써넣는다. 123function 더하기(첫째, 둘째) &#123; return 첫째 + 둘째 + 3 + 5;&#125; 1234567891011console.log(\"안녕하세요\");console.log(\"제로초님\");console.log(\"반가워요\");console.log(\"안녕하세요\");console.log(\"김성수님\");console.log(\"반가워요\");console.log(\"안녕하세요\");console.log(\"진호인님\");console.log(\"반가워요\"); 이름 부분만 바뀌고 있다. 불필요하게 코드를 반복하고 있다. 반복되는 부분을 함수로 만들자. 12345function 인사(이름) &#123; console.log(\"안녕하세요\"); console.log(이름 + \"님\"); console.log(\"반가워요\");&#125; 이제 위 함수를 이용하여 처음에 총 9줄로 작성했던 코드를 3줄로 줄일 수 있다. 123456789101112인사(\"제로초\");// 안녕하세요// 제로초님// 반가워요인사(\"김성수\");// 안녕하세요// 김성수님// 반가워요인사(\"진호인\");// 안녕하세요// 진호인님// 반가워요 123함 수 야 놀 자1 2 3 4 5 &lt;-- 사람0 1 2 3 4 &lt;-- 컴퓨터(자바스크립트) 사람은 보통 1부터 세고,자바스크립트에서는 0부터 센다.cf) 파이썬같은 언어는 0이 아닌 1부터 센다. 123456\"함수야놀자\"[2];//야\"함수야놀자\"[0];//함\"함수야놀자\"[3];//놀 조건문if else문1234567if (true) &#123; (\"안녕\");&#125; else &#123; (\"잘가\");&#125;// 조건문에 true가 들어있으므로// 무조건 `안녕`이 나옴 12345678let 변수 = false;// 다른 코드// 다른 코드if (변수) &#123; (\"안녕\");&#125; else &#123; (\"잘가\");&#125; 시한 폭탄을 if ~ else문으로 짠다고 생각해보자. 12345678910111213let 변수 = \"펑\";변수 = \"암호\";if (변수 === \"펑\") &#123; (\"펑펑\");&#125; else &#123; (\"해제되었습니다.\");&#125;// 변수 값이 \"펑\"일 때는 \"펑펑\"이 나오지만,// 변수에 \"암호\"라는 값이 대입되었기 때문에// 실행흐름이 바뀌어서// \"해제되었습니다.\"가 나온다. else if문을 이용한 예시1234567891011let 변수 = \"사과\";if (변수 === \"사과\") &#123; (\"사과 좋아\");&#125; else if (변수 === \"오렌지\") &#123; (\"오렌지 좋아\");&#125; else if (변수 === \"딸기\") &#123; (\"딸기 좋아\");&#125; else &#123; (\"과일 싫어\");&#125; 자바스크립트는 코드가 위에서부터 한 줄씩 읽어 내려간다. if를 보는 순간, 우리 앞에는 4가지의 갈림길이 생긴 것이다. 이 4가지 조건 중에 하나가 실행된다. 이 4가지 조건들은 첫 번째 조건부터 차례대로 검사한다. if ~ else if ~ else문은코드에 갈림길을 제공한다고 생각하면 쉽다. 조건문에서 else if(){}와 else {}는 써도 되고 안 써도 된다. if만 써도 된다.(조건문을 쓰고자 한다면 if는 필수로 써야 함)cf) switch문도 참고","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"전송 오류 제어 방식","slug":"data-communication6","date":"2019-02-12T12:59:23.000Z","updated":"2019-02-12T13:14:39.065Z","comments":true,"path":"2019/02/12/data-communication6/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/12/data-communication6/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 전송 오류 제어 방식에 대해 알아봅시다.전송 오류 제어 방식전진(순방향) 오류 수정(FEC) 재전송 요구 없이 수신 측에서 스스로 오류 검출과수정을 하는 방식 역채널이 필요 없고, 연속적인 데이터 흐름이 가능함 데이터 비트 이외에 오류 검출 및 수정을 위한 비트(잉여 비트)들이 추가로 전송되어야 하기 때문에 전송 효율이 떨어짐 해밍 코드, 상승 코드 방식이 있음 후진(역방향) 오류 수정(BEC) 데이터 전송 과정에서 오류가 발생하면송신 측에 재전송을 요구하는 방식 패리티 검사, CRC, 블록 합 방식 등을 사용하여오류를 검출하고, 오류 제어는 자동 반복 요청(ARQ)에 의해이루어짐 순방향 에러 수정(Forward Error Correction) 방식에 사용되는 검사 방식에는 (해밍 코드), (상승 코드)가 있다. 송신 측에서 정보 비트에 오류 정정을 위한제어 비트를 추가하여 전송하면 수신 측에서 이 비트를 사용하여에러를 검출하고 수정하는 방식은 (전진(순방향) 오류 수정(FEC))이다. 전진에러수정(FEC) 코드는 역채널을 사용한다.(X) 1234[해설]3. 전진 오류 수정(FEC)은 데이터 전송 과정에서 발생한 오류를검출하여 오류를 재전송 오류 없이 스스로 수정하는 방식 입니다.즉 재전송 요구가 없기 때문에 역 채널이 필요 없습니다. 전진 오류 정정(FEC) 방식은 데이터 전송 과정에서 오류가발생하면 송신 측에 재전송을 요구하는 방식이다. (X) 12345[해설]4. 전진(순방향) 오류 정정(FEC) 방식은송신 측에 재전송을 요구하지 않습니다.송신 측에 재전송을 요구하는 방식은후진(역방향) 오류 수정 방식입니다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"전송 오류 제어 방식","slug":"전송-오류-제어-방식","permalink":"https://JihyeHwang09.github.io/tags/전송-오류-제어-방식/"}]},{"title":"HDLC의 프레임 및 데이터 전송 모드","slug":"data-communication5","date":"2019-02-11T13:50:04.000Z","updated":"2019-02-11T14:16:27.231Z","comments":true,"path":"2019/02/11/data-communication5/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/11/data-communication5/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 HDLC의 프레임 및 데이터 전송 모드에 대해 알아봅시다. 본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. HDLC의 프레임 종류정보(I) 프레임(Information Frame) 제어부가 &#39;0&#39;으로 시작하는 프레임 사용자 데이터를 전달하거나 피기백킹(Piggybacking) 기법을 통해데이터에 대한 확인 응답을 보낼 때 사용 감동(S) 프레임(Supervisor Frame) 제어부가 &#39;10&#39;으로 시작하는 프레임 오류 제어와 흐름 제어를 위해 사용 비번호(U) 프레임(Unnumbered Frame) 제어부가 &#39;11&#39;로 시작하는 프레임 링크의 동작 모드 설정과 관리, 오류 회복을 수행함 HDLC의 데이터 전송 모드: 데이터 전송 모드는 제어부에서 관리하는 U프레임에 의해 설정 표준(정규) 응답 모드(NRM) 반이중 통신을 하는 포인트 투 포인트 또는 멀티 포인트불균형 링크 구성에 사용 종국은 주국의 허가(Poll)이 있을 때에만 송신 비동기 응답 모드(ARM) 전이중 통신을 하는 포인트 투 포인트 불균형 링크 구성에 사용 종국은 주국의 허가(Poll) 없이도 송신이 가능하지만,링크 설정이나 오류 복구 등의 제어기능은 주국만 함 비동기 균형(평형) 모드(ABM) 전이중 통신을 하는 포인트 투 포인트 균형 링크에서 사용 혼합국끼리 허가 없이 언제나 전송할 수 있도록 설정 다음 전송 모드 중 HDLC에서 사용되지 않는 것은(b. 동기 응답 모드(SRM))이다. 1234a. 정규 응답 모드(NRM)b. 동기 응답 모드(SRM)c. 비동기 응답 모드(ARM)d. 비동기 평형 모드(ABM) 다음 설명에 알맞은 프레임을 고르시오. 1234a. 감독(Supervisor) 프레임b. 조정(Controll) 프레임c. 정보(Information) 프레임d. 비번호(Unnumbered) 프레임 1) 보기 중 HDLC에서 사용하는 프레임이 아닌 것은 `(b. 조정(Controll) 프레임)`이다. 2) 흐름 제어나 에러 제어를 위해 사용되는 프레임은 `(a. 감독(Supervisor) 프레임)`이다. 3) 사용자 데이터 전달을 위해 사용되는 프레임은 `(c. 정보(Information) 프레임)`이다. 4) 링크의 설정과 해제, 오류 회복을 위해 주로 사용되는 프레임은 `(d. 비번호(Unnumbered) 프레임)`이다. 5) 피기백킹(Piggybacking) 기법을 통해 데이터에 대한 확인 응답을 보낼 때 사용되는 프레임은 `(c. 정보(Information) 프레임)`이다. HDLC의 동작 모드 중 전이중 전송의 점대점 균형 링크 구성에 사용되는 것은 (비동기 균형(평형) 모드(ABM))이다. HDLC(High-level Data Link Control)의 세 가지 동작 모드 중 다음 설명에 해당하는 것은 (표준(정규) 응답 모드(NRM))이다. 123- 이 모드는 점대점이나 멀티포인트 불균형 링크 구성에 사용된다.- 주 스테이션이 링크 제어를 담당하며,부 스테이션은 주 스테이션으로부터 폴 메시지를 수신한 경우에만 데이터를 전송할 수 있다. (피기백킹(Piggybacking))은 수신측이 별도의 ACK를 보내지 않고 상대편으로 향하는 데이터 전문을 이용하여 응답하는 것이다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"HDLC","slug":"hdlc","permalink":"https://JihyeHwang09.github.io/tags/hdlc/"},{"name":"High-level Data LInk Control","slug":"high-level-data-link-control","permalink":"https://JihyeHwang09.github.io/tags/high-level-data-link-control/"},{"name":"데이터 전송 모드","slug":"데이터-전송-모드","permalink":"https://JihyeHwang09.github.io/tags/데이터-전송-모드/"}]},{"title":"전송 제어의 기본","slug":"data-communication4","date":"2019-02-10T00:28:40.000Z","updated":"2019-02-11T14:07:35.667Z","comments":true,"path":"2019/02/10/data-communication4/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/10/data-communication4/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 전송 제어의 기본과 HDLC(High-level Data Link Control)의 특징에 대해 알아봅시다. 본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. 전송 제어의 기본1. 전송 제어 데이터의 원활한 흐름을 위하여 입.출력 제어, 회선 제어, 동기 제어, 오류 제어, 흐름 제어 등을 수행하는 것 OSI 7 참조 모델의 데이터 링크 계층(2계층)에서 수행하는 기능이다. 2. 전송 제어 절차데이터 통신 회선의 접속 -&gt; 데이터 링크 설정(확립)-&gt; 정보 메시지 전송 -&gt; 데이터 링크 종결 -&gt; 데이터 통신 회선의 절단 다음은 전송 제어 절차를 순서 없이 나열한 것이다.알맞은 답을 고르시오.(1~2번) 12345a. 통신 회선 접속b. 정보 전송c. 데이터 링크 해제d. 데이터 링크 확립e. 통신 회선 절단 전송 제어 절차를 순서에 맞게 나열하시오.(a -&gt; d -&gt; b -&gt; c -&gt; e) 접속된 통신 회선 상에서 송신 측과 수신 측 간의 확실한 데이터 전송을 수행하기 위해논리적 경로를 구성하는 단계는 (d)이다. HDLC(High-level Data LInk Control)의 특징 비트(Bit) 위주의 프로토콜로, 각 프레임에 데이터의 흐름을 제어하고오류를 검출할 수 잇는 비트 열을 삽입하여 전송한다. 포인트 투 포인트 및 멀티 포인트, 루프 방식에서 모두 사용 가능하다. 단방향, 반이중, 전이중 통신을 모두 지원하며,동기식 전송 방식을 사용한다. 오류 제어를 위해 Go-Back-N과 선택적 재전송(Selective Repeat) ARQ를 사용한다. 흐름 제어를 위해 슬라이딩 윈도우 방식을 사용한다. 전송 제어상의 제한을 받지 않고 자유로이 비트 정보를 전송할 수 있는 것을 비트 투과성(투명성)이라고 한다. 비트 투과성(투명성)을 보장하기 위한 기능으로 비트 스터핑(Bit Stuffing)이 사용된다. 전송 효율과 신뢰성이 높다. HDLC 프레임 구조 HDLC 프레임 구조 - 이미지 출처 HDLC의 프레임 구조를 순서대로 나열하면,(주소부) -&gt; (제어부) -&gt; (정보부) -&gt; FCS -&gt; 플래그 순이 된다. 데이터 링크 프로토콜인 HDLC(High level Data Link Control)에서프레임의 동기를 제공하기 위해 사용되는 것으로항상 ‘01111110’의 형태를 보이는 구성 요소는 (플래그(Flag))이다. 데이터 링크 제어 프로토콜 중 전송 효율과 신뢰성이 높고정보 전송 단위가 프레임인 전송 제어 방식은 (HDLC)이다. 다음 중 HDLC 프로토콜의 특징이 아닌 것을 모두 고르시오.(c, e, f, g) 1234567a. 점대점 링크 및 멀티포인트 링크를 위한 프로토콜이다.b. 반이중 통신과 전이중 통신을 모두 지원한다.c. 비동기식 전송 방식을 사용한다.d. 슬라이딩 윈도우 방식에 의해 흐름 제어를 제공한다.e. 에러 제어를 위해 Stop-and-Wait 방식을 사용한다.f. 문자 지향형 전송 프로토콜이다.g. FCS 영역의 길이는 64비트이다. 123456[해설]c. HDLC 프로토콜은 동기식 전송 방식을 사용합니다.e. HDLC 프로토콜은 에러 제어를 위해 Go-Back-N ARQ와선택적 재전송 ARQ를 사용합니다.f. HDLC는 비트 지향형 전송 프로토콜 입니다.g. FCS 영역의 길이는 16 비트 또는 32비트 입니다. HDLC에서 비트 스터핑(Bit Stuffing)을 수행하는 목적은데이터의 투명성을 보장하기 위해서이다.(O) HDLC 프레임의 시작과 긑을 정의하는 것은 (플래그)이다. HDLC 프레임 형식 중 프레임의 종류를 식별하기 위해 사용되는 것은(제어부)이다. HDLC 프레임 구성에서 프레임 검사 시퀀스(FCS) 영역의 기능은(전송 오류 검출)이다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"HDLC","slug":"hdlc","permalink":"https://JihyeHwang09.github.io/tags/hdlc/"},{"name":"data-communication","slug":"data-communication","permalink":"https://JihyeHwang09.github.io/tags/data-communication/"},{"name":"전송 제어의 기본","slug":"전송-제어의-기본","permalink":"https://JihyeHwang09.github.io/tags/전송-제어의-기본/"},{"name":"High-level Data Link Control","slug":"high-level-data-link-control","permalink":"https://JihyeHwang09.github.io/tags/high-level-data-link-control/"}]},{"title":"통신 속도와 통신 용량","slug":"data-communication3","date":"2019-02-08T16:50:22.000Z","updated":"2019-02-09T03:59:16.709Z","comments":true,"path":"2019/02/09/data-communication3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/09/data-communication3/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 통신 속도와 통신 용량에 대해 알아봅시다. 본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. 통신 속도 / 통신 용량1. 통신 속도1) 변조 속도 1초 동안 몇 개의 변화가 있었는가를 나타내는 것(단위: Baud) 변조 속도(Baud) = 데이터 신호 속도(Bps)/ 변조 시간 상태 변화 수 2) 신호 속도 1초 동안 전송 가능한 비트의 수(단위: Bps(Bit/Sec)) 데이터 신호 속도(Bps) = 변조 속도(Baud) X 변조 시간 상태 변화의 수 3) 전송 속도 단위 시간에 전송되는 데이터의 양(문자, 블록, 비트, 단어 등) 4) 베어러 속도 데이터 신호에 동기 문자, 상태 신호 등을 합한 속도(Bps(Bit/Sec)) 변조 시 상태 변화 수 모노비트(Monobit) = 1Bit 디비트(Dibit) = 2Bit 트리비트(Tribit) = 3Bit 쿼드비트(Quadbit) = 4Bit 2. 통신 용량 단위 시간 동안 전송 회선이 최대로 전송할 수 있는 통신 정보량 샤논(Shannon)의 정의 1C = W * log₂(1 + S/N) C: 통신 용량, W: 대역폭(대역폭이 ‘Band Width’이므로 &#39;W&#39; 대신 &#39;B&#39;로도 사용), S: 신호 전력, N: 잡음 전력 전송로의 통신 용량을 늘리기 위한 방법 주파수 대역폭을 늘림 신호 세력을 높임 잡음 세력을 줄임 보(Baud) 속도가 2,400[Baud]이고 8위상 2진폭 변조를 수행하는 모뎀(MODEM)이라면데이터 전송 속도는 (9,600)bps이다. 1234567891011[해설]8위상이란 2진수 3비트로 표현 가능한 수로변조 시 상태 변화 수는 3Bit이고,2진폭이란 2진수 1비트로 표현 가능한 수로변조 시 상태 변화 수는 1Bit 입니다.-&gt; 변조 시 상태 변화 수는 모두 4Bit 입니다.-&gt; 신호 속도(bps) 계산 공식인`Bps = 변조 속도(Baud) X 변조 시 상태 변화 수&apos;에 대입하면,Bps = 2,400 X 4 = 9,600Bps 입니다. 4,800[Bps]의 8위상 편이 변조 방식 모뎀의 변조 속도는(1,600) 보[Baud]이다. 12345678[해설]8위상이란 2진수 3비트로 표현 가능한 수로변조 시 상태 변화 수는 3Bit이고,변조 속도(Baud) 계산 방법인&apos;Baud = 신호 속도(Bps) / 변조 시 상태 변화 수&apos;이므로Baud = 4,800 / 3 = 1,600Baud 입니다. 신호 속도, 변조 속도, 베어러 속도, 변환 속도 중통신 속도를 나타내는 단위가 아닌 것은 (변환 속도)이다. 123[해설]통신 속도를 나타내는 단위에는신호 속도, 변조 속도, 전송 속도 베어러 속도가 있습니다. 신호 대 잡음비가 63인 전송 채널의 대역폭이 8KHz라 하면통신 용량은 (48000)bps이다. 12345[해설]통신용량(C) = W * log₂(1 + S/N)이므로C = 8K * log₂(64)C = 8000 * 6C = 48000","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"data-communication","slug":"data-communication","permalink":"https://JihyeHwang09.github.io/tags/data-communication/"},{"name":"통신 속도","slug":"통신-속도","permalink":"https://JihyeHwang09.github.io/tags/통신-속도/"},{"name":"통신 용량","slug":"통신-용량","permalink":"https://JihyeHwang09.github.io/tags/통신-용량/"}]},{"title":"펄스 코드 변조(PCM)와 다중화기(Multiplexer)","slug":"data-communication2","date":"2019-02-08T06:39:50.000Z","updated":"2019-02-08T16:52:42.334Z","comments":true,"path":"2019/02/08/data-communication2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/08/data-communication2/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 펄스 코드 변조(PCM)와 다중화기(Multiplexer)에 대해 알아봅시다. 본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. 펄스 코드 변조(PCM) 화상, 음성, 동영상 비디오, 가상 현실 등과 같이연속적인 시간과 진폭을 가진 아날로그 데이터를디지털 신호로 변조하는 방식으로, CODEC을 이용한다. 펄스 코드 변조(PCM) 순서: 송신 측(표본화 -&gt; 양자화 -&gt; 부호화 -&gt; 수신 측(복호화 -&gt; 여과화) 아날로그-디지털 부호화 방식인 PCM(Pulse Code Modulaiton) 송신 측 과정을순서대로 바르게 나열하면(표본화(Sampling))-&gt; (양자화(Quantizing))-&gt; (부호화(Encoding))순이다. 음성 주파수 대역이 4KHz일 때, 디지털화하기에 가장 적당한 샘플 주파수는 (8)KHz이다. 123해설2. 샤논의 표본화 이론에 의해 적당한 표본화(샘플링) 횟수는 최고 주파수의 2배입니다.표본화 횟수 = 2 X 4KHz = 8KHz 아날로그 데이터(음성)를 디지털 신호로 전송하기에 적합한 변조 방법은(펄스코드변조방식(PCM))이다. PCM(Pulse Code Modulaiton)방식에서 PAM(Pulse Amplitude Modulation)신호를얻는 과정은 (표본화)이다. PCM 방식에서 표본화 과정을 거친 신호의 진폭을이산값으로 변화시키는 과정은 (양자화)이다. PCM 방식은 Frequency Modulation을 사용하여 변조한다.(X) 12해설6. PCM 방식은 Pulse Code Modulaiton을 사용하여 변조합니다. PAM 펄스의 아날로그 값과 양자화된 PCM 펄스의 디지털값의 차이를(양자화 잡음)이라고 한다. PCM 과정 중 양자화 과정에서 레벨 수가 128레벨인 경우(7) 비트로 부호화 된다. 123해설표본당 비트 수가 n인 경우 양자화 레벨은 2^n이므로,양자화 레벨이 128인 경우 표본당 비트 수는 7입니다. 다중화기(Multiplexer) 하나의 통신 회선에 여러 대의 단말기가 동시에 접속하여 사용할 수 있도록 하는 장치 cf) 다중화(Multiplexing): 하나의 통신 회선을 다수의 단말기가 공유할 수 있도록 하는 것으로,다중화를 위한 장치에는 다중화기, 집중화기, 공동 이용기가 있습니다. 다음과 같은 특징을 갖는 장비는 (다중화기(Multiplexer))이다. 123456- 여러 개의 채널들이 하나의 통신 회선을 통하여 결합된 신호의 형태로 전송되고, 수신 측에서 다시 이를 여러 개의 채널 신호로 분리하는 역할을 수행하는 장비- 여러 단말기가 같은 장소에 위치하는 경우, 하나의 통신 회선을 공유하도록 하여 전송로의 수를 감소시키기 위해 사용하는 장비 다중화(Multiplexing)을 함으로써 얻어지는 가장 좋은 점은전송 효율을 높일 수 있다는 것이다.(O) 효율적인 전송을 위해 넓은 대역폭(고속 전송 속도)을 가진하나의 전송 링크를 통해 여러 신호(데이터)를 동시에 실어 보내는기술은 (다중화)이다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"data-communication","slug":"data-communication","permalink":"https://JihyeHwang09.github.io/tags/data-communication/"},{"name":"펄스 코드 변조","slug":"펄스-코드-변조","permalink":"https://JihyeHwang09.github.io/tags/펄스-코드-변조/"},{"name":"PCM","slug":"pcm","permalink":"https://JihyeHwang09.github.io/tags/pcm/"},{"name":"다중화기","slug":"다중화기","permalink":"https://JihyeHwang09.github.io/tags/다중화기/"},{"name":"Multiplexer","slug":"multiplexer","permalink":"https://JihyeHwang09.github.io/tags/multiplexer/"}]},{"title":"전송 방식","slug":"data-communication1","date":"2019-02-07T14:06:21.000Z","updated":"2019-02-08T16:52:45.400Z","comments":true,"path":"2019/02/07/data-communication1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/07/data-communication1/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 전송 방식에 대해 알아봅시다. 본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. 전송 방식전송 방식에는동기식 전송과 비동기식 전송이 있다. 비동기식 전송 비동기식 전송에서 어떤 문자도 전송되지 않을 때 통신 회선은 예비(Reserve) 상태가 된다.(X) 123해설 1. 비동기식 전송에서 어떤 문자도 전송되지 않을 때 통신 회선은 휴지(Idle)상태가 됩니다. 비동기식 전송에서는 송.수신기의 클록 오차에 의한 오류 발생을 줄이기 위해짧은 비트열은 전송하지 않음으로써 타이밍 오류를 피한다.(X) 1234해설비동기 전송 방식은 짧은 비트열도 전송합니다.비동기 전송 방식은 타이밍 오류를 피하기 위해Start Bit와 Stop Bit를 사용하여 동기를 맞춥니다. 비동기 전송 방식에서 스타트(Start) 신호와 스톱(Stop) 신호는(Byte와 Byte) 사이를 구분하기 위하여 사용한다. 동기식 전송 다음 그림과 같은 전송 방식은 (동기식 전송 방식)이다.| SYN | SYN | STX | TEXT | ETX | 123456해설그림은 동기식 전송 방식 중에서 SYN 등의 동기 문자(전송 제어 문자)에 의해동기를 맞추는 문자 위주 동기 방식입니다.또한 아래 그림과 같이 동기 문자로 구성된 프레임 단위로 전송하는 비트(프레임)위주 동기 방식도그림과 함께 종종 출제되고 있으니 함께 알아두세요.| Control | error check | user data | control | address | sync | 다음 보기를 동기식 전송과 비동기식 전송으로 구분하시오. 비동기식 전송 123456a. 이진수 0 값을 갖고 1비트의 길이만큼 지속되는 시작(Start) 비트와이진수 1값을 갖고 1~2비트의 길이만큼 지속되는 정지(Stop)비트를 사용한다.b. 저속인 통신 시스템에 주로 사용한다.c. 비트 열이 전송되지 않을 때는 휴지 상태가 된다. 동기식 전송 12345678910111213d. 문자 또는 비트들의 데이터 블록을 송.수신한다.e. 전송 효율이 좋고 주로 원거리 전송에 사용하며 정보의 프레임 구성에 따라문자 동기 방식, 비트 동기 방식, 프레임 동기 방식으로나뉘는 전송 방식f. 동기 문자, 제어 정보, 데이터 블록을 구성되는 프레임이 사용된다.g. 수신기가 데이터 블록의 시작과 끝을 정확히 인식하기 위한프레임 레벨의 동기화가 요구된다.h. 전송할 데이터를 블록으로 구성하며,송신기와 수신기가 동일한 클록을 사용하여 데이터를 송수신한다. 전송 데이터와 제어 정보를 합친 것으로동기식 전송의 전송 단위를 (프레임)이라고 한다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"data-communication","slug":"data-communication","permalink":"https://JihyeHwang09.github.io/tags/data-communication/"},{"name":"전송 방식","slug":"전송-방식","permalink":"https://JihyeHwang09.github.io/tags/전송-방식/"},{"name":"동기식 전송","slug":"동기식-전송","permalink":"https://JihyeHwang09.github.io/tags/동기식-전송/"},{"name":"비동기식 전송","slug":"비동기식-전송","permalink":"https://JihyeHwang09.github.io/tags/비동기식-전송/"}]},{"title":"정보처리기사 시험에 자주 출제되는 주제","slug":"engineer-information-processing","date":"2019-02-06T14:48:35.000Z","updated":"2019-02-08T16:52:44.573Z","comments":true,"path":"2019/02/06/engineer-information-processing/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/06/engineer-information-processing/","excerpt":"","text":"본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. 1과목: 데이터베이스데이터베이스의 개념스키마(Schema)데이터 모델의 개념개체-관계 모델데이터베이스 설계관계형 데이터베이스의 구조관계형 데이터베이스의 제약 조건관계대수 및 관계해석정규화(Normalization)뷰(View)시스템 카탈로그트랜잭션의 개념병행제어스택(Stack)이진 트리의 운행법(Traversal)내부 정렬 2과목: 전자계산기 구조중앙처리장치명령어(Instruction)명령어 형식주소지정방식(Addressing Mode)마이크로 오퍼레이션(Micro Operation)메이저 스테이트(Major State)입.출력 제어방식인터럽트의 개념인터럽트 우선순위(Priority) 체제주기억장치연관기억장치, 복수 모듈 기억장치 3과목: 운영체제운영체제의 개념프로세스의 개요비선점 스케줄링교착 상태기억장치 관리의 개요페이지 교체 알고리즘가상기억장치 기타 관리사항디스크 스케줄링파일과 파일 시스템디렉토리 구조다중 처리기의 운영체제 구조와 프로세서 결합도분산 처리 시스템UNIX의 개요UNIX 파일 시스템과 명령어 4과목: 소프트웨어 공학소프트웨어와 시스템소프트웨어 생명 주기 모형1프로젝트 일정 계획소프트웨어 품질 보증구조적 분석 도구모듈과 모듈화검사 기법검사 전략유지보수객제지향 소프트웨어 공학객제지향 기법의 기본 원칙객제지향 기법의 생명 주기와 분석소프트웨어 재사용소프트웨어 재공학CASE 5과목: 데이터 통신전송 방식신호 변환 방식 - 디지털 변조(PCM)다중화(Multiplexing)통신 속도와 통신 용량전송 제어의 기본데이터 링크 제어 프로토콜- HDLC, SDLC오류 제어 방식오류 검출 방식데이터 교환 방식 - 축적 교환 방식경로 제어와 트래픽 제어OSI 참조 모델X.25TCP/IP","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"}]},{"title":"해시(Hash)","slug":"datastructure-hash","date":"2019-02-05T14:49:10.000Z","updated":"2019-02-05T15:04:22.897Z","comments":true,"path":"2019/02/05/datastructure-hash/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/05/datastructure-hash/","excerpt":"","text":"이번 시간에는 자료구조 중의 하나인 해시(Hash)에 대해 알아봅시다. 해시(Hash)란? 해시(Hash)는 Key-value쌍으로 데이터를 저장하는 자료구조를 말합니다. ● 키(Key)를 특정 해시 함수(Hash Function)를 통해 해싱한 후 나온 결과(정수)를 배열의 인덱스로 사용하여 값(Value)를 찾는다. ● 검색 성능은 해시 함수의 성능과 해시 테이블의 크기에 좌우된다. ● { “연필” : 200, “볼펜” : 300, “샤프” : 3000, “필통” : 15000 } 의 데이터가 있으면 키(Keys)를 특정 해시 함수(Hash Function)을 사용하여 다음과 같은 해시 테이블의 인덱스 형태로 만든 후 값(Values)을 저장한다. 장점(Advantage)과 단점(Disadvantage)● 해싱된 키(Hash Key)를 가지고 배열의 인덱스로 사용하기 때문에 삽입, 삭제, 검색이 매우 빠르다. ● 해시 함수(Hash Function)를 사용하는데 추가적인 연산이 필요하다. ● 적은 데이터 저장시 구현 방식에 따라 연결리스트(Linked List)를 사용하는 경우 오버 헤드의 부담이 생기고, 캐시 효율이 떨어진다. ● 해시 테이블(Hash Table)의 크기가 유한적이고 해시 함수(Hash Function)의 특성상 해시 충돌(Hash Collision)이 발생할 수 밖에 없다. ● 충돌이 없거나 적으면 O(1)의 상수 시간에 가까워지고, 충돌이 발생하면 할수록 성능은 점점 O(n)에 가까워진다. 문제점(Problem)● 해시 충돌(Hash Collision) : 해싱된 키(Hash Key)가 중복되어 해당 버킷(Bucket)에 이미 레코드가 존재하는 현상을 말한다. ● 오버플로우(Overflow) : 해시 충돌(Hash Collision)이 버킷(Bucket)에 할당된 슬롯(Slot) 수보다 많이 발생하면 더 이상 버킷에 값을 넣을 수 없다. 이러한 현상을 말한다. ● 클러스터링(Clustering) : 연속된 레코드에 데이터가 몰리는 현상을 말한다. 해시 함수(Hash Function)해싱(Hashing) 참고 해시 충돌(Hash Collision) 방지Separate Chaining(혹은 Closed Addressing) 방식 연결 리스트(Linked List)를 이용한 방식으로 JDK 내부에서도 사용된다. 키(Key)에 매핑된 인덱스가 가르키는 연결 리스트(Linked List)에 노드(Node)를 추가하여 값(Value)을 추가한다. 데이터의 주소 값(인덱스)이 바뀌지 않는다. 검색은 해시 함수(Hash Function)을 통해 인덱스를 구하고 해당 인덱스의 연결 리스트(Linked List)를 선형적으로 검사하여 해당 키(Key)의 노드(Node)가 존재하는지 확인하고 값(Value)를 리턴한다. 삭제는 검색과 동일하게 해당 인덱스의 연결 리스트(Linked List)를 선형적으로 검사하여 해당 키(Key)의 노드(Node)를 삭제하면 된다. 연결 리스트(Linked List)를 이용하기 때문에 추가할 수 있는 데이터의 제약이 적다. 부하율(Load Factor, 전체 버킷에서 사용중인 버킷의 비율)이 100%에 가까울수록 삽입, 삭제, 검색의 효율이 비약적으로 낮아진다. 일반적으로는 80%로 제한한다. (Java의 HashMap의 경우 75%) 구현하기 간단하고 기본적인 자료구조 정도만 요구한다. 해시 함수(Hash Function) 구현(선택)하는 관점에서, Chaining Hash Table의 경우 클러스터링(Clustering)에 거의 영향을 받지 않아 충돌의 최소화만 중점적으로 고려하면 된다. 해시 테이블의 버킷(Bucket)이 채워져도 성능 저하가 선형적으로 발생한다. 테이블의 높은 부하율(Load Factor)가 예상되거나, 데이터가 크거나, 데이터의 길이가 가변일 때 성능이 좋아진다. ※ JDK 1.8(Java 8)에서는 슬롯(Slot)의 갯수가 8개 이하일 경우 연결 리스트(Linked List)를 사용하며 그 이상의 경우는 트리(Tree) 구조를 사용하여 검색의 효율을 높이고 있다. Open Addressing 방식 충돌이 발생했을 경우 연결 리스트(Linked List)같은 추가적인 메모리를 사용하지 않고 해시 테이블(Hash Table)의 빈 버킷(Bucket)을 이용하는 방법이다. 충돌이 발생하면 다른 버킷(Bucket)에 저장하기 때문에 데이터의 주소 값(인덱스)이 바뀐다. 삽입시 메모리 할당 오버헤드가 없으며, 메모리 할당자가 없이도 구현이 가능하다. 외부 저장공간이 없기 때문에 외부 공간에 필요한 추가적인 작업이 요구되지 않는다. 특히 선형 검색법(Linear Probing)에서 Separate Chaining보다 뛰어난 참조 지역성(Locality of reference, 하나의 자원에 여러번 접근하는 프로세스)을 가진다. 이러한 특성으로 적은 데이터에서 특히 Lookup 연산에서 Separate Chaining보다 좋은 성능을 보인다. 포인터(Pointer)를 사용하지 않음으로써 직렬화(Serialization)가 용이하다. 테이블에 모두 저장될 수 있고, 캐시 라인에 적합할 수 있을 정도로 데이터의 크기가 작을수록 성능이 좋아진다. 삭제의 경우 충돌(Collision)에 의해 뒤에 저장된 데이터가 검색되지 않을 수 있다. 이를 방지하기 위해 삭제한 위치에 Dummy Node를 삽입한다. Dummy Node는 실제 값을 가지지는 않지만, 검색할 때 다음 위치(인덱스)까지 연결해주는 역할을 한다. 하지만 삭제가 빈번히 일어날 경우 Dummy Node 수가 많아져서 검색할 경우에 많은 버킷(Bucket)을 연속적으로 검색해야 하기 때문에 이 Dummy Node의 개수가 일정 수 이상이 되었을 경우에 주기적으로 새로운 배열을 만들어고 재해시(Rehash)를 해줘야 성능을 유지할 수 있다. 선형 검색(탐사)법(Linear Probing)· 충돌을 해결할 수 있는 가장 간단한 해결법이다. · 충돌 발생시 새로운 키(Key)를 저장할 기억공간을 찾기 위해 충돌이 일어난 그 위치에서 선형적으로 검색하여 첫 번째 빈 영역에 키를 저장하는 방법이다. · 테이블의 끝에 도달하게 되면 처음으로 되돌아 간다. · 조사를 시작한 위치로 되돌아 오게 되면 테이블이 가득찬 것이다. · 장점 : 구조가 간단하고 캐시의 효율이 높다. · 단점 : 최악의 경우 해시 테이블(Hash Table) 전체를 검색해야 하는 상황이 발생할 수 있으므로 비효율적이고, 데이터의 클러스터링(Clustering)에 가장 취약하다. 2차 검색(탐사)법(Quadratic Probing)· 선형 검색법(Linear Probing)에서 발생하는 제1밀집(primary clustering) 문제를 제거하는 방법이다. · 같은 해시 값을 갖는 키(Key)에 대해서는 제2밀집(secondary clustering) 발생 · 원래 저장할 위치로부터 1, 4, 9, 16, … 과 같이 떨어진 영역을 차례대로 검색하여 첫번째 빈 영역에 키를 저장하는 방법이다. · 캐시 효율과 클러스터링(Clustering) 방지 측면에서 선형 검색법(Linear Probing)과 이중 해싱(Double Hashing)의 중간 정도의 성능이다. 이중 해싱(Double Hashing)· 하나의 해시 함수(Hash Function)에서 충돌이 발생하면 2차 해시 함수를 이용해 검색 이동 거리를 얻는 방법이다. · 캐시 효율은 떨어지지만 클러스터링(Clustering)에 영향을 거의 받지 않는다. · 가장 많은 연산량을 요구한다. 무작위 검색법· 충돌을 유발하는 키(Key)를 저장할 수 있는 가용 공간을 찾을 때까지 난수 계산 프로그램을 실행하여 해시 테이블(Hash Table)의 주소 값(인덱스)을 결정하는 방법이다. Coalesced Chaining(혹은Coalesced Hashing, 병합 체이닝) Separate Chaining과 Open Addressing을 혼합한 방식이다. 테이블 내의 버킷(Bucket)들끼리 서로 체인 링크(Chain Link)를 가지게 됨(Separate Chaining 방식은 각 버킷들끼리 고유한 체인 링크를 가짐) Separate Chaining 방식과는 다르게 버킷(Bucket)끼리 체인 링크(Chain Link)를 거는 방식이기 때문에 테이블 슬롯(Slot)보다 많은 수의 데이터를 저장할 수 없다. Separate Chaining 방식에 비해 메모리와 캐시 성능에서 우위를 가진다. Open Addressing 방식에 비해 클러스터링(Clustering)에 거의 영향을 받으며 실제로 테이블이 높은 밀도로 효과적으로 채워질 수 있다. ResizingOpen Addressing에서 사용되는 고정 크기의 배열이 가득차거나 Separate Chaining에서 사용되는 연결 리스트(Linked List)가 길어지게 되면 검색 효율이 떨어지기 때문에 버킷(Bucket)의 갯수를 늘려줘야 한다. 이를 Resizing이라고 하며, 새로운 배열에 기존 배열의 키(Key)를 새롭게 재해싱(Rehashing)한다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"자료구조","slug":"컴퓨터-과학/자료구조","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/자료구조/"}],"tags":[{"name":"해시","slug":"해시","permalink":"https://JihyeHwang09.github.io/tags/해시/"},{"name":"Hash","slug":"hash","permalink":"https://JihyeHwang09.github.io/tags/hash/"}]},{"title":"CSS 레이아웃 핵심속성 position","slug":"css-layout-position","date":"2019-02-04T13:19:24.000Z","updated":"2019-02-04T14:07:42.537Z","comments":true,"path":"2019/02/04/css-layout-position/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/04/css-layout-position/","excerpt":"","text":"position 속성position 속성 중에 relative, absolute가 거의 90%의 비율로 사용된다. position: relative; position: relative;는현재 이미지를 기준으로 변화를 주겠다는 의미이다. relative는 주위 환경에 영향을 끼치지 않으면서위치를 조정한다. position: absolute; 부모에 relatvie를 주지 않으면,전체창 기준으로 position: absolute;를 준 요소가 배치된다. 절대적인 기준점은 원래는 전체 창이다. 부모로 계속 올라가다가 relatvie를 만나면,그 relative를 기준으로absolute 준 요소가 배치된다. absolute 준 요소는 공간을 차지하지 못한다. 자기가 차지하고 있는 공간을 다 버리고 뜬다. 즉, 부모 요소에 상관없이 뜬다. float속성과 position속성을 이용하여 예제를 만들어 봅시다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;WOOD&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 클래스의 장점: 여러 개를 만들어놓고 재활용할 수 있다는 장점이 있다. --&gt; &lt;!-- wrapper의 역할은 동일하다. 가운데 정렬 --&gt; &lt;div class=\"header\"&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"container\"&gt; &lt;!-- float할 요소는 마크업에서 뒤따라오는 요소들과 섞이는 성질이 있기 때문에 오른쪽에 위치하고 있더라도 가장 상단에 마크업 해야 한다. --&gt; &lt;img class=\"container-bg\" src=\"./images/axe.png\" alt=\"\" /&gt; &lt;h1&gt;OAK &lt;span&gt;LABORATORY&lt;/span&gt;&lt;/h1&gt; &lt;p&gt; Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"contents\"&gt; &lt;div class=\"wrapper\"&gt; &lt;ul class=\"grid\"&gt; &lt;li&gt; &lt;!-- li에는 class를 달지 않아도 됨 li안에 li가 있는 게 아니므로 왠만하면 class를 붙이는 게 좋음. type selector는 불안정한 부분이 많음 --&gt; &lt;img src=\"./images/type-a.png\" alt=\"\" /&gt; &lt;div class=\"grid-title\"&gt; &lt;h2&gt;Tree House&lt;/h2&gt; &lt;a href=\"\"&gt;Play&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;!-- li에는 class를 달지 않아도 됨 li안에 li가 있는 게 아니므로 왠만하면 class를 붙이는 게 좋음. type selector는 불안정한 부분이 많음 --&gt; &lt;img src=\"./images/type-b.png\" alt=\"\" /&gt; &lt;div class=\"grid-title\"&gt; &lt;h2&gt;Furniture&lt;/h2&gt; &lt;a href=\"\"&gt;Play&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"./images/type-c.png\" alt=\"\" /&gt; &lt;div class=\"grid-title\"&gt; &lt;h2&gt;Wave Woods&lt;/h2&gt; &lt;a href=\"\"&gt;Play&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;div class=\"wrapper\"&gt;2015 © OAK LABORATORY&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/* CSS Reset */body,h1,h2,p,ul &#123; /* CSS 초기화를 위한 body */ /* 브라우저마다 기본 설정된 margin이 있으므로 0으로 초기화해야 함*/ /* margin 병합 현상을 해결하기 위해서 먼저 margin을 0으로 줘서 브라우저 내장 스타일인 margin에 조건에 맞는 margin이 0이라 존재하지 않아서 마치 적용되지 않은 것처럼 보이는 것임 */ margin: 0; padding: 0; /* p태그에는 padding이 없지만, 통상적으로 같이 묶어서 초기화하려고 묶어서 padding: 0을 줌. */&#125;li &#123; list-style-type: none;&#125;/* Common */.wrapper &#123; width: 960px; margin: 0 auto;&#125;/* Design */body &#123; /* 시각적인 디자인을 위한 body임. CSS Reset위한 body와 구분해야 협업할 때 좋다. */ /* 모든 페이지에 걸쳐진 배경색을 지정해준다. */ /* 모든 페이지에 걸쳐진 전경색(homeground color)을 지정해준다. */ background-color: #efefef; color: #999;&#125;.header &#123; background-image: url(images/header-bg.png); /* 배경색이 어둡기 때문에 전경색을 먼저 밝은 색으로 준다. */ color: orange; /* display: flow-root; */ /* 1. display: flow-root; header 안의 모든 margin이 밖으로 삐져나가지 않고, header안에 위치하도록 함. But 브라우저 호환성 때문에 추천 X */ overflow: hidden; /* container의 마진 병합 현상을 해결하기 위해서 부모인 header에 overflow: hidden;을 줘서 해결한다. (이 용도로 만들어진 overflow: hidden; 속성은 아니지만, 이렇게 사용한다. 야매나 트릭은 X) */ /* .header에 overflow: hidden;이 있기 때문에 float된 요소인 .container-bg의 높이를 읽을 수 있는 것이다. */&#125;.container &#123; /* wrapper는 2~3개 정도라 공통적인 스타일이므로 wrapper가 아니라 container에 스타일을 줘야 한다. */ /* border-left:;, border-right: ;로 나눠서 적어도 됨 */ border-width: 20px 20px 0 20px; border-style: 10px solid; padding: 50px; border-color: orange; overflow: hidden; /* 자식 요소인 .container-bg가 float된 요소라서 높이를 읽지 못하기 때문에 부모 요소인 container에 overlfow: hidden;을 줘서 자식 요소의 높이를 읽게 한다. */ position: relative;&#125;.container-bg &#123; /* margin-bottom: 20px; /* 주위 환경에 영향을 끼치지 않으면서도 이 도끼 사진을 아래쪽에 위치시키고 싶다. 이 도끼 사진을 이 container-bg가 차지하는 공간 안에서 아래쪽에 위치시키려면 -&gt; */ /* position: relative; */ /* 현재 이미지를 기준으로 변화를 주겠다. */ /* relative는 주위 환경에 영향을 끼치지 않으면서 위치를 조정한다. */ /* left: 0; right: 0; top: 100px; */ /* 도끼가 위로 가게 하고 싶다. */ /* top에 음수값 주면 됨 */ /* top: -100px; */ /* 도끼가 이미지가 잘린 이유? 부모 요소인 container에 overflow: hidden을 줬기 때문에 */ /* 부모에 relatvie를 주지 않으면, 전체창 기준으로 position: absolute;를 준 요소가 배치된다. */ /* 절대적인 기준점이 원래는 전체 창이다. */ /* 부모로 계속 올라가다가 relatvie를 만나면 그 relative를 기준으로 absolute준 요소가 배치된다. */ position: absolute; /* absolute 준 요소는 공간을 차지하지 못한다. */ right: -150px; bottom: 0; /* 자기가 차지하고 있는 공간을 다 버리고 뜬다. 부모 요소에 상관없이 뜬다. */ /* position 속성에서 relative, absolute가 거의 90% 사용된다. */&#125;.container h1 &#123; margin-bottom: 30px; letter-spacing: 10px; border-bottom: 5px solid; display: inline-block;&#125;.container h1 span &#123; /* h1은 기본 브라우저 내장 스타일이 bold이므로 굵기를 얇게 주고 싶은 span요소에 normal을 주면 됨 */ font-weight: normal;&#125;.container p &#123; line-height: 1.7; /* inline요소의 높이는 line-height로 조절한다. */ /* line-height는 숫자만 적어야 함.(단위 x) -&gt; 폰트 크기에 비례해서 늘어나고 줄어듬*/ margin-right: 300px;&#125;.contents &#123; background-color: #ddd; padding: 30px 0;&#125;.grid &#123; /* background-color: yellow; */ /* 자식 요소인.grid li의 높이를 읽기 위해서 overflow: hidden;을 한다. */ overflow: hidden;&#125;.grid li &#123; background-color: white; color: orange; float: left; width: 300px; margin-right: 30px; border-radius: 10px; /* 모서리를 둥글게 boder-radius를 줬을 때, 이미지가 너무 커서 border-radius가 안먹는 것처럼 보이는 것임*/ /* overflow: hidden;을 줘서 넘치는 부분을 숨기며 네 모서리 모두 둥글게 보인다. */ overflow: hidden;&#125;.grid li:last-child &#123; margin-right: 0;&#125;.grid li img &#123; display: block; /* 빔캠프 유튜브를 참고 */ border-bottom: 3px solid orange;&#125;.grid-title &#123; overflow: hidden;&#125;.grid-title h2 &#123; float: left; /* a태그의 이미지와 줄을 맞추기 위해서 padding을 주기 보다는 height를 고정값을 준 다음, line-height을 줘서 line중간에 텍스트가 오도록 한다. */ font-size: 14px; height: 50px; line-height: 50px; padding: 0 10px;&#125;.grid-title a &#123; float: right; background-image: url(./images/play.png); /* 크기가 작아서 배경이미지가 안나올 경우, 이미지 크기만큼 width, heigth값을 준다. */ width: 50px; height: 50px; /* 텍스트가 안보이게 하기 위해서 text-indent: -9999px;을 준다. */ text-indent: -9999px;&#125;.footer &#123; text-align: center; padding: 20px; letter-spacing: 10px; text-indent: 10px; font-size: 12px; color: #bbb; margin-bottom: 100px;&#125;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"[object Object]","slug":"object-object","permalink":"https://JihyeHwang09.github.io/tags/object-object/"},{"name":"position","slug":"position","permalink":"https://JihyeHwang09.github.io/tags/position/"}]},{"title":"CSS 레이아웃 핵심속성 float","slug":"css-layout-float","date":"2019-02-03T14:11:20.000Z","updated":"2019-02-04T14:00:17.295Z","comments":true,"path":"2019/02/03/css-layout-float/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/03/css-layout-float/","excerpt":"","text":"1교시float로 가로배치 하기가로배치는 소박한 꿈이다.그러나 공식적으로 지원되는 게 없다.float도 가로 배치를 위한 속성이 아니다. 공식적인 방법이 아닌 방식으로 가로배치를 하려고 하기 때문에문제가 발생한다. 박스가 위로 떠있어야만이 그 박스 주위로 Dummy Text들이 그 주위로 흐른다.(같은 선상에 있지 않아야 한다.) float의 목적은 이미지와 텍스트가 어우러지게끔 하고 싶은 것이며,이미지는 공간을 차지 않도록 한다. 부모 요소가 아닌 body영역은 float된 요소의 높이 조차도 인식하고 있다.body를 root요소라고 한다. 123456789부모 &#123; display: flow-root; /* overflow: hidden과 관련되어 있음 */ /* 실무에서는 부모요소에 clearfix를 주는 방법을 많이 사용 */&#125;자식 &#123; float: left;&#125; 1번 예제 이제 float로 박스 2개를 양 옆으로 나누어 보자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;float로 양옆 나누기&lt;/title&gt; &lt;style&gt; body &#123; background-color: #ddd; color: dodgerblue; &#125; .wrapper &#123; width: 500px; background-color: white; border: 1px solid; margin: 50px auto; box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); padding: 10px; display: flow-root; /* body요소를 따라서 흐른다. */ &#125; .box &#123; font-family: \"arial\"; font-weight: bold; font-size: 50px; width: 100px; height: 100px; line-height: 100px; text-align: center; background-color: #c7e1fd; box-shadow: inset 0 0 1px; display: inline-block; float: left; &#125; .box.right &#123; float: right; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box\"&gt;1&lt;/div&gt; &lt;!-- .box의 디자인은 유지된 상태에서 float: right를 추가해야하므로 1) class에 box는 그대로 두고, right라는 클래스를 추가 -&gt; 2) float: right를 주기 --&gt; &lt;div class=\"box right\"&gt;2&lt;/div&gt; &lt;!-- &lt;div class=\"box\"&gt;3&lt;/div&gt; &lt;div class=\"box\"&gt;4&lt;/div&gt; &lt;div class=\"box\"&gt;5&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2교시2번 예제유지보수에 최적화하는 습관을 들여야 한다. sidebar에 margin-right: 20px를 주면 되지만,유지보수를 위해서는 float된 요소는 마크업 순서가 중요하다.float되는 요소는 마크업 순서가 contents보다 더 앞에 와야 한다.float는 상단에서 float가 이루어지고 그 후에 다른 요소가 그 주위로 흐르는 거니까float 요소는 마크업 순서가 먼저 와야 한다!!! float는 시각적인 위치랑 마크업 위치가 다르다!!! 이 특성 때문에 많이들 고생한다!! 이제 float로 사이드바를 만들어보자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;float로 사이드바 만들기&lt;/title&gt; &lt;style&gt; p &#123; margin: 0; &#125; body &#123; background-color: #ddd; color: dodgerblue; &#125; .wrapper &#123; width: 800px; margin: 50px auto; background-color: white; display: flow-root; &#125; .sidebar &#123; background-color: #c7e1fd; float: left; /* float가 적용되면, 왼쪽이든 오른쪽이든 컨텐츠가 붙어야하니까 contents 크기만큼 크기가 줄어버림 */ /* sidebar랑 contents는 시작점이 같음 sidebar랑 contents랑 겹치면 안되니까 contents가 오른쪽으로 밀린 것임 */ width: 100px; height: 300px; /* 보통, height는 사이즈르 주지 않는 게 좋다. */ &#125; .contents &#123; /* 1) 부모요소인 sidebar에 margin-right: 20px를 주면 된다. margin-left: 100px;(비추천!)2) 유지보수를 위해서는 자식 요소인 contents에 margin-left: 100px을 주면 된다. -&gt; 좋은 방법은 X (sidebar의 너비를 모르면 사용할 수 X)3) flow-root는 가장 최상위 요소처럼 보여지게 하라는 뜻float된 요소랑 float되지 않은 요소랑 독립되게 하려면, 자식 요소인 contents에display: flow-root;를 준다.*/ display: flow-root; /* 장점: sidebar의 너비가 줄거나 늘어나도, wrapper의 너비가 줄거나 늘어나도 수정할 게 X */ border: 5px solid mediumpurple; padding: 20px; &#125; .sidebar.right &#123; float: right; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"sidebar\"&gt;Sidebar&lt;/div&gt; &lt;div class=\"sidebar right\"&gt;Sidebar&lt;/div&gt; &lt;p class=\"contents\"&gt; Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate ele &lt;/p&gt; &lt;!-- &lt;div class=\"sidebar right\"&gt;Sidebar&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3번 예제자식이 float가 되면, 부모 기준에서 정리를 하지 않으면 안된다.부모 기준에서 정리를 하지 않으면, 뒤따라오던 content와 엉켜버린다. float로 이미지와 텍스트가 어우러지게 만들어보자! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;float로 이미지와 텍스트가 어우러지게!&lt;/title&gt; &lt;style&gt; p &#123; margin: 0; &#125; body &#123; background-color: #ddd; color: dodgerblue; &#125; .wrapper &#123; width: 600px; margin: 50px auto; padding: 50px; background-color: white; display: flow-root; &#125; .section &#123; background-color: #efefef; float: right; margin: 20px; margin-bottom: 20px; display: flow-root; /* 자식이 float가 되면, 부모 기준에서 정리를 하지 않으면 안된다. */ /* 부모 기준에서 정리를 하지 않으면, 뒤따라오던 content와 엉켜버린다. */ /* -&gt; 따라서, 부모 요소인 .section에 display: flow-root;를 준다. */ border: 10px solid; /* 색깔을 안주면, 전경색으로 자동으로 들어감 */ &#125; .section:last-child &#123; margin-bottom: 0px; /* 마지막 section아래에 margin 20px이 들어가면 맨 위와 대칭이 맞지 않으므로 가상 선택자를 써서 마지막 margin-bottom을 주지 않도록 만들기 */ &#125; .section p &#123; padding: 20px; display: flow-root; &#125; .section img &#123; float: left; &#125; .section.right &#123; text-align: right; &#125; .section.right img &#123; float: right; &#125; .section.mario &#123; color: dodgerblue; &#125; .section.luigi &#123; color: mediumorchid; &#125; .section.toad &#123; color: orange; &#125; /* 내가 작성한 코드 */ /* .section img &#123; float: left; &#125; .seciton p &#123; float: right; padding: 10px; &#125; .first &#123; border: 2px solid blue; &#125; .second &#123; border: 2px solid purple; &#125; .second img &#123; float: right; &#125; .second p &#123; float: left; display: flow-root; &#125; .third &#123; border: 2px solid yellow; &#125; */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"section mario\"&gt; &lt;img src=\"images/mario2.png\" /&gt; &lt;p&gt; &lt;strong&gt;Mario&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;div class=\"section luigi right\"&gt; &lt;img src=\"images/luigi2.png\" /&gt; &lt;p&gt; &lt;strong&gt;lugi&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;div class=\"section toad\"&gt; &lt;img src=\"images/toad2.png\" /&gt; &lt;p&gt; &lt;strong&gt;toad&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- border 색깔이 다름 --&gt;&lt;!-- lugi만 오른쪽으로 --&gt; 4번 예제display: flow-root;를 대체하는 방법 CSS를 공부한 사람들도 왜 display: flow-root;를 처음 보는 경우가 많은가? 생긴지 얼마 안 된 속성이며, 비교적 최근에 만들어진 속성이기 때문이다. 호환성이 좋지 않기 때문에 이 속성보다는 overflow: hidden;이나 clearfix를 이용하는 걸 추천한다. caniuse.com에서 flow-root 검색한 내용 쓸 수 없는 브라우저의 경우에는display: flow-root;의 대용품이 있다.overflow: hidden;이다.cf) margin 겹침 현상이 있을 때, 부모에게 overflow: hidden;을 사용함 위의 예제에서 display: flow-root;를 줬던 속성 자리에 overflow: hidden;을 주는 게 좋다. 이유: 이 두 가지가 성질이 똑같기 때문이다. Block Formating Context(BFC)라는 성질을overflow: hidden;과display: flow-root; 둘 다 가지고 있다. overflow: hidden; 넘쳐 흐르는 게 잘리는 속성 transition과 transform 속성은ie 크로스브라우징을 어느 정도 무시해야 한다는 생각이 있을 때 사용한다.(6-9버전)에서 사용할 수 없기 때문이다. 실무에서는 ie9버전을 맞춰야 하기 떄문에 float를 배우는 것이다. 이제 float 속성과 overflow: hidden;을 이용하여 그리드를 만들어 보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;float로 그리드 만들기&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"style.css\" /&gt; &lt;style&gt; p &#123; margin: 0; &#125; body &#123; background-color: #ddd; color: dodgerblue; &#125; .wrapper &#123; width: 640px; padding: 20px; background-color: white; border: 1px solid; margin: 50px auto; display: flow-root; &#125; .section &#123; background-color: #efefef; float: left; width: 200px; /*cf) width값을 %로 주는게 더 효율적임 */ margin-right: 20px; /* width값을 주지 않으면, 가로로 배치할 수 X */ &#125; .section:last-child &#123; margin-right: 0px; &#125; .section p &#123; padding: 20px; &#125; .section img &#123; transition: transform 1s; &#125; .section .cover &#123; overflow: hidden; &#125; .section:hover img &#123; transform: scale(1.2); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"section mario\"&gt; &lt;img src=\"images/mario2.png\" /&gt; &lt;p&gt; &lt;strong&gt;Mario&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;div class=\"section luigi right\"&gt; &lt;img src=\"images/luigi2.png\" /&gt; &lt;p&gt; &lt;strong&gt;Luigi&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;div class=\"section toad\"&gt; &lt;img src=\"images/toad2.png\" /&gt; &lt;p&gt; &lt;strong&gt;Toad&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"float","slug":"float","permalink":"https://JihyeHwang09.github.io/tags/float/"},{"name":"[object Object]","slug":"object-object","permalink":"https://JihyeHwang09.github.io/tags/object-object/"}]},{"title":"자바스크립트 19일차","slug":"javascript19","date":"2019-02-01T17:12:59.000Z","updated":"2019-02-04T13:47:32.109Z","comments":true,"path":"2019/02/02/javascript19/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/02/javascript19/","excerpt":"","text":"모듈 역사 DOM Tree 라이브러리require.js 모듈 번들러Browserify CommonJS-require()함수를 이용해서 모듈을 이용 Node.js 모듈 UMD define()함수를 이용해서 모듈을 이용 많은 모듈 시스템이 있었다.기존의 자바스크립트 함수를 사용하는 모듈 시스템들이 사용되었다. 예전 모듈 시스템은 자바스크립트 함수를 사용했지만,지금의 모듈 시스템은 새롭게 추가된 문법을 사용한다. 1&lt;script type=\"module\" src=\"index.mjs\" /&gt; 위의 예시처럼 사용할 수는 있지만,ES2015모듈을 사용하지 않는 사용자가 있기 때문에 모듈 번들러를 통해 변환과정을 거친 뒤,브라우저에는 일반적인 JavaScript 파일로서 불러오는 방법이 널리 사용되고 있는 추세이다. 모듈이란? 특수한 방식(코드 변환 방식)을 이용해야 하는 방식을 모듈이라고 한다. import 혹은 export 구문을 사용할 수 있다. 별다른 처리를 해주지 않아도 엄격 모드(strict mode)로 동작한다. 모듈의 가장 바깥쪽에서 선언된 이름은 전역 스코프가 아니라 모듈 스코프에서 선언된다. 모듈 스코프 모듈 스코프에서 선언된 이름은 모듈 안에서만 사용할 수 있다. (전역 스코프가 아니라) 모듈 스코프에 선언된 이름은 (export 해주지 않는다면) 해당 모듈 내부에서만 접근할 수 있다. cf) 전역 변수는 편하긴 한데, 오염될 가능성이 높다. ex) 강남역 한복판의 사물함 -&gt; 따라서 여러 모듈의 가장 바깥쪽에서 같은 이름으로 변수, 함수, 클래스를 선언하더라도,서로 다른 스코프에서 선언되기 때문에 이름의 충돌이 생길 일이 없다. export &amp; importexport의 2가지 종류 named export default export 선언과 동시에 export 하기 실무에서 named export를 사용하고 싶을 때, 선언부 앞에 export를 붙여준다. 변수 이름을 수출하는 거지, 값을 수출하는 게 X default export 모듈마다 하나의 값을 지정해서 그 값을 export할 수 있다. 모듈을 대표하는 값이 이거다!라는 걸 지정해서그 값을 다른 모듈에서 편하게 불러와서 사용할 수 있다. import받는 쪽에서 중괄호로 감싸주지 않고 써준다. import할 때, export할 때의 변수 이름과 통일할 필요 X.import 받는 쪽에서 값에 내가 쓰고 싶은 이름을 붙여서 쓰면 된다.(이유: 값을 export하는 것이기 때문에) 클래스도 값이다. 익명 클래스도 만들 수 있다. 123export default class MyComponent &#123; render() &#123;&#125;&#125; 표현식이 와야하는 자리에 이름이 있는 클래스를 써도 되고, 익명 클래스를 써도 된다. class명 앞에 export 써도 되고, export default 써도 된다. 1234// `React`라는 이름의 default export와,// Component, Fragment라는 일반적인 export를 동시에 가져오기// 굳이 2줄로 나눠서 import할 필요 Ximport React, &#123; Component, Fragment &#125; from \"react\"; 12345// named export는 여러 개 있을 수 있다.// defualt export는 0개 or 하나 있을 수 있다. (여러 개 있을 수 X)export default class &#123;&#125;export const Component = \"...\";export const Fragment = \"...\"; 다른 이름으로 export &amp; import 하기 export 혹은 import 하는 이름의 뒤에 as를 붙여서,다른 이름이 대신 사용되게 할 수 있습니다. import하는 쪽에서 같은 이름의 변수들이 넘어올 경우,충돌을 막기 위해서 as를 사용해서 이름을 바꿔서 사용할 수 있다. 모듈 사용 시 주의할 점 주의할 점이 한 가지 있습니다.import 구문과 export 구문은 모듈 간 의존 관계를 나타내는 것일 뿐,코드를 실행시키라는 명령이 아니라는 것입니다. 같은 모듈을 여러 다른 모듈에서 불러와도, 모듈 내부의 코드는 단 한 번만 실행된다. import를 한다고 해서 그 당시에 코드가 반드시 실행된다는 보장이 없다. 여러 파일에서 그 모듈을 불러와서 실행한다고 해서 여러 번 실행되는게 아니라,딱 1번만 실행된다. import를 여러 번 했는데, 딱 한 번 실행되는 것이다. import명령을 한 줄 한 줄 실행하라는 의미가 아니다. cf1) 폴더를 import할 경우, 그 안에 있는 index.js를 import하는 것과 같다.import TodoList from ‘./TodoList’import TodoList from ‘./TodoList/index.js 위, 아래는 같게 작동함 cf) export * from … export, import를 같이 해주는 구문 …에 적혀있는 모든 모듈을 export해서 바로 import하겠다. export {name1, name2, …, nameN} from …; …이 모듈에서 이 nam e들을 export해서 바로 import하겠다.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 18일차","slug":"javascript18","date":"2019-01-31T15:01:40.000Z","updated":"2019-01-31T16:26:44.028Z","comments":true,"path":"2019/02/01/javascript18/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/01/javascript18/","excerpt":"","text":"예외 처리동기식 코드에서의 예외 처리 JavaScript 코드에서 발생할 수 있는 에러에는 다양한 것들이 있습니다.문법 에러와 같이 프로그래머의 실수로 인해 에러가 발생하는 경우도 있지만,네트워크 에러와 같이 코드와는 무관한 이유로 발생하는 에러도 있습니다. 코드 실행 중에 에러가 발생하면,코드의 실행이 중단되어 그 시점에 실행 중이었던 작업을 완료할 수 없게 됩니다. JavaScript는 이로부터 코드의 실행 흐름을 원상복구할 수 있는 기능을 제공하며,try...catch...finally 구문을 사용하면에러가 나더라도 코드의 실행을 지속할 수 있습니다. 1234567891011121314151617try &#123; console.log(\"에러가 나기 직전까지의 코드는 잘 실행됩니다.\"); // Array 생성자는 배열의 길이를 인수로 받는다. -1이 들어가서 에러가 남 // try문 안에서 에러가 나지 않으면, catch문 안에 있는 코드는 실행이 되지 X new Array(-1); // RangeError: Invalid array length console.log(\"에러가 난 이후의 코드는 실행되지 않습니다.\");&#125; catch (e) &#123; console.log(\"코드의 실행 흐름이 catch 블록으로 옮겨집니다.\"); alert(`다음과 같은 에러가 발생했습니다: $&#123;e.name&#125;: $&#123;e.message&#125;`);&#125;// try -catch문으로 에러를 잡지 않았다면, 아래 코드는 실행되지 X.// 에러가 잡혀야만 그 후의 코드가 실행됨console.log(\"에러가 잡혔다면, 다음에 나오는 코드도 문제없이 실행됩니다.\");// 에러가 나기 직전까지의 코드는 잘 실행됩니다.// 코드의 실행 흐름이 catch 블록으로 옮겨집니다.// 에러가 잡혔다면, 다음에 나오는 코드도 문제없이 실행됩니다. 에러가 났을 때 원상복구를 시도할 코드를 try 블록 내부에 작성하면,에러가 발생했을 때 코드의 실행 흐름이 try 블록에서 catch 블록으로 옮겨갑니다.이 때, catch 블록 안에서는에러에 대한 정보를 담고 있는 객체(위 코드의 e)를 사용할 수 있습니다. try 블록은 예외 처리를 위해서만 쓰이는 것은 아닙니다.try 블록 바로 뒤에 finally 블록이 오면,finally 블록에 있는 코드는 try 블록 안에서의 에러 발생 여부와 관계 없이무조건 실행됩니다.심지어 try 블록 내에서 return, break, continue 등으로 인해코드의 실행 흐름이 즉시 이동될 때에도 마찬가지로 무조건 실행됩니다. 1234567891011121314151617for (let i of [1, 2, 3, 4, 5]) &#123; try &#123; // i = 1 // i = 2 // i = 3 if (i === 3) &#123; // break를 만나면, 코드의 실행 흐름이 루프를 빠져나오게 되는데!! // for루프 안에 finally가 있으므로 -&gt; finally 안의 코드를 실행한 후에!! // 루프를 빠져나온다. break; &#125; // finally는 무조건 실행되어야 하므로 break를 만나서 루프를 빠져나가기 전에 `finally`를 실행한 후 빠져나간다. &#125; finally &#123; console.log(`현재 i의 값: $&#123;i&#125;`); &#125;&#125; finally 블록은catch 블록과도 같이 사용됩니다.이 때 코드의 실행 순서를 정리해 보면 다음과 같습니다. 에러가 안 났을 때: try - finally에러가 났을 때: try - 에러 발생 - catch - finally아래 코드를 통해 코드의 실행 순서를 시험해보세요. 123456789101112try &#123; console.log(\"try\"); new Array(-1); // RangeError: Invalid array length&#125; catch (e) &#123; console.log(\"catch\");&#125; finally &#123; console.log(\"finally\");&#125;// try// catch// finally 123456789try &#123; const length = prompt(\"배열의 길이를 입력하세요.\"); //prompt로 입력받은 값은 문자열이므로 parseInt로 정수를 써야 한다. const arr = new Array(parseInt(length));&#125; catch (e) &#123; alert(\"제대로 된 숫자를 입력하세요.\");&#125; finally &#123; console.log(\"finally\");&#125; 직접 에러 발생시키기 Error 생성자와 throw 구문을 사용해서 프로그래머가 직접 에러를 발생시킬 수 있습니다. 123456// 에러 생성자는 자바스크립트 자체에 내장되어 있는 생성자// new Error 에러 객체를 throw한다.const err = throw new Error(\"짝수가 아닙니다.\");// 에러 객체만 throw할 수 있다.// 아래 코드는 에러가 발생하지 Xthrow 1; 12345678910111213141516171819202122// 우리만의 Error 클래스를 만들고, 그 클래스를 이용해서 에러 처리를 할 수 있다.class MyError extends Error &#123; //...params는 나머지 매개변수 문법 // 나머지 매개변수들이 배열로 담긴다 constructor(value, ...params) &#123; super(...params); this.value = value; // name속성은 매개변수의 속성을 나타낸다. this.name = \"MyError\"; &#125;&#125;try &#123; const even = parseInt(prompt(\"짝수를 입력하세요\")); if (even % 2 !== 0) &#123; throw new MyError(even, \"짝수가 아닙니다.\"); &#125;&#125; catch (e) &#123; if (e instanceof MyError) &#123; console.log(e.value); &#125;&#125; 비동기식 코드에서의 예외 처리비동기 콜백 비동기식으로 작동하는 콜백의 내부에서 발생한 에러는,콜백 바깥에 있는 try 블록으로는 잡아낼 수 없습니다. 123456789101112function func1() &#123; try &#123; // setTimeout()은 작업큐에 이따가 실행해달라고 부탁하고 넘어가는 거므로 // setTimeout()바깥에 try문으로 감싸고 있더라도 // func1이 실행될 때는 setTimeout()이 실행되는 게 아니므로 에러가 잡히지 X setTimeout(() =&gt; &#123; throw new Error(\"에러!\"); &#125;); &#125; catch (e) &#123; console.error(e); &#125;&#125; JavaScript 엔진은 에러가 발생하는 순간 호출 스택을 되감는 과정을 거칩니다.이 과정 중에 try 블록을 만나야 코드의 실행 흐름을 원상복구시킬 수 있습니다.위 예제에서 setTimeout에 넘겨진 콜백에서 에러가 발생하면,호출 스택을 따라 올라가도 try 블록을 만나는 것이 아니므로,코드의 실행 흐름이 catch 블록으로 옮겨지지 않는 것입니다. 따라서, 위 예제의 try 블록을 비동기 콜백 내부에 작성해주어야 합니다. 123456789//// 콜백 바깥이 아니라 안에 작성해야 에러를 잡을 수 있다.setTimeout(() =&gt; &#123; try &#123; throw new Error(\"에러!\"); &#125; catch (e) &#123; console.error(e); &#125;&#125;); Promise Promise 객체는 세 가지 상태를 가질 수 있습니다. pending - Promise 객체에 결과값이 채워지지 않은 상태fulfilled - Promise 객체에 결과값이 채워진 상태(resolved라고도 함)rejected - Promise 객체에 결과값을 채우려고 시도하다가 에러가 난 상태 Promise 객체가 rejected 상태가 되면,이 Promise에 대해서는 then 메소드에 첫 번째 인수로 넘겨준 콜백이 실행되지 않고,두 번째 인수로 넘겨준 콜백이 대신 실행됩니다.그리고 이 콜백에는 에러 객체가 첫 번째 인수로 주어집니다. 12345678910111213141516171819const p = new Promise(resolve =&gt; &#123; const even = parseInt(prompt(\"짝수를 입력하세요\")); if (even % 2 !== 0) &#123; throw new Error(\"짝수가 아닙니다.\"); &#125; else &#123; resolve(even); &#125;&#125;);p.then( even =&gt; &#123; return \"짝수입니다.\"; // 에러가 발생했을 때, 이 콜백이 실행된다 //then 메소드의 2번째 인수로 에러 콜백을 넘겨준다 &#125;, e =&gt; &#123; return e.message; &#125;).then(alert); 혹은, catch 메소드를 통해 에러 처리 콜백을 지정해줄 수도 있습니다. 1234567p.then(even =&gt; &#123; return \"짝수입니다.\";&#125;) .catch(e =&gt; &#123; return e.message; &#125;) .then(alert); 만약, then 메소드의 연쇄 안에서 에러가 발생하면,try...catch 구문과 유사하게 처음 만나는 에러 처리 콜백으로코드의 실행 흐름이 건너뛰는 결과를 낳게 됩니다. 1234567891011121314151617// undefined가 full filled 되어있는 Promise를 생성Promise.resolve() .then(() =&gt; &#123; // then 안에서 에러가 발생하면, 다음 then이 실행되는 게 X // catch콜백으로 실행 흐름이 건너뜀 // try -catch처럼 Promise에서는 then ~catch를 사용할 수 있음 // 우리가 이런 코드를 작성하지는 않더라도, 코드를 보고 해석할 수는 있어야 한다. // Promise에 finally 메소드는 지금은 없으나 곧 추가될 예정임 throw new Error(\"catch 메소드를 통해 예외 처리를 할 수 있습니다.\"); &#125;) .then(() =&gt; &#123; console.log(\"이 코드는 실행되지 않습니다.\"); &#125;) .catch(e =&gt; &#123; return e.message; &#125;) .then(console.log); 비동기 함수앞에서 봤던 Promise 객체의 예외 처리 방식은,일반적인 동기식 예외 처리 방식과 다르게 콜백을 사용하고 있어서코드를 복잡하게 만드는 원인이 됩니다. 비동기 함수 내부에서는,rejected 상태가 된 Promise 객체를 동기식 예외 처리 방식과 동일하게try...catch...finally 구문으로 처리할 수 있습니다. 12345678910111213// 비동기 함수인 경우 -&gt; rejected 상태인 함수를 await하면 에러가 발생하고,// 그 에러는 try ~catch ~finally 구문으로 잡을 수 있다.async function func() &#123; try &#123; // 'https://nonexistent-domain.nowhere'이런 도메인이 없으므로 요청이 에러가 남 // 이에 대한 에러 처리를 try catch로 할 수 있음 const res = await fetch(\"https://nonexistent-domain.nowhere\"); &#125; catch (e) &#123; console.log(e.message); &#125;&#125;func(); // 출력 결과: Failed to fetch 단, Promise 객체에 대해 await 구문을 사용하지 않는 경우,에러가 발생해도 catch 블록으로 코드의 실행 흐름이 이동하지 않는다는 사실을 기억하세요. 비동기 함수인 경우-&gt; rejected 상태인 함수를 await구문을 사용하지 않으면,에러가 발생해도 catch 블록으로 코드의 실행 흐름이 이동하지 않는다는 걸 기억할 것! 123456789async function func() &#123; try &#123; fetch(\"https://nonexistent-domain.nowhere\"); &#125; catch (e) &#123; console.log(e.message); &#125;&#125;func(); // 아무것도 출력되지 않습니다.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 17일차","slug":"javascript17","date":"2019-01-31T14:50:15.000Z","updated":"2019-01-31T16:26:45.182Z","comments":true,"path":"2019/01/31/javascript17/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/31/javascript17/","excerpt":"","text":"업데이트 방식비관적 업데이트 vs 낙관적 업데이트1. 비관적(pessimistic) 업데이트1사용자 입력 -&gt; 수정 요청 -&gt; 성공 시 화면 갱신 사용자에게는 불편하지만, 개발자에게는 쉬움 2. 낙관적(optimistic) 업데이트1사용자 입력 -&gt; 바로 화면 먼저 갱신 -&gt; 수정 요청 ex) slack, trello 네트워크 요청은 항상 성공과 실패로 나뉜다는 걸 명심해야 한다.(ex) 지하철처럼 네트워크가 불안정한 곳에서 접속할 때) 사용자에게는 편하지만, 개발자에게는 어려움(실패했을 경우 원상복구하는 기술을 구현하는 게 어려움) 수정 요청 12성공 -&gt; 끝실패 -&gt; 원상복구 화면을 그릴 때는 비관적 업데이트 or 낙관적 업데이트로 그려줄 지를 정해야 함.(서버가 멀리 떨어져 있기 때문에 신경 써야함) 멀리 떨어져 있는 서버에 통신을 해야 하기 때문에 항상 실패할 가능성이 존재함 사용자가 원래 쓰던 경험을 존중하기 위해서는 주로 낙관적 업데이트를 사용 비용을 들여서 낙관적 업데이트를 해야 하는 필요성이 있으면, 낙관적 업데이트를 구현.아니면, 더 쉬운 비관적 업데이트로 구현 사용자가 무엇을 기대하는지를 고려하는 게 중요하다. 비동기 함수를 호출했을 때 반환되는 promise에는 비동기 함수 내부에서 반환한 값이 채워진다. 화면을 모두 다시 그리는 코드 VS 필요한 부분만 갱신하는 코드 화면을 모두 다시 그리는 코드 개발자에게는 좋지만, 기계에게는 좋지 않은 코드(속도도 느리고) 필요한 부분만 갱신하는 코드 개발자에게는 고통스러운 코드, 기계에게는 좋은 코드 -&gt; React는 개발자는 화면을 모두 다시 그리는 코드를 짜면서도기계에게는 필요한 부분만 갱신할 수 있게 알아서 바꿔주는 라이브러리이다.(DOM API를 직접 만져서 쓰는 게 아니라) 개발용 API서버, 운영용 API 서버를 따로 둔다. 테스트할 때는 개발용 API서버에 접속할 수 있고,운영할 때는 운영용 API 서버에 접속할 수 있어야 함. baseURL은 고정되어 있는 게 아니라, 그때그때마다 밖에서 변경할 수 있어야 함 Parcel에서 .env파일로 환경변수를 사용한다. ###Plural routes경로 사용법 게시물 목록 전체를 가져오고 싶을 때 1GET /posts 1번 게시물 가져오고 싶을 때 123GET /posts/1POST /postsPUT /posts/1 1번 게시물 수정하고 싶을 때 12PATCH /posts/1DELETE /posts/1 FilterFilter를 사용하는 이유 조건을 만족하는 특정 요소들을 가져오기 위해 사용 1Use . to access deep properties 게시물을 가져오는데, title은 json-server고 게시자가 typicode일 때 1GET /posts?title=json-server&amp;author=typicode id가 1이거나 id가 2인 경우의 게시물을 가져온다. 1GET /posts?id=1&amp;id=2 객체 안에 객체가 들어있는 경우 사용함. 1GET /comments?author.name=typicode PaginateUse _page and optionally _limit to paginate returned data. In the Link header you’ll get first, prev, next and last links. 한 페이지에 자료가 2개씩 나오는 페이지들 중의 1페이지 1GET/posts?\\_page=1&amp;\\_limit=2 한 페이지에 자료가 15개씩 나오는 페이지들 중의 2페이지 1GET/posts?\\_page=2&amp;\\_limit=15 _page=페이지 번호_limit= 한 페이지에 나올 게시물 수 12GET /posts?\\_page=7GET /posts?\\_page=7&amp;\\_limit=20 10 items are returned by default(기본적으로 한 페이지에 10개임) Sort123456Add \\_sort and \\_order (ascending order by default)GET /posts?\\_sort=views&amp;\\_order=ascGET /posts/1/comments?\\_sort=votes&amp;\\_order=ascFor multiple fields, use the following format:GET /posts?\\_sort=user,views&amp;\\_order=desc,asc 오름차순(Ascending) -&gt; asc 내림차순(Descending) -&gt; desc id 내림차순 정렬(최신글부터 보여주기 위해서) 1ex) https://fds-json-server-bbs.glitch.me/posts?_sort=id&amp;_order=desc id 내림차순 정렬(최신글부터 보여주기) + 한 페이지에 게시물 2개로 하되, 첫 페이지를 보여주기 1ex(https://fds-json-server-bbs.glitch.me/posts?_sort=id&amp;_order=desc&amp;_limit=2&amp;_page=1 Slice123456789Add \\_start and \\_end or \\_limit(an X-Total-Count header is included in the response)- id가 20인것부터 30인것까지 가져오고 싶다. GET /posts?\\_start=20&amp;\\_end=30GET /posts/1/comments?\\_start=20&amp;\\_end=30GET /posts/1/comments?\\_start=20&amp;\\_limit=10Works exactly as Array.slice (i.e. \\_start is inclusive and \\_end exclusive) OperatorsAdd _gte or _lte for getting a range조회수가 10보다 크거나 같고 조회수가 20이하인 게시물 1GET /posts?views_gte=10&amp;views_lte=20 Add _ne to exclude a value 1GET /posts?id_ne=1 Add _like to filter (RegExp supported) 1GET /posts?title_like=server 비교!! gte = greater than or equal: 크거나 같은 less than or equal: 작거나 같은 정확히 title이 React인 것만 고르고 싶을 때 1https://fds-json-server-bbs.glitch.me/posts?title=React title에 React라는 문자열이 포함되어 있는 경우 다 고르고 싶을 때 12https://fds-json-server-bbs.glitch.me/posts?title_like=React Full-text searchAdd q 1GET /posts?q=internet 텍스트로 상품 검색할 때 prop이라는 문자열이 포함되어 있는 게시물 골라올 때 12ex)https://fds-json-server-bbs.glitch.me/posts?q=prop Relationships자료들 간의 관계가 맺어져 있을 때 ex) 게시물, 댓글간의 관계To include children resources, add _embed 게시물과 댓글을 한꺼번에 가져오고 싶을 때 embed를 사용 1GET /posts?\\_embed=comments 1번 게시물만 가져올 건데, 그 1번 게시물의 자식인 댓글까지 가져오고 싶다. 12GET /posts/1?\\_embed=commentsex) https://fds-json-server-bbs.glitch.me/posts/1?embed=comments 배열이 아닌 객체가 반환된다. 123456&#123; \"id\": 1, \"userId\": 1, \"title\": \"프론트엔드 입문자를 위한 도서 목록\", \"body\": \"자바스크립트 완벽 가이드\\n프론트엔드 개발자를 위한 자바스크립트 프로그래밍\"&#125; comment와 user등등도 관계가 맺어져 있음.To include parent resource, add _expand 1번 게시물의 정보와 + 작성자 정보까지 받아오고 싶을 때 1ex) https://fds-json-server-bbs.glitch.me/posts/1?_expand=user 12345678910&#123; \"id\": 1, \"userId\": 1, \"title\": \"프론트엔드 입문자를 위한 도서 목록\", \"body\": \"자바스크립트 완벽 가이드\\n프론트엔드 개발자를 위한 자바스크립트 프로그래밍\", \"user\": &#123; \"id\": 1, \"username\": \"fds\" &#125;&#125; 12GET /comments?\\_expand=postGET /comments/1?\\_expand=post To get or create nested resources (by default one level, add custom routes for more) 1GET /posts/1/comments posts/1 의 자식이되는 comments를 만들 것이다. 1POST /posts/1/comments 같은 이름의 queryString을 여러 번 사용할 경우에는 URLSearchParams.append()를 사용한다.(특정 키/값을 새로운 검색 매개변수를 추가) embed: 자식 불러오기expand: 부모 불러오기 1ex) const &#123;data: postList&#125; = await api.get(&apos;/posts?\\_expand=user&apos;) 게시물 데이터 - 자식 댓글 데이터 게시글을 기준으로 한 부모 데이터나 자식 데이터는 가져올 수 있으나부모의 부모, 자식의 자식은 가져올 수 X(이런 기능이 X) 12345678const p = new URLSearchParams();// undefinedp.append(\"id\", 1);// undefinedp.append(\"id\", 2);// undefinedp.toString();// \"id=1&amp;id=2\"","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 16일차","slug":"javascript16","date":"2019-01-30T14:39:21.093Z","updated":"2019-01-30T14:42:36.607Z","comments":true,"path":"2019/01/30/javascript16/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/30/javascript16/","excerpt":"","text":"모던 웹 서비스의 구성요소Fetch APIFetch API 웹 브라우저의 XMLHttpRequest를 대체하기 위해 만들어진 새로운 HTTP client 표준 비교적 최근에 도입되어 IE 및 구형 안드로이드 브라우저(4.x)는 지원하지 않음 Fetch Polyfill transfiler는 최신 문법을 예전 문법으로 바꿔줌(문법만 바꿔주지, 최신 기능을 과거 문법으로 사용할 수 있게 하지는 X.) 최신 브라우저 기능과 똑같이 만들어진 라이브러리 = 폴리필 ex) Array.prototype.includes(이 메소드는 ES2015나 ES2016에 추가됨. ) -&gt; 라이브러리에서는 Array.prototype.includes Proposal이라는 라이브러리를 가져다가 사용하면 됨. ex) fetch도 최신 기능인데, 이 기능을 사용하고 싶다면, fetch polyfill을 검색해서 사용하면 됨 isomorphic-fetch(https://www.npmjs.com/package/isomorphic-fetch) cf) XML 문서 json이 만들어지기 전에는 xml이 많이 쓰였음. 정보의 타입은 태그&lt;&gt;로, 내용은 &lt;&gt;안의 컨텐츠로 나타냈음 데이터를 받아와도 그 안에 있는 데이터에 접근하려면 qeurySelector로 접근해야 함.(json은 parse하면 객체로 반환되서 쉽게 접근할 수 있음) Fetch API도 Axios처럼 promise 객체를 반환함 Axios vs Fetch API Axios는 여러 편의기능(instance와 같이 설정을 재사용하거나 요청중인 연결을 취소하는 등)을 제공 다만, Axios는 내부적으로 XMLHttpRequest를 사용하고 있는데Service Worker 등의 최신 기술이 XMLHttpRequest를 지원하지 않으므로,Service Worker를 사용할 예정에 있는 프로젝트에서는 Axios 대신 Fetch API를 사용해야만 함정말 멋진 Fetch API 1234567891011121314151617181920212223// fetch(\"/data.json\")하면 promise 객체가 반환됨// .then(function(res)에서 처음으로 응답을 기다림// fetch를 쓰면 헤더가 먼저 도착. 헤더가 도착하면 =&gt; .then(function(res)&#123;&#125;코드가 실행됨fetch(\"/data.json\").then( function(res) &#123; // res instanceof Response == true. if (res.ok) &#123; // res.json()을 쓰면 응답을 한 번 더 기다려야 함 // 바디가 도착하면 =&gt; 그때, .then(function(data)&#123;&#125;이 실행됨 res.json().then(function(data) &#123; console.log(data.entries); &#125;); &#125; else &#123; console.log( \"Looks like the response wasn't perfect, got status\", res.status ); &#125; &#125;, function(e) &#123; console.log(\"Fetch failed!\", e); &#125;); Fetch API 의 가장 유용하고, 핵심적인 함수는 fetch() 함수이다.가장 간단한 형태의 fetch() 함수는 URL 을 인자로 받고 응답을 처리하기 위한 promise 를 반환한다.응답을 처리할 때 Response 객체를 이용할 수 있다. React 프로젝트에서 봤을 때, 현업에서 fetch와 axios가 반반 정도 사용되고 있음 fetch가 더 확장되서 사용될 예정임 HTTP CacheCache (무기 등의) 은닉처 은닉하다 컴퓨터 분야에서의 캐시는 (주로 접근 속도의 개선을 위해) 데이터를 미리 복사해 놓는 임시 저장소,혹은 그 임시 저장소에 데이터를 저장하는 행위를 가리킴 ‘cache’ 혹은 ‘caching’이라는 용어 자체는 특정 기술을 가리키는 것이 아니라,접근 속도를 개선하기 위해 따로 저장소를 두는 ‘방법’을 가리킴 컴퓨터의 아주 많은 부분(CPU, GPU, HDD, 네트워크, 웹, 데이터베이스…)에서 사용되고 있음 1234567- ex) 하드디스크는 자석으로 0,1을 기록함(7,200 rpm)- 메모리(RAM)에는 전기로 기록함- 하드디스크는 속도가 너무 느리니까 임시 저장소에 넣어서 기록함.- 큰 데이터가 있으면 일단 캐시로 보낸다.- cpu의 동작 속도는 일반 메모리(RAM)보다 훨씬 빠름. But 용량은 작음. - (ex) L3 캐시 메모리: 8MB, 메인 메모리: 8GB)- 프로그램을 실행시키면, 메모리 -&gt; 캐시메모리(cpu옆에 붙어있음)에 올림. 자원의 효율적 로딩을 위한 웹 표준 서버에서 가져온 자원(HTML, CSS, JS, 이미지, …)을 가까운 곳(브라우저, 혹은 다른 서버)에 저장해놓고 재사용 캐시를 할 것인지 말 것인지, 어떻게 할 것인지를 결정하는 규칙이 복잡하고, 브라우저마다 조금씩 다름 캐시를 사용하면, 원본과 사본이 달라지는 경우가 항상 생긴다. -&gt; 그에 대한 처리를 어떻게 할 것인가. ex) 원본과 사본이 달라지는 경우를 방지하기 위해서,자원을 쓸 때마다 서버에 물어보고 쓰라고 하거나 유효기간을 하루로 주거나 등등의 처리를 해줄 수 있다. Common Problem 캐시된 자원과 실제 자원의 내용이 달라지는 문제를 어떻게 해결할 것인가? Solution Expiration (만료): 정해진 시간이 지나면 캐시가 자동으로 삭제되도록 설정 Validation (검증): 서버에 요청을 보내서 캐시를 계속 사용할 수 있는지 확인 Cache 관련 헤더 Cache 범주 Conditionals 범주 Cache-Control: (요청, 응답) 캐시와 관련된 다양한 기능을 하는 지시자를 포함. no-cache, max-age가 많이 사용됨.no-cache, max-age=0 지시자는 캐시를 사용하지 않도록 하거나, 캐시를 아직도 쓸 수 있는지 검증하기 위해 사용됨(각각의 자세한 의미)(유효기간의 만료를 나타내기 위해 max-age를 사용) 123456- 자료를 통째로 보내는 게 X. 서버에서 식별자를 만들어서 예를 들어 1번을 붙임.- 브라우저가 서버에 어떤 내용이 바뀌었는지 물어볼 때, 식별자 1이라는 숫자를 서버에 보내서-&gt; 그 식별자가 바뀌었는지 서버에 물어봄- 전체 자원을 전송하지 않고도 자원이 바꿨는지를 확인할 수 있게 되는 것임- 서버에서 원본 자료가 바뀔 때마다 식별자 번호를 붙임(버전 번호처럼)- 서버에서 브라우저로 응답에 바뀐 자원과 바뀐 식별자 번호를 같이 보내줌. ETag: (응답) 캐시의 검증을 위해 사용되는 자원의 식별자.주로 자원의 해시값이 사용되나, 마지막으로 수정된 시각, 혹은 버전 넘버를 사용하기도 함 해시값을 식별자로 사용함. - [md5 Hash generator](http://www.miraclesalad.com/webtools/md5.php) - 해시(hash): 아래와 같은 특징을 갖고 있는 연산 - 1. 같은 입력을 주면 항상 같은 출력이 나온다. - 2. 입력이 조금이라도 달라지면 완전히 다른 출력이 나온다. &gt;![md5 Hash Generator]() &gt;캡쳐 해둔 이미지 경로 넣기!! - 아무리 긴 문자열의 길이가 길더라도 Hash의 길이는 같다. Expires: (응답) 캐시를 만료시킬 시각을 서버에서 명시적으로 지정 Last-Modified(응답) 원래 자료가 마지막으로 수정된 시각 If-None-Match(요청) 검증을 위해 사용됨. 이전에 저장해두었던 자원의 ETag 값을 If-None-Match 헤더의 값으로 요청에 포함시켜서 보내면,서버는 해당 경로에 있는 자원의 ETag와 비교해보고 자원의 전송 여부를 결정 ETag, If-None-Match 를 묶어서 외울 것!! 식별자가 바뀌지 않았을 경우에는 서버에서 브라우저로 응답을 보낼 때, body가 비어있는 상태로 응답함.(바뀐 내용이 없으므로) 자원이 바뀌었다면, 200 OK 상태 코드와 함께, body에 내용을 실어서 브라우저로 응답함. ETag 캐시가 가장 많이 사용된다. cf) netlify에 ETag 기능이 포함되어 있다. 12 If-Modified-Since(요청) 검증을 위해 사용됨.이전에 저장해두었던 자원의 Last-Modified 값을 If-Modified-Since 헤더의 값으로 요청에 포함시켜서 보내면,서버는 해당 경로에 있는 자원의 Last-Modified와 비교해보고 자원의 전송 여부를 결정 브라우저 실습 ctrl+shift+r or command+shift+r누르면 캐시가 지워지는 새로고침을 할 수 있다. - Cacheable Methods POST 메소드는 Cacheable 범주에 포함되기는 하지만,특별한 조건을 만족시켜야 하며 실무에서는 POST cache가 거의 사용되지 않습니다. delete, post나 fetch, put은 자원을 받아오는 메소드가 X-&gt; 서버와 브라우저가 이 메소드들에는 캐시 기능을 사용하지 X 캐시라는 건 자원을 불러오는 속도를 높이기 위해서 사용하기 때문에 서버에서 자료를 불러오는 경우(읽기)할 때즉, get메소드 등을 사용할 때 캐시를 사용할 수 있다. 캐시의 사용 브라우저는 이미 캐시를 잘 활용하도록 만들어져 있습니다. Express는 이미 캐시를 잘 활용하도록 만들어져 있습니다. Netlify는 이미 캐시를 잘 활용하도록 만들어져 있습니다.오예일단은 별다른 추가작업 없이도 편하게 캐시 기능을 사용할 수 있지만,우리가 원하는대로 캐시가 동작하지 않을 때 그 원인을 파악하기 위해 캐시 관련 헤더는 숙지해두는 것이 좋습니다.그리고 HTTP method를 용도에 맞게 사용하는 것도 중요합니다. 용도에 맞게 메소드를 사용하는 게 중요하다. 서버와 내 컴퓨터 사이에 수많은 컴퓨터가 있다. ex) 서버 - CDN(Contents delivery network) - Porxy - 내 컴퓨터 CDN 자료를 제공하기 위한 네트워크 global Application Delivery Network ex) netlify에도 CDN기능이 내장되어 있다. GraphQL ex) REST API 예시 GET/todos POST/todos GET/todos/3: 3번 글 가져오기 DELETE/todos/3: 3번 글 지우기 REST API의 단점 (보통의 경우) 각각의 자원마다 경로가 따로 있음.즉, 여러 자원이 동시에 필요한 경우에는 요청을 여러 번 보내야 함 (요청의 횟수 면에서 비효율적) (보통의 경우) 자원의 필요한 속성만 얻어올 수 없음.즉, 일부 속성의 필요하더라도 전체 속성을 가져와야만 함 (요청의 용량 면에서 비효율적) GraphQL 프론트엔드에서 쓰는 SQL이라고 보면 됨 Facebook에서 2015년 공개한 데이터 질의 언어 REST API를 대체하기 위해 만들어짐 클라이언트에서 필요한 데이터의 구조를 GraphQL 언어로 정의한 후 질의할 수 있고,서버는 그에 맞게 구조화된 데이터를 응답 서버에서는 GraphQL 질의를 해석하기 위해 별도의 해석기가 필요하며,여러 언어의 구현체가 나와있는 상태 별도의 언어라서 이 언어를 해석할 별도의 해석기가 필요한 것임 예전에는 node.js에서만 썼지만 현재는 다 사용가능함. 우리나라의 90%는 REST API를 사용하고 있지만 10% 정도는 GraphQL을 사용함 GraphQL Github API 실습 viewer: User! viewer필드는 User타입이다. Rest API: 경로를 queryString으로 표현했음. ex) GEt.todos?title=React graphQL: 내가 어떤 자료를 원하는지 구조적으로 표현할 수 있음. graphQL는 요청 1번으로 우리가 필요로 하는 여러 정보를 한꺼번에 가져올 수 있음. 내가 필요로 하는 정보만 골라서 가져올 수 있기 때문에 용량면에서도 효율적임 apolloGraphQl 책 추천: High Performance Browser Networking의 번역본 컴퓨터 네트워크 HTTP 하부에 TCP / IP가 쓰여지고 있음 템플릿 사용하는 경우 목록 표시(똑같이 생긴 걸 여러 개 보여줘야 함) 페이지 전환 우리는 프론트엔드 개발자니까 페이지를 새로고침하지 않고,DOM API를 만져서 요소들을 넣었다 뺐다 하기 위해서 사용함","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 15일차","slug":"javascript15","date":"2019-01-28T15:13:16.694Z","updated":"2019-01-28T15:21:58.010Z","comments":true,"path":"2019/01/29/javascript15/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/29/javascript15/","excerpt":"","text":"모던 웹 서비스의 구성요소Access Token &amp; JWTJWT 실습 JWT는 서버가 만들어주는 토큰 JWT 실습 토큰 요청하기2로그인 안하면, 정보를 가져올 수 없게 get 요청을 읽기전용, 정보를 보낼때는 post로 요청! 1234567891011121314151617181920212223// 토큰 받아오기let token;axios .post(\"/auth\", &#123; username: \"fast\", password: \"campus\" &#125;) .then(res =&gt; &#123; token = res.data.token; console.log(`token: $&#123;token&#125;`); &#125;);// axios에 post로 요청 보냄// axios.post('/auth', &#123;// username: 'fast',// password: 'campus'// &#125;).// 까지 실행하면 promise 객체가 반환됨.// 지금은 promise 객체가 비어있는 상태// .then(res =&gt; &#123;// token = res.data.token// console.log(`token: $&#123;token&#125;`)// &#125;)//then이후에 실행되면 promise 객체가 채워짐 1234567891011// 토큰으로 요청하기 1axios .get(\"/auth\", &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125; // promise에 값이 채워지면(작업이 끝나면) 할 일 &#125;) .then(res =&gt; &#123; prettyPrint(res.data); &#125;); 토큰은 사람마다 달라야 한다. 1234567891011// 토큰으로 요청하기 2// 로그인 안하면, 정보를 가져올 수 없게 한다.axios .get(\"/some-api\", &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125; &#125;) .then(res =&gt; &#123; prettyPrint(res.data); &#125;); 12345678910// 토큰으로 요청하기 3axios .post(\"/count\", null, &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125; &#125;) .then(res =&gt; &#123; prettyPrint(res.data); &#125;); 토큰을 포함시키지 않고 요청을 보내면, 401 에러가 난다. postman이든 axios든 정해진 방법으로 요청을 보내면, 정보를 가져올 수 있다. 1234567891011121314// 개발자 도구에서 입력한 코드들// 토큰 받아오기let token;axios.post('/auth', &#123; username: 'fast', password: 'campus'&#125;).then(res =&gt; &#123; token = res.data.token console.log(`token: $&#123;token&#125;`)&#125;)Promise &#123;&lt;pending&gt;&#125;VM138:8 token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZhc3QiLCJpc0FkbWluIjp0cnVlLCJpYXQiOjE1NDExMjU3MTh9.FGx5UZwqhz1QY30vwoGpcVnCpQmOgVuOAQSly87maGItoken\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZhc3QiLCJpc0FkbWluIjp0cnVlLCJpYXQiOjE1NDExMjU3MTh9.FGx5UZwqhz1QY30vwoGpcVnCpQmOgVuOAQSly87maGI\" 12345678910111213// 토큰으로 요청하기 2axios.get('/some-api', &#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;)Promise &#123;&lt;pending&gt;&#125;(index):102 &#123; \"ok\": true, \"message\": \"Hello JWT!\"&#125; 12345678910111213// 토큰으로 요청하기 3axios.post('/count', null, &#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;)Promise &#123;&lt;pending&gt;&#125;(index):102 &#123; \"ok\": true, \"count\": 74&#125; Axios Instance Axios에서는 편의기능을 내장하고 있다. 위의 예제에서는 토큰이 포함된 요청을 보낼 때마다매번 config 객체(axios.get의 두 번째 인자, axios.post의 세 번째 인자)를 통해 헤더를 설정해주고 있습니다.모든 요청에 똑같은 식으로 헤더를 넣어주는 일은 번거롭고, 또 에러를 일으키기 쉽겠죠? (Don’t Repeat Yourself!) Axios는 이렇게 중복된 설정을 하지 않도록 해주는 편의도구를 제공하고 있습니다.그것을 Axios instance라고 부르는데,한 번 config 객체를 넘겨서 Axios instance를 생성하면해당 instance를 통해 보내는 요청에는 config 객체가 자동으로 설정됩니다. 1234567891011121314151617// Axios.createconst authedAxios = axios.create(&#123; // header를 여기서 설정해주면, // 인스턴스를 실행할 때마다 매번 이 헤더가 자동으로 요청을 보낼 때 포함됨 headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125;&#125;);authedAxios.get(\"/auth\").then(res =&gt; &#123; prettyPrint(res.data);&#125;);authedAxios.get(\"/some-api\").then(res =&gt; &#123; prettyPrint(res.data);&#125;);authedAxios.post(\"/count\").then(res =&gt; &#123; prettyPrint(res.data);&#125;); 참고 링크 (https://blog.outsider.ne.kr/1160) react 관련 강의 하시는 velopert님 블로그 출처 url JWT에 대한 소개는 생략하고 Token이 어떻게 구성되어 있는지 간략하게 알아보겠습니다.JSON Web Token은 세 파트로 나뉘어지며, 각 파트는 점(.)에 의해 구분됩니다. 이를 테면 xxxxx.yyyyy.zzzzz 이런식입니다. Header는 토큰의 타입과 해시 암호화 알고리즘으로 구성되어 있습니다. Payload는 claim 정보를 포함하고 있습니다. userId, expire, scope 등이 여기에 해당합니다. 마지막으로 Signature는 secret key를 포함하여 암호화되어 있습니다. 일반적으로 JWT 토큰 기반의 인증 시스템은 위와 같은 프로세스로 이루어집니다. 처음 사용자를 등록할 때 Access token과 Refresh token이 모두 발급되어야 합니다. 먼저 사용자가 id와 password를 입력하여 로그인을 시도합니다. 서버는 요청을 확인하고 secret key를 통해 Access token을 발급합니다. 이후 JWT가 요구되는 API를 요청할 때는 클라이언트가 Authorization header에 Access token을 담아서 보냅니다. 서버는 JWT Signature를 체크하고 Payload로부터 user 정보를 확인해 데이터를 리턴합니다. jwt는 토큰의 한 가지 형식일 뿐이다. 다른 토큰 형식을 사용할 수 있다. 항상 똑같은 형식으로 토큰을 주고 받는 건 아니다. 세부적인 토큰 형식이나 토큰을 포함시키는 방식은 서버마다 다를 수 있다. 토큰을 어떻게 포함시켜야 하는지 서버 개발자에게 물어봐야 한다. 서버 개발자가 토큰을 어떻게 포함시킬지 설명서를 줄 것이다. 쿠키와 토큰의 차이점 인증 토큰(Authentication Token) 인증 토큰 저장소로 어떤 서버는 쿠키를 사용하는 경우 쿠키를 만들어내고 쿠키를 저장하는 것도 서버 개발자가 하는 일이다. 직접 관리하는 경우 여러 가지 방법 중 하나는 localStorage를 사용한다. But 새로고침 버튼을 누르면 정보가 날아간다. (이유: 변수에 정보를 저장했기 때문에) 쿠키는 저장소이고, 토큰은 내가 누구인지 나타내는 값을 의미한다. 토큰의 유효기간을 정하는 방법 김승하, abcd라는 토큰, 2018-11-07일 이라는 정보를 서버에 저장해 둔다. 토큰의 유효기간이 지났으면, 서버에서 토큰이 유효하지 않다는 응답을 준다. 토큰의 유효기간이 얼마 남지 않은 경우, 브라우저에 알려준다. 오랜만에 어떤 사이트에 접속하면 토큰이 유효하지 않다고 뜰 수 있다. 비동기 프로그래밍 이 작업을 해달라고 부탁하고 넘어가는 것 그리고 작업이 끝나면, 이 통에 작업 결과물을 담아줄래? Promise Promise는 ‘언젠가 끝나는 작업’의 결과값’을 담는 통과 같은 객체이다. Promise 객체가 만들어지는 시점에는 그 통 안에 무엇이 들어갈지 모를 수도 있다. 대신 then 메소드를 통해 콜백을 등록해서, 작업이 끝났을 때 결과값을 가지고 추가 작업을 할 수 있다. Promise 객체를 생성하는 가장 쉬운 방법은 Promise.resolve 정적 메소드를 사용하는 것이다. 1const p = Promise.resolve(1); 위 코드에서 1이라는 결과값을 갖는 Promise 객체를 생성했다. 그러나 이 코드는 비동기 작업을 하고 있지는 않다. 비동기 작업을 하는 Promise객체는 Promise생성자를 통해 만들 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 생성자 Promise에 new를 붙여줘서 인스턴스를 생성한다.// new Promise할 때는, 값을 반환하기 위해 resolve를 사용함// then을 쓸 때는 그냥 return해주면 된다.// 브라우저에 부탁할 수도 있지만,// resolve: 작업이 성공했을 때 실행할 것// reject: 작업이 실패했을 때 에러 반환// new Promise((resolve, reject) =&gt; &#123;&#125;) 우리가 직접 Promise를 생성할 수 있다.// resolve, reject 자리에는 각각 함수가 들어온다.const p = new Promise((resolve, reject) =&gt; &#123; // 이 자리에는 동기, 비동기 코드 둘 다 올 수 있다. setTimeout(() =&gt; &#123; // 2초 뒤에 작업큐에 등록됨. -&gt; 호출 스택으로 옮겨져서 실행됨 console.log('2초가 지났습니다.'); // resolve('hello'); // 작업이 성공했을 때 hello라는 문자열이 promise통에 들어감. // 그때! 작업큐에 then메소드로 등록해둔 콜백이 작업큐에 들어감. resolve('hello'); &#125;, 2000);&#125;);// p.then(msg =&gt; &#123;// console.log(msg); // hello// &#125;)이 표현식의 결과도 promise객체를 반환한다.// 함수 매개변수 이름인 msg는 내 마음대로 바꿔도 됨. But 사람들이 보통 많이 쓰는 msg로 썼음// 그 전의 promise통이 채워지면, 그때! 작업큐에 이 콜백이 등록된다.p.then(msg =&gt; &#123; console.log(msg); // hello // 윗 줄의 promise통이 채워지면, 그때 이 then메소드에 있는 콜백 함수가 등록되고, // 이 promise통이 채워지면, 다음 then메소드가 실행된다.&#125;).then((=&gt; &#123; ...&#125;)).then((=&gt; &#123; ...&#125;)).then((=&gt; &#123; ... //에러가 발생하면 catch라는 메소드가 실행됨&#125;)).catch(err =&gt; &#123;&#125;)// then메소드를 쓰면, 값이 채워졌을 때 실행할 코드를 등록할 수 있다.// 실행 순서: 먼저 Promise통이 생기고,// p.then 안에 있는 console.log(msg)가 실행된 후, Promise안에 있는 코드가 실행됨 then 메소드에는 아주 중요한 특징이 있는데, 바로 then 메소드 자체도 Promise 객체를 반환한다는 것입니다.이 때, 콜백에서 반환한 값이 곧 Promise의 결과값이 됩니다. then메소드를 사용하면 연이어 실행할 콜백 함수를 중첩해서 쓰지 않고(cf) 장풍 날리는 그림)깔끔하게 콜백 함수를 쓸 수 있다. 이어붙이는 과정을 체이닝이라고 한다. then 메소드에는 아주 중요한 특징이 있는데, 바로 then 메소드 자체도 Promise 객체를 반환한다는 것입니다.이 때, 콜백에서 반환한 값이 곧 Promise의 결과값이 됩니다. 반환값이 다음 promise에 채워진다. 만일, 반환값이 promise라면(통 자체를 넘기면) -&gt; 그 통을 열어서 안에 있는 내용물이 다음통에 들어간다. 15번 예제 코드(delya-promise-exmaple)는 슬랙에 강사님이 올려주시면, 붙여넣기! 이제 HTTP 통신을 할 때 Promise가 어떻게 사용되는지 살펴보겠습니다.아래에 사용된 axios는 JavaScript를 통해 직접 요청을 보내기 위해 널리 사용되는 라이브러리입니다.GET 메소드로 요청을 보내기 위해 axios.get() 함수를 사용할 수 있는데, 이 때 Promise 객체가 반환됩니다. 1234567891011// 반환된 값이 promise 객체임const axios = require(\"axios\");const API_URL = \"https://api.github.com\";axios .get(`$&#123;API_URL&#125;/repos/facebookincubator/create-react-app/issues?per_page=10`) .then(res =&gt; &#123; console.log(\"최근 10개의 이슈:\"); res.data.map(issue =&gt; issue.title).forEach(title =&gt; console.log(title)); console.log(\"출력이 끝났습니다.\"); &#125;); 9번 예제와 17번 예제가 같은 동작을 하는 코드임 promise의 핵심은 비동기 작업을 값으로 변환했다는 것이다. 비동기 작업을 값으로 바꾸면, 9번 예제 - 콜백으로 하는 방법 17번 예제 - promise 이용 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const API_URL = \"https://api.github.com\";const starCount = &#123;&#125;;const axios = require(\"axios\");// 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다.axios .get( `$&#123;API_URL&#125;/search/repositories?q=language:javascript&amp;sort=stars&amp;per_page=1` ) // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다. .then(res =&gt; axios.get( `$&#123;API_URL&#125;/repos/$&#123;res.data.items[0].full_name&#125;/contributors?per_page=5` ) ) // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다. .then(res =&gt; &#123; // ps는 promise로 이루어진 배열 const ps = res.data.map(user =&gt; axios.get(`$&#123;API_URL&#125;/users/$&#123;user.login&#125;/starred?per_page=10`) ); return Promise.all(ps); &#125;) // promise를 이용함 .then(ress =&gt; Promise.all(ress.map(r =&gt; r.data))) // 아래의 코드처럼 콜백으로만 나타냈을 때는 엄청 길고 복잡함 // if (repoArrs.length === 5) &#123; // for (let repoArr of repoArrs) &#123; // for (let repo of repoArr) &#123; // if (repo.full_name in starCount) &#123; // starCount[repo.full_name]++; // &#125; else &#123; // starCount[repo.full_name] = 1; // &#125; // &#125; // &#125; // console.log(starCount); // &#125; // &#125;); // &#125; // 와 같은 코드임 // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다. .then(repoArrs =&gt; &#123; for (let repoArr of repoArrs) &#123; for (let repo of repoArr) &#123; if (repo.full_name in starCount) &#123; starCount[repo.full_name]++; &#125; else &#123; starCount[repo.full_name] = 1; &#125; &#125; &#125; console.log(starCount); &#125;);console.log(\"fetching...\"); then 메소드보다 더 밑에 있는 문법을 더 자주 사용함 비동기 함수 (Async Function) C#에 있는 async라는 문법을 빌려옴(ES2017에서 도입됨) 비동기 함수(async function)를 사용하면,동기식 코드와 거의 같은 구조를 갖는 비동기식 코드를 짤 수 있다. async 키워드를 붙이면, 이 함수는 비동기 함수가 된다. 12345678910111213141516// 비동기 함수async function func1() &#123; // ...&#125;// 비동기 화살표 함수const func2 = async () =&gt; &#123; // ...&#125;;// 비동기 메소드class MyClass &#123; async myMethod() &#123; // ... &#125;&#125; 비동기 함수는 항상 Promise 객체를 반환한다는 특징을 갖습니다.이 Promise의 결과값은 비동기 함수 내에서 무엇을 반환하느냐에 따라 결정되며,then 메소드와 똑같은 방식으로 동작합니다. 안에서 return을 하든 안하든 항상 Promise 객체를 반환한다.(cf) Generate 함수는 iterator객체를 항상 반환함)(함수에 반환하는 코드를 쓰든 안쓰든) 12345678910111213async function func1() &#123; &gt; 질문: 통이 언제 만들어지는것인지????? return 1;&#125;async function func2() &#123; // 2가 채워진 통을 바로 생성하는 문법 return Promise.resolve(2);&#125;// func1()은 1이 들어있는 promise 객체func1().then(console.log); // 1// func2()는 2가 채워져있는 promise 객체func2().then(console.log); // 2 또 하나의 중요한 특징은 비동기 함수 내에서 await 키워드를 쓸 수 있다는 것입니다.await는 Promise의 then 메소드와 유사한 기능을 하는데,await 키워드 뒤에 오는 Promise가 결과값을 가질 때까지 비동기 함수의 실행을 중단시킵니다.여기서의 ‘중단’은 비동기식이며, 브라우저는 Promise가 완료될 때까지 다른 작업을 처리할 수 있습니다. await는 연산자이기도 하며, await 연산의 결과값은 뒤에 오는 Promise 객체의 결과값이 됩니다. 앞서 then 메소드를 사용했던 예제와 아래의 예제를 비교해보세요. 1234567891011121314151617181920212223// Promise 객체를 반환하는 함수.function delay(ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`$&#123;ms&#125; 밀리초가 지났습니다.`); resolve() &#125;, ms); &#125;);&#125;async function main() &#123; // 실행시키다가 promise통에 값이 채워질 때까지 기다리다가 // 값이 채워지면 실행const str1 = await delay(1000. 'hello');// await는 연산자임. 이 함수를 실행시킬 때 1초 뒤에 hello라는 값이 str1에 들어감.console.log(str1);const str2 = await delay(2000, 'world'); const result = await Promise.resolve('끝'); console.log(result);&#125;main(); await를 이용하면 기다렸다가 함수를 실행할 수 있다. await의 역할 2가지 promise가 값이 채워질 때까지 기다리는 것 promise 안의 결과값을 반환하는 것 비동기 함수의 가장 큰 장점은 동기식 코드를 짜듯이 비동기식 코드를 짤 수 있다는 것입니다.아래 예제는 Github 데이터를 불러오는 예제를 비동기 함수를 사용해 다시 작성한 것입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041// 21번 예제 코드가 3가지 방법중에 가장 간단// 9, 17, 21번 예제 코드 비교const axios = require(\"axios\");const API_URL = \"https://api.github.com\";async function fetchStarCount() &#123; const starCount = &#123;&#125;; // 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다. const topRepoRes = await axios.get( `$&#123;API_URL&#125;/search/repositories?q=language:javascript&amp;sort=stars&amp;per_page=1` ); // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다. const topMemberRes = await axios.get( `$&#123;API_URL&#125;/repos/$&#123; topRepoRes.data.items[0].full_name &#125;/contributors?per_page=5` ); // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다. const ps = topMemberRes.data.map(user =&gt; axios.get(`$&#123;API_URL&#125;/users/$&#123;user.login&#125;/starred?per_page=10`) ); const starredReposRess = await Promise.all(ps); const starredReposData = starredReposRess.map(r =&gt; r.data); // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다. for (let repoArr of starredReposData) &#123; for (let repo of repoArr) &#123; if (repo.full_name in starCount) &#123; starCount[repo.full_name]++; &#125; else &#123; starCount[repo.full_name] = 1; &#125; &#125; &#125; return starCount;&#125;fetchStarCount().then(console.log); then 메소드를 사용한 버전과 비교했을 때,비동기 작업을 위해 콜백을 사용하는 부분이 모두 사라졌습니다. await 키워드는 for, if와 같은 제어 구문 안에서도 쓰일 수 있기 때문에,then 메소드를 사용할 때보다 복잡한 비동기 데이터 흐름을 아주 쉽게 표현할 수 있다는 장점이 있습니다.다만, 비동기 함수 역시 Promise를 사용하기 때문에, 비동기 함수를 잘 쓰기 위해서는 여전히 Promise에 대해 잘 알고 있어야 합니다. 비동기 함수는 await 도중 에러가 났을 때 이를 편하게 처리할 수 있는 방법도 지원하는데,이에 대해서는 예외 처리 챕터에서 자세히 살펴보겠습니다. Generate 함수로도 비동기 처리를 할 수 있다. promise가 나오고 async,await가 나오기 전 그 사이에 Generate 함수로 비동기 프로그래밍을 구현했었다. 12345678910111213141516171819202122232425262728293031323334353637383940const co = require(\"co\");const axios = require(\"axios\");const API_URL = \"https://api.github.com\";function* fetchStarCount() &#123; const starCount = &#123;&#125;; // 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다. const topRepoRes = yield axios.get( `$&#123;API_URL&#125;/search/repositories?q=language:javascript&amp;sort=stars&amp;per_page=1` ); // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다. const topMemberRes = yield axios.get( `$&#123;API_URL&#125;/repos/$&#123; topRepoRes.data.items[0].full_name &#125;/contributors?per_page=5` ); // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다. const ps = topMemberRes.data.map(user =&gt; axios.get(`$&#123;API_URL&#125;/users/$&#123;user.login&#125;/starred?per_page=10`) ); const starredReposRess = yield Promise.all(ps); const starredReposData = starredReposRess.map(r =&gt; r.data); // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다. for (let repoArr of starredReposData) &#123; for (let repo of repoArr) &#123; if (repo.full_name in starCount) &#123; starCount[repo.full_name]++; &#125; else &#123; starCount[repo.full_name] = 1; &#125; &#125; &#125; return starCount;&#125;co(fetchStarCount).then(console.log); 어떤 회사에서는 Async와 await가 아니라일부러 Generate함수와 yield를 사용하는 경우가 있다. 그 이유는, Generate 함수로 비동기 프로그래밍을 구현하면,yield를 이용해서 일시정지 구간을 개발자가 세밀하게 컨트롤할 수 있어서이다. 개발자의 영어 문서 읽는 습관의 중요성 opensource 기술들이 특히 다 영어로 되어있음. angular는 구글에서 만든 것임 react는 여러 가지 조합을 해서 써야 함.(그 여러가지는 대개 오픈소스이고 그 오픈소스는 다 영어로 되어있음.) 단어 단위로라도 영어로 된 공식 문설르 읽어야 정확하게 개발할 수 있다. 파파고 등을 이용해서 최대한 번역해서라도 읽기 개발자들이 쓰는 어투가 있다. 개발 문서들이 쓰는 단어가 다 비슷하다. 공식 문서 영어로 된 문서를 하루에 10~20분 정도 매일 투자해서 읽기 -&gt; 영어 표현 정리해두기 원본 공식 문서를 읽고 쓸 수 있으면 연봉이 달라진다. 새로운 기술을 빠르고 정확하게 사용할 수 있기 때문에 예제 코드만 잘 읽어도 사용법을 알 수 있다. axios(config) axops는 config라는 객체를 받는다. 123456789// Send a POST requestaxios(&#123; method: \"post\", url: \"/user/12345\", data: &#123; firstName: \"Fred\", lastName: \"Flintstone\" &#125;&#125;); axios(url[, config]) 개발문서에 대괄호[]가 나오면, 배열이 X. []는 생략 가능하다는 뜻으로 널리 사용되는 표기법임. []안에 있는 내용은 써도 되고 안 써도 된다. axios에 config객체를 넣어도, 안 넣어도 잘 작동한다는 의미임 12// Send a GET request (default method)axios(\"/user/12345\"); Request method aliases aliase는 별명이라는 뜻임 For convenience aliases have been provided for all supported request methods. 1234567891011axios.request(config)axios.get(url[, config])// 설정 객체는 생략할 수 있다.- axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])- axios.post(url[, data[, config]])// : 1. url만// 2. url, data 이 2가지를 넘겨줄 수 있다.// 3. url, data, config를 넘겨줄 수 있다.axios.put(url[, data[, config]])- axios.patch(url[, data[, config]]) get과 post의 넘겨주는 객체가 다르다는 걸 기억! Request Config These are the available config options for making requests.Only the url is required. Requests will default to GET if method is not specified. 1234567// `params` are the URL parameters to be sent with the request // Must be a plain object or a URLSearchParams object ... params: &#123; ID: 12345 &#125;, ... Response Schema The response for a request contains the following information. 응답의 본문, 헤더, 상태 코드를 다 볼 수 있는 방법이 있다. json-server는 node.js로 만들어져 있음 -&gt; npm install로 설치할 수 있음 json-server는 json파일만 만들면 서버를 띄울 수 있다. json-server는 로그인 기능이 X json-server 토큰을 암호화하기 위한 문자열이 필요하다 암호화를 위한 환경변수 설정이 필요 환경변수 설정하기 토큰을 생성할 때 사용할 비밀 키를 JWT_SECRET 환경변수로 설정해주어야 합니다. 혹은 .env 파일을 통해서 비밀 키를 설정해줄 수도 있습니다.프로젝트 폴더에 .env 파일을 생성하고 아래와 같이 작성해주세요. 1JWT_SECRET = mysecret; 내 생각대로 서버가 동작하는지 서버 사용하는 코드를 작성 후에는 postman으로 꼭 확인해보기 Single Source of Truth 상태를 저장하는 저장소가 여러 개 있는 경우에는 상태가 불일치하는 문제가 생길 수 있다. -&gt; 따라서 믿을 수 있는 상태 저장소는 딱 하나만 두는 게 좋다. 이런 원칙을 Single source of Truth 진리의 유일한 원천.이라고 한다. 그래야 동기화가 잘 됨 매번 Single Source로부터 상태를 가져와서 매번 그려주는 게 좋다. -&gt; 동기화해서 변경사항을 적용하고 버그를 줄일 수 있다. 실시간 웹 slack이나 trello같은 사이트 -&gt; 다른 사람이 글 올리면 실시간으로 바로 볼 수 있음 실시간 웹을 구현하기 위해 사용할 수 있는 기능이 여러가지 있는데, 그 중에 한 가지가 ‘웹소켓’이다. 웹소켓을 쓰면, 내가 요청을 보내지 않아도 응답을 받을 수 있다.(cf) 그냥 http를 쓰면 내가 요청을 보내야만 응답을 받을 수 있다.) 웹소켓 연결이 맺어져 있으면 실시간으로 변경 사항이 반영됨","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 14일차","slug":"javascript14","date":"2019-01-27T16:59:12.654Z","updated":"2019-01-27T17:37:59.154Z","comments":true,"path":"2019/01/28/javascript14/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/28/javascript14/","excerpt":"","text":"클래스 프로토타입은 기능을 재사용하기 위해서 사용한다. 클래스는 객체가 공유해서 써야 하는 기능들을 모아둔다. 클래스 상속 (Class Inheritance) 클래스 상속(class inheritance, subclassing) 기능을 통해한 클래스의 기능을 다른 클래스에서 재사용할 수 있다. 1234567class Parent &#123; // ...&#125;class Child extends Parent &#123; // ...&#125; 위 코드에서, extends 키워드를 통해 Child 클래스가 Parent 클래스를 상속했다.이 관계를 보고 ‘부모 클래스-자식 클래스 관계’혹은 ‘슈퍼 클래스(superclass)-서브 클래스(subclass) 관계’라고 말하기도 한다. 어떤 클래스 A가 다른 클래스 B를 상속받으면, 다음과 같은 일들이 가능해진다. 자식 클래스 A를 통해 부모 클래스 B의 정적 메소드와 정적 속성을 사용할 수 있다. 부모 클래스 B의 인스턴스 메소드와 인스턴스 속성을 자식 클래스 A의 인스턴스에서 사용할 수 있다. 12345678910111213141516171819class Parent &#123; static staticProp = \"staticProp\"; static staticMethod() &#123; return \"I'm a static method.\"; &#125; instanceProp = \"instanceProp\"; instanceMethod() &#123; return \"I'm a instance method.\"; &#125;&#125;class Child extends Parent &#123;&#125;console.log(Child.staticProp); // staticPropconsole.log(Child.staticMethod()); // I'm a static method.const c = new Child();console.log(c.instanceProp); // instancePropconsole.log(c.instanceMethod()); // I'm a instance method. super 앞서 봤듯이, 자식 클래스에서 부모 클래스의 정적 속성과 인스턴스 속성에 접근할 수 있었다.하지만, 자식 클래스에 같은 이름의 속성을 정의한 경우 문제가 생긴다. 12345678910111213141516class Melon &#123; // 인스턴스 메소드 getColor() &#123; return \"제 색깔은 초록색이다.\"; &#125;&#125;class WaterMelon extends Melon &#123; // 인스턴스 메소드 getColor() &#123; return \"속은 빨강색이다.\"; &#125;&#125;const waterMelon = new WaterMelon();waterMelon.getColor(); // 속은 빨강색이다. 메소드 오버라이딩: 부모 클래스의 기능을 확장해서 사용하고 싶은 경우,일부러 부모 클래스의 메소드와 같은 이름으로 메소드를 만들어서 사용한다. 이런 경우에, super 키워드를 통해 부모 클래스의 메소드에 직접 접근할 수 있다. 1234567891011121314class Melon &#123; getColor() &#123; return \"제 색깔은 초록색이다.\"; &#125;&#125;class WaterMelon extends Melon &#123; getColor() &#123; return super.getColor() + \" 하지만 속은 빨강색이다.\"; &#125;&#125;const waterMelon = new WaterMelon();waterMelon.getColor(); // 제 색깔은 초록색이다. 하지만 속은 빨강색이다. super 키워드의 동작 방식은 다음과 같다. 생성자 내부에서 super를 함수처럼 호출하면, 부모 클래스의 생성자가 호출된다. 정적 메소드 내부에서는 super.prop과 같이 써서 부모 클래스의 prop 정적 속성에 접근할 수 있다. 인스턴스 메소드 내부에서는 super.prop과 같이 써서 부모 클래스의 prop 인스턴스 속성에 접근할 수 있다. 123456789101112131415161718192021222324252627282930313233class Person &#123; constructor(&#123; name, age &#125;) &#123; this.name = name; this.age = age; &#125; introduce() &#123; return `제 이름은 $&#123;this.name&#125;이다.`; &#125;&#125;class Student extends Person &#123; // 분해 대입과 나머지 속성 // grade = 3, rest에는 객체가 들어감. 그 객체에는 name: '윤아준', age: 19가 들어있음 constructor(&#123; grade, ...rest &#125;) &#123; // 부모 클래스의 생성자를 호출할 수 있다. super(rest); this.grade = grade; &#125; introduce() &#123; // 부모 클래스의 `introduce` 메소드를 호출할 수 있다. return super.introduce() + ` 저는 $&#123;this.grade&#125;학년이다.`; &#125;&#125;// this는 그때 그때 다른 걸 가리킬 수 있다.const p = new Person(&#123; name: \"신하경\", age: 20 &#125;);p.introduce();const q = new Person(&#123; name: \"신하경\", age: 20 &#125;);p.introduce();const s = new Student(&#123; grade: 3, name: \"윤아준\", age: 19 &#125;);s.introduce(); // 제 이름은 윤아준이다. 저는 3학년이다. 클래스 상속과 프로토타입 상속 클래스 상속은 내부적으로 프로토타입 상속 기능을 활용하고 있다. 아래 코드의 클래스 상속에 대한 프로토타입 체인을 그림으로 나타내보면 다음과 같이 된다. 123class Person &#123;&#125;class Student extends Person(&#123;&#125;const student = new Student(); 이와 같이 부모 클래스의 메소드와 이름이 같은 메소드를 자식 클래스에정의하는 것을 보고 메소드 오버라이딩(method overriding)이라고 한다. 자바스크립트에서 클래스는 부모를 하나만 줄 수 있다. (다중 상속이 불가능하다.) 큐, 스택, 트리 어떤 데이터의 구체적인 구현 방식은 생략한 채,데이터의 추상적 형태와 그 데이터를 다루는 방법만을 정해놓은 것을 가지고ADT(Abstract Data Type) 혹은 추상 자료형이라고 한다. 이 챕터에서는 널리 사용되는 ADT인 큐, 스택, 트리에 대해 배운다. 큐 (Queue) 큐(Queue)는 한 줄의 파이프라고 생각하면 된다. 데이터를 집어넣을 수 있는 선형(linear) 자료형이다. 먼저 집어넣은 데이터가 먼저 나온다. 이 특징을 줄여서 FIFO(First In First Out)라고 부른다. 데이터를 집어넣는 enqueue, 데이터를 추출하는 dequeue 등의 작업을 할 수 있다. JavaScript에서는 배열을 이용해서 간단하게 큐를 구현할 수 있다. 1234567891011121314151617class Queue &#123; constructor() &#123; this._arr = []; &#125; enqueue(item) &#123; this._arr.push(item); &#125; dequeue() &#123; return this._arr.shift(); &#125;&#125;const queue = new Queue();queue.enqueue(1);queue.enqueue(2);queue.enqueue(3);queue.dequeue(); // 1 큐는 순서대로 처리해야 하는 작업을 임시로 저장해두는 버퍼(buffer)로서 많이 사용된다. ex) 스트리밍을 할 때, 임시저장소(buffer)에서 대개 큐(Queue)가 사용된다. 스택(Stack) 스택(stack)은 다음과 같은 성질을 갖는 자료형이다. 데이터를 집어넣을 수 있는 선형(linear) 자료형이다. 나중에 집어넣은 데이터가 먼저 나온다. 이 특징을 줄여서 LIFO(Last In First Out)라고 부릅니다. 데이터를 집어넣는 push, 데이터를 추출하는 pop, 맨 나중에 집어넣은 데이터를 확인하는 peek 등의 작업을 할 수 있다. JavaScript에서는 배열을 이용해서 간단하게 스택을 구현할 수 있다. 1234567891011121314151617181920class Stack &#123; constructor() &#123; this._arr = []; &#125; push(item) &#123; this._arr.push(item); &#125; pop() &#123; return this._arr.pop(); &#125; peek() &#123; return this._arr[this._arr.length - 1]; &#125;&#125;const stack = new Stack();stack.push(1);stack.push(2);stack.push(3);stack.pop(); // 3 스택은 서로 관계가 있는 여러 작업을 연달아 수행하면서 이전의 작업 내용을 저장해 둘 필요가 있을 때 널리 사용된다. ex) ctrl + z 되돌리기 기능을 스택을 이용해서 만든다. import를 입력한다. i를 입력했다면, i를 저장했다는 사실이 스택에 저장된다. m를 입력했다면, m를 저장했다는 사실이 스택에 저장된다. p를 입력했다면, p를 저장했다는 사실이 스택에 저장된다. 지우는건 p부터 지운다. (스택에서는 나중에 들어온 p가 먼저 나온다. -&gt; 먼저 지워진다. ) 트리 (Tree) 트리(tree)는 여러 데이터가 계층 구조 안에서 서로 연결된 형태를 나타낼 때 사용된다. 부모-자식 관계가 있는 구조를 트리라고 부른다. 비동기 프로그래밍 한 번에 촥~ 실행되는 게 아니라시간을 나눠서 조금씩 실행되는 프로그래밍을 비동기 프로그래밍이라고 한다. 순서 뿐만 아니라 시간에 대해서도 생각해야 한다. Motivation - 타이머 API 웹 브라우저에는 함수를 특정 시간이 지난 뒤에 실행시키거나,혹은 함수를 주기적으로 실행시키는 작업을 할 수 있게 해 주는 함수가 내장되어 있다. 12345678setTimeout(() =&gt; &#123; console.log(\"setTimeout이 실행된 지 2초가 지났습니다.\");&#125;, 2000);// 특정 간격마다 주기적으로 실행setInterval(() =&gt; &#123; console.log(\"3초마다 출력된다.\");&#125;, 3000); setTimeout과 setInterval은 각각 타이머 식별자를 반환한다. 이 식별자를 가지고 실행 중인 타이머를 취소할 수 있다. setTimeout - clearTimeout setInterval - clearInterval 123456789101112const timeoutId = setTimeout(() =&gt; &#123; console.log(\"setTimeout이 실행된 지 2초가 지났습니다.\");&#125;, 2000);const intervalId = setInterval(() =&gt; &#123; console.log(\"3초마다 출력된다.\");&#125;, 3000);clearTimeout(timeoutId);clearInterval(intervalId);// 아무것도 출력되지 않습니다. 타이머 사용 시 주의할 점 setTimeout과 setInterval은 정확한 지연시간을 보장해 주지 않는다. 1234567const start = new Date();setTimeout(() =&gt; &#123; console.log(new Date() - start);&#125;, 100);// 실제 지연시간과 약간의 차이가 존재한다. 주식 거래나 게임 같은 경우에는 자바스크립트를 사용하지 않는다. 아주 빠르게 반응하는 c언어 같은 언어를 사용해야 한다. 또한 지연시간을 0으로 주었을 때는 코드가 기대한대로 동작하지 않는다.setTimeout 호출 시 지연시간으로 0을 넘기면 어떻게 되는지 확인해보자. 1234567891011// 지연시간을 0으로 준다고 해서 코드가 바로 실행이 되지 않는다.// -&gt; 코드 실행 순서가 뒤죽박죽이 된다.setTimeout(() =&gt; &#123; console.log(\"hello\");&#125;, 0);console.log(\"world\");// 출력 결과:// world// hello 분명 지연시간을 0으로 주었는데도 코드가 뒤늦게 실행되었다.어떻게 된 일일까?이를 이해하기 위해서는 먼저 브라우저에서 JavaScript 코드가 실행되는 과정을 알아야 할 필요가 있다. 브라우저의 JavaScript 코드 실행 과정호출 스택 (Call Stack) 호출 스택(call stack)은 스택 형태의 저장소로,JavaScript 엔진은 함수 호출과 관련된 정보를 이 곳에서 관리한다. 1234567891011121314function add(x, y) &#123; return x + y;&#125;function add2(x) &#123; return add(x, 2); // `add`를 호출&#125;function add2AndPrint(x) &#123; const result = add2(x); // `add2`를 호출 console.log(result); // `console.log`를 호출&#125;add2AndPrint(3); // `add2AndPrint`를 호출 호출 스택에 저장되는 각 항목을 실행 맥락(execution context)이라고 부른다.실행 맥락에는 아래와 같은 정보들이 저장된다. 함수 내부에서 사용되는 변수 - 스코프 체인 - this가 가리키는 객체 브라우저가 JavaScript 코드를 실행시킬 때, 호출 스택을 다음과 같이 조작한다. 스크립트를 불러올 때, 전역 실행 맥락(global execution context)을 호출 스택에 추가한다. 함수가 호출되면, 해당 호출에 대한 실행 맥락을 생성해서 호출 스택에 추가(push)한다. 변수에 대입이 일어나면, 호출 스택에 저장되어 있는 변수의 내용을 변경한다. 함수의 실행이 끝나면, 결과값을 반환하고 호출 스택 가장 위에 있는 실행 맥락을 제거(pop)한다. 스크립트의 실행이 모두 끝나면, 전역 실행 맥락을 호출 스택에서 제거(pop)한다. 이를 통해, 변수에 값을 대입한다거나,함수가 여러 번 중첩되어 호출되는 등의 복잡한 코드의 동작을 단순한 자료구조로 표현할 수 있게 된다. 웹 브라우저는 호출 스택에 실행 맥락이 존재하는 동안,즉 실행 중인 함수가 존재하는 동안에는 먹통이 되어 버린다. 브라우저는 대개 60fps로 동작하기 때문에,대략 16ms 안에 코드의 실행을 완료하지 못하면 브라우저의 애니메이션이 뚝뚝 끊기는 현상이 나타난다.이는 사용자 경험에 악영향을 미칠 수 있다. 123456789101112// 특정 시간동안 계속 루프를 도는 코드function sleep(milliseconds) &#123; // Data.now()는 유닉스 시간 const start = Date.now(); // Data.now()가 실행된 시점의 유닉스 시간(이거는 안 바뀌는 것임) //- 현재 Data.now()실행한 유닉스 시간(시간이 흘렀으니까 start보다는 큰 숫자를 반환함) // while (10, 20, 30........ &lt; 5000) while (Date.now() - start &lt; milliseconds);&#125;sleep(5000);// 5초 동안 while 루프가 실행되므로, 호출 스택이 비워지지 않고 브라우저는 먹통이 된다. 따라서, 브라우저에서 동작하는 JavaScript 코드,특히 사용자와의 상호작용을 위한 코드를 작성할 때에는코드의 실행 시간이 얼마나 될지를 항상 염두에 두어야 한다. 작업 큐 (Task Queue) 하지만 모든 작업을 16ms 안에 처리할 수는 없습니다.어떤 사건(event)이 일어날 때까지 기다리거나, 혹은 큰 데이터에 대한 계산이 완료될 때까지기다리는 데에는 시간이 오래 걸리기 마련이다. 이런 경우, 브라우저에서는 다음과 같은 절차를 통해 오래 기다려야 하는 일을 처리할 수 있다. 기다려야 하는 일을 JavaScript 엔진에서 직접 처리하는 것이 아니라 API를 통해 브라우저에 위임한다.이 때, 일이 끝나면 실행시킬 콜백을 같이 등록한다. 위임된 일이 끝나면, 그 결과와 콜백을 작업 큐(task queue)에 추가한다. JavaScript 엔진은 호출 스택이 비워질 때마다작업 큐에서 가장 오래된 작업을 꺼내와서 해당 작업에 대한 콜백을 실행시킨다.브라우저는 이 과정을 끊임없이 반복하는데, 이를 이벤트 루프(event loop)라고 부릅니다. JavaScript 코드를 작성할 때에는, 호출 스택과 작업 큐의 성질을 반드시 염두에 두어야 한다. 각 작업은 작업 큐에 쌓인 순서대로 실행된다. 이미 작업 큐에 작업이 쌓여있다면, 뒤늦게 추가된 작업은 앞서 추가된 작업이 모두 실행된 다음에,즉 호출 스택이 비워진 다음에야 실행된다. 호출 스택이 비워지지 않는다면, 작업 큐에 쌓여있는 작업을 처리할 수 없습니다. 각 작업 사이에 브라우저는 화면을 새로 그릴 수 있다.즉, 호출 스택이 비워지지 않는다면 브라우저는 화면을 새로 그릴 수 없습니다. 12345678910setTimeout(() =&gt; &#123; console.log(\"hello\");&#125;, 0); // 작업 큐에 콜백이 추가됨// 콜백은 () =&gt; &#123;// console.log('hello');// &#125;, 0// 를 의미함console.log(\"world\"); cf) request Animation Frame: 다음 번 화면을 그릴 때, 함수를 실행시켜달라는 함수(브라우저 내장 기능) 작업큐에 부탁하고 넘어가는 것이라는 개념을 이해할 것 비동기 프로그래밍 (Asyncronous Programming) 이처럼 어떤 일이 완료되기를 기다리지 않고 다음 코드를 실행해 나가는 프로그래밍 방식을일러 비동기 프로그래밍(asynchronous programming)이라고 한다. 반대로 어떤 일이 완료될 때까지 코드의 실행을 멈추고 기다리는 프로그래밍 방식을동기식 프로그래밍(synchronous programming)이라고 부릅니다. 브라우저에서의 비동기 프로그래밍은 주로 통신과 같이 오래 걸리는 작업들을 브라우저에 위임할 때 이루어진다. 비동기 프로그래밍 방식은 대개 프로그램의 성능과 응답성을 높이는 데에 도움을 준다. 하지만 코드가 실제로 실행되는 순서가 뒤죽박죽이 되므로, 코드의 가독성을 해치고 디버깅을 어렵게 만든다는 비판을 받아왔다. 이런 문제를 해결하기 위해 비동기 프로그래밍을 위한 여러 기법이 생겨났고,또 어떤 것들은 JavaScript 언어 자체에 포함되기도 했다. 여기에서는 근래 JavaScript 생태계에서 자주 사용되는 몇 가지 비동기 프로그래밍 기법들을 살펴 보자. 몇몇 예제 코드에서 사용한 Github REST API v3에는 API 사용량 제한이 있어서,이를 초과하면 코드 실행 중에 에러가 날 수도 있다. 이 때에는 한 시간 정도 흐른 뒤에 다시 코드를 실행해보자. 콜백 (Callback) 콜백은 다른 함수의 인수로 넘기는 함수를 말하는데, 이 콜백을 가지고 비동기 프로그래밍을 할 수 있다. 아래 예제는 유명한 JavaScript 라이브러리인 jQuery를 이용해,Github의 create-react-app 프로젝트에 등록되어 있는 이슈 목록을 가져와서 출력하는 코드이다. (여기에서 코드를 직접 실행해볼 것.) 123456789101112131415const $ = require(\"jquery\");const API_URL = \"https://api.github.com/repos/facebookincubator/create-react-app/issues?per_page=10\";$.ajaxSetup(&#123; dataType: \"json\"&#125;);$.get(API_URL, issues =&gt; &#123; console.log(\"최근 10개의 이슈:\"); issues.map(issue =&gt; issue.title).forEach(title =&gt; console.log(title)); console.log(\"출력이 끝났습니다.\");&#125;);console.log(\"받아오는 중...\"); 콜백이라고 해서 항상 비동기식으로 호출되는 것은 X 콜백은 동기식 or 비동기식으로 호출된다. 예제에서 $.get 메소드의 두 번째 인수로 콜백을 넘겨주었다.$.get 메소드는 비동기식으로 동작하며, Github API 서버와 통신하는 일을 브라우저에 위임한 후 바로 종료된다.통신이 끝나면, 그 결과를 첫 번째 인수로 해서 콜백을 호출하게 된다. 여기서 주의할 것이 있다.콜백을 인수로 받는 함수가 항상 비동기식으로 동작하는 것은 아닙니다.위 예제의 map, forEach의 인수로 넘겨준 것 역시 콜백이지만,이 때에는 콜백이 동기식으로 호출된다.즉, 콜백의 실행이 끝날때까지 코드의 실행 흐름이 다음으로 넘어가지 않습니다.예제 코드를 직접 실행해본 후, 어떤 순서로 출력이 되었는지 살펴보세요. 콜백은 JavaScript가 고차함수를 잘 지원한다는 특징 때문에 가장 많이 사용되는 비동기 프로그래밍 양식이었다.하지만 콜백만으로는 복잡한 비동기 데이터 흐름를 표현하기가 어려워서 많은 프로그래머들이 힘들어했고,결국 콜백 지옥(callback hell)이라는 용어까지 생겨났습니다. 예를 들어, 아래의 흐름대로 데이터를 가져오기 위해서는 복잡한 형태로 콜백을 사용해야 한다. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다. 123456789101112131415161718192021222324252627282930313233343536373839404142const $ = require(\"jquery\");const API_URL = \"https://api.github.com\";const starCount = &#123;&#125;;$.ajaxSetup(&#123; dataType: \"json\"&#125;);// 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다.$.get( `$&#123;API_URL&#125;/search/repositories?q=language:javascript&amp;sort=stars&amp;per_page=1`, result =&gt; &#123; // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다. $.get( `$&#123;API_URL&#125;/repos/$&#123;result.items[0].full_name&#125;/contributors?per_page=5`, users =&gt; &#123; let repoArrs = []; for (let user of users) &#123; // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각 기여자마다 10개씩 불러온다. $.get(`$&#123;API_URL&#125;/users/$&#123;user.login&#125;/starred?per_page=10`, repos =&gt; &#123; repoArrs.push(repos); // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다. if (repoArrs.length === 5) &#123; for (let repoArr of repoArrs) &#123; for (let repo of repoArr) &#123; if (repo.full_name in starCount) &#123; starCount[repo.full_name]++; &#125; else &#123; starCount[repo.full_name] = 1; &#125; &#125; &#125; console.log(starCount); &#125; &#125;); &#125; &#125; ); &#125;);console.log(\"fetching...\"); 위의 2, 3번 과정은 한 비동기 작업이 끝난 후 다른 비동기 작업을 시작하고 있고,이를 위해 콜백 안에서 다시 콜백을 사용하고 있다.또한 4번 과정을 실행하기 위해서는 앞서 3번 과정에서 실행된 10개의 비동기 작업이 모두 끝나는 시점을 알아야 할 필요가 있기 때문에,repoArrs 배열의 길이를 체크하고 있다. 이처럼 순수하게 콜백만 사용했을 때는, 데이터 흐름이 조금만 복잡해져도 코드가 복잡해지는 문제가 생긴다. Promise 위에서 설명한 콜백의 문제를 해결하기 위해 여러 라이브러리들이 등장했고,그 중에서 개발자들에게 널리 선택받은 것이 바로 Promise 패턴을 사용한 라이브러리들(jQuery Deffered, Q, Bluebird)이었다.이 라이브러리들이 표준화되어, 결국 ES2015에 이르러 JavaScript 언어 자체에 포함되게 되었다. Promise는 언젠가 끝나는 작업의 결과값을 담는 통과 같은 객체이다.Promise 객체가 만들어지는 시점에는 그 통 안에 무엇이 들어갈지 모를 수도 있다.대신 then 메소드를 통해 콜백을 등록해서, 작업이 끝났을 때 결과값을 가지고 추가 작업을 할 수 있다. Promise 객체를 생성하는 가장 쉬운 방법은 Promise.resolve 정적 메소드를 사용하는 것이다. 10번 예제는 보면 수강생들이 헷갈려해서 안보고 넘어감 비동기 작업을 하는 Promise 객체는 Promise 생성자를 통해 만들 수 있다. 1234567// 자바스크립트가 resolve, reject라는 함수를 준다.const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"2초가 지났습니다.\"); resolve(\"hello\"); &#125;, 2000);&#125;); Promise 생성자는 콜백을 인수로 받습니다. 이 콜백의 첫 번째 인수로 resolve 함수가 들어오는데,콜백 안에서 resolve를 호출하면 resolve에 인수로 준 값이 곧 Promise 객체의 궁극적인 결과값이 된다. 두 번째 인수로 들어오는 reject 함수는 비동기 작업에서 에러가 발생했을 때 호출하는 함수인데,여기에서는 소개만 하고 넘어가고 예외 처리 챕터에서 자세히 다루도록 할 것이다. 위 예제에서는 setTimeout을 이용해 2초가 지난 뒤에 콜백이 실행되도록 했다.즉, p 변수에 저장된 Promise 객체는 2초 동안은 결과값이 없는 상태가 된다.그리고 2초가 지나면, resolve 함수가 호출되어 p 객체는 결과값을 갖는 객체가 된다. Promise 객체의 결과값을 사용해 추가 작업을 하려면 then 메소드를 호출해야 한다.then 메소드에 콜백을 넘겨서, 첫 번째 인수로 들어온 결과값을 가지고 추가 작업을 할 수 있다. 123p.then(msg =&gt; &#123; console.log(msg); // hello&#125;); 모던 웹 서비스의 구성요소 모던 웹 서비스의 구성요소에서 배우는 것들은 통신할 때 중요한 것들이기 때문에 반드시 알아야 함!!! 실무에서 잘 써야 함! Cookie쿠키의 필요성 개별 클라이언트의 여러 요청에 걸친 정보의 유지 장바구니 로그인/로그아웃 방문 기록… HTTP Cookie 서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보 웹 브라우저는 쿠키를 저장하기 위한 저장소를 가지고 있음 저장소는 *자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공 쿠키 전송 절차 서버는 브라우저에 저장하고 싶은 정보를 응답과 같이 실어 보낸다 (Set-Cookie 헤더) 123HTTP/1.1 200 OKSet-Cookie: cookieName=cookieValue; Secure; Max-Age=60000... 브라우저는 같은 서버에 요청이 일어날 때마다 해당 정보를 요청에 같이 실어서 서버에 보낸다 (Cookie 헤더) 123GET / HTTP/1.1Cookie: cookieName=cookieValue; anotherName=anotherValue... Set-Cookie Options(쿠키를 저장하는 서버에서) Expires, Max-Age: 쿠키의 지속 시간 설정(ex) 10분간만 로그인이 유지되는 사이트) Secure: HTTPS를 통해서만 쿠키가 전송되도록 설정 HttpOnly: 자바스크립트에서 쿠키를 읽지 못하도록 설정 자바스크립트를 통해서 Cookie를 건드리지 않는 것이 좋다. ex) 게시판을 만들었을 때, 쿠키를 읽어와서 해커에게 전송할 수도 있다. -&gt; HttpOnly 속성을 사용해서 자바스크립트에서 쿠키를 읽지 못하게 만드는 게 좋다. Domain, Path: 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한) Express + Cookie 이 내용은 강사님이 그냥 넘어가심(내용을 읽지 않고 넘어가심) Express에도 Cookie 기능이 내장되어 있다. 쿠키 읽기 - req.cookies: 요청에 실려온 쿠키가 객체로 변환되어 req.cookies에 저장됨 (cookie-parser 미들웨어 필요) 쿠키 쓰기 - res.cookie(name, value): 쿠키의 생성 혹은 수정 쿠키 예제 JavaScript + Cookie 자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다. 자바스크립트에서 쿠키에 접근하지 못하도록 HttpOnly를 항상 설정하는 것이 best practice 쿠키의 한계점 US-ASCII 밖에 저장하지 못함. 보통 percent encoding을 사용 4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못함 브라우저에 저장됨. -&gt; 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보,혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절하다. ex) 보통 이 사람이 누구인지를 쿠키에 저장함. 인증 토큰을 보통 쿠키에 저장한다. 우리는 최종 프로젝트에서는 쿠키를 사용하지 않을 것임 But 회사에 입사했을 때, 로그인 정보를 유지하는 기능을 구현할 때, 쿠키를 써야 할 수도 있음 AjaxHTTP methods 복습 자주 사용할 것: GET, POST, PUT, PATCH, DELETE CRUD C(Create) - POST (만들 때)R(Read) - GET(읽을 때)U(Update) - PUT, PATCH(수정)D(Delete) - DELETE Ajax 비동기적인 웹 어플리케이션의 제작을 위한 클라이언트 측 웹 개발 기법…을 뜻하나 요즈음은 의미가 변형되어 웹 브라우저에서 XMLHttpRequest혹은 fetch를 이용해서 보내는 HTTP 요청을 통칭하기도 함 서버에서 필요한 부분만 받아서 브라우저의 필요한 부분만 수정한다. Ajax의 장점 화면 전체를 다시 로드하지 않고도 내용을 갱신할 수 있어 더 나은 사용자 경험 제공 서버의 응답을 기다리는 동안에도 여전히 웹 어플리케이션을 사용 가능 필요한 자원만 서버에서 받아오게 되므로 트래픽이 줄어듬 Ajax의 단점 클라이언트 구현이 굉장히 복잡해짐 Ajax Library Comparison Axios Promise based HTTP client 브라우저와 Node.js에서 모두 사용 가능 XMLHttpRequest, fetch에 비해 사용하기 편하고 기능이 더 많음(브라우저 내장 기능이라서 쓰기에는 불편함이 있음) 참고글: 내가 fetch API를 쓰지 못했던 이유 Axios + json-server 예제 12345678// GETaxios .get(\"/api/todos\") // 통신이 끝나면 응답 객체를 넣어서 콜백을 실행시킨다. .then(res =&gt; &#123; // prettyPrint는 강사님이 미리 만들어둔 함수 prettyPrint(res.data); &#125;); 1234// POST: 자료를 등록할 때 사용axios.post(\"/api/todos\", &#123; title: \"ajax 공부\" &#125;).then(res =&gt; &#123; prettyPrint(res.data);&#125;); put, patch는 수정할 때 사용. (But 미묘하게 다름) 123456// PATCH// 보통, 수정하고 싶은 자료의 식별자를 뒤에 붙여서 주소를 만든다.// 이런 식으로 주소를 만드는 방법은 restAPI라고 한다.axios.patch(\"/api/todos/3\", &#123; title: \"axios 공부\" &#125;).then(res =&gt; &#123; prettyPrint(res.data);&#125;); GET /api/todos/?title=reactaxios 요청 메소드의 두 번째 인자로 config 객체를 넘길 수 있다.config 객체를 통해 요청의 쿼리 스트링, 요청 헤더, 쿠키 포함 여부 등 많은 것들을 설정할 수 있다. 12345678910111213141516// config 객체axios .get(\"/api/todos\", &#123; params: &#123; // query string title: \"react 공부\" &#125;, headers: &#123; // 요청 헤더 \"X-Api-Key\": \"my-api-key\" &#125;, timeout: 1000 // 1초 이내에 응답이 오지 않으면 에러로 간주 &#125;) .then(res =&gt; &#123; prettyPrint(res.data); &#125;); 응답 객체 응답 객체를 통해 응답의 여러 정보에 접근할 수 있다. 12345678// config.paramsaxios.get(\"/api/todos/1\").then(res =&gt; &#123; console.log(`status code: $&#123;res.status&#125;`); console.log(\"headers:\"); prettyPrint(res.headers); console.log(\"data:\"); prettyPrint(res.data);&#125;); 쿠키를 통한 인증 예제 axios 공식 문서 CORSSame-origin Policy(동일 출처 정책) 웹페이지에서 리소스를 불러올 때,리소스의 출처가 웹페이지의 출처와 같으면 안전하다고 보고,출처가 다르면 해당 리소스는 안전하지 않다고 보는 원칙 여기서 ‘출처’란 ‘프로토콜 + 도메인 + 포트번호’의 결합을 가리킴.즉, 세 개가 다 같아야 동일 출처라고 할 수 있고, 셋 중에 하나라도 다르면 동일 출처로 간주되지 않음 웹 보안의 기본 원칙으로, 웹 브라우저의 많은 요소에 적용됨 [Same-origin Policy 실습] 1234567// 크롬 개발자 도구에서 코드 넣기&gt; const child = window.open('http://www.fastcampus.co.kr')// 새로 열린 웹 페이지의 콘솔에서&gt; window.foo = 'bar'// 이전 웹 페이지의 콘솔에서&gt; child.foo// 출처가 같다면 접근 가능, 아니면 불가 Content-Security-Policy Content-Security-Policy 헤더를 이용하면, 동일하지 않은 출처에 대한 리소스를 불러올지 말지 결정할 수 있음 CORS(Cross-Origin Resource Sharing) 클라이언트 측 cross-origin 요청을 안전하게 보낼 수 있는 방법을 정한 표준 쉽게 말하면,스크립트가 전혀 다른 출처를 갖는 API 서버를 사용하려고 하는 상황에서는뭔가 추가적인 처리를 해주어야 한다는 것! ex1) abc.com에서 abc.com/api/todos로 요청 -&gt; 브라우저가 막지 X. ex2) abc.com에서 cdf.com/api/todos로 요청 -&gt; 브라우저가 막음. 추가적인 처리를 해주어야 요청할 수 있음. Cross-origin 요청의 위험성 아래 상황을 가정해보자. mywebsite.com에서 서비스 중인 웹 사이트는 mywebsite.com/api 에서REST API를 통해 필요한 정보를 얻는다.mywebsite.com/api 경로에 대한 인증은 쿠키로 이루어지고 있다. 그런데 만약 evil.com 웹 사이트의 스크립트에서 mywebsite.com API에 요청을 마음대로 보낼 수 있다면,이미 my-website.com 도메인에 대해 브라우저에 저장된 쿠키를 이용해서 API를 마음대로 호출할 수 있을 것이다. Cross-origin 요청 예제 IE8 이상의 모던 웹 브라우저는 cross-origin 요청에 대해 여러가지 제한을 두고 있음 cross-origin 요청을 허용하려면, 서버가 특별한 형태의 응답을 전송해야 함 만약 서버가 cross-origin 요청을 허용하지 않으면, 웹 브라우저는 에러를 발생시킴 Cross-origin 요청 예제 CORS에 관여하는 응답 헤더 Access-Control-Allow-Origin Access-Control-Expose-Headers Access-Control-Max-Age Access-Control-Allow-Credentials Access-Control-Allow-Methods Access-Control-Allow-Headers CORS에 관여하는 요청 헤더 Origin Access-Control-Request-Method (preflighted 전용) Access-Control-Request-Headers (preflighted 전용) CORS - Safe, Unsafe GET, HEAD 요청은 safe(읽기 전용)이기 때문에서버에 요청이 도달한다고 해서 서버의 상태에 영향을 미칠 일은 없으므로,웹 브라우저는 일단 해당 요청을 보내본다.만약 서버가 cross-origin 요청을 허용한다고 응답하면 응답을 그대로 사용하고, 그렇지 않으면 에러를 낸다. POST, PUT, PATCH, DELETE 등의 메소드는 요청이 서버에 전송되는 것 자체가 위험하므로,실제 요청을 보내기 전에 서버가 cross-origin 요청을 허용하는지를 알아보기 위해 시험적으로 요청을 한 번 보내본다.이 요청을 preflighted request라고 한다. (단, 기존 HTML form의 동작방식인 application/x-www-form-urlencoded혹은 multipart/form-data 형태의 POST 요청은 preflighted request가 발생하지 않음) safe, unsafe 말고도 다른 원인에 의해 preflighted request가 발생하는 경우가 있는데,자세한 사항은 MDN 문서를 참고해주세요. CORS with credentials cross-origin 요청에는 기본적으로 쿠키가 포함되지 않으나,XMLHttpRequest 혹은 fetch를 통해서 요청을 보낼 때쿠키를 포함시키는 옵션을 줄 수 있고 이 때 CORS 요건이 더 엄격해짐 (Access-Control-Allow-Credentials 헤더 설정 필요, Access-Control-Allow-Origin 헤더에 와일드카드 허용 안됨) 복잡하면 그냥… 프론트엔드와 API 서버를 같은 도메인으로 제공한다. 불가피하게 둘을 다른 도메인으로 제공해야 한다면 CORS를 허용한다 (cors 미들웨어를 사용하면 간단함) CORS를 허용하는 경우, 쿠키를 쓸 수는 있으나 보안 상 허점이 생기기 쉽고 사용하기도 불편하므로보통 JWT와 같은 토큰 방식의 인증을 사용한다. Access Token &amp; JWT쿠키의 단점 쿠키를 지원하는 클라이언트에서 밖에 사용할 수 없음 적절히 관리되지 않은 쿠키는 보안에 취약하며, 관리를 하려고 해도 CORS 대응이 복잡함 Token Based Auth 토큰이란, 사용자의 자격증명(아이디, 패스워드 등)을 통해 인증이 이루어진 후,특정 자원에 대한 자격증명으로서 대신 사용되는 인증 수단 서버에 요청을 할 때마다 토큰을 요청에 직접 포함시켜서 전송 (주로 Authorization 헤더에 넣어서 전송) 보안 상 주의사항 (당연히) HTTPS를 사용해야 함 토큰을 localStorage에 저장하게 되면 자바스크립트로 토큰을 탈취할 수 있게 되므로,웹사이트에 악성 스크립트를 삽입하는 공격(XSS)에 노출되지 않도록 신경써야 함 JSON Web Token 최근 널리 사용되고 있는 토큰 형식의 표준 토큰 안에 JSON 형식으로 정보를 저장함 보안을 위해 서명 또는 암호화를 사용할 수 있음 JWT 실습(jwt.io) Cookie vs Token 토큰 사용의 장점 쿠키를 지원하지 않는 클라이언트에서도 편하게 사용할 수 있음 쿠키를 사용하지 않음으로써 CORS 관련 문제를 회피할 수 있음 토큰 사용의 단점 매 요청에 토큰이 포함되게 되므로 적당히 짧은 길이를 유지해야 함 토큰 유출에 대한 대비책이 필요 (토큰에 유효기간을 두거나, 유출된 토큰을 강제로 무효화하는 등의 방법을 사용)-&gt; 백엔드 개발자가 신경써야 하는 요소임 쿠키와는 다르게, 클라이언트 개발자가 직접 토큰을 저장하고 관리해야 함 Web Storage 브라우저에서 키-값 쌍을 저장할 수 있는 저장소 쿠키에 비해 사용하기 편리하고 저장 가능한 용량도 큼(10MB 가량) 브라우저 탭이 닫히면 내용이 삭제되는 sessionStorage,브라우저 탭이 닫혀도 내용이 유지되는 localStroage가 있음 [Web Storage 실습] - 크롬 개발자 도구에서 실습함 우리는 앞으로 로그인 유지되는 사이트만 만들 거라서 localStorage를 사용할 것임 보안 상 주의사항 (당연히) HTTPS를 사용해야 함 토큰을 localStorage에 저장하게 되면 자바스크립트로 토큰을 탈취할 수 있게 되므로,웹사이트에 악성 스크립트를 삽입하는 공격(XSS)에 노출되지 않도록 신경써야 함 JSON Web Token 최근 널리 사용되고 있는 토큰 형식의 표준 토큰 안에 JSON 형식으로 정보를 저장함 보안을 위해 서명 또는 암호화를 사용할 수 있음 JWT 실습(jwt.io)","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 13일차","slug":"javascript13","date":"2019-01-27T10:54:29.000Z","updated":"2019-01-27T11:17:51.844Z","comments":true,"path":"2019/01/27/javascript13/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/27/javascript13/","excerpt":"","text":"Express Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크 내장하고 있는 기능은 매우 적으나,미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음 Express 앱의 기본 구조12345678910111213141516171819202122232425262728293031323334353637383940// Express 인스턴스 생성// 서버를 대표하는 앱 객체const app = express();// 미들웨어 주입app.use(sessionMiddleware());app.use(authenticationMiddleware());// 미들웨어란? (출처: 위키백과)// 각기 분리된 두 개의 프로그램 사이에서,// 매개 역할을 하거나 연합시켜주는 프로그램을 말한다.// 데이터베이스와 웹서버를 연결시켜주는 것// ex1) 웹브라우저에 양식을 띄워놓고,// 이를 이용하여 데이터베이스로부터 데이터를 찾아올 수 있게 하는 것// ex2) 사용자의 요청 내용에 따라 페이지를 동적으로 나타낼 수 있게 한다.// 미들웨어는 양 쪽을 연결하여 데이터를 주고 받을 수 있도록// 중간에서 매개 역할을 하는 소프트웨어, 네트워크를 통해서// 연결된 여러 개의 컴퓨터에 있는 많은 프로세스들에게// 어떤 서비스를 사용할 수 있도록 연결해 주는 소프트웨어를 말한다.// 3계층 클라이언트/서버구조에서 미들웨어가 존재한다.// 웹 브라우저에서 데이터베이스로부터 데이터를 저장하거나 읽어올 수 있게// 중간에 미들웨어가 존재하게 된다.// 라우트 핸들러 등록// 요청이 들어왔을 때 분석해서 처리해준다.// app객체에 get방식으로 루트경로로 요청이 들어왔을 때, 일어날 일을 등록할 수 있다.// 요청에 대한 정보가 객체에 담겨서 request 자리에 들어온다.// response 객체에 응답을 담아서 브라우저에게 응답을 보낼 수 있다.app.get(\"/\", (request, response) =&gt; &#123; response.send(\"Hello express!\");&#125;);// 서버 구동// 서버에서 3000번 포트에서 코드를 실행시키고, &#123;&#125; 안의 코드인 console.log를 찍어라.app.listen(3000, () =&gt; &#123; console.log(\"Example app listening on port 3000!\");&#125;); Routing1234567891011121314151617181920// HTTP 요청 메소드(GET, POST, ...)와 같은 이름의 메소드를 사용// ex) /articles로 요청이 들어올 경우, 실행됨app.get(\"/articles\", (req, res) =&gt; &#123; res.send(\"Hello Routing!\");&#125;);// 특정 경로에만 미들웨어를 주입하는 것도 가능app.post(\"/articles\", bodyParserMiddleware(), (req, res) =&gt; &#123; database.articles.create(req.body).then(() =&gt; &#123; res.send(&#123; ok: true &#125;); &#125;);&#125;);// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음// ex) /articles/1로 요청이 들어올 경우, 실행됨app.get(\"/articles/:id\", (req, res) =&gt; &#123; database.articles .find(req.params.id) // `req.params`에 저장됨 .then(article =&gt; &#123; res.send(article); &#125;);&#125;); [Request 객체] req.body: 요청 바디를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장(body-parser 미들웨어에 의해 처리됨) req.ip: 요청한 쪽의 IP req.params: route parameter req.query: query string이 객체로 저장됨 요청의 구성 요소 메소드(ex) GET, POST) 주소 헤더(ex) 요청에 대한 부가정보) 바디(ex) 새로 등록하고자 하는 정보 등) 응답의 구성 요소 상태 코드 헤더 바디: 본문이 포함되는 영역 res.status(...): 응답의 상태 코드를 지정하는 메소드 res.append(...): 응답의 헤더를 지정하는 메소드 res.send(...): 응답의 바디를 지정하는 메소드 인자가 텍스트면 text/html, 객체면 application/json 타입으로 응답 Express 실습 Template LanguageTemplate Engine 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리 템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 함 ex) jsp(html에 java코드를 넣는 언어), php(html 안에 c#코드를 넣는 언어) EJS(Embedded JavaScript Template) Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진 JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음 EJS VSCode Extension EJS에서 Emmet 사용하기 EJS 예제 Example 1234567891011121314&lt;%# index.ejs %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"message\"&gt;&lt;%= message %&gt;&lt;/div&gt; &lt;!-- showSecret이 truethy이면, my secret을 보여주고, --&gt; &lt;!-- 아니면 보여주지 마라. --&gt; &lt;% if (showSecret) &#123; %&gt; &lt;div&gt;my secret&lt;/div&gt; &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; Express에서 EJS 사용하기 EJS 실습 파일을 그대로 제공하기 내가 가지고 있는 파일을 그대로 응답할 수 있다. ex) 이미지, 폰트 파일 등을 그대로 응답한다. EJS 실습 예제 코딩 퀴즈 2번 풀이 코드를 짤 때 순서: 상태로부터 화면을 그리는 코드를 먼저 짜고,그 후에 이벤트 리스너 코드를 짜는 게 쉽다. 클래스ES2015 class 그 전에 배웠던 프로토타입 부분 보기 123456789101112131415// 생성자function Person(&#123; name, age &#125;) &#123; this.name = name; this.age = age;&#125;Person.prototype.introduce = function() &#123; return `안녕하세요, 제 이름은 $&#123;this.name&#125;입니다.`;&#125;;const person = new Person(&#123; name: \"윤아준\", age: 19 &#125;);console.log(person.introduce()); // 안녕하세요, 제 이름은 윤아준입니다.console.log(typeof Person); // functionconsole.log(typeof Person.prototype.constructor); // functionconsole.log(typeof Person.prototype.introduce); // functionconsole.log(person instanceof Person); // true ES2015에서 도입된 클래스는 생성자의 기능을 대체한다. class 표현식을 사용하면,생성자와 같은 기능을 하는 함수를 훨씬 더 깔끔한 문법으로 정의할 수 있다. 123456789101112131415161718192021// 클래스class Person &#123; // 이전에서 사용하던 생성자 함수는 클래스 안에 `constructor`라는 이름으로 정의합니다. constructor(&#123; name, age &#125;) &#123; this.name = name; this.age = age; &#125; // 객체에서 메소드를 정의할 때 사용하던 문법을 그대로 사용하면, // 메소드가 자동으로 `Person.prototype`에 저장됩니다. introduce() &#123; return `안녕하세요, 제 이름은 $&#123;this.name&#125;입니다.`; &#125;&#125;const person = new Person(&#123; name: \"윤아준\", age: 19 &#125;);console.log(person.introduce()); // 안녕하세요, 제 이름은 윤아준입니다.console.log(typeof Person); // functionconsole.log(typeof Person.prototype.constructor); // functionconsole.log(typeof Person.prototype.introduce); // functionconsole.log(person instanceof Person); // true 12345// 클래스 내에서는 일반 함수에서 쓰는 문법을 사용할 수 X.class Person &#123; console.log('hello');&#125;// 에러: Unexpected token 12345678// 클래스는 객체가 아닙니다!// ',' 쓰지 X// class안에서 ','을 써서 에러난 것임class Person &#123; prop1: 1, prop2: 2&#125;// 에러: Unexpected token 1234567891011121314151617181920212223class Person &#123;&#125;// undefinedPerson();// 에러 메시지// VM135:1 Uncaught TypeError:// Class constructor Person cannot be invoked without 'new'// at &lt;anonymous&gt;:1:1 (anonymous) @ VM135:1new Person();// Person &#123;&#125;function Student(name) &#123; this.name = name;&#125;// undefinedconst s = new Student(\"haha\");// undefined1;// 1s.name;// \"haha\"const s2 = Student(\"haha\");// undefinedwindow.name;// \"haha\" 클래스는 함수로 호출될 수 없다. 클래스 선언은 let과 const처럼 블록 스코프에 선언되며,호이스팅(hoisting)이 일어나지 않는다. function으로 정의한 함수는 var변수와 비슷.호이스팅이 일어난다. 클래스의 메소드 안에서 super 키워드를 사용할 수 있다. 메소드 정의하기 getter, setter는 속성에 접근하기만 해도 함수가 실행된다. 클래스에서 Getter 혹은 setter를 정의하고 싶을 때는 메소드 이름 앞에 get 또는 set을 붙여주면 된다. 123456789101112131415class Account &#123; constructor() &#123; this._balance = 0; &#125; get balance() &#123; return this._balance; &#125; set balance(newBalance) &#123; this._balance = newBalance; &#125;&#125;const account = new Account();account.balance = 10000;account.balance; // 10000 static 키워드를 메소드 이름 앞에 붙여주면 해당 메소드는 정적 메소드가 된다. 정적 메소드는 인스턴스에 . 찍고 사용하는 메서드 (X). 생성자에 . 찍고 사용하는 메소드를 말한다. 메소드 중에 정적 메소드를 제외하면, 다 프로토타입 안에 들어간다. 클래스 필드 (Class Field) 클래스 필드는 내년쯤 정식 표준으로 채택될 것으로 예상됨. 현업에서는 다들 사용하고 있음. 클래스 필드는 최신 문법이라서 일반 repl.it에서는 실행되지 X. constructor vs class repl 코드 123456789101112131415161718192021222324252627282930// constructor vs classclass Person &#123; constructor(&#123; name, age &#125;) &#123; this.name = name; this.age = age; &#125; // 이 메소드는 정적 메소드입니다. static sumAge(...people) &#123; return people.reduce((acc, person) =&gt; acc + person.age, 0); &#125;&#125;// function Person(&#123;name, age&#125;) &#123;// this.name = name;// this.age = age;// &#125;// Person.prototype.introduce = function() &#123;// console.log(`안녕하세요, $&#123;this.name&#125;입니다.`)// &#125;// Person.sumAge = function(...people) &#123;// return people.reduce((acc, person) =&gt; acc + person.age, 0);// &#125;const person1 = new Person(&#123; name: \"윤아준\", age: 19 &#125;);const person2 = new Person(&#123; name: \"신하경\", age: 20 &#125;);// person1.introduce()Person.sumAge(person1, person2); // 39 클래스 필드와 this 메소드를 다른 함수의 인수로 넘겨줘야 하는 경우,화살표 함수를 사용하는 것이 좋다. React를 사용할 때 this 때문에 버그가 많이 일어난다. 클래스를 확실히 이해하려면, 교재의 ‘객체, 함수 더 알아보기’ 읽어보기class field repl 코드 12345678910class MyClass &#123; a = 1; getA = () =&gt; &#123; return this.a; &#125;;&#125;const instance = new MyClass();const getA = instance.getA;getA(); Web FormHTML FORMHTML form의 기본 동작 From Data가 요청 body에 담겨져 전달된다. HTML form을 전송하면,입력된 정보가 기본적으로 percent encoding 되어 요청됨 GET method 12 GET /search?query=%EA%B0%9C&amp;sort=latest HTTP/1.1... 123456POST methodPOST /form HTTP/1.1Content-Type: application/x-www-form-urlencoded...home=Cosby&amp;favorite+flavor=flies HTML Form 예제 - 할일 관리 웹 서비스 브라우저의 새로고침은 이전에 보냈던 요청을 그대로 보내는 것이다. 이런 일이 발생하지 않기 위해서 redirect를 하는 것이다. redirect 하지 x면, 새로고침을 여러 번 누르면 -&gt; POST로 요청이 계속 감 redirect 하면, 새로고침을 여러 번 누르면-&gt; GET으로 요청이 계속 감 DOM API만 사용하면 -&gt; 브라우저 내장 UI인 뒤로 가기, 앞으로 가기 버튼 등이 잘 작동하지 않는다. MIME 타입","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 12일차","slug":"javascript12","date":"2019-01-26T11:26:48.000Z","updated":"2019-01-26T11:57:52.163Z","comments":true,"path":"2019/01/26/javascript12/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/26/javascript12/","excerpt":"","text":"Node.js + HTTPhttp: 통신 규약 이름 처음 만나는 Node.jsREST API 실습 POSTMAN 설치 서버와 통신을 할 때는 주로 JASON 형식으로 주고 받는다. REST API: 통신 규약에 관한 용어 Authentication: 통신을 할 때 내가 누군지를 밝히는 절차 (인증) 내가 누군지를 밝혀야 나에 관한 자료를 받을 수 있다. token: 내가 누구인지 증명하는 보안카드, 주민등록증 같은 것 token 생성하기github.com-&gt; 프로필의 settings-&gt; developer settings-&gt; personal access tokens-&gt; generate new token 버튼 클릭-&gt; Token description에 설명을 적음.아래에 체크박스에는 아무 것도 체크 누르지 말 것.(아무 권한도 없는 식별 코드를 생성)-&gt; 각기 다른 token이 생성됨-&gt; ex) 607d493859c0ddb1cc8e1da472fc49fd66a12724 OAUth2 token(sent as a parameter) 방식 POSTMAN에https://api.github.com/user/repos/?access_token=OAUTH-TOKEN(발급받은 토큰)넣기-&gt; send 버튼 누르기 OAuth2 token (sent in a header) 방식 개발자들이 주로 사용하는 방식POSTMAN의 Headers를 누르고 KEY에 Authorization 입력VALUE에 token, 2번째 칸에 발급받은 토큰 입력reqeust URL에 https://api.github.com/user/repos 입력 Nods.js git bash에서 node를 입력 -&gt; javascript 코드를 입력할 수 있다. .exit를 입력하거나 Ctrl+C를 두 번 입력해서 빠져나갈 수 있다. alert, prompt는 브라우저 내장 기능이기 때문에 node.js에는 없다. 대신, 브라우저에 내장되지 않은 기능들이 많이 있다. nods.js는 브라우저와 완전히 다른 구동 환경이라는 것을 기억! module: 내장 함수를 가지고 있는 객체 Node.js module 사용하기 123456789// git bash에 입력node;const os = require(\"os\");// undefinedos.platform();//'win32'os.freemem();//2084761600 Node.js란? 아주 빠른 속도로 요청을 처리할 수 있는 기능을 내장하고 있다. Nods.js는 2009년에 만들어짐. 현재는 프론트엔드 개발도 node.js로 하게 되었다. 세계에서 가장 많은 오픈 소스 라이브러리를 가지고 있다. Node.js Module의 사용법12// git bash에 입력`code name.js`; 123456789// name.js에 아래의 코드 붙여넣기 -&gt; 저장// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음module.exports = &#123; familyName: \"김\", givenName: \"승하\", fullName: function() &#123; return this.familyName + this.givenName; &#125;&#125;; 12// git bash에 입력`code calc.js`; 1234567// calc.js에 아래의 코드 붙여넣기 -&gt; 저장// `exports`로도 참조 가능exports.add = (x, y) =&gt; x + y;exports.sub = (x, y) =&gt; x - y;// 파일을 만들고 다른 곳에서 불러서 쓸 수 있다.// 'require 함수를 이용해서 다른 곳에 있는 코드를 불러올 수 있구나.' 정도를 알고 넘어가면 된다 12345678910111213`node` &gt; `const name = require('./name')` &gt; // undefined `name.fullName()` &gt; // '김승하' `const calc = require('./calc')` &gt; // undefined calc &gt; // &#123; add: [Function], sub: [Function] &#125; `calc.add(1, 2)` &gt; // 3 `calc.sub(1, 2)`;// -1 Hello NPM1234// git bash에 입력`mkdir hello-npm``cd hello-npm``npm init -y``code .`;// npm으로 관리되는 프로젝트를 초기화하겠다.// code .으로 파일을 열어보면, json파일이 생성된 것을 볼 수 있다. pakage.json123456-`npm install --save` - `npm install sweetalert` - // 홈 폴더에서 node_modules 지우기 `rm -rf node_modules` - // 전에 설치했던 라이브러리들이 다시 다 설치됨 `npm install`; 다른 사람과 협업할 때, node_modules 폴더는 파일이 너무 많기 떄문에 git에 올리지 않고, package-lock.json, package.json을 git에 올린다. .gitignore에 modules/를 추가 https://www.npmjs.com/에 접속 -&gt; randomstring을 검색 npm 라이브러리를 사용하는 이유 bower https://bower.io/ npm과 비슷한 프론트엔드 도구. 클라우드 저장소 현재 bower는 거의 사용하지 않는다. 빌드 도구(ex) webpack 등)가 npm을 기반으로 만들어졌다. npm에서 빌드 도구를 다운 받는다.(ex) webpack 등이 node.js에서 작동하기 때문에) bower와 npm에서 각각 다운 받아야 하는 불편함이 있어서,요즘은 npm에서 거의 대부분의 라이브러리를 다운 받는 게 문화이다. npm install으로 한 번에 다운 받으면 설치된다. 거의 모든 (심지어 CSS코드까지) 라이브러리를 받을 수 있다.ex) css reset, jQuery 등 프론트엔드 라이브러리도 npm에서 다운받을 수 있다. HTTPHTTP 까보기 새로고침을 1번 해도 요청은 여러 번 일어날 수 있다. HTTP(HyperText Transfer Protocol) HTTP의 원래의 목적: 웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약 최근에는 REST API의 부상과 함께 다른 용도로도 널리 사용됨 모바일 앱 - 서버 간 통신 서버 - 서버 간 통신 localhost:8080 localhost: 컴퓨터의 이름 컴퓨터 하나에 통신을 위한 수많은 콘센트가 있다고 생각하면 된다. 그 콘센트에 번호를 매긴 것이라고 생각하면 이해하기 쉽다. ex) interpark.com:80/malls/index.html:80포트가 생략된 것이다. :80을 붙여서 주소를 입력해도 잘 작동한다. http를 사용하면 80번 포트가 기본으로 사용된다. 클라이언트의 요청(request)과 서버의 응답(response)으로 이루어짐 역사: 지금 사용되고 있는 버전은 1999년에 발표한 HTTP 1.1이다. HTTPS HTTP over SSL HTTP 통신을 암호화해 주고받는 내용을 중간에서 가로챌 수 없도록 함 같은 공유기를 사용하는 다른 사용자가 HTTP 사이트에 접속했을 때,어떤 사이트에 무슨 내용으로 접속했는지를 볼 수 있다. (공유기를 해킹한 해커도 그 공유기 사이로 흘러다니는 내용을 다 볼 수 있다.-&gt; HTTP 사이트에 아이디와 비밀번호를 넣어서 접속했을 때 해킹 당할 수 있다.) HTTPS를 사용했을 때는 해커가 알아볼 수 없는 암호화된 형태로 정보가 흘러다니기 때문에 해킹할 수 없다. https를 사용했을 때는 443번 포트를 기본적으로 사용한다. HTTP/2 구글의 SPDY 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준 속도 개선에 중점을 두고 개발됨 반드시 HTTPS를 사용해야 함 현재 전체 웹사이트 중 26% 이상이 사용중 HTTP 1.1에 비해 보안이 강화되고 속도도 빨라짐 HTTP/2로 바뀌는 추세 HTTP 구성요소Request &amp; Response 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄 그에 따라 서버는 클라이언트에 응답(response)를 보냄 웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, [중요!!] 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, …) Request Methods 요청에만 메소드가 있다. (응답에는 메소드가 X) HTTP 명세에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음 GET GET 메소드는 특정 리소스의 표시를 요청한다.GET을 사용하는 요청은 오직 데이터를 받기만 한다. GET 메소드는 정보를 달라는 것 POST: 서버에 등록하는 게 아니라, 정보를 받아올 때는 POST 메소드를 사용 웹 브라우저는 특정 상황에서 특정 메소드로 요청을 보내도록 만들어져 있음. 제출할 때 사용. POST 메소드는 특정 리소스에 엔티티를 제출할 때 쓰임. 이는 종종 서버의 상태의 변화나 부작용을 일으킨다. PUT: PUT 메소드는 목적 리소스 모든 현재 표시를 요청 payload로 바꾼다. Ajax와 같이 요청을 보내는 코드를 직접 짤 때는 요청 메소드를 선택할 수 있음 자료의 본문을 요청하는 GET 메소드와, 새로운 자료를 등록하는 POST 메소드가 가장 많이 쓰임 URL url이 반드시 웹사이트에 대한 주소가 아닐 수 있다. 특정 자원을 가리키기 위해서 url을 사용할 수 있다. 123&lt;a href=\"mailto:seungha.me@gmail.com\"&gt;메일&lt;/a&gt;// 메일 주소에 대한 링크를 만들 때 사용&lt;a href=\"tel:01012345678\"&gt;전화걸기&lt;/a&gt; https://www.example.com:3000/path/resource?id=123#section-id https://www.example.com:3000까지는 서버 주소 그림이 잘못되어있음. 3000 뒤의 /는 경로에 포함됨. /path/resource?id=123#section-id /부터 그 뒤까지는 자원의 주소 7번: 어떤 자원을 가져오고 싶은지, 부가정보를 포함시킬 때 querystring을 사용한다. 8번: #section-id : 문서의 특정 부분을 가리킬 때 #(해시)를 기억할 것! ex) https://www.google.com/search?source=hp&amp;ei=PaDWW7T7EImz8QWZ8ZKoCg&amp;q=http&amp;oq=http&amp;gs_l=psy-ab.3..0i131k1l5j0j0i131k1j0i3k1j0l2.989.1350.0.1568.4.3.0.1.1.0.138.248.0j2.2.0....0...1c.1.64.psy-ab..1.3.255....0._7JtWYsiHlc 해시태그(#) 챕터1: https://s.codepen.io/dbeat999/debug/pxBJNO/yoAZEWKOwOZr#chapter-1 챕터2: https://s.codepen.io/dbeat999/debug/pxBJNO/yoAZEWKOwOZr#chapter-2 url에서 해시태그(#) 뒷 부분이 바뀐다. 아무 의미없는 긴 문자열을 html에 넣고 테스트하고 싶을 때,lorem*50 넣어주기. lorem은 표준 채우기 텍스트 Percent Encoding 주소 표시줄 https://www.google.co.kr/search?q=%ED%95%9C%EA%B5%AD&amp;oq=%ED%95%9C%EA%B5%AD&amp;aqs=chrome..69i57j69i61l2j69i65l2j69i59.2351j0j7&amp;sourceid=chrome&amp;ie=UTF-8 크롬 개발자 도구 -&gt; Network-&gt; Name: search?..로 된 파일을 누르기 -&gt; Reqeust URL https://www.google.co.kr/search?q=%ED%95%9C%EA%B5%AD&amp;oq=%ED%95%9C%EA%B5%AD&amp;aqs=chrome..69i57j69i61l2j69i65l2j69i59.2351j0j7&amp;sourceid=chrome&amp;ie=UTF-8 Response Status Status Category 2xx: 성공 3xx: 추가 작업이 필요함 4xx: 실패 - 클라이언트 책임 5xx: 실패 - 서버 책임 Status Code - 2xx 200 OK: 성공 201 Created: 자료가 성공적으로 생성됨 Status Code - 3xx301 Moved Permanently (Redirection) 자료가 완전히 다른 곳으로 이동했음 서버가 여기에 없고 완전히 이동했다고 서버가 브라우저에 응답을 줌. 302 Found (Redirection) 자료가 일시적으로 다른 곳에 있음 302는 일시적으로 이동했다는 뜻이기 때문에 서버가 다른 곳으로 이동하라고 해도 다시 사용자에게 요청을 함. 304 Not Modified (Cache) 클라이언트가 이미 가지고 있던 자료가 수정되지 않았음 (그대로 사용하면 됨) 어떤 웹사이트들은 다운 받았던 이미지를 그대로 사용하는 경우가 있음. -&gt; 캐시(Cache)라고 한다. 이미지별로 식별번호가 있어서 서버가 브라우저로 이미지와 식별번호를 보내게 된다. ex) 똑같은 주소에 이미지를 요청한다. -&gt; 식별번호와 이미지를 브라우저가 가지고 있음.-&gt; 브라우저가 서버에 내가 이 식별번호와 이미지를 가지고 있는데, 바뀐 사항이 있는지 물어봄.-&gt; ‘브라우저 네가 가지고 있는 그대로 사용하면 돼~’ 라고 알려주는 게 304 Not Modified임. cf) Network에 Preserve log에 체크표시하면, 그 전 기록도 남게 됨. Status Code - 4xx 클라이언트의 책임이다. 400 Bad Request 요청의 형태가 잘못되어 응답할 수 없음 403 Forbidden 요청한 자료에 접근할 권한이 없음 404 Not Found 요청한 자료가 없음 Status Code - 5xx 서버의 책임이다. 500 Internal Server Error 요청을 처리하던 중에 예상치 못한 오류가 발생함 503 Service Unavailable -서버가 일시적으로 응답을 할 수 없음 Header 요청과 응답에 대한 추가 정보를 표현하는 데 사용됨 인증, 캐싱, 쿠키, 보안, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨 Authorization: 요청의 인증 정보- User-Agent: 요청 중인 클라이언트의 정보 Location: 301, 302 응답에서 자료의 위치 Accept: 요청이 어떤 형태의 자료를 원하는지 나타냄 Content-Type: 요청 혹은 응답이 어떤 형태의 자료인지 나타냄 Express Glitch Tutorial 버튼을 클릭 -&gt; github 계정으로 가입 설치 후, 교재의 Glitch Tutorial 버튼을 다시 클릭해서 들어오기 오른쪽 상단의 Remix This 버튼을 누르면, fork 됨 Glitch는 서버를 만드는 도구 우리가 작성한 서버를 클라우드에 띄운 다음 주소를 붙여주는 기능을 제공한다. 좌측 바의 package.json을 클릭 -&gt; add Package를 클릭 -&gt;express를 검색해서 설치 1234567// git bash에 입력// ~/hello-npm// FOO라는 환경변수에 BAR라는 값을 넣는다.FOO=BAR node// 환경변수 FOO를 호출한다.&gt; process.env.FOO// 'BAR' Glitch 튜토리얼 우측 상단의 Sign in 버튼을 눌러 Github 계정으로 로그인 해 주세요. Remix this 버튼을 눌러 프로젝트를 복제하세요. 현재 express가 설치되지 않아서 프로젝트가 실행되지 않는 상태입니다.좌측 파일 목록에서 package.json을 클릭한 후,문서 상단의 Add package 버튼을 클릭해 express를 설치해주세요. Glitch는 코드가 수정될 때마다 자동으로 npm start 명령을 실행합니다.package.json에서 어떤 명령이 실행되는지 확인하고, 해당 파일을 확인한 다음, 상단 Show 버튼을 눌러주세요.Glitch 앱은 기본적으로 HTTPS로 작동합니다. server.js에서 NAME이라는 환경변수를 불러와 표시해주고 있습니다.환경변수는 .env 파일에서 설정할 수 있으며,이 파일의 내용은 소유자와 공동작업자밖에 볼 수 없습니다.외부에 노출하면 안 되는 설정사항을 저장하기에 적합합니다..env에서 NAME 환경변수를 자신의 이름으로 수정하고, 앱이 잘 업데이트 되었는지 확인하세요. 좌측 최상단의 프로젝트 이름을 클릭하면, 프로젝트와 관련된 여러가지 설정을 할 수 있습니다.프로젝트 이름을 수정해주세요.그에 따라 앱의 url도 변경됩니다. 우측 최상단의 아이콘을 클릭하고 Keyboard Shortcuts를 확인해보세요. Glitch를 사용하면 환경 변수 설정, 코드 작성 후-&gt; 서버에서 어떤 응답을 해주는 지 볼 수 있다. 1주일 간, Glitch를 이용해서 서버 코드를 작성할 예정 Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크 내장하고 있는 기능은 매우 적으나,미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음 자바스크립트 교재- JAVASCRIPT 심화2 Iterable 반복 가능한 객체(iterable object)는 for...of 구문과 함께 ES2015에서 도입됨. 반복 가능한 객체를 다른 객체와 구분짓는 특징은,객체의 Symbol.iterator 속성에 특별한 형태의 함수가 들어있다는 것이다. 12const str = \"hello\";str[Symbol.iterator]; // [Function] Symbol은 객체의 속성 key로 사용할 수 있는 원시타입의 값 for...of 구문은 iterable에 대해서 사용하는 함수이다. 내장된 생성자 중 iterable 객체를 만들어내는 생성자에는 아래와 같은 것들이 있다. String Array TypedArray Map Set Iterable의 사용 객체가 Iterable이라면, 그 객체에 대해서 아래의 기능들을 사용할 수 있다. for…of 루프 spread 연산자 (…) 분해대입(destructuring assignment) 기타 iterable을 인수로 받는 함수 12345678910111213141516171819202122// `for...of`for (let c of \"hello\") &#123; console.log(c);&#125;// spread 연산자const chars = [...\"hello\"];// const chars = 'hello'.split('')으로도 가능함console.log(chars);// 분해대입// 배열처럼 분해대입이 가능하다.const [c1, c2] = \"hello\";console.log(c1, c2);// h e// `Array.from`은 iterable 혹은 array-like 객체를 인수로 받습니다.Array.from(\"hello\");const s = new Set([1, 2, 3]);const [c1, c2] = s;console.log(c1, c2); // 1 2 Generator 함수 Iterable을 구현하는 가장 쉬운 방법은 ES2015에 도입된 generator 함수를 사용하는 것이다. Gererator 함수는 만드는 개발자가 반환값을 만들지 않아도 객체를 반환한다. Generator 함수를 호출하면, 무조건 객체를 반환한다. Generator 함수를 호출하면 객체가 생성되는데, 이 객체는 iterable protocol을 만족한다.-&gt; 즉, Symbol.iterator 속성을 갖고 있다. Generator 함수를 실행하면, iterable 객체를 만들 수 있다. Generator 함수는 일시정지가 가능하다. 실무에서는 보통 루프 사용할 때는 거의 사용하지 않고, 일시정지 기능을 사용하고 싶을 때 많이 활용한다. 12345678910111213141516// generator 함수 선언하기function* gen1() &#123; // ...&#125;// 표현식으로 사용하기const gen2 = function*() &#123; // ...&#125;;// 메소드 문법으로 사용하기const obj = &#123; *gen3() &#123; // ... &#125;&#125;; Generator 함수 안에서는 yield라는 특별한 키워드를 사용할 수 있다. Generator 함수 안에서 yield 키워드는 return과 유사한 역할을 하며,iterable의 기능을 사용할 때 yield 키워드 뒤에 있는 값들을 순서대로 넘겨준다. yeild(양보하다) yield는 바깥으로 함수 여러 번 값을 반환한다.(cf) return은 1번만 반환함.) 1234567891011121314151617// yield 뒤에 붙어있는 숫자를 차례대로 반환한다.function* numberGen() &#123; yield 1; yield 2; yield 3;&#125;// 1, 2, 3이 순서대로 출력됩니다.// 첫 번째 실행시: 1이 들어감// 두 번째 실행시: 2가 들어감// 세 번째 실행시: 3이 들어감for (let n of numberGen()) &#123; console.log(n);&#125;// 1// 2// 3 yield* 표현식을 사용하면, 다른 generator 함수에서 넘겨준 값을 대신 넘겨줄 수도 있다. 12345678910111213141516171819202122function* numberGen() &#123; yield 1; yield 2; yield 3;&#125;function* numberGen2() &#123; yield* numberGen(); yield* numberGen();&#125;// 1, 2, 3, 1, 2, 3이 순서대로 출력됩니다.for (let n of numberGen2()) &#123; console.log(n);&#125;// 1// 2// 3// 1// 2// 3 사용자가 루프를 돌리고 싶을 때, 함수를 만들어서 루프를 돌릴 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041// 등차수열 생성하기// start=0 , end= Infinity는 매개변수의 기본값(인자가 들어오지 않으면, 기본값으로 사용)// start= 0, end= 5, step=1로 실행됨function* range(start = 0, end = Infinity, step = 1) &#123; for (let i = start; i &lt; end; i += step) &#123; yield i; &#125;&#125;// for (const item of range(0, 5)) &#123;// console.log(item);// &#125;// 0// 1// 2// 3// 4// 피보나치 수열 생성하기function* fibonacci(count = Infinity) &#123; let x = 1; let y = 1; for (let i = 0; i &lt; count; i++) &#123; yield x; [x, y] = [y, x + y]; &#125;&#125;for (const item of fibonacci(10)) &#123; console.log(item);&#125;// 1// 1// 2// 3// 5// 8// 13// 21// 34// 55 배열과의 차이점: Generator 함수는 순서대로 무한히 값을 반환해주는 무한 배열을 만들 수 있다. 루프를 값으로 다룰 수 있게 된다. Generator로 루프를 값으로 만들면, 조합을 하기 쉬워지고 변경을 하기 자유로워진다. Generator 함수를 사용할 때 주의할 점 123456789101112131415161718// Generator 함수로부터 생성된 iterable은 한 번만 사용될 수 있다.function* gen() &#123; yield 1; yield 2; yield 3;&#125;const iter = gen();for (let n of iter) &#123; // 잘 출력됩니다. console.log(n);&#125;//Generate 함수는 1번만 순회가 가능하므로 이 코드는 무시됨.for (let n of iter) &#123; // `iter`는 한 번 사용되었으므로, 이 코드는 실행되지 않습니다. console.log(n);&#125; 12345678910// Generator 함수 내부에서 정의된 일반 함수에서는 `yield` 키워드를 사용할 수 없다.function* gen2() &#123; // 아예 문법 오류가 난다. (Unexpected token) function fakeGen() &#123; yield 1; yield 2; yield 3; &#125; fakeGen();&#125; Generate 함수의 특징 값을 여러 번 뱉어낼 수 있는 함수 일반 함수와는 다르게 일시정지가 가능한 함수 1234567891011121314151617// Generate로부터 만들어진 함수는 next라는 메소드가 들어있고,// 이 next 메소드를 이용해서 함수를 일시정지 할 수 있다.function* gen() &#123; yield 1; yield 2; yield 3;&#125;const iterable = gen();// 다음 yield를 만날 때까지 함수가 실행됨// value는 yield뒤에 붙어있는 숫자// done은 함수가 끝까지 실행되면 ture가 나옴.iterable.next(); // &#123; value: 1, done: false &#125;iterable.next(); // &#123; value: 2, done: false &#125;iterable.next(); // &#123; value: 3, done: false &#125;iterable.next(); // &#123; value: undefined, done: true &#125;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 11일차","slug":"javascript11","date":"2019-01-25T13:52:53.097Z","updated":"2019-01-25T14:23:20.508Z","comments":true,"path":"2019/01/25/javascript11/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/25/javascript11/","excerpt":"","text":"previousElementSibling previousElementSibling는 가장 앞에 있는 요소에 주면, null이 반환된다. insertBefore와 appendChild insertBefore에 2번째 인자로 null이 들어가면 appendChild와 똑같이 동작한다. nextElmentSibling 맨 마지막에 있는 요소의 nextElmentSibling은 null을 반환한다.따라서, nextElmentSibling.nextElmentSibling은null.nextElmentSibling이 되므로 -&gt; 타입 에러가 난다. 위로 버튼을 눌렀을 때 mouseover는 부모 요소의 경계선을 지날 때 뿐만 아니라,자식 요소의 경계선을 지나쳤을 때도 부모 요소의 이벤트 리스너가 실행된다. 이런 현상이 일어나는 이유 mouseover, mouseout은 버블링이 일어난다. mouseenter, mouseleave은 버블링이 일어나지 않는다. 2가지 방법1. DOM 객체를 실제로 만들어서 넣기 HTML 문서에 직접 써넣을 수 없는 경우코드 작성 시점에 정확히 요소가 몇 개 표시될 지 모를 경우 ex) 사용자의 입력을 받아서 할 경우(Todo List 할 일 추가할 때) ex) createElement, appendChild, removeChild 등을 사용 2. CSS Style을 다르게 먹이는 방법 코드 작성 시점에 정확히 요소가 몇 개 표시될 지 아는 경우 ex) display: block or none했다가 나타나게 하기 2가지 방법 다 많이 사용되므로 필요에 따라 그때그때 다르게 사용하자. 스타일은 CSS에 작성하고, 자바스크립트에서는 클래스를 넣었다 뺐다 해주자.(자바스크립트에서 스타일을 넣고 빼는 건 할 수 있으나 역할과 책임에 맞지 않는다.) 게임을 만들 때 생각하는 절차 원래 그려져 있던 화면을 시간이 지남에 따라or 사용자의 입력에 따라서,화면을 바꿔주는 과정을 거친다.(화면을 새로 그려준다.) 사용자의 입력 시간의 경과 뭔가 기억하고 있는 것과 화면을 그리는 것이 연관이 있다. 상태(State) 화면을 그리기 위해 기억하고 있는 것을 상태(State)라고 부른다. 사용자의 입력을 받았을 때 어떤 상태가 될 지, 상태의 구조는 어떻게 될 지 프로그램이 기억하는 무언가가 모두 상태가 될 수 있다. 예시1textContent는 해당 텍스트를 기억해뒀다가 화면을 1초에 약 60번씩 계속 그리고 있는 것이다. classList.add, textContent의 상태를 바꾸면화면이 자동으로 다시 그려지게 기능이 내장되어 있다.(브라우저 내장 상태이기 때문에)-&gt; 굳이 ‘그리기’라는 절차를 코딩하지 않아도 된다. 예시2ex) score라는 상태는 우리가 기억하고 있는 상태이기 때문에개발자가 직접 일일히 화면을 그려주는 작업을 해야 한다.(score를 바꿀 때마다 화면이 다시 그려지는 게 X. ) React를 이용하기 React를 이용하면, 우리가 만든 상태를 사용할 때도 그 상태를 바꾸면,자동으로 화면을 다시 그려준다. React는 기술이기도 하지만 사고방식이라고 볼 수 있다. 게임에서 사용하던 기술들을 React에 많이 가져왔다. 프로그래밍하기에 편하도록 바꿔준 기술이다. Parcel은 자바스크립트가 수정될 때마다 다시 실행된다. Style을 수정할 때는 괜찮지만, 자바스크립트를 수정할 때는 그 때마다 새로고침을 눌러주는 게 좋다. Git으로 협업할 때 주의할 점 개행문자 때문에 문제가 생길 수 있다. window 사용자는 설정을 해야 한다. max: LF(/n) window: CRLF(/r/n) Window 사용자 개행문자 관련 설정 방법 자동으로 해결하는 방법이 있음(git에 내장된 기능을 이용) autocrlf기능을 켜기 git이 파일을 가져올 때는 LF(/n)를 CRLF(/r/n)로 저장해준다. 컴퓨터에서 파일을 저장한 걸 git에 커밋하면 LF(/n)로 바꿔줘서 Git에 올려준다. Git Bash에 입력 git config--global core.autocrlf를 입력한 후에 true가 반환되면 그대로 쓰면 된다. 아무것도 안 뜨면 설정이 안된 것이므로 -&gt; git config--global core.autocrlf true를 입력 Git 기본적인 명령어1234git pullgit add .git commit -m \"커밋 메시지\"git push","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 10일차","slug":"javascript10","date":"2019-01-24T08:21:30.791Z","updated":"2019-01-24T08:24:32.656Z","comments":true,"path":"2019/01/24/javascript10/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/24/javascript10/","excerpt":"","text":"DOM API이벤트 객체 e.stopPropagation() - 이벤트 전파 과정을 멈추기 더 이상 이벤트 과정을 실행시키지 않는다. 종종 사용하므로 기억할 것! e.currentTarget - ‘실제로 이벤트를 일으킨 요소’가 저장되어 있음 이벤트를 실제로 일으킨 요소와 이벤트가 등록되어 있는 요소는 같지 않을 수 있다. ex) 버튼을 클릭했을 때 실제로 이벤트를 일으킨 요소는 버튼인데, 이벤트 리스너가 outer에서도 실행될 수 있다. e.target과 e.currentTarget target은 실제로 이벤트를 일으킨 요소 ex) 실제로 클릭한 요소. button을 누른 경우 currentTarget에는 이벤트가 등록되어 있는 요소 ex) outer 클래스를 갖는 div를 가지고 있는 경우: outer가 나옴 보통은 target을 사용함. 항상 캡쳐링이나 버블링이 일어나는 것은 아니다. 버블링이 일어나는 이벤트도 있고, 일어나지 않는 이벤트도 있다. (ex) submit, focus, blur, change 등) submit: form만을 위한 이벤트 foucs, blur: input만을 위한 이벤트 폼 이벤트 자료를 실제로 전송할 수 있는 이벤트 type = “text”인 경우에는 input을 쓰고, 다른 type인 경우에는 change를 쓴다. change vs input change - checkbox, radio 등의 타입을 갖는 input 요소나 select 요소에 사용자의 선택이 일어났을 때 발생 input - text 타입을 갖는 input 요소나 textarea 요소의 값이 변경되었을 때(키보드 입력이 일어났을 때) 발생 contenteditable를 주면 input 이벤트가 발생 focus vs blur focus - 키보드 포커스가 해당 요소에 옮겨졌을 때 발생 마우스를 누르든, 키보드로 누르든 포커스가 오면, focus가 출력됨 blur - 키보드 포커스가 해당 요소에서 벗어났을 때 발생 마우스든, 키보드든 포커스가 해당 요소에서 벗어나면, blur가 출력됨 submit - 폼 전송이 일어났을 때 발생 폼 이벤트(submit)todo List(form 이용) codePen 예시 요즘은 form 태그의 내장 기능으로 전송하지 않고, 자바스크립트로 직접 구현을 해서 전송한다. -&gt; 따라서 form태그의 속성을 세세하게 알 필요는 X. 가끔 예전에 만든 프로젝트를 만져야 할 때 알아야하기 때문에 알고는 있어야 함. 실무에서 폼의 전송 기능을 거의 사용하지 않음에도, 폼 태그를 굉장히 많이 사용한다. (폼에 내장되어 있는 편리한 기능을 사용하기 위해서) 폼 태그에는 전송 기능 외에도 여러 가지 편리한 기능이 내장되어 있다. ex) 폼 태그의 안에서 Enter를 눌렀을 때 전송되는 기능 ex) 폼 안에 있는 input 태그에 required를 주면, 해당 input태그가 입력되지 않고 빈칸이면 ‘이 입력란을 작성하세요’라고 창을 띄워주는 기능 https://httpbin.org/post에 정보를 전송하면, 우리가 전송한 정보를 JSON 형태로 반환해서 보여줌 정보를 전송하는 방식: get방식, post방식 전송 버튼을 누를 때, 폼 안에서 엔터키를 누르거나 하면 정보를 전송할 수 있다. (브라우저의 내장 기능) form 안에 있는 button을 누르면 정보를 전송할 수 있다. (브라우저의 내장 기능) type에는 submit, reset, button 3가지가 있다. submit reset: 초기값으로 다시 되돌아가게 함. button: form기능을 사용하되 브라우저 내장 기능을 사용하고 싶지 않은 경우(비활성화하기 위해서), preventDefault 메소드를 사용한다. 사용자 입력 검증을 할 때, HTML5의 검증 기능을 사용(required를 주기)하거나 자바스크립트로 직접 사용자 입력 검증을 하거나 둘 다 혼합해서 사용하기도 한다. 마우스 이벤트 click / dblclick - 마우스 클릭 / 더블클릭 mouseover / mouseout - 요소에 마우스 포인터가 들어왔을 때 / 나갔을 때 mousedown / mouseup - 요소 위에서 마우스 버튼을 눌렀을 때 / 놓았을 때 mousemove - 요소 위에서 마우스 포인터가 움직일 때마다 Drag&amp;Drop(실습) 스타일링은 자바스크립트에서 할 수도 있지만, 되도록이면 CSS로 스타일을 주는 것이 좋다. 자바스크립트에서는 클래스를 넣었다 뺐다 조작해주고, 스타일링은 css에서 해주자. 마우스 포인터가 갑자기 확 움직이면, 인식 못할 수도 있다. 브라우저가 인식하기에는 점으로 이동하는 것처럼 인식 하기 때문에 123456789101112// boxEl.하면 마우스 포인터가 갑자기 확 움직이면, 인식 못할 수도 있다.// 브라우저가 인식하기에는 점으로 이동하는 것처럼 인식 하기 때문// document.으로 써야 함// boxEl.addEventListener('mousedown', e =&gt; &#123;// // 마우스를 눌렀을 때// dragging = true;// &#125;)document.addEventListener(\"mousedown\", e =&gt; &#123; // 마우스를 눌렀을 때 dragging = true;&#125;); [과제] 박스의 중간 지점과 마우스가 일치하게 그 상태로 움직이려면 어떻게 해야 할 지 내가 누른 지점 그대로(마우스 포인터를 올렸을 때 그 마우스 포인터 위치 그대로) 부드럽게 움직이려면 어떻게 해야할 지 키보드 이벤트 한글은 잘 작동하지 않는다는 걸 기억해두기 keydown / keyup - 키보드 버튼을 눌렀을 때 / 놓았을 때 keypress - 문자가 입력되었을 때 keydown에서 charCode와 keyCode는 없어질 예정임. 사용하지 X. input이벤트는 문서가 실행될 때 바로 document에 이벤트를 먹일 수 없으나(querySelector로 가져온 후 이벤트 붙일 수 있다.), keydown은 가능하다. 123document.addEventListener(\"keydown\", e =&gt; &#123;&#125;);document.querySelector(\".todo-input\").addEventListener(\"keypress\", e =&gt; &#123;&#125;); 스크롤 이벤트 scroll - 요소 내부의 콘텐츠가 스크롤 될 때마다 parallax Scrolling","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 9일차","slug":"javascript9","date":"2019-01-22T15:41:52.969Z","updated":"2019-01-22T16:21:18.425Z","comments":true,"path":"2019/01/23/javascript9/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/23/javascript9/","excerpt":"","text":"내장 객체 및 생성자JSON 자료구조(메모리에 올라간 객체나 배열)은 그대로 전송할 수 없다. 객체나 배열은 메모리에 저장된다.크롬, 익스플로러 등등 각 브라우저가 메모리에 저장하는 방법이 달라서 호환이 되지 않는다. (브라우저 간의 메모리 구조가 다르다.) 따라서 저장/전송 가능한 형태로 변환하는 절차가 필요하다. -&gt; 직렬화(serialization) 텍스트 형태의 데이터를 프로그래밍 언어에서 다시 사용할 수 있도록 변환해주는 절차를 역직렬화(deserialization)라고 한다. JSON(JavaScript Object Notation)은 직렬화 포맷 중에 요즘 압도적으로 사용되고 있는 형식이다. 직렬화 하기: JSON.stringify 역직렬화 하기: JSON.parse 12345678910111213141516// `JSON.stringify`로 직렬화를 할 수 있다.// stringify라는 메소드에 객체를 넘겨준 것이다.// 객체 그대로 전송할 수 없으니 텍스트로 변환해서 전송하는 것이다.// 이 객체를 문자열로 변환해준 것이다.JSON.stringify(&#123; key: \"value\", arr: [1, 2, 3], nullProp: null, undefinedProp: undefined // 값이 `undefined`인 속성은 직렬화 과정에서 제외된다.&#125;); // '&#123;\"key\":\"value\",\"arr\":[1,2,3],\"nullProp\":null&#125;'// `JSON.parse`로 역직렬화를 할 수 있다.JSON.parse('&#123;\"key\":\"value\",\"arr\":[1,2,3],\"nullProp\":null&#125;');const obj = JSON.parse(text);// =&gt; &#123; key: 'value', arr: [ 1, 2, 3 ], nullProp: null &#125; JSON은 JavaScript와 아주 유사한 언어이지, 같은 언어가 아니다. 다른 언어이다. JSON을 직접 편집해야 할 때는 JSON이 JavaScript가 아니라는 사실에 주의!!!! JSON을 편집할 때 주의할 점 속성 이름에 꼭 쌍따옴표(&quot;&quot;)를 둘러주어야 한다. 아주 단순한 객체나 배열만 표현할 수 있다. 객체 리터럴로 만들어진 아주 단순한 형태의 객체만 표현할 수 있다. JSON 문서 안에 함수를 저장할 수 없다. 함수는 JSON으로 변환할 수 없다. Map, Set, Date, Error, RegExp, Function, Promise와 같이특별한 동작방식을 가지는 객체들을 제대로 표현할 수 없다. undefined, NaN, Infinity과 같은 값을 표현할 수 없다. 주석을 쓸 수 없다. Date 협정 세계시(UTC)를 많이 사용한다. 지구 상의 여러 지역에서는 시간대(timezone)와 일광 절약 시간제(DST)에 따라 서로 다른 시각을 사용한다. 조금씩 느려지는 지구 자전 속도에 맞추기 위해 UTC에는 가끔씩 윤초(leap second)가 추가되기도 한다. 유닉스 시간 - 컴퓨터에서는 시간 데이터를 편하게 다루기 위해서 유닉스 시간이라는 특별한 단위를 사용한다.유닉스 시간은 UTC 기준 1970년 1월 1일 0시 0분 0초부터 경과한 시간을 초 단위의 정수로 나타낸다. 자바스크립트에도 유닉스 시간이 사용되고 있다. Date 객체의 생성Date 생성자의 사용 방법 new Date() - 현재 시각을 나타내는 Date 객체를 반환한다. new Date(value) new Date(정수)- value가 정수인 경우,이를 밀리초 단위의 유닉스 시간으로 간주해서 이에 해당하는 Date 객체를 반환한다. new Date(&#39;문자&#39;)- value가 문자열인 경우, 이 문자열이 나타내는 Date 객체를 반환한다. new Date(year, month, day, hour, minutes, seconds, milliseconds)- 년, 월, 일, 시, 분, 초, 밀리초를 직접 입력해서 Date 객체를 생성할 수 있다. ‘월’ 부분은 0부터 11까지의 값을 가집니다. 월 이후의 인수는 생략가능하고, 인수를 생략하면 ‘일’은 1로, 나머지는 모두 0으로 지정됩니다.(월은 0월부터 시작한다. ex) 1월이면, 0을 입력한다.) Date 객체를 생성하고 난 뒤에는, 해당 객체가 나타내는 년, 월, 일, 시, 분, 초, 밀리초를 가져오거나 변경할 수 있다. 12345678910// 현재 날짜와 시간new Date();// =&gt; 2018-10-15T11:37:03.577Zconst d = new Date();// =&gt; undefinedtypeof d;// =&gt; 'object'd.getTime();// =&gt; 1539603459005// 유닉스 시간을 가져옴 123456789101112131415161718192021 new Date();// =&gt; 2018-10-15T02:39:41.453Z const d = new Date();// =&gt; undefined typeof d// =&gt; 'object' d.getTime(); // Date타입을 유닉스 시간으로 바꿈// =&gt; 1539571216084 const msec = d.getTime();// =&gt; undefined new Date(msec - 60000);// 유닉스 시간을 Date타입으로 바꿈(msec- 60000)은 1분 전 객체를 얻기 위해서 연산해준 것임&lt;!-- 60 X 1000 = 60,000 = '1분'을 나타냄--&gt;// =&gt; 2018-10-15T02:39:16.084Z d// =&gt; 2018-10-15T02:40:16.084Znew Date('2018-10-10T01:01:02')// =&gt; 2018-10-09T16:01:02.000Z// Date객체의 포맷으로 value를 넘겨줌// 우리가 입력한 건 한국 시간이고, 결과로 출력되는 건 한국 시간 - 9시간인// 협정 세계시로 나온다.new Date(year, month, day, hour, minutes, seconds, milliseconds) 데이터 객체를 숫자로 바꾼 후에 저장해야 한다. 12345678910obj2 = &#123; date: d.getTime() &#125;;// =&gt; &#123; date: 1539571216084 &#125;const text = JSON.stringify(obj2);// =&gt; undefinedtext;// =&gt; '&#123;\"date\":1539571216084&#125;'const obj3 = JSON.parse(text);// =&gt; undefinedtext;// =&gt; '&#123;\"date\":1539571216084&#125;' 문자열로 변환하기 Date 객체가 나타내는 시각을 여러 가지 방법으로 문자열로 변환할 수도 있다. 12345678910const now = new Date();// new Date().toLocaleString()// 지역 + 언어: Locale// ex) 캐나다 + 불어, 캐나다 + 영어// 해당 지역과 언어에 맞게 현재 시간이 나온다.console.log(now.toLocaleString()); // 2018. 10. 15. 오후 8:47:14// Z가 붙어있으면 UTC기준이라는 뜻이다.// new Date().toISOString()은 사람도 알아보기 쉽기 때문에 시간 표시 형식으로 많이 쓴다.console.log(now.toISOString()); // 2017-12-10T03:49:31.145Z 숫자로 넣고 숫자로 빼서 그걸 Date객체로 바꾸는 게 속편하다. 시간 간격 측정하기 - 연산자를 사용해서 두 Date 객체 사이의 시간 간격이 얼마나 되는지를 밀리초 단위로 측정할 수 있다. 어떤 특정 시간으로부터 경과시간을 계산할 때 사용한다. 123456const start = new Date();alert(\"시간이 가고 있습니다...\");// 경고창을 끈 후 new Date()가 실행된다.const end = new Date();// (뒷쪽 시간 - 처음 시간)을 밀리초 단위로 반환alert(`$&#123;end - start&#125; 밀리초 만큼의 시간이 경과되었습니다.`); 12345678// 주기적으로 코드를 실행하고 싶을 때const start = new Date();setInterval(() =&gt; &#123; const end = new Date(); console.log(`경과시간: $&#123;end - start&#125; 밀리초`);&#125;, 1000);const end = new Date();// 시간이 정확하지 않다는 문제점이 있음 라이브러리 사용하기 moment.js라는 라이브러리를 jquery 다음으로 많이 사용함. 간단한 작업을 할 때는 Date 생성자를 사용하는데,실무에서는 moment.js혹은 date-fns와 같은 별도의 라이브러리를 사용하는 경우가 많다. 123456789101112const moment = require(\"moment\");// 한국어 사용자를 위해서 moment라이브러리를 사용하겠다.moment.locale(\"ko\");// 한국 시간을 가져오려고 locale('')안에 ko를 적어줌.// moment(); 현재 시간을 가져오는 객체const now = moment();// 내가 원하는 형태로 문자열을 만들고 싶을 때, format()에 원하는 형식의 문자열을 넘겨주면 그 형식대로 가져올 수 있다.console.log(now.format(\"dddd, MMMM Do YYYY, h:mm:ss a\")); // 일요일, 12월 10일 2017, 1:02:42 오후// 7일 전의 날짜를 문자열로 바꾸고 싶을 때 사용console.log(now.subtract(7, \"days\").calendar()); // 2017.12.03// \"YYYYMMDD\" 이 형태로 만든 \"20120101\" 이 날짜가 .fromNow() 지금으로부터 얼마 전인지를 나타내라.console.log(moment(\"20120101\", \"YYYYMMDD\").fromNow()); // 6년 전 Symbol ES2015에서 도입된 새로운 원시 타입 참조 타입 X!! Symbol 내장 함수를 통해 새 심볼을 생성할 수 있다. 123const sym = Symbol(); // 새 Symbole값이 만들어짐console.log(typeof sym); //symbolconsole.log(sym); // Symbol() Symbol은 객체의 속성 키로 사용하기 위해서 만들어졌다. 객체의 비밀 통로 역할을 하기 위해서 심볼이 만들어진 것이다. 대괄호 표기법을 통해 심볼을 객체의 속성 키로 사용할 수 있다. 객체의 속성 키로 문자열과 심볼이 사용될 수 있다. 웹프론트엔드 개발자 입장에서 Symbol을 사용할 일은 자주 없으나, Symbol이 무엇인지는 알아야 한다. 1234567891011121314const mySymbol = Symbol(\"my symbol\");const obj = &#123; // 대괄호 표기법: 대괄호[]안의 표현식의 결과값을 속성의 이름으로 사용하고 싶을 때 // mySymbol이 객체의 속성 키로 사용되고 있다. [mySymbol]: \"hello\"&#125;;// obj.mySymbol과 obj[mySymbol]는 완전히 다른 것이다!!// obj.mySymbol; // undefined// obj.mySymbol 이걸 대괄호로 나타내면// obj['mySymbol'] // undefiend// mySymbol이라는 문자열을 속성키로 갖는 속성console.log(obj); // &#123; [Symbol(my symbol)]: 'hello' &#125; 1234567891011121314151617181920212223242526// Symbol.iterator// Symbol에 있는 내장심볼const arr = [1, 2, 3];// 배열 뿐만 아니라 iterable 객체를 순회할 때에도 사용할 수 있다.for (const item of arr) &#123; console.log(item);&#125;// iterable 객체란, Symbol.iterator 속성에 특별한 형태의 함수가 들어있는 객체를 말한다.for (const char of \"hello\") &#123; console.log(char);&#125;const obj = &#123; [Symbol.iterator]: function*() &#123; yield 1; yield 2; yield 3; &#125;&#125;;for (const item of obj) &#123; console.log(item);&#125; Map 객체와 비슷함 Map은 대응시킨다는 의미가 있음 ES2015에서 도입된 Map 생성자는 객체와 유사하게키-값 쌍(key-value pair)을 저장할 수 있는 새로운 자료구조를 제공한다. 1234567891011121314151617181920const m = new Map();// new Map().set('key', 'value');m.set(\"hello\", \"world\");console.log(m.get(\"hello\")); // 'world'// ('hello')라는 키의 값을 가져와라.console.log(m.has(\"hello\")); // true// ('hello')라는 키를 가지고 있냐?m.delete(\"hello\");console.log(m.get(\"hello\")); // undefinedconsole.log(m.has(\"hello\")); // falseconst obj = &#123;&#125;;obj.hello = \"world\";obj.hello;\"hello\" in obj;const obj = &#123; a: 1 &#125;;m.set(obj, 1);console.log(m.get(obj)); 객체에는 문자열 키만 저장할 수 있다는 제한점이 있다. 프로토 타입이 붙기 때문에 무겁다는 특징이 있다. Map에는 문자열이 아닌 키도 만들 수 있다. 속성의 개수를 알고 싶을 때 Object.keys와 Map 비교 1Object.keys(obj).length; Object.keys로 속성의 개수를 알아보려고 하면, 상속 받은 속성까지 알고 싶은지,열거 가능한 속성만 알고 싶은 지 등등을 고려해야 한다. Object.keys는 열거 가능한 속성만 반환한다. Map에는 열거 가능, 상속 이런 개념이 없으므로 단순하게 사용할 수 있다. Map객체는 데이터의 추가/삭제가 빈번하게 일어나는 경우 일반적인 객체보다 훨씬 빠르게 동작한다는 장점이 있다. 반면, JSON 등으로 직렬화 하기 어렵다는 특징이 있다. 키 값에 문자열 말고도 여러 가지 값을 넣을 수 있기 때문이다. 키-값 쌍 형태의 데이터를 다루면서 속도가 중요한 경우에는 Map의 사용을 고려해보자. Set 배열과 비슷함. 집합 형태의 자료구조 제공 중복 제거할 때 자주 사용함 중복된 데이터의 저장을 허용하지 않는다. ex) {1, 2} U {1, 3} = {1, 2, 3} 배열과는 다르게 첫 번째, 두 번째 요소라는 순서 개념이 없다. 배열과 유사한 자료구조가 필요하지만, 순서가 중요하지 않은 경우, 그리고 중복된 데이터의 저장을 허용하지 않아야 할 경우, Set의 사용을 고려해보자. 12345678function removeDuplicates(arr) &#123; // Set에 넣기만 하면, 중복된 요소가 사라진다. const set = new Set(arr); //집합을 다시 배열로 변환하는 함수: Array.from() return Array.from(set);&#125;removeDuplicates([1, 2, 3, 2, 1]); DOM API이벤트 리스너 el.addEventListener(eventName, callback)- 이벤트 리스너 등록 이 함수가 실행될 때마다 callback이 실행된다. el.removeEventListener(eventName, callback)- 이벤트 리스너 제거 DOM 엘리먼트 생성하기 document.createElement(tagName) - 새로운 엘리먼트 객체 생성하기 el.cloneNode()- 엘리먼트 복사하기 HTML 문서의 구조를 바꾸는 방법 12345// createElement는 ()안의 div를 만들기는 했지만,// 아직 HTML 문서를 변경한 게 X.// div 만들기document.createElement('div');&lt;!-- &lt;div&gt;​&lt;/div&gt;​ --&gt; 요소 객체는 문서 바깥에 있을 수 있고, 문서 안에 있을 수 있다. 문서 상에는 아무런 영향을 미치지 않을 수 있다. 문서 밖에서 만들었다면, 안에 집어넣어줘야 문서에 영향을 미칠 수 있다. 12// 문서 내에서 요소 객체를 가져올 때document.querySelector(\"footer\"); DOM 트리 조작하기 el.appendChild(newChild) - 요소 끝에 자식 요소를 삽입하기 el.insertBefore(newChild, beforeWhat) - 원하는 위치에 자식 요소를 삽입하기 el.replaceChild(newChild, oldChild) - 자식 요소를 교체하기 el.removeChild(child) - 자식 요소 제거하기 appendChild와 insertBefore는 요소의 위치를 이동시킬 때도 사용된다. el.appendChild(newChild): 요소 끝에 자식 요소를 삽입하기.무조건 마지막에 넣는 것임 formEl.insertBefore(divEl2, null)은 formEl.appendChild(divEl2)와 같은 것임. insertBefore에 두 번째 인자로 null을 넣으면 appendChild와 같게 작동 이미 문서에 존재하는 요소 객체를 인수에 넣어서 호출하면, 그 요소 객체를 복사하지 않고, 위치를 이동시킨다. dataset el.dataset - data-* 어트리뷰트를 가져오기. (kebab-case가 camelCase로 변환됨) 12345678910formEl.getAttribute(\"data-foo-bar\");// \"hello\"// ES전에는 getAttribute로 로 가져왔었는데,// ES5부터는 dataset으로 짧게 가져올 수 있다.const formEl = document.querySelector(\"form\");// undefinedformEl.dataset.fooBar;// \"hello\"formEl.dataset.index;// \"1\" 노드 간 관계 el.childNodes - 자식 노드 el.firstElementChild - 첫 번째 자식 요소 el.lastElementChild - 마지막 자식 요소 el.previousElementSibling - 이전 형제 요소 el.nextElementSibling - 다음 형제 요소 el.parentElement- 부모 요소 el.offsetParent: 포지션 세팅이 되어있는 가장 가까운 조상 요소DOM 트리 조작하기 &amp; 노드 간 관계 이용 예시 코드(추가/ 삭제 기능 Todo List) 요소의 크기 및 위치 el.getBoundingClientRect()- 화면 좌측 상단으로부터의 요소의 위치 및 요소의 크기를 반환 el.offsetHeight / el.offsetWidth- border를 포함한 요소의 크기 el.clientHeight / el.clientWidth - border를 제외한 요소의 크기 el.scrollHeight / el.scrollWidth - 요소 내부에 포함된 콘텐츠의 크기 (스크롤 가능한 영역의 크기) el.offsetTop / el.offsetLeft - offsetParent로부터의 요소의 위치 el.clientTop / el.clientLeft - border의 너비 el.getBoundingClientRect()를 가장 많이 사용함. formEl.getBoundingClientRect()했을 때, 반환되는 값 중 x, y는 익스플로러에서는 사용할 수 없다. bottom, height, left, right, top, width 이 6가지 요소를 사용하도록 하자. absolute position을 할 때 기준이 되는 부모가 있는데, 이 부모는 position: relative가 된다. 이벤트 객체 e.target - 실제로 이벤트를 일으킨 요소 e.currentTarget - 이벤트 전파 과정 중 현재 이벤트가 위치한 요소 e.stopPropagation() - 이벤트 전파 과정을 멈추기. e.stoprPropagation()를 만나면, 이벤트 전파 과정이 멈추고 그 이후 이벤트는 실행되지 않는다. MouseEventaltKey: false // altKey를 누른채로 실행하면 true가 반환됨button:clientX: 화면 가장 왼쪽 위, 끝에서부터의 X좌표clientY: 화면 가장 왼쪽 위, 끝에서부터의 Y좌표 e.preventDefault(): 이벤트가 일으키는 브라우저의 기본 동작과정을 취소하기 ex) 링크를 클릭해도 페이지가 넘어가지 않게 만들기 이벤트는 해당 태그가 아니라 그 안에 있는 태그를 클릭해도 발생할 수 있다. ex) form 태그에 마우스 이벤트를 걸었는데, 안에 있는 label태그를 눌러도 마우스 이벤트가 작동한다. 이벤트 전파 Capturing At Target Bubbling 이벤트의 실행 순서가 중요할 때가 있다. ex) 부모 요소의 이벤트가 먼저 실행되어야 하는 경우, Capturing단계에 이벤트를 등록해줘야 하는 경우가 있다. Capturing과정에 걸렸을 때 이벤트를 실행할 것인지, Bubbling과정에 걸렸을 때 이벤트를 실행할 것인지 정해줄 수 있다. 그냥 addEventListener하면 Bubbling과정에서 이벤트가 실행된다. Capturing 단계에 이벤트가 실행되게 하려면, addEverListener의 3번째 인수로 true를 넘겨주면, capturing단계에서 이벤트가 실행되게 할 수 있다. 이벤트 전파 관련 예시 (Capturing &amp; Bubbling 실습)","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 8일차","slug":"javascript8","date":"2019-01-21T17:01:07.000Z","updated":"2019-01-21T17:23:49.453Z","comments":true,"path":"2019/01/22/javascript8/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/22/javascript8/","excerpt":"","text":"연산자 더 알아보기표현식(Expression) 표현식: 코드 중에 값으로 변환될 수 있는 부분 평가: 표현식을 값으로 변환하기 위해 실제로 해당 표현식을 실행시키는 절차 단축 평가(Short-circuit Evaluation)단축 평가의 연산자는 React할 때 많이 쓰인다. &amp;&amp; 왼쪽 피연산자가 falsy이면 이 값을 반환.오른쪽 피연산자는 코드가 실행조차 안된다. 왼쪽 피연산자가 falsy가 아니면,오른쪽 피연산자를 평가한 후, 이 값을 반환 || 왼쪽 피연산자를 평가해서 truthy이면, 이 값을 바로 반환. 아니라면 오른쪽 피연산자를 평가한 결과값을 반환. 특히 || 연산자는 ‘기본 매개변수’ 문법이 생기기 전까지매개변수의 기본값을 지정하는 용도로 많이 사용됐다. 12345678910111213141516171819function func1(arg = \"hello\") &#123; console.log(arg); // arg가 undefined일 때만 'hello'를 출력&#125;function func2(arg) &#123; arg = arg || \"hello\"; // 매개변수 자리에 아무것도 안들어오면 undefined // -&gt; arg가 falsy이므로 오른쪽 피연산자를 평가하게 됨. // arg가 falsy이면 'hello'를 출력 console.log(arg);&#125;function func3(arg) &#123; if (arg === undefined) &#123; arg = \"hello\"; &#125; console.log(arg);&#125; 삼항 연산자 (Ternary Operator) 삼항 연산자 역시 평가할 필요가 없는 부분은 평가하지 않는다. if...else구문처럼 작동한다. 1234console.log(true ? 1 : 2); // 1// : 오른쪽의 코드는 실행조차 안함console.log(false ? 1 : 2); // 2// : 왼쪽의 코드는 실행조차 안함 증가/감소 연산자 (Increment/Decrement Operator) 증가/감소 연산자의 결과값을 어딘가에 저장하거나 사용할 때 코드의 실행 결과가 달라진다. 1234567891011// 아래 코드 예제의 위에 있는 루프는 3번 실행되지만,// 아래 있는 루프는 2번 밖에 실행되지 않는다.let i = 3;while (i--) &#123; console.log(\"감소 연산자를 뒤에 쓰면 어떻게 될까요?\");&#125;let j = 3;while (--j) &#123; console.log(\"감소 연산자를 앞에 쓰면 어떻게 될까요?\");&#125; 할당 연산자 (Assignment Operator) j -= 1과 --j는 같은 의미 j를 1감소시킨 후에 j에 대입하므로 같은 의미이다. 할당 연산자에 대한 표현식의 결과값은 왼쪽 피연산자에 실제로 할당된 값이 된다. 1234let i, j, k, l, m, n;i = j = k = l = m = n = 1;// 이런 표현식도 쓸 수 있다.// =연산자는 오른쪽부터 계산된다. 연산자 우선 순위 (Operator Precedence)연산자 결합 순서 (Operator Associativity) 부등호를 연달아 2개 쓸 수 없다. 12345678// 위아래 식은 완전히 같은 방식으로 동작합니다.// 결과적으로 `true &gt; 1`이 되어 결과값이 `false`가 됩니다.3 &gt; 2 &gt; 1;3 &gt; 2 &gt; 1;true &gt; 1; // false// 세 개의 수에 대한 비교를 하고 싶다면 아래와 같이 해야 합니다.3 &gt; 2 &amp;&amp; 2 &gt; 1; // true 1234// 삼항 연산자 예제 코드const num = 4;const str = num === 1 ? \"one\" : num === 2 ? \"two\" : num === 3 ? \"three\" : \"?\";console.log(str); 삼항연산자를 너무 여러 개 이어서 쓰면 한 눈에 알아보기 어렵다. if...else처럼 작동하게 하고 싶은데 꼭 표현식이어야 한다면 삼항연산자를 사용해야 한다. 거듭제곱 연산자, 할당 연산자는 오른쪽부터 실행된다. 삼항연산자는 괄호는 오른쪽부터 쳐지는데, 실행은 왼쪽부터 작동한다. 123// 위아래 식은 완전히 같은 방식으로 동작합니다.a ? b : c ? d : e ? f : g;a ? b : c ? d : e ? f : g; 값을 비교하는 여러 가지 방법 ==연산자는 두 피연산자의 타입이 다를 때는 타입을 변환한 후 비교한다. null check할 때만 ==연산자를 사용하자. 엄격한 동일성(Strict Equality) ===, !== 연산자는 두 피연산자의 타입이 다른 경우에는 무조건 false를 반환한다. NaN은 ===로 비교하면 자기 자신에 대해서도 같지 않다고 false가 반환된다. NaN인지 아닌지 검사할 때는 Number.isNaN을 사용해야 한다. 1234567// `===` 연산에서, `NaN`은 number 타입의 **모든** 값과 다릅니다.// 이는 자기 자신에 대해서도 마찬가지입니다.NaN === NaN; // false// `0`과 `-0`은 서로 다른 값이지만,// `===` 연산은 이 둘을 같은 것으로 취급합니다.0 === -0; // true Object.is 두 인수가 정말로 같은 값인지를 검사 아래의 두 예외를 제외하고는 === 연산자와 같은 방식으로 동작 12Object.is(NaN, NaN); // trueObject.is(0, -0); // false 무엇을 써야 하나요? 특별한 경우를 제외하고는 === 혹은 !==연산자를 사용해서 비교를 하면 된다. Spread Syntax 배열을 이어붙이거나 복사할 때 사용한다. 배열이 들어가는 게 아니라 배열의 요소들이 펼쳐져서 들어간다. Spread 문법을 통해 배열 리터럴의 중간에 다른 배열을 이어붙일 수 있다. 이 때, arr1 안에 있는 요소들이 arr2 안으로 복사된다. 배열을 복사할 때는 Spread Sytax보다는 slice 메소드가 더 자주 사용된다. Spread Syntax도 slice 메소드와 마찬가지로 얕은 복사를 한다. 12345const arr1 = [3, 4];const arr2 = [1, 2, ...arr1, 5]; // [1, 2, 3, 4, 5]// 이전에는 같은 작업을 하기 위해 `Array.prototype.concat` 메소드를 사용했습니다.[1, 2].concat(arr1).concat([5]); // [1, 2, 3, 4, 5] Spread 문법은 *함수 호출 시에도 사용할 수 있다.8 이 때 배열의 모든 요소를 함수의 인수로 넘긴다. Spread 문법은 배열을 펼쳐서 요소들을 넣고 싶을 때,함수의 인수로 배열을 넘기고 싶을 때 사용한다. 123456789const arr = [1, 2, 3, 4, 5];// 배열 앞에 ...붙이는 건 ES2018에 추가된 문법.// 어떤 브라우저에서는 동작하지 않을 수 있으므로 꼭 변환한 코드로 적용해야 한다.// 아래 코드는 `Math.max(1, 2, 3, 4, 5)`와 동일합니다.Math.max(...arr); // 5// 이전에는 같은 작업을 하기 위해 `Function.prototype.apply` 메소드를 사용했습니다.Math.max.apply(null, arr); // 5 객체123//Object Spread 예제 코드const obj1 = &#123; prop: 1 &#125;;const obj2 = &#123; ...obj1 &#125;; 123456789101112const obj1 = &#123; prop: 1, a: 2, b: 3 &#125;;const obj2 = &#123; a: 3, b: 4 &#125;;const obj = &#123; a: 7, b: 8, ...obj1, ...obj2, c: 4, d: 5&#125;;console.log(obj); 123456789// array spread flatten 코드const arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];function flatten(arr) &#123; return arr.reduce((acc, item) =&gt; [...acc, ...item], []); // return arr.reduce((acc, item) =&gt; acc.concat(item), [])&#125;flatten(arr); 분해대입. 비구조할당 (Destructuring Assignment)배열의 분해대입 배열 순서 섞을 때, [x, y] = [y, x]를 이용해 보기 객체의 분해대입 수의 선언과 동시에 객체의 속성을 해당 변수에 대입할 수 있다. 123const &#123; a: prop1, b: prop2 &#125; = &#123; a: 1, b: 2 &#125;;console.log(prop1, prop2); // 1 2 속성 이름과 변수 이름이 같다면 변수 이름을 생략할 수 있다. 1234// 위의 예제보다 이 예제처럼 변수 이름을 생략하는 경우가 훨씬 압도적으로 더 많이 사용된다.const &#123; a, b &#125; = &#123; a: 1, b: 2 &#125;;console.log(a, b); // 1 2 12345678910let a, b;// 자바스크립트에서는 문장이 여는 중괄호`&#123;&#125;`로 시작되면 이는 '블록'으로 간주되므로,// &#123;a, b&#125;가 블록이라고 간주되서 에러가 난다.&#123;a, b&#125; = &#123;a: 1, b: 2&#125;; //SyntaxError: Unexpected token// 아래와 같이 분해대입을 할 때는 식 전체를 괄호()로 둘러싸주어야 합니다.//()가 문장의 첫 글자이면 아~ &#123;&#125; 블록이랑 다른거구나~ 라고 자바스크립트가 인식한다.(&#123;a, b&#125; = &#123;a: 1, b: 2&#125;);console.log(a, b); // 1 2 화살표 함수에서 중괄호{}가 등장하면,객체라고 인식하는게 아니라 ‘구문이구나.표현식이구나’ 라고 인식하므로객체를 반환하고 싶으면 괄호()로 감싸줘야 한다. 화살표 함수에서 객체를 바로 반환하고 싶은 경우,괄호()로 객체를 둘러싸주어야 한다. 123456const returnObj = (x, y) =&gt; &#123; x, y;&#125;;// 표현식의 결과는 y. 아무 리턴도 하고 있지 않음.const returnObj = (x, y) =&gt; (&#123; x, y &#125;);console.log(returnObj(1, 2)); 객체가 중첩되어 있으면, 해당 객체에 대해서 분해대입을 할 수 있다. 객체의 나머지 속성 분해대입 시 무시된 속성들을 가지고 새로운 객체를 만들고 싶다면,...을 붙여주면 된다. 123const &#123; a, b, ...rest &#125; = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;console.log(rest); // &#123; c: 3, d: 4 &#125; 분해대입의 기본값 분해대입 시, 만약 좌측 변수의 위치에 해당하는 값이 우측의 배열 혹은 객체에 존재하지 않으면거기에는 대입이 일어나지 않는다.-&gt; undefined가 나온다. 좌측 변수에 기본으로 대입될 값으로 미리 지정해둘 수 있다. 12345// 많이 사용되는 기능임// `c` 위치에는 대입될 값이 없으므로, 기본값인 `3`이 대신 사용됩니다.let [a, b, c = 3] = [1, 2];console.log(c); // 3 매개변수에서의 분해대입 함수의 매개변수에서 분해대입을 할 수 있다. 123456789function func(&#123; prop, array: [item1, item2, item3 = 4] &#125;) &#123; console.log(prop); console.log(item1); console.log(item2); console.log(item3);&#125;// 1, 2, 3, 4가 차례대로 출력됩니다.func(&#123; prop: 1, array: [2, 3] &#125;); 분해 대입은 요즘 덧셈만큼 많이 쓰인다. 특히, 할당할 때 많이 쓰이므로 잘 익혀두어야 한다. 123456789101112131415161718// 매개변수에서 객체를 분해대입하는 코드가 많이 쓰이고 있다.function func1(name, age, address, country) &#123;&#125;// 특정 매개변수의 역할을 바로 알아보기 어렵다.// 함수를 사용할 때마다 매개변수의 이름과 순서를 기억해야 한다는 불편함이 있다.// 순서를 바꿔서 쓰면 문제가 생긴다.func(31, \"김승하\", \"관악구\", \"대한민국\");func(\"김승하\", 31, \"관악구\", \"대한민국\");function func2(&#123; name, age, address, country &#125;) &#123;&#125;func2(&#123; // 직관적으로 알아보기 쉽고, 순서를 바꿔도 이상없이 잘 동작한다. name: \"김승하\", age: 31, address: \"관악구\", country: \"대한민국\"&#125;); FDS 브라우저 측 JavaScriptDOM API 실무에서는 DOM API를 직접 쓸 일은 거의 없다. React가 DOM API를 기반으로 되어 있기 떄문에 이해가 필요하다. React를 벗어나는 수준의 고급 웹 개발에도 필요하기 때문에 DOM API를 공부할 필요가 있다. DOM API: 문서를 조작하는 API 라우터가 내장하고 있는 수많은 WEB API들 중에 하나임(통신을 위한 API, 모바일 화면이 가로인지 세로인지 등을 인식하는 API 등이 있음) 메모리에 올라간 html파일을 편집하고 있는 것이므로하드디스크에 저장되어있는 html 문서 내용이 바뀌는 건 X. 요소 선택하기 document.querySelector(selector) - CSS 선택자를 통해 단일 요소 가져오기 이 selector와 일치하는 가장 첫번째 요소 하나를 가져온다. el은 요소 객체 document.querySelectorAll(selector) - CSS 선택자를 통해 여러 요소 가져오기 못 찾은 경우 null 반환 el.querySelector(selector)- CSS 선택자를 통해 단일 자식 요소를 가져오기 el.closest(selector)- 엘리먼트의 조상 중에 CSS 선택자와 일치하는 가장 가까운 조상 요소 가져오기 el.matches(selector)- 해당 요소가 CSS 선택자와 일치하는지 검사하기 요소 내용 조작하기 내용을 읽어오거나 변경하는 방법 2가지 el.textContent: 요소 본문을 가져오거나 변경할 때 사용하는 속성 (텍스트).태그를 제외하고 텍스트 내용만 넣거나 반환 el.innerHTML - 요소 본문을 가져오거나 변경할 때 사용하는 속성 (HTML).태그를 포함해서 html으로써 넣거나 반환 대부분은 textContent를 사용한다. 특히, 사용자로부터 입력받은 텍스트를 innerHTML에 대입해서는 절대로 안된다.textContent를 사용하자. 악의적인 사용자가 자바스크립트로 해킹하는 코드를 게시물로 올렸을 때,사용자로부터 입력받은 텍스트를 innerHTML에 대입하도록 하면 해킹하는 데에 이용될 수 있다. 요소 선택하기 &amp; 조작하기 실습 코드(Counter 실습) 요소 어트리뷰트 조작하기 el.hasAttribute(attrName)- 어트리뷰트가 있는지 검사하기 el.getAttribute(attrName)- 어트리뷰트의 값 가져오기 el.setAttribute(attrName, attrValue)- 어트리뷰트 설정하기 el.removeAttribute(attrName)- 어트리뷰트 삭제하기 리스너 붙이기, 떼기 실습 코드 요소 클래스 조작하기 el.classList.add(className, ...) - 클래스 추가 el.classList.remove(className, ...)- 클래스 삭제 el.classList.contains(className)- 클래스 포함 여부 검사 클래스 추가, 제거 실습 코드(Form Scripting 실습) boolean attribute: 붙어있으면 true, 없으면 false기능을 하는 attribute 클래스명이 여러 개 들어있을 때,setAttribute를 하면 기존의 여러가지 클래스들이 다 지워진다는 버그가 있다.-&gt; setAttribute로 클래스 이름을 추가하는 작업은 거의 하지 않는다.-&gt;classList.add(className,...)하면 쉽게 클래스 이름을 추가할 수 있다. 인라인 스타일 조작하기 el.style- 요소의 인라인 스타일을 읽고 쓸 때 사용하는 객체. camelCase 사용 el.style.backgroundColor = &#39;#000000&#39;- 요소의 배경색을 검은색으로 변경","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"Recursion의 응용 - Counting Cells in a Blob","slug":"recursion-counting-cells-in-a-blob","date":"2019-01-21T03:45:09.000Z","updated":"2019-01-21T07:08:10.101Z","comments":true,"path":"2019/01/21/recursion-counting-cells-in-a-blob/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/21/recursion-counting-cells-in-a-blob/","excerpt":"","text":"이번에는 Recursion의 응용 - Counting Cells in a Blob에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. Counting Cells in a Blob Binary 이미지 각 픽셀은 background pixel(white)이거나혹은 image pixel(blue) 서로 연결된 image pixel들의 집합을 blob이라고 부름 상하좌우 및 대각방향으로도 연결된 것으로 간주 입력: N * N 크기의 2차원 그리드(grid) 하나의 좌표 (x, y) 출력: 픽셀 (x, y)가 포함된 blob의 크기, (x, y)가 어떤 blob에도 속하지 않는 경우에는 0 Recursive Thinking바로 코드부터 작성하지 않고먼저, 순환적인 사고를 글로 적어보자. 123456789현재 픽셀이 이 속한 blob의 크기를 카운트하려면 현재 픽셀이 image color가 아니라면 0을 반환한다 현재 픽셀이 image color라면 먼저 현재 픽셀을 카운트한다 (count=1). 현재 픽셀이 중복 카운트되는 것을 방지하기 위해 다른 색으로 칠한다. 현재 픽셀에 이웃한 모든 픽셀들에 대해서 그 픽셀이 속한 blob의 크기를 카운트하여 카운터에 더해준다. 카운터를 반환한다. 순환적 알고리즘N * N 크기의 2차원 그리드(grid)를 보고, blob의 크기를 계산해보자.blob의 크기는 count값에 누적하여 계산하자. 1. count = 0 2.현재 cell을 칠했기 때문에 count에 1 증가시킨다. count = 1 인접한 8개의 픽셀 각각에 대해서 &gt; 순서대로 그 픽셀이 포함된 blob의 크기를 count한다. &gt; 북, 북동, 동, 동남, … 이런 순서로 고려한다. 3. 북쪽 픽셀을 검사 count = 1 4-1) 북동쪽 픽셀을 검사 count = 1 4-2) count = 1 + 3 = 4 5. 동쪽과 남동쪽 픽셀을 검사 count = 4 6-1) 남쪽 픽셀을 검사 count = 4 6-2) count = 4 + 9 = 13 7. 남서, 서, 북서 방향으로 픽셀을 검사 count = 13 Counting Cells in a Blob1234567891011121314151617181920212223Algorithm for countCells (x, y) &#123; // 예외 처리: pixel (x, y)가 유효한 좌표가 아닐 때(grid의 범위를 벗어날 때) // -&gt; (x &lt; 0 || y &lt; 0 || x &gt; N || y &gt; N) if the pixel (x, y) is outside the grid // 0을 return하고 함수를 종료한다. the result is 0; // Base Case: 1) pixel (x, y)가 0이 아니거나 // (-&gt; 즉, 이 함수에서는 image pixel이 아니면-&gt; background pixel을 의미) // 2) 이미 카운트된 (빨간색으로 칠해진)셀일 경우 else if pixel (x, y) is not an image pixel or already counted // 0을 return하고 함수를 종료한다. the result is 0; // 이미 카운트된 pixel도 아니고 image pixel일 경우 else // 이미 카운트했다는 걸 표시하기 위해서 // 그 pixel (x, y)를 빨간색으로 칠한다; set the colour of the pixel (x, y) to a red colour; // 1) 그 pixel에 1(자기 자신)을 더한 후, // 2) 이 pixel에 인접한 8개의 인접 pixel 각각에 대해서 recursion을 호출한다. // 3) recursion을 8번 호출한 그 결과들을 다 더해준다. the result is 1 plus the number of cells in each piece of the blob that includes a nearest neighbour;&#125; Java 코드로 구현해보기위의 알고리즘을 Java 코드로 구현해 봅시다. 123456789101112131415161718192021222324252627282930private static int BACKGROUND_COLOR = 0;private static int IMAGE_COLOR = 1;private static int ALREADY_COUNTED = 2;public int countCells (int x, int y) &#123; int result; // N * N 그리드는 0 ~ N-1까지가 유효한 좌표이므로 if (x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= N) return 0; // grid[x][y]가 IMAGE_COLOR이 아니라는 건, // grid[x][y]이 // 1) 0 (BACKGROUND_COLOR)이거나 // 2) 0 (ALREADY_COUNTED)일 경우라는 뜻이다. else if (grid[x][y] != IMAGE_COLOR) return 0; // 그렇지 않다면, 카운트할 셀이기 때문에 ALREADY_COUNTED를 표시하기 위해 // 해당 셀을 빨간색으로 칠해준다. else &#123; grid[x][y] = ALREADY_COUNTED; // grid[x][y]의 값인 1과 // (여기에서 더하는 1은 자기자신을 의미한다.) // 이 셀에 인접한 8개의 셀 각각의 recursion을 호출해서 // 그 결과를 다 더해준 값이 답이 된다. return 1 + countCells(x - 1, y + 1) + countCells(x, y + 1) + countCells(x + 1, y + 1) + countCells(x - 1, y) + countCells(x + 1, y) + countCells(x - 1, y - 1) + countCells(x, y - 1) + countCells(x + 1, y - 1) &#125;&#125;","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"순환 함수","slug":"순환-함수","permalink":"https://JihyeHwang09.github.io/tags/순환-함수/"},{"name":"recursion","slug":"recursion","permalink":"https://JihyeHwang09.github.io/tags/recursion/"},{"name":"Counting Cells in a Blob","slug":"counting-cells-in-a-blob","permalink":"https://JihyeHwang09.github.io/tags/counting-cells-in-a-blob/"}]},{"title":"자바스크립트 7일차","slug":"javascript7","date":"2019-01-20T15:29:09.000Z","updated":"2019-01-20T15:53:12.554Z","comments":true,"path":"2019/01/21/javascript7/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/21/javascript7/","excerpt":"","text":"클래스 클래스는 생성자의 기능을 대체한다. (세부적인 기능상의 차이는 있지만) 함수형 프로그래밍 프로그래밍의 큰 흐름: 객체 지향 프로그래밍 vs 함수형 프로그래밍 고차 함수(Higher-order Function) 함수를 인수로 받는 함수, 또는 함수를 반환하는 함수를고차 함수(higher-order function)라고 한다. 자바스크립트에서는 함수도 값이다. 함수를 호출할 때 함수를 넘기는 함수나 함수를 반환하는 함수(ex) this를 바꿔치기 하는 메소드: bind)가 고차 함수에 속한다. 함수를 인수로 받는 Array의 많은 메소드들(forEach, map, reduce, filter, sort, every, some, find 둥)은 고차 함수이다. 다른 함수의 인수로 넘겨지는 함수를 콜백(callback)이라고 부른다. 클로저(Closure) 자바스크립트에서 스코프는 함수 단위 자기 자신 스코프에 없으면(자기 자신 스코프 내에서 찾는 해당 변수가 정의되어 있지 않거나 함수 등이 없으면)상위 스코프로 올라가서 찾는다. 찾을 때까지 상위 스코프로 올라가서 찾으면 가져다가 쓴다. 없으면 global까지 올라간다. 둘러싸고 있는 것. 성질. 좀비같은 것임 예전에는 자바스크립트에서 아주 중요한 개념이었으나 요즘은 자주 쓰이지는 않음 클로저의 2가지 의미 바깥 스코프에 있는 변수를 가져다가 사용하는 함수변수가 저장되는 저장소 고차함수를 사용할 때 클로저의 성질을 이용할 수 있다. threshould: 임계값, 기준값 클로저는 데이터를 숨기고 정해진 방법을 통해서만 데이터에 접근할 수 있도록 제한을 두는 데 활용된다. 다른 프로그래머가 내가 만든 값에 실수로라도 접근하거나 변경하지 못하게 하고 싶을 때 클로저를 사용한다. 1234567891011121314151617function personFactory(initialAge) &#123; let age = initialAge; return &#123; getOlder() &#123; age++; &#125;, getAge() &#123; return age; &#125; &#125;;&#125;// `age`를 직접 변경할 수 있는 방법이 없습니다!const person = personFactory(20);person.getAge();// age가 비밀스런 저장공간인 클로저에 저장되었으므로 person.getAge()로 값을 가져올 수 있다.// 밑에 코드를 추가해서 나이값을 바꿀 수는 없다. 화살표 함수와 고차 함수 화살표 함수 문법을 이용하면, 적은 양의 코드만 사용해서(간단하게) 고차 함수를 만들 수 있다. 1234const makeAdder = x =&gt; y =&gt; x + y;// 매개변수: x, 반환값: 함수임. y =&gt; x + yconst add2 = makeAdder(2);add2(3); // 5 1234567const makeCounter = (x = 1) =&gt; () =&gt; x++;// 매개변수: (x = 1), x의 기본값을 1로 지정// 반환값: 함수임. () =&gt; x++const counter = makeCounter();console.log(counter()); // 1console.log(counter()); // 2 재귀 함수(Recursive Function) 재귀 함수(recursive function): 함수 내부에서 자기 자신을 호출하는 함수 문제를 같은 형태의 부분 문제로 쪼갤 수 있을 때, 재귀함수를 활용할 수 있다. 프론트엔드 개발자가 실무에서 자주 사용하지는 않으나, 어떤 문제는 재귀 함수로 푸는 게 편할 때가 있다. 12sb(5) = 1 + 2 + 3 + 4 + 5 = sb(4) + 5 12345678910111213141516171819202122232425262728293031323334353637383940414243function sumBy(n) &#123; let memory = 0; for (let i = 1; i &lt;= n; i++) &#123; memory += i; &#125; return memory;&#125;sumBy(5);function sumByRec(n) &#123; // Rec를 붙여주는 건 -&gt; '재귀 함수'라는 의미임. if (n === 1) &#123; return 1; &#125; else &#123; return sumByRec(n - 1) + n; // return에 오는 표현식이 다 계산이 되어서 실행이 되어야 // 그 다음에 결과값을 return하고 함수 호출을 종료된다. // return은 함수 호출을 종료시키는 것이지, 함수 실행 자체를 종료시키는 게 X. // 일시중지 되어있는 함수들이 촤라락 있고 다시 되감기되면서 연산을 수행한다. &#125;&#125;sumByRec(5);// 위의 코드를 삼항연산자로function sumByRec(n) &#123; return n === 1 ? 1 : sumByRec(n - 1) + n;&#125;// 함수 안에서 함수가 호출되면, 코드의 실행 흐름이 일시정지, 재개를 반복한다.function add(x, y) &#123; return x + y;&#125;function mult(x, y) &#123; return x * y;&#125;function calc(x, y) &#123; return add(x, y) + mult(x, y);&#125;calc(1, 2); 1234567891011121314151617181920212223242526272829303132333435363738// 피보나치 수를 루프로 구현function fibo(n) &#123; // 다음 단계의 수는 이전 두 단계 수의 합 let x = 0; let y = 1; for (let i = 0; i &lt; n; i++) &#123; // 다음 x = 원래 y // 다음 y = 원래 x + 원래 y const sum = x + y; x = y; y = sum; &#125; return x;&#125;fibo(5);// 피보나치 수를 재귀 함수로 바꿔보기// 아이디어// fibo(5) = fibo(3) + fibo(4);// fibo(4) = fibo(2) + fibo(3);// fibo(1) = 1;// fibo(0) = 0;function fiboRec(n) &#123; if (n === 0) &#123; return 0; &#125; else if (n === 1) &#123; return 1; &#125; else &#123; return fiboRec(n - 2) + fiboRec(n - 1); &#125;&#125;fiboRec(7);// 피노나치 수, 팩토리얼 등의 개념이 중요한 게 X.// 재귀 함수를 이용해서 루프를 다시 구현할 수 있다는 걸 아는 게 중요. 재귀 함수를 작성할 때는부분 문제와 종료 조건(재귀 함수가 멈추는 부분)을 생각해 봐야 한다.그 후에 코드로 구현하자. 객체 더 알아보기객체 자신의 속성(Own Property) 객체 자신이 특정 속성을 가지고 있는지를 확인하기 위해 Object.prototype.hasOwnProperty메소드를 사용한다. true or false값을 반환 데이터 속성(Data Property)의 부수속성(Property Attribute) 내장 객체 중에 어떤 속성은 delete 연산자를 통해 삭제하려고 해도 삭제가 되지 않는 것이 있다. JavaScript에서는 각 속성마다 동작 방식이 다를 수 있다. 생성자.메소드() -&gt; 정적 메소드 객체의 부수속성을 알아보려면,Object.getOwnPropertyDescriptor라는 정적 메소드를 사용해 부수속성을 나타내는 객체를 얻을 수 있다.-&gt; 이 객체를 속성 기술자(property descriptor)라고 한다. 데이터 속성(data property)에 대한 속성 기술자가 갖는 속성 value: 속성에 어떤 값이 저장되어 있으면 true, 아니면 false를 반환 writable: 변경할 수 있으면 true, 아니면 false를 반환 enumerable: 열거 가능한 속성이면 true, 아니면 false를 반환 configurable: 부수속성을 변경하거나 속성을 삭제할 수 있으면 true, 아니면 false를 반환 속성의 성질을 가지고 있는 객체를 가져오는 방법 속성 하나에 대한 속성 기술자 가져올 때 Object.getOwnPropertyDescriptor 속성 전체에 대한 속성(여러 속성) 기술자 가져올 때 Object.getOwnPropertyDescriptors 엄격 모드에서는 writable: false, configurable: false인 속성을 변경하거나 삭제하려고 하면 에러가 난다. 속성 기술자를 통해 객체의 속성 정의하기12345678const obj = &#123;&#125;;Object.defineProperty(obj, \"prop\", &#123; // Object.defineProperty(객체 이름, '속성명', &#123;속성 정의하는 내용&#125;); value: 1, writable: false, enumerable: true, configurable: false&#125;); 접근자 속성(Accessor Property)과 그 부수속성 단위를 하나로 통일해서 저장해둔다. 넣고 꺼낼 때 환율 적용한다. 일일히 메소드를 사용하지 않고 getter와 setter 기능을 사용해서, 코드를 조금 더 깔끔하게 작성할 수 있다. 메소드 이름 앞에 get을 써주면, 이 메소드는 getter 메소드가 된다. 메소드 이름 앞에 set을 써주면, 이 메소드는 setter 메소드가 된다. 함수를 실행한 적도 없는데, 속성을 읽어오기만 해도 getter가 실행된다. 1234567891011121314151617181920212223242526272829303132const obj = &#123; // 메소드 이름 앞에 `get`을 써주면, 이 메소드는 getter 메소드가 됩니다. get prop() &#123; console.log(\"getter가 호출되었습니다.\"); return this._hidden; &#125;, // 메소드 이름 앞에 `set`을 써주면, 이 메소드는 setter 메소드가 됩니다. set prop(arg) &#123; console.log(\"setter가 호출되었습니다.\"); this._hidden = arg; &#125;&#125;;// `set prop` 메소드가 `1`을 인수로 해서 호출됩니다.// 값을 저장하려면 인수가 필요하다.obj.prop = 1;// `get prop` 메소드가 호출되고 해당 메소드의 반환값을 읽어옵니다.// 저장된 값을 불러올 때는 따로 인수가 필요없다.obj.prop; // 1Object.getOwnPropertyDescriptors(obj);// &#123;// prop: &#123;// get: [Function: get],// set: [Function: set],// enumerable: true,// configurable: true// &#125;,// ...// &#125; obj 객체 리터럴 안에서 함수 앞에 get과 set 키워드를 사용했다. 이 두 함수는 각각 prop이라는 속성의 getter와 setter가 된다. getter는 속성을 읽어올 때, setter는 속성을 변경할 때 호출됩니다. getter와 setter가 정의된 속성을 접근자 속성(accessor property)라고 한다. 1234567891011121314151617181920212223242526272829303132333435// 위 Money 생성자 예제를 접근자 속성을 통해 재작성function Money(won) &#123; this._won = won;&#125;// `Object.defineProperties` 정적 메소드를 사용해서// 속성 기술자를 통해 특정 객체의 여러 속성을 한꺼번에 정의할 수 있습니다.Object.defineProperties(Money.prototype, &#123; // `Money.prototype` 객체에 `won` 이라는 속성을 정의합니다. won: &#123; get: function() &#123; return this._won; &#125;, set: function(arg) &#123; this._won = arg; &#125; &#125;, // `Money.prototype` 객체에 `dollar` 라는 속성을 정의합니다. dollar: &#123; get: function() &#123; return this._won / 1086; &#125;, set: function(arg) &#123; this._won = arg * 1086; &#125; &#125;&#125;);const w = new Money(1086);w.won += 1086;console.log(w.dollar); // 2w.dollar += 1;console.log(w.won); // 3258 객체의 속성 열거하기1234567891011const obj = &#123; a: 1, b: 2&#125;;Object.keys(obj); // ['a', 'b']// Object.keys(객체명): 속성 이름만 다 뽑아내서 배열로 반환해준다.// Object.values(객체명): 속성 값만 다 뽑아내서 배열로 반환해준다.// Object.entries(객체명): [속성 이름, 값] 다 뽑아내서 배열로 반환해준다.// [[속성 이름, 값], [속성 이름, 값], [속성 이름, 값]] 공부방법: 각 기능을 기억할 것! Object.keys - 객체 자신의 속성 중 열거 가능한(enumerable) 속성의 이름을 배열로 반환합니다. 상속받은 속성은 반환하지 X. 객체 자신의 속성만 반환한다. Object.values - 객체 자신의 속성 중 열거 가능한(enumerable) 속성의 속성 값을 배열로 반환합니다. Object.entries - 객체 자신의 속성 중 열거 가능한(enumerable) 속성의 이름과 값을 배열로 반환합니다. Object.getOwnPropertyNames - 객체 자신의 모든 속성의 이름을 배열로 반환합니다. 열거 불가능한 속성도 포함합니다. for...in 구문 - 객체 자신의 속성 및 상속받은 속성 중 열거 가능한(enumerable) 속성의 이름을 배열로 반환합니다. for...in 구문은 꼭 필요할 때만 사용하자. 123456789101112131415161718192021222324252627282930313233const parent = &#123; d: 4, e: 5&#125;;const obj = &#123; a: 1, c: 3&#125;;Object.defineProperty(obj, \"b\", &#123; value: 2, enumerable: false&#125;);Object.setPrototypeOf(obj, parent);console.log(obj.b);// obj.hasOwnProperty('b')// '객체 자신의 속성' 중 '열거 가능한 속성'만 반환Object.keys(obj); // ['a', 'b']for (let name in obj) &#123; console.log(name);&#125;// a// c// d// e// 브라우저에 따라 순서가 다르게 나올 수 있음.// 대부분의 브라우저들은 먼저 넣은 걸 먼저 꺼내서 출력해주는 경향이 있다.// 어떤 공식 명세서에도 마치 넣은 순서대로 출력되는 것처럼 보이지만,// 사실은 random으로 나온다고 생각하고 프로그래밍 해야 함. 얕은 복사(Shallow Copy) &amp; 깊은 복사(Deep Copy)1234const obj = &#123;&#125;;Object.assign(obj, &#123; a: 1 &#125;, &#123; b: 2 &#125;);// Object.assign(대상객체, 넣을 속성, 넣을 속성)console.log(obj); // &#123; a: 1, b: 2 &#125; Object.assign 정적 메소드는 인수로 받은 객체들의 모든 열거 가능한 속성을 대상 객체에 복사한다.- 배열을 복사할 때는 slice메소드를 사용하고, 객체를 복사할 때는 Object.assign을 사용한다. 첫번째 인수에 빈 객체{}를 넣어준다. 사본을 바꿔도 원본에는 영향이 없다. 객체의 원본을 바꾸고 싶지 않을 경우에는객체를 복사한 후에, 그 사본으로 작업을 하면 된다. 12345678const obj = &#123; a: 1, b: 2&#125;;// 빈 객체를 대상으로 `Object.assign`을 사용하면, 객체를 간단히 복제할 수 있습니다.const obj2 = Object.assign(&#123;&#125;, obj);console.log(obj2); // &#123; a: 1, b: 2 &#125; 1234567const obj = &#123; innerObj: &#123; // innderObj에는 객체 자체가 아니라 객체에 대한 참조가 저장된다. a: 1, b: 2 &#125;&#125;; Object.assign, slice메소드는 객체가 중첩되어 있다면,내부에 있는 객체는 복사되지 않는다. 가장 겉에 있는 한겹만 복사된다. 배열 안의 배열, 객체 안의 배열, 배열 안의 객체 등등 중첩되어 있는 자료구조까지 복사하지는 못한다. 간편해서 많이 사용하는데, 겉껍질만 복사하기 때문에 조심해서 써야한다. 깊은 복사(deep copy)를 하고 싶다면JavaScript에 깊은 복사를 위한 기능이 내장되어 있지 않기 때문에,Immutable.js와 같은 관련 라이브러리를 사용하자. Object.preventExtensions Object.preventExtensions: 특정 객체에 더 이상 속성을 추가하지 못하도록 막아버리는 기능 12345678910111213const obj = &#123; a: 1;&#125;;// Object.seal(obj); 객체에 속성이 삭제되는 것을 막는다.Object.freeze(obj);// Object.freeze(obj); 속성 변경까지 막는다.function func() &#123; 'use strict'; delete obj.a;&#125;func(); // TypeError: Cannot add property a, object is not extensible","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"미로 찾기(Decision Thinking)","slug":"recursion-maze","date":"2019-01-20T08:17:57.000Z","updated":"2019-01-21T03:48:47.307Z","comments":true,"path":"2019/01/20/recursion-maze/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/20/recursion-maze/","excerpt":"","text":"이번에는 Recursion의 응용 - 미로 찾기에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 미로 찾기 Recursive Thinking현재 위치에서 출구까지 가는 경로가 있으려면 현재 위치가 출구이거나 혹은 이웃한 셀들 중 하나에서 현재 위치를 지나지 않고 출구까지 가는 경로가 있거나 미로 찾기(Decision Problem) 답이 yes or no인 문제 어떤 위치를 나타내는 x, y값이 주어졌을 때 (x, y)로부터 출구로까지 가는 경로가 있는지 없는지를 판단 경로가 있으면 true를, 없으면 flase를 반환한다. 123456789101112131415161718192021222324252627282930313233boolean findPath(x, y) &#123; // Base Case: 현재 위치 자체가 출구인지를 검사 if (x, y) is the exit // 현재 위치 = 출구라면, true를 return하고 종료 return true; // 현재 위치가 출구가 X라면, else // 현재 위치와 인접한 셀들(이 경우에는 4개) 중에(현재 위치를 지나지 않고!!) // 출구까지 가는 경우가 만약에 있다면 // 현재 위치로부터 해당 셀로 가서 경로를 따라가면 // 출구까지 가는 경로가 있는 것이다. // (x', y')가 (x, y)의 인접한 셀들 4개 //for each니까 각각에 대해서! for (each neighbouring cell (x', y') of (x, y) do)&#123; // (x', y')가 통로에 속한 셀이라면(지나다닐 수 있는 셀이라면) // (x', y')가 통로에 속한 셀이 X(벽에 위치한 셀)라면, // 무시하고 넘어가면 된다. if (x', y') is on the pathway // 한 칸 이동한 위치에서 recursion으로 다시 검사 if findPath(x', y') return true; &#125; // for문을 빠져나와서 여기까지 왔다는 것은 // 위에 있는 코드의 if findPaht(x', y')&#123;return true;&#125;에서 // return true하지 않았다는 뜻이다. // -&gt; 따라서, 출발하는 현재 위치가 출구가 X고, // 인접한 셀들도 통로가 아니라면(벽이라면) // 미로를 빠져나갈 수 있는 경로가 X므로 // false를 return한다. return false;&#125; Recursion 코드를 작성할 때는 항상 이것이 무한루프에 빠지지는 않는가? 생각해야 한다.따라서 Base Case(무한 루프에서 빠져나올 수 있는 조건)이 반드시 필요Recursion을 반복하다보면, 반드시 Base Case로 수렴한다는 게 보장되어야 한다! 미로 찾기 1자신이 미로에 갇혔다고 생각해보자. 가장 중요한 일 중에 하나가 무엇인가? 내가 가 본 위치와 아직 가보지 않은 위치를 구분하는 것이다.이를 구분하지 않으면, 무한루프를 돌 수 있겠죠? 미로 찾기 문제를 푸는 것도 마찬가지이다. 이미 방문해 본 위치와 방문하지 않은 위치를 적절하게 표시해서 구분할 필요가 있다. 1234567891011121314151617181920212223boolean findPath(x, y) &#123; // 현재 위치가 출구라면 if (x, y) is the exit // true를 return하고 함수를 종료한다. reutrn true; else // (x, y)가 방문한 위치라면, 방문한 위치라고 표시를 해둔다. // recursion이 1번 반복될 때마다 // 새로운 셀이 visited로 표시가 되고, 셀의 개수는 유한하기 때문에 // -&gt; 어떤 경우에도 무한 루프에 빠지지 않게 된다. mark (x, y) as a visited cell; // (x, y_)와 인접한 4개의 위치 각각(x', y')에 대해서 for (each neigthbouring cell (x', y') of (x, y) do) &#123; // 1. (x', y')의 셀이 pathway가 아니거나(벽의 일부거나) // 2. 이미 방문한 셀이라면, 그 셀을 검사해볼 필요가 X // -&gt; (x', y')가 통로이면서 방문한 적이 없는 셀일 경우만 검사하면 된다! // (그 셀에서 출구로 가는 경로가 있는지를 검사하면 됨) if (x', y') is on the pathway and not visited if findPath(x', y') return true; &#125; return false;&#125; point 11mark (x, y) as a visited cell; recursion이 1번 반복될 때마다새로운 셀이 visited로 표시가 되고, 셀의 개수는 유한하기 때문에-&gt; 무한 루프에 빠지지 않게 된다. point 2123if (x', y') is on the pathway and not visited if findPath(x', y') return true; recursion에 들어가기 전에 먼저,그 지점(x’, y’)이 벽이 아닌지 혹은 이미 방문한 지점이 아닌지를 체크 한다. 둘 다에 해당되지 않으면, recursion에 들어가게 설계한다. 미로 찾기 2 무조건 (x, y)에 인접한 각각의 셀(x&#39;, y&#39;)이 벽인지, 이미 방문한 셀인지체크하지 X고, 그냥 findPath(x’, y’)로 recursion을 호출한다. 대신, 이 함수의 맨 앞에 조건을 준다. 만약에 호출된 (x, y)가 1. 벽이나 2. 방문한 위치라면 즉시 false를 return한다. 이 경우에는 미로 찾기 1번 방식보다 recursion이 호출되는 횟수는 많아진다.대신 코드는 간결해진다는 장점이 있다. cf) 미로 찾기 1번, 2번 코드는 어느 코드가 더 낫다고 결론지을 수 없고, 보통 취향에 따라 선택해서 작성한다. 1234567891011121314151617181920212223242526272829303132boolean findPath(x, y) &#123; // First Base Case: (x, y)가 벽이거나 이미 방문한 셀이라면, if (x, y) is either on the wall or visited cell // 즉시 false를 return하고 함수를 종료한다. return false; // 그렇지 않으면서 (x, y)가 출구라면 else if (x, y) is the exit // (x, y)부터 출구까지가는 경로가 존재하는 것이므로 // true를 return하고 함수를 종료한다. return true; // 그렇지 않다면((x, y)가 출구가 아니라면) else // 이 셀(x, y)를 visited라고 표시를 해서 // 이 위치를 중복 방문하는 일을 방지한 다음에 mark (x, y) as a visited cell; // 그 위치(x, y)에 인접한 각각의 셀(x', y')에 대해서 for (each neighbouring cell (x', y') of (x, y) do) &#123; // (x', y')가 벽인지, 방문했는지 여부를 검사하지 않고 // 그냥 recursion을 호출한다. // 왜냐하면, recursion을 호출하면 함수가 실행되고 // 즉시(맨 처음 코드) if절에 걸려서 false가 return될 것이기 때문에 // 여기에서 굳이 검사해 주지 않는다! if findPath(x', y') // 인접한 셀이 최대 4개이므로 4번 호출하고, // 그 중 하나라도 true라면 true를 반환하고 함수를 종료한다. return true; &#125; // 아래 코드까지 왔다는 것은 전부 false라는 뜻이다. // -&gt; 따라서, false를 return 한다. return false; &#125;&#125; class MazeMaze의 출구를 찾는 함수를 Java로 구현해보자. 123456789101112131415161718public class Maze &#123; private static int N = 8; private static int[][] maze = &#123; &#123;0, 0, 0, 0, 0, 0, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 0, 0, 0, 1&#125;, &#123;0, 1, 0, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 0, 0, 0, 1, 0, 1&#125;, &#123;0, 0, 0, 1, 0, 0, 0, 1&#125;, &#123;0, 1, 1, 1, 0, 1, 0, 0&#125;, &#125;; private static final int PATHWAY_COLOUR = 0; // white private static final int WALL_COLOUR = 1; // blue private static final int BLOCKED_COLOUR = 2; // red private static final int PATH_COLOUR = 3; // green PATHWAY_COLOUR: 아직 가본 적 없는 cell (지나다닐 수 있는 통로) WALL_COLOUR: 벽이어서 사람들이 지나다닐 수 없는 cell 방문했던 셀을 표시하기 위해 2가지 색깔이 필요함 출구까지의 경로가 막힌 셀 출구까지 가는 경로가 될 가능성이 있는 셀 BLOCKED_COLOR: visited이며, 출구까지의 경로상에 있지 않음이 밝혀진 cell(가본 셀인데 꽝인 경로) PATH_COLOR: visited이며, 아직 출구로 가는 경로가 될 가능성이 있는 cell 12345678910111213141516171819202122232425262728293031 // recursion으로 미로의 출구를 찾는 함수인 findMazePath public static boolean findMazePath(int x, int y) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= N || y &gt;= N) return false; else if (maze[x][y] != PATHWAY_COLOUR) return false; else if (x == N-1 &amp;&amp; y == N-1) &#123; maze[x][y] = PATH_COLOUR; return true; &#125; else &#123; maze[x][y] = PATH_COLOUR; if (findMazePath(x-1, y) || findMazePath(x, y + 1) || findMazePath(x+1, y) || findMazePath(x, y - 1)) &#123; return true; &#125; maze[x][y] = BLOCKED_COLOR; // dead end return false; &#125; &#125; public static void main(String [] args) &#123; printMaze(); // (0, 0)로부터 출발해서 미로를 탈출할 수 있는 경로가 있는지 알고 싶다. // -&gt; 매개변수를 (0, 0)로 준다. // -&gt; (0, 0)인 입구로부터 미로의 출구가 있는지를 검사하게 된다. findMazePath(0, 0); printMaze(); &#125;// 아래 중괄호는 public class Maze를 닫아주는 중괄호임&#125; point 1123456else &#123; maze[x][y] = PATH_COLOUR; if (findMazePath(x-1, y) || findMazePath(x, y + 1) || findMazePath(x+1, y) || findMazePath(x, y - 1)) &#123; return true; &#125; recursion으로 호출할 때findMazePath의 매개변수인 (x, y)가음수인지, 양수인지 또는 0인지를 검사하지 않고 무작정 호출하기 한다. 이렇게 recursion이 호출되면, 가장 먼저[x][y]가 유효한 범위에 있는가를 검사해야 한다. point 2123456// x &lt; 0 || y &lt; 0 || x &gt;= N || y &gt;= N라는 것은// 미로의 범위 바깥에 있다는 것을 의미한다.// -&gt; 현재 위치(x, y)가 미로의 범위 바깥에 위치한다면, if (x &lt; 0 || y &lt; 0 || x &gt;= N || y &gt;= N) // 즉시 false를 return 한다. return false; N X N 그리드이므로 유효한 좌표는 0 ~ N -1이다. point 312else if (maze[x][y] != PATHWAY_COLOUR) return false; [x][y]가 벽의 일부이거나 이미 방문한 셀이라면 false를 retrun 한다.이걸 뒤집어 말하면[x][y]의 color가 PATHWAY_COLOUR가 아니라면,즉, visited(green, red)나 wall(blue)라면 false를 return하면 된다. point 41234else if (x == N-1 &amp;&amp; y == N-1) &#123; maze[x][y] = PATH_COLOUR; return true;&#125; x == N-1 &amp;&amp; y == N-1라는 것은 이 [x][y]가 출구라는 뜻이다.따라서, 이 경우에는 true를 return 한다.그리고 이 위치를 PATH_COLOUR인 초록색으로 칠한다. point 5123456else &#123; maze[x][y] = PATH_COLOUR; if (findMazePath(x-1, y) || findMazePath(x, y + 1) || findMazePath(x+1, y) || findMazePath(x, y - 1)) &#123; return true; &#125; 북 -&gt; 동 -&gt; 남 -&gt; 서 순으로 검사한다. 이 4가지 방향을 시도해 봐서 그 중 하나라도 출구로 가는 경로가 있다면,true를 return하고 함수를 종료한다. point 612maze[x][y] = BLOCKED_COLOR; // dead endreturn false; 코드의 실행흐름이 여기까지 도달했다는 것은이 위치에서 어느 방향으로 가더라도이미 가본 셀을 거치지 않고서는 출구까지 가는 경로가 없다.-&gt; 즉, 이 maze[x][y]는 꽝이다! 이 자리를 BLOCKED_COLOR인 빨간색으로 칠한다. 그 후 false를 return하고 함수를 종료한다. 움직인 경로 아래 그림은 방금 위에서 살펴본 알고리즘을 호출했을 때실제로 미로상에서 어떻게 움직이는지를 그림으로 그린 것이다. 물론, 실제로 움직이는 경로는 각각의 위치에서 어느 쪽(동, 서, 남, 북)을먼저 시도해보느냐에 따라 달라질 수 있다. 이 그림의 예는 항상 어떤 위치에서 북 -&gt; 동 -&gt; 남 -&gt; 서 순으로검사한다는 가정하에 그린 것이다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"순환 함수","slug":"순환-함수","permalink":"https://JihyeHwang09.github.io/tags/순환-함수/"},{"name":"recursion","slug":"recursion","permalink":"https://JihyeHwang09.github.io/tags/recursion/"},{"name":"미로 찾기","slug":"미로-찾기","permalink":"https://JihyeHwang09.github.io/tags/미로-찾기/"},{"name":"Decision Thinking","slug":"decision-thinking","permalink":"https://JihyeHwang09.github.io/tags/decision-thinking/"}]},{"title":"자바스크립트 6일차","slug":"javascript6","date":"2019-01-19T03:50:27.000Z","updated":"2019-01-19T03:56:25.913Z","comments":true,"path":"2019/01/19/javascript6/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/19/javascript6/","excerpt":"","text":"6일차let, const 변수와 블록 스코프 let과 const는 같은 이름을 갖는 변수의 재선언을 허용하지 X. 유효범위: 블록 스코프 함수의 매개변수나, var 변수는 함수 스코프를 갖는다. 유효범위: 함수 var변수를 둘러싸고 있는 함수가 없을 경우, 유효범위는 전체가 된다. 12345678910111213&#123; let i = 0; console.log(i);&#125;let i = 0;console.log(i, \"a\");let i = 0;console.log(i, \"b\");let i = 0;console.log(i, \"c\"); 비슷한 작업을 여러 번 하는데, 같은 이름의 변수가 사용될 때 ,{}로 묶어주면 같은 이름의 let 변수를 여러 번 선언해도 오류가 나지 않도록 해준다. (유효범위가 블록 스코프이므로) var 변수와 함수 스코프 var 변수는 변수의 선언부를 맨 위로 끌어올린다. 대입부는 그 자리에 그대로. -&gt; 이 과정을 호이스팅이라고 한다. 1234function print() &#123; console.log(foo); var foo = 1;&#125; 123456// 호이스팅function print() &#123; var foo; console.log(foo); // 대입하기 전에 변수의 값을 읽으면, undefined가 반환됨. foo = 1;&#125; var 변수는 함수 스코프를 갖기 때문에 함수가 아닌 블록에서 정의된 var변수가 해당 블록 바깥에서도 유효할 수 있다. var변수를 사용하면, 중첩된for`루프와 같이 블록이 중첩된 코드에서 의도치 않은 동작을 할 수 있다. 12345678910var i;for (var i = 0; i &lt; 3; i++) &#123; console.log(\"outer\"); // 위아래 두 `i` 변수는 같은 함수 스코프에서 정의된 같은 변수입니다. // 바깥쪽 루프를 한 번 도는 동안, 안쪽 루프를 도느라 이미 `i`의 값이 3이 되어버렸습니다. for (var i = 0; i &lt; 3; i++) &#123; console.log(\"inner\"); &#125;&#125;// let은 유효범위가 블록스코프이기 때문에 for이 중첩되어 있을 때 변수 이름을 똑같은 i로 써도 의도대로 잘 작동한다. 전역 변수 (Global Variable) 전역 변수라는 용어는 쓰이고, 요즘은 지역 변수라는 용어는 쓰이지 않는다. 전역 스코프는 스코프 체인의 가장 바깥쪽에 있는 스코프 전역 스코프에 선언된 변수를 전역 변수(global variable)라고 한다. 변수를 전역 스코프에서 선언하지 않고, 한 번도 선언되지 않은 이름으로 안쪽 스코프에서 let, const, var를 붙여주지 않고 변수를 선언하면, 전역 스코프에 변수가 만들어진다. - 변수를 선언할 때, let이나 const를 꼭 써주자. 전역 변수에 의존해서 프로그래밍을 하는 것은 굉장히 금기시되는 일이다. - 값을 공유해야 할 일이 생긴다면, 다른 방식으로 값을 공유하자. 전역 객체 (Global Object) var변수로 전역 변수를 만들었을 때, 전역 객체의 속성이 되어 전역 객체를 통해서 접근할 수 있게 된다. let, const변수는 전역 객체의 속성이 되지 않는다. 참조 (Reference) 객체가 컴퓨터 메모리 상에서 어디에 저장되었는지를 가리키는 값 화살표를 생각하면 됨. 사실 변수에 저장되는 건 객체 그 자체가 아니라 참조(화살표)다. 원시 타입(primitive type) 참조 타입(reference type) 함수 호출 값이 전달되는 것이지, 변수가 전달되는 것이 X. 함수를 호출하면, 변수 안에 값은 그대로 있고, 그 값이 복사되어 인수로 넘긴다. 원시 타입을 인수로 넘길 때는 원본을 변경할 수 없지만, 참조 타입으로 인수로 넘길 때는 원본을 변경할 수 있다. 12345678910const obj = &#123;&#125;;function addProp(o) &#123; o.prop = 1;&#125;// 변수 `obj`에 저장되어 있는 참조가 매개변수 `o`에 복사됩니다.addProp(obj);console.log(obj.prop); // 1 객체의 같음 (Equality) ===로 비교를 하면, 같은 객체를 가리키고 있으면 true, 다른 객체를 가리키고 있지 않으면 -&gt; false를 반환 내가 지금 객체의 내용이 다른지, 아닌지를 판별하고 싶은지 or 두 참조가 정말로 같은 객체를 가리키고 있는지를 알고 싶은지를 구분해야 한다. 12var equal = require(\"fast-deep-equal\");console.log(equal(&#123; foo: \"bar\" &#125;, &#123; foo: \"bar\" &#125;)); // true 객체를 내용을 통해서 비교하고 싶을 때 깊은 비교기능을 지원하는 라이브러리를 이용 node.js에 require라는 함수가 들어있다. 정확히 어떤 내용을 비교하고 싶은지를 가지고 함수 혹은 메소드를 작성 -&gt; 그것을 이용 불변성 (Immutability) 원시 타입의 특징 Object타입(ex) 객체, 배열, 함수)가 아닌 원시타입(ex) boolean, null, number, string 등)은 원본의 값 자체를 변경할 수 있는 방법은 없다. ex) 문자열을 변형하는 메소드는 모두 기존 문자열의 내용을 바꾸는 게 아니라 새 문자열을 반환한다. -&gt; 원시타입의 값을 바꾸려면, 오직 변수에 다른 값을 재대입하는 방법 밖에 없다. 객체는 가변(mutable)이다. 객체는 가변이지만 일부러 불변으로 만들어주고 사용할 때도 있다. 어떤 값이 가변이면 그 값이 변경되지 않았을까? 걱정하면서 프로그래밍 할 수 있는데, 이럴 경우를 대비하기 위해 객체를 불변으로 만들기도 한다. ex1) Object.freeze를 사용해서 객체를 얼려서 속성의 추가/변경/삭제를 막는다. But 사용하기 조금 불편하다. Object.freeze를 호출한다고 해서 객체 안에 있는 객체까지 얼리는 것은 아니기 떄문이다. 중첩된 객체는 Object.freeze를 사용하기가 조금 까다롭다. 123456789101112const obj = &#123; prop: 1&#125;;Object.freeze(obj);// 모두 무시됩니다.obj.prop = 2;obj.newProp = 3;delete obj.prop;console.log(obj); // &#123; prop: 1 &#125; ex2) Immutable.js같은 라이브러리를 사용 Object.freeze처럼 객체를 정말로 얼려버리지는 않음. 이 객체들은 메소드를 통해 내용이 조금이라도 달라지면 아예 새로운 객체를 반환 내용이 달라지면 참조 역시 달라지게 된다. 12345678import &#123; List &#125; from \"immutable\";// Immutable.js에서 제공하는 `List`는 배열과 유사하지만, 불변인 것처럼 다룰 수 있는 자료구조입니다.const list = List.of(1, 2, 3);const newList = list.push(4); // 새 List 인스턴스를 반환합니다.// 내용이 달라지면, 참조도 달라집니다.list === newList; // false const와 불변성을 잘 구분해야 한다. const는 재대입을 막는 것이지, 원본이 변경되지 않는다는 걸 보장해주는 게 X. 불변성은 값 자체가 변하지 않는 것을 의미한다. 래퍼 객체 (Wrapper Object) 원시 타입의 값에 대해 속성을 읽으려고 시도하면, 그 값을 그 순간에만 객체로 변환되어 마치 객체인 것처럼 작동한다. 12345678910const s = \"hello\";s.toUpperCase(); // 'HELLO's.length; // 5const n = 1.2345;n.toFixed(2); // '1.23'// 소수점 아래 2자리 소수로 바꿔줘라.const b = true;b.toString(); // 'true' 함수 더 알아보기객체로서의 함수 함수는 Function 생성자로부터 생성되는 객체 다른 객체들과는 다르게 호출할 수 있다는 특징이 있다. length - 함수의 매개변수의 개수를 반환합니다. name - 함수의 이름을 반환합니다. 주인 없는 this 생성자나 메소드가 아닌 함수에서 this 키워드를 사용하면 에러는 나지 않지만, this가 전역 객체를 가리키게 된다. 123456789function Person(name) &#123; this.name = name;&#125;// `new`를 빠트린 채 생성자를 호출하면, `this`는 전역 객체를 가리키게 됩니다!Person(\"john\");// 의도치 않게 전역 객체의 속성이 변경되었습니다.console.log(window.name); // john 엄격 모드(Strict Mode)12345678910function Person(name) &#123; // 엄격 모드를 활성화합니다. \"use strict\"; // `undefined`의 속성을 변경하려고 하고 있기 때문에, 에러가 납니다. this.name = name;&#125;Person(\"john\"); // TypeError: Cannot set property 'name' of undefined// this는 undefined의 name이라는 속성을 지정해줄 수 없다. 항상 엄격 모드를 켜고 프로그래밍을 하는 게 좋다. 실무에서는 항상 ‘use strict’를 써줄 필요는 없다. -&gt; 나중에 모듈을 쓴다면 자동으로 엄격 모드가 켜지기 떄문에 만약, react에서 작동하지 않는데, repl.it에서는 작동할 경우 -&gt; repl.it에서는 엄격 모드가 꺼진 채로 작동하기 때문에 ‘엄격모드’ 떄문일 수 있다. this 바꿔치기 window.name에는 빈문자열(‘’)이 저장되어 있다. call과 apply는 인수를 넘겨주는 형식에 차이가 있다. 12345678910function printGrade(grade) &#123; console.log(`$&#123;this.name&#125; 님의 점수는 $&#123;grade&#125;점입니다.`);&#125;const student = &#123; name: \"Mary\" &#125;;printGrade.call(student, 100); // Mary 님의 점수는 100점입니다.// printGrad를 실행하되, this는 student로 하고, 첫 번째 인수를 100으로 한 채 실행하라.printGrade.apply(student, [100]); // Mary 님의 점수는 100점입니다.// this는 student로 하고, 배열의 첫 번째 요소가 첫 번쨰 인수가 되서 실행된다. arguments와 나머지 매개변수 (Rest Parameters) 인수의 개수에 제한이 없는 함수 function 구문을 통해 생성된 함수가 호출될 때, arguments라는 변수가 함수 내부에 자동으로 생성된다. 1234567function add() &#123; // `arguments[0]`에는 `x`와 같은 값이, `arguments[1]`에는 `y`와 같은 값이 저장됩니다. console.log(arguments[0], arguments[1]); return arguments[0] + arguments[1];&#125;add(1, 2); // 1 2 arguments는 ES2015 이전까지 인수의 개수에 제한이 없는 함수를 정의하는 데에 사용되곤 했다. ES2015에서 도입된 나머지 매개변수(rest parameters) 문법을 통해서 똑같은 기능을 더 깔끔한 문법으로 구현할 수 있기 떄문에 arguments는 더 이상 사용되지 않는 기능이다. ... 문법은 마지막 매개변수에만 사용할 수 있다. 자바스크립트는 매개변수의 개수와 인수의 개수가 일치하지 않아도 에러가 나지 않는다는 특징이 있다. 123456789101112131415161718function func() &#123; console.log(\"haha\");&#125;func(1, 2, 3, 4);const arr = [1, 2, 3, 4];arr.reduce((acc, item, index, arr) =&gt; acc + item);arr.map((item, index, arr) =&gt; item * 2);function map(func) &#123; func(item, index, arr);&#125;// map은 함수를 인수로 받는다.// map 입장에서 실행할 때 item, index, arr를 넘겨받지만,// 우리가 필요한 것만 골라서 사용할 수 있다.// 필요없는 매개변수는 생략해서 써도 에러가 나지 않는다. 화살표 함수(Arrow Function) ES2015에서 도입된 새로운 유형의 함수 화살표 함수는 생성자로 사용될 수 없다. 따라서, 화살표 함수는 prototype 속성을 가지고 있지 X. function 키워드로 만든 함수는 모두 생성자로 사용될 수 있다. 12345function func() &#123; console.log(\"haha\");&#125;const obj = new func(); 123456const func = () =&gt; &#123; console.log(\"haha\");&#125;;const obj = new func();// TypeError: func is not a constructor 화살표 함수는 스스로의 this를 가지지 않는다. 화살표 함수는 자기 this가 없으므로, 바로 바깥에 있는 this를 가져다 쓴다. 화살표 함수 내부에서 this를 사용하면, 함수가 정의된 스코프에 있는 this를 가리킨다. 화살표 함수 내부의 this는 화살표 함수가 정의된 문맥에 의해 결정되고, 그 후에는 절대 바꿀 수 없다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function Person(name) &#123; this.name = name; this.getName = () =&gt; &#123; // 여기에서 사용된 `this`는 '함수가 정의된 스코프', // 즉 'Person 함수 스코프'에 존재하는 `this`를 가리키게 됩니다. return this.name; &#125;;&#125;const mary = new Person1(\"mary\");console.log(\"mary.getName():\", mary.getName());// `this`를 바꿔보려고 해도, 아무런 효과가 없습니다.console.log( \"mary.getName.call(&#123;name: 'john'&#125;):\", mary.getName.call(&#123; name: \"john\" &#125;));// function 키워드를 통해 정의된 함수는 '어떻게 호출되느냐에 따라' this의 값이 결정됩니다.function getName() &#123; return this.name;&#125;const john = &#123; name: \"john\", getName&#125;;const bob = &#123; name: \"bob\", getName&#125;;// .getName() 앞에 있는 john이 함수 내부의 this로 사용됩니다.console.log(\"john.getName():\", john.getName());// .getName() 앞에 있는 bob이 함수 내부의 this로 사용됩니다.console.log(\"bob.getName():\", bob.getName());function Person2(name) &#123; this.name = name; this.getName = () =&gt; &#123; return this.name; &#125;; this.getName2 = function() &#123; return this.name; &#125;;&#125;const kate = new Person2(\"kate\");// 함수를 인수로 받는 함수function printResult(func) &#123; // 아래 func는 '메소드로서 호출'되고 있지 않습니다. // 따라서 function 키워드를 통해 생성된 함수일 경우 문제가 생길 수 있습니다. console.log(func());&#125;// 화살표 함수로 정의된 메소드를 다른 함수의 인수로 넘겨도 아무런 문제가 없습니다!console.log(\"printResult(kate.getName)\");printResult(kate.getName);// function 키워드 함수의 경우 this에 문제가 생깁니다. '메소드로서 호출'되고 있지 않기 때문입니다.console.log(\"printResult(kate.getName2)\");printResult(kate.getName2);// 위와 같은 경우 bind 메소드를 사용하면 됩니다만, 좋아보이지는 않습니다.console.log(\"printResult(kate.getName2.bind(kate))\");printResult(kate.getName2.bind(kate));// 화살표 함수가 if문이나 for문 같은 스코프 안에서 정의되지 않음. -&gt; 전역 스코프에 정의됨. -&gt; `this`가 전역 객체를 가리키게 된다.// 위의 화살표 함수는 전역 스코프에서 정의되었기 때문에, `this`는 전역 객체를 가리킵니다.// `mary`의 메소드로 사용된다고 해도, 이 사실이 변하지 않습니다. 브라우저 환경의 전역 객체인 window는 name이라는 속성에 빈 문자열을 갖고 있기 때문에, 이 값이 대신 반환됩니다. 객체의 속성 값에 메소드를 직접 정의할 때는 화살표 함수를 사용해서는 안 된다. 화살표 함수는 어떻게 호출되지는 상관 X. 어떻게 정의되었는지에 따라서 동작한다. 1234// 매개변수로 function keyword 함수를 넘겨주면, this의 주인이 없는채로 실행된다.// 이유는 function keyword함수는 메소드를 실행하려면 `객체.`메소드();해야 하기 때문에// 화살표 함수로 정의된 메소드는 다른 함수의 인수로 넘겨도 아무런 문제가 없습니다! 매개변수의 기본값(Default Parameter) 함수 호출 시에 인수에 값을 넘겨주지 않으면, 매개변수가 undefined가 대입된다. name은 var변수처럼 재대입이 가능하다. 매개변수의 기본값 지정하기 12345678910// 'Mary'가 `name` 매개변수의 기본값이 됩니다.// 만약에 name에 값이 들어오면 그 값이 사용되지만, name에 값이 들어오지 않으면, 'Mary'가 값으로 사용된다.function hello(name = \"Mary\") &#123; // 코드가 훨신 더 깔끔해졌습니다! console.log(`Hello, $&#123;name&#125;!`);&#125;hello(\"John\"); // Hello, John!hello(); // Hello, Mary!hello(undefined); // Hello, Mary!","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 5일차","slug":"javascript5","date":"2019-01-18T06:16:20.000Z","updated":"2019-01-18T06:23:28.750Z","comments":true,"path":"2019/01/18/javascript5/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/18/javascript5/","excerpt":"","text":"프로토타입(Prototype) 함수가 실행될 때마다 객체가 새로 만들어지고 함수도 매번 새로 만들어진다. 객체 안에 메소드를 만들어서 이렇게 매번 만들어지는건 메모리 낭비다. 비슷한 객체들의 속성을 하나로 모아두기 위해서 쓰는 게 프로토타입(Prototype)이다. 프로토타입 상속(prototype inheritance):프로토타입 기능을 이용해 한 객체에서 다른 객체의 기능을 가져와 사용하는 것을 말한다. 프로토타입 상속은 기능을 물려받는 것이다. 부모, 자식으로 표현하기도 한다. ex) personPrototype의 자식에는 person1, person2가 있다. 상속을 받은 객체라고 하더라도 실제로 상속받은 게 이 객체 안에 들어있는 게 X. 12345678910const parent = &#123; a: 1&#125;;const child = &#123; b: 2&#125;;Object.setPrototypeOf(child, parent);// childe가 parent를 상속받는다고 하더라도,// child 안에는 실제로 a라는 속성이 없다.console.log(child); // &#123; 'b': 2 &#125; child 객체에 확인해 봤는데 없으면 계속 부모를 따라 올라가서 확인해본다. object까지 올라갔는데도 없으면 undefined를 반환한다.(없는 속성을 반환하라고 하면 undefined를 반환하므로) 프로토타입의 체인(연쇄)(Prototype Chain) 프로토타입의 체인을 올라가다가 처음 만나는 속성을 사용한다. 더 위의 부모까지 올라가지 않는다. 객체를 쓸 때마다 프로토타입 체인은 항상 동작한다. cf) 배열에는 push라는 메소드가 없다. 배열의 부모에 push라는 메소드가 있다. 프토타입 체인이 동작해서 push라는 메소드가 작동하는 것이다. 자식.isPrototypeOf(부모) 메소드 어떤 객체가 다른 객체의 프로토타입 체인에 존재하는지 확인하기 위해 사용한다. 12obj1.isPrototypeOf(obj3); // trueobj2.isPrototypeOf(obj3); // true 속성 가리기 (Property Shadowing) 프로토타입 체인의 상위에 있는 속성이 하위 속성에 의해 가려지는 현상 프로토타입을 간접적으로 변경하는 것은 불가능 속성을 읽어올 때만 프로토타입 체인을 사용할 수 있다. 속성을 쓰거나 지우는 등의 작업을 할 때는 프로토타입 체인을 사용할 수 없다. 즉, 자식 객체를 통해서 프토토타입 체인을 이용해서 부모 객체의 속성을 변경하거나 삭제할 수 X. 어떤 객체의 속성을 변경하거나 속성을 삭제하는 작업은 그 객체의 프로토타입에 아무런 영향을 미치지 않는다. 생성자 (Constructor) Person.prototype에 객체를 저장한 적이 없지만 객체가 저장이 되어 있다. 생성자로부터 인스턴스를 생성하면, 인스턴스의 부모는 생성자.prototype이 된다. 1234567891011121314151617181920212223242526// Person 생성자 예제function Person(name) &#123; this.name = name; this.age = age;&#125;Person.prototype.familyName = \"김\";// person1.familyName;의 결과값은 '김'이 된다.Person.prototype.introduce = function() &#123; console.log(`안녕하세요, $&#123;this.familyName&#125;$&#123;this.name&#125;입니다.`); // 이 this는 person1을 가리킨다.&#125;;erson.compareAge = function(person1, person2) &#123; if (person1.age &lt; person2.age) &#123; return \"첫 번째 사람의 나이가 더 많습니다.\"; &#125; else if (person1.age === person2.age) &#123; return \"두 사람의 나이가 같습니다.\"; &#125; else &#123; return \"두 번째 사람의 나이가 더 많습니다.\"; &#125;&#125;;const person1 = new Person(\"승하\");// person1의 부모는 Person.prototype이 된다.person1.introduce();const person2 = new Person(\"아준\");person2.introduce(); 요즘은 클래스를 많이 쓰는 편. 클래스를 알려면 먼저 이걸 잘 이해해야 한다. (function keyword 함수로 만들어진) 메소드 내부의 this는 호출되는 시점에 결정된다.(화살표 함수에서의 this는 동작 방식이 다르다.) cf) 화살표 함수의 this는 정의되는 시점에 결정된다. 함수가 정의되는 시점 함수가 호출되는 시점 함수가 만들어질 때(정의될 때), this가 무엇을 가리키는지 정해지는 게 X. constructor 객체.constructor를 사용하면 객체가 어떤 생성자로부터 생성되었는지를 알아낼 수 있다. 정적 메소드 생성자 속성에 직접 지정된 메소드를 정적메소드라고 한다. ex) Number.isNaN, Object.getPropertyOf등의 함수들은 모두 정적 메소드이다. reduce 메소드123const arr = [1, 2, 3];arr.reduce((acc, item) =&gt; acc + item, 0); // 6 초기 누적값: 0 마지막의 누적값이 결과값이 된다. 누적값: accumulator ex) 문자열 길이의 총합을 구하고 싶다. reduce 메소드를 가지고 map, filter, sort 등 다른 메소드를 만들수도 있다. 12345678910111213// fileter 직접 구현하기function filter(arr, func) &#123; return arr.reduce(function(acc, item) &#123; if (func(item)) &#123; acc.push(item); &#125; return acc; &#125;, []);&#125;const arr = [1, 2, 3, 4, 5];filter(arr, x =&gt; x % 2 === 0); 배열을 반환할 거니까 빈 배열을 초기 누적값으로 줌. reduce메소드에 초기누적값을 넘겨주지 않으면, 배열의 첫번째 값이 초기누적값으로 사용됨. reduce를 쓸 때는 항상 초기값을 넣어주자. 123const arr = [\"Denton\", \"Roy\", \"Jay\"];arr.reduce((acc, item) =&gt; acc + item, 0);// Denton33 배열을 순회할 때, 순회 중인 배열을 편집하면 안된다. 루프를 돌면서 배열에 뭔가를 편집하고 싶다면, 새 배열을 만들어서 편집해라.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"CSS 박스모델","slug":"css-box-model","date":"2019-01-17T13:38:24.000Z","updated":"2019-01-17T14:10:31.047Z","comments":true,"path":"2019/01/17/css-box-model/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/17/css-box-model/","excerpt":"","text":"1일차1교시123.wing &#123; 색상: 빨강;&#125; 웹사이트는 .html이라는 확장자를 가진 파일이 실행된다. https://www.naver.com에 접속하면, 실제로는 index.html파일이 실행되는 것이다. https://www.naver.com/index.html Ctrl + + / Ctrl + -로 화면을 확대, 축소를 할 수 있다. 전체 큰 틀부터 작성하라. 123456789101112&lt;!DOCTYPE html&gt;&lt;!--태그`&lt;&gt;`안에 들어있는 내용은 이미 약속된 내용--&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Orange&lt;/title&gt; &lt;!--Orange라고 작성한 내용은 내가 작성하고 싶은 내용--&gt; &lt;/head&gt; &lt;body&gt; Orange &lt;/body&gt;&lt;/html&gt;&lt;!--태그의 시작부분에 `/`가 있으면 종료 태그를 의미--&gt; 작성한 html 파일을 웹 브라우저를 통해 해석하는 개념이므로,꼭 저장을 한 후! 실행한 html파일에서 F5를 눌러서 새로고침해서 웹사이트를 확인 검색 엔진에 정보를 전달하기 위해서 내가 어떤 태그를 써야할까 고민하는 게 첫 번째 일이다. html의 목표는 시각화 하는게 목적이 X. 검색 엔진을 위한 것이기 때문에 디자인적인 요소는 들어가지 않는다. 엔터를 쳤다고 해서 목록으로 정렬되는 게 X. 태그를 사용해서, 목록이라는 의미를 부여해 줘야 한다. ul(Unordered List): 순서가 정해지지 않은 목록 이미지 삽입 html문서에 이미지가 포함되는 게 X. 이미지를 별도의 파일로 만들고, 불러오기만 가능하다. image를 줄여서 &lt;img&gt;라는 태그를 사용한다. 는 다른 태그와 목적이 다르기 때문에 닫는 태그가 없다. 태그는 태그 자체가 컨텐츠이기 때문에. 어떤 내용물을 꾸며주는 태그가 아니라, 이미지 자체가 내용물이기 때문에 닫는 태그가 없다. src(source)는 이미지 경로를 줄 때 사용 2교시1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt; /* 문서의 버전을 명시(이렇게 작성하면, 최신 버전으로 만들어줌) */&lt;html&gt;/* &lt;head&gt;안에는 문서의 정보가 들어감 */ &lt;head&gt; &lt;title&gt;Orange&lt;/title&gt; /* html과는 별개로 head안에 style태그를 넣어줌 */ &lt;style&gt; body &#123; /* background-repeat: no-repeat; background-position: center;*/ background-image: url(fruit/orange-bg.png); background-color: #c5b1fc; color: red; &#125; div &#123; background-color: white; width: 400px; /* margin은 바깥쪽 여백을 주어 전체 요소가 내려갈 수 있게 해줌.*/ /* margin-top: 50px;*/ /* auto는 내가 쓸 수 있는 공간 다 쓸게.*/ /* margin-left: auto; margin-right: auto; margin의 상단, 하단, 왼쪽, 오른쪽 다 auto로 준다. margin: auto;*/ /* 상하 좌우 margin주는 걸 실무에서 가장 많이 사용함 */ margin: 20px auto; /* 상하 좌우 */ margin: 30px auto 40px; /* 상 좌우 하 */ margin: 30px auto 40px 50px; /* (시계 방향을 생각) 상 우 하 좌 */ padding: 50px; /* border-width: 10px; border-style: solid; border-color: orange;*/ /*단축속성인 border로 여러가지의 속성들을 한꺼번에 줄 수 있다. */ /* div야, 네 안에 있는 text들이 다 가운데 정렬되게 해라. */ /* div 자체가 가운데 정렬되는 게 X */ /* text-align: center;*/ /* height값을 주지 않았을 때는 자동으로 조절되지만, 고정값을 주면 나중에 내용이 넘칠 경우에 내용이 밖으로 나가게 된다. */ /* height는 안 적는게 좋다. */ /* height: 400px;*/ /* 넘쳐 흐르는 내용 처리하는 방법*/ /* overflow: hidden;*/ /* overflow: scroll;*/ &#125; h1 &#123; border-bottom: 5px solid orange; /* background-color: antiquewhite; */ width: 110px; /* 기본적으로 배치가 왼쪽으로 붙으므로 */ /* h1도 박스다. h1은 기본적으로 div처럼 부모의 너비만큼 너비를 차지한다. /* 따라서 -&gt; margin을 주려면, width값을 먼저 줘야 적용된다. */ /* width값을 따로 주지 않으면, 꽉 차있는 상태니까 margin이 적용되지 않는다. ex) 꽉 차 있는 방을 어떻게 가운데 정렬할 수 있겠어요?! */ margin-left: auto; margin-right: auto; padding-bottom: 5px; text-align: center; &#125; &lt;/style&gt; /* 태그`&lt;&gt;`안에 들어있는 내용은 이미 약속된 내용 */ /* Orange라고 작성한 내용은 내가 작성하고 싶은 내용 */ &lt;/head&gt; /* 실제 우리 눈에 보이는 영역 */ &lt;body&gt; &lt;div&gt; &lt;img src=\"fruit/orange.png\" /&gt; /* heading1의 의미. 제목을 적을 때 작성 */ /* h1태그는 웹브라우저에 미리 저장되어 있는 CSS가 적용된 것이다. */ &lt;h1&gt;Orange&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Orange&lt;/li&gt; &lt;li&gt;Kiwi&lt;/li&gt; &lt;li&gt;Strawberry&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;/* 태그의 시작부분에 `/`가 있으면 종료 태그를 의미 */ 부모 태그자식 태그 들여쓰기 해주는 이유? 부모 - 자식 간의 관계를 직관적으로 인지하게끔 하는 것임 Brackets에 ul&gt;li라고 작성후 tab키 누르면, 부모-자식 관계로 자동 완성할 수 있음 Brackets에 실시간 미리보기라는 기능으로 Chrome에서 F5키를 누르지 않고, 바로 확인이 가능하나 오류가 많기 때문에 수동으로 새로고침하기를 권장 CSS(Cascading Style Sheets) 어떤 요소를 파악하려면, 어떻게 공간을 차지하고 있나를 파악하기 위해서 배경색(background-color)을 많이 사용한다. h1, body 등은 선택자(Selector)라고 하고, 이 선택자에 {}안에 디자인 코드를 적어주면 스타일을 적용할 수 있다. background-color, color 등은 속성(property) :는 구분자 : 구분자 다음에 나오는 내용을 값(value)라고 한다. ; CSS에서 ;를 잘 적어줘야 한다. 빠뜨리면 스타일이 적용되지 x. Ctrl+ E를 누르면, 컬러를 선택할 수 있는 표가 나온다. background-image: url() url()안에 이미지의 경로를 적어준다. background-image와 background-color는 작성 순서가 중요하지 X ex) background-repeat: no-repeat; h1과 ul을 같이 묶어야 같이 옮길 수 있다. -&gt; 새로운 태그로 감싼다.cf) 이사 다닐 때 박스에 물건을 함께 넣으면 옮기기 편하다는 걸 떠올려라. div(division): 내가 그룹핑하고 싶은 태그들을 감싸는 역할 ul처럼 목록, h1은 제목 등 의미가 있는데, div는 의미는 없다. div의 너비(width)는 부모인 body가 가지고 있는 너비만큼이다. div의 높이(height)는 자식들의 높이만큼 자동으로 조절이 된다. 주석(Comments) 작성법: /**/사이에 메모를 적으면, 브라우저가 이 사이에 있는 내용은 해석하지 않는다. 해당 요소를 가운데 정렬 CSS는 급격하게 발전하면서, 정렬에 대한 키워드가 따로 없다. margin은 바깥쪽 여백을 나타냄. 사용자들은 각기 다른 화면으로 웹 브라우저를 보기 때문에 왼쪽 기준으로 여백을 주는 것이기 때문에 고정된 px로 주지 말고, auto로 주자. auto는 내가 쓸 수 있는 공간 다 쓴다는 뜻 12margin-left: auto;margin-right: auto; 여백의 개념은 2가지이다. 안쪽 여백(padding)을 지정할 수 있다. 안쪽 공간이라고 해서 width가 유지되는 게 아니라, width에 padding이 양 옆으로 붙음. ex) width 400에 padding이 양 옆에 50px씩 붙으니까 500px이 됨. 테두리border border도 padding처럼 width, height값에 추가 된다. border-width border-style border-color CSS에는 단축속성이 있다.여러가지의 속성들을 한꺼번에 적어줄 수 있다. 1border: 10px solid orange; 오늘의 핵심 키워드는 CSS 박스 모델(Box Model) 5가지이다. &gt; width, height, margin, padding, border CSS를 잘하려면, 재료를 잘 이해하고 아이들이 물감 놀이 하듯이 많이 연습해보아야 한다. 123456789/* 내가 작성한 내용 */h1 &#123; color: orange; border-bottom: 6px solid orange; /* h1도 박스다. margin을 주려면, width값을 먼저 줘야 적용된다. */ width: 120px; margin: auto; padding: 6px;&#125; 12345678910111213141516/* 강사님이 작성하신 내용 */h1 &#123; border-bottom: 5px solid orange; /* background-color: antiquewhite; */ width: 110px; /* 기본적으로 배치가 왼쪽으로 붙으므로 */ /* h1도 박스다. h1은 기본적으로 div처럼 부모의 너비만큼 너비를 차지한다. */ /* 따라서 -&gt; margin을 주려면, width값을 먼저 줘야 적용된다. */ /* width값을 따로 주지 않으면, 꽉 차있는 상태니까 margin이 적용되지 않는다. ex) 꽉 차 있는 방을 어떻게 가운데 정렬할 수 있겠어요?! */ margin-left: auto; margin-right: auto; padding-bottom: 5px; text-align: center;&#125; h1도 박스다. margin을 주려면, width값을 먼저 줘야 적용된다.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"}]},{"title":"자바스크립트 4일차","slug":"javascript4","date":"2019-01-16T00:45:56.000Z","updated":"2019-01-16T00:57:01.228Z","comments":true,"path":"2019/01/16/javascript4/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/16/javascript4/","excerpt":"","text":"객체(Object) 자바스크립트의 자료구조에는 객체와 배열이 있다. 객체는 한꺼번에 여러 값을 담을 수 있는 통(container)과 같은 자료구조(data structure)이다. 객체 안에는 이름-값 쌍(name-value pair)이 저장되는데, 이를 객체의 속성(property)라고 한다. 객체 리터럴(Object Literal) 객체 리터럴에서 속성을 정의할 때는 &#39;&#39;를 써도 되고 안써도 된다. 식별자 규칙을 만족하는 문자열을 속성 이름으로 사용할 때는 따옴표를 생략해도 된다. 식별자 이름 규칙을 만족하지 않는 경우, &#39;&#39;로 감싸줘야 한다. 식별자의 이름에 공백은 허용되지 않으므로 ex) ‘한국 나이’ 따옴표로 둘러싸줘야 한다. ‘한국 나이’: 20 + 3 해도 된다. 표현식의 결과값이 속성값이 된다. 축약 표기법 내가 갖고 있는 변수의 이름과 똑같은 이름을 갖는 속성을 만들고 싶을 때, 1234567const name = \"윤아준\";const person = &#123; name, // `name: name`과 똑같이 동작합니다. age: 19 // ...&#125;; 왼쪽: 속성 이름- name, 오른쪽: 속성 값이 될 표현식- name 객체 리터럴에서 속성을 정의하는 세 가지 방법 아래와 같이 대괄호를 사용해서 다른 변수에 저장된 문자열을 그대로 속성의 이름으로 쓰는 것도 가능합니다. []로 둘러싸여있으면 이 표현식의 결과값이 속성의 이름이 된다. 1234567891011121314const propName = 'prop3'const obj = &#123; // 아래 두 예제는 왼쪽 부분이 문자열로 간주된다. // 그리고 그 문자열이 그대로 속성 이름으로 사용된다. prop1: 1, // prop1이 속성 이름이 된다. 'prop2': 2, // prop2가 속성 이름이 된다. // 아래 예제는, 대괄호 내부의 표현식의 결과값이 // 속성 이름으로 사용된다. [propName]: 1 // prop3이 속성 이름이 된다. [propName + propName]: 1 // prop3prop3이 속성 이름이 된다.&#125;;// 아래의 표기법들은, 주로 '코드 작성 시점에 속성 이름을 알 수 없는 경우'에 사용된다. 점 표기법, 대괄호 표기법123456const person = &#123;&#125;; // 빈 객체// 점 표기법 (Dot notation)person.name = \"윤아준\";person.age = 19;person.languages = [\"Korean\", \"English\"]; 문자열이 그대로 속성 이름으로 사용되는가 표현식의 결과값이 속성 이름으로 사용되는지를 봐야 한다. 객체 리터럴을 통해 이미 만들어진 객체에도 얼마든지 속성을 추가할 수 있다. 속성 접근자를 통해서 접근할 때 식별자 규칙을 만족하는 경우에만 점 표기법을 통해 접근할 수 있다. 식별자 규칙을 만족하지 X경우, 반드시 대괄호 표기법을 사용해야 한다. 12345// 대괄호 표기법(Bracket notation)person.한국 나이 = 20;//이렇게 쓸 수 X. 식별자 이름에 공백이 있어서 쓸 수 X.person.'한국 나이' = 20;//이렇게 쓸 수 X.person.['한국 나이'] = 20; // 식별자 규칙을 만족하지 않으므로 []안에 써준다.person.['한국' +' 나이'] = 20; // 이렇게도 쓸 수 있음. []안에 있는 건 표현식이라는 걸 보여주기 위한 예시 코드 보통 점표기법이 많이 사용되나 대괄호 표기법을 사용해야 하는 경우가 있다. 접근하고자 하는 사용자로부터 입력받은 문자열을 속성 이름으로 사용하고 싶을 경우, 코드 작성 시점에는 어떤 이름이 될지 모르므로 대괄호 표기법을 사용한다. 12345678// 사용자로부터 입력받은 문자열을 속성 이름으로 사용하는 예제const propName = prompt(\"속성 이름을 입력하세요\");const propValue = prompt(\"속성 값을 입력하세요\");const obj = &#123;&#125;;obj[propName] = propValue;// propName이라는 변수에 저장되어있는 값을 속성 이름으로 사용하는 경우이므로// 이때는 사용자가 입력한 값이 속성의 이름이 되는 게 아니라 값이 된다. 객체 다루기123// 속성 삭제하기delete person.address;// delete는 연산자이다. 객체의 속성이 삭제되면 true값이 반환된다.객체의 속성이 사라지는 걸 막는 경우가 있는데 그 경우에는 delete연산자로 속성을 삭제하려고 하면, false값이 반환된다. 1234// 속성이 객체에 존재하는지 확인하기\"name\" in person; // true\"phoneNumber\" in person; // false// in도 연산자이다. 메소드 (Method)1234567const person = &#123; greet: function() &#123; return \"hello\"; &#125;&#125;;person.greet(); // 'hello'; 12345678// 축약 표기법. 위 예제와 완전히 똑같이 동작한다.const person = &#123; greet() &#123; return \"hello\"; &#125;&#125;;person.greet(); // 'hello'; 1234567891011121314151617181920212223const person = &#123; name: \"윤아준\", age: 19, introduce() &#123; // `this`를 사용해서 객체의 속성에 접근함 return `안녕하세요, 제 이름은 $&#123;this.name&#125;입니다. 제 나이는 $&#123; this.age &#125;살 입니다.`; &#125;, getOlder() &#123; // `this`를 사용해서 객체의 속성을 갱신함 this.age += 3; // 3살 더하기 &#125;, getYounger() &#123; this.age--; // 1살 빼기 &#125;&#125;;// person.introduce(); // '안녕하세요, 제 이름은 윤아준입니다. 제 나이는 19살 입니다.'person.getOlder(); // undefinedperson.introduce(); // '안녕하세요, 제 이름은 윤아준입니다. 제 나이는 20살 입니다.' 객체 리터럴 안에서는 객체 속성값으로 함수를 지정할 때 ,를 찍어줘야 한다. 화살표 함수와 function keyword함수를 사용했을 때는 ‘this’를 사용했을 때, 동작 방식이 다르게 동작한다. 생성자(Constructor) new를 써서 호출하는 함수를 생성자라고 한다. 12345678910111213// 생성자 정의function Person(name) &#123; this.name = name; this.age = 0; this.getOlder = function() &#123; this.age++; &#125;;&#125;// 생성자를 통한 객체 생성const person1 = new Person(\"윤아준\");person1.getOlder();console.log(person1); // Person &#123; name: '윤아준', age: 1, getOlder: [Function] &#125; 12345678910111213// 생성자 정의function Person(name, age) &#123; this.name = name; this.age = age; this.getOlder = function() &#123; this.age++; &#125;;&#125;// 생성자를 통한 객체 생성const person1 = new Person(\"윤아준\", 0);person1.getOlder();console.log(person1); //Person &#123; name: '윤아준', age: 1, getOlder: [Function] &#125; 인스턴스 (Instance) 생성자를 통해 생성된 객체를 그 생성자의 인스턴스(instance)라고 한다. instanceof 연산자를 사용하면, 객체가 특정 생성자의 인스턴스가 맞는지를 확인할 수 있다. 1person1 instanceof Person; // true 12const obj = &#123;&#125;;obj instanceof Object; // true ‘자바스크립트’에서 생성자와 일반적인 함수 간의 차이는 없다. 함수를 생성자로 쓰면 생성자가 되는 것이었다. 이것이 자바스크립트의 부족한 점이었다. ES6에 객체를 만드는 일만 하는 함수인 클래스가 생겼다. 현재는 생성자를 많이 쓰진 않으나 클래스를 이해하려면 생성자를 먼저 이해해야 한다. 프로토 타입 prototype은 메소드를 넣는 방법 중의 하나다. cf) 참고 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes 배열 객체에서는 안에 들어있는 값들을 속성, 배열 안에 들어있는 값들을 요소 또는 항목이라고 한다. 배열 생성하기배열 리터럴 배열 안에 객체 등을 넣을 수 있다. Array 생성자 자주 쓰이지는 X. 인수를 하나 넘기면 그 개수만큼 빈칸이 있는 비어있는 배열이 만들어진다. 인수가 2개 이상이면 그 인수들을 요소로 갖는 배열을 생성한다. Array.of Array 생성자의 단점을 보완하기 위해 만들어짐. 자주 쓰이진 X Array.of 메소드를 사용하면 인수가 하나이더라도 그 인수를 요소로 갖는 배열을 반환한다. Array.from 간간히 사용되는 편임. 외울 것. 12Array.from(\"hello\"); // [\"h\", \"e\", \"l\", \"l\", \"o\"]// 'hello'.split('');으로 만들수도 있음. 요소 읽기요소 수정하기fill 메소드 하나의 값으로 배열 전체나 일부분을 채울 수 있다. arr.fill(배열을 채울 값, index시작, index 끝번호-1 ) 123// 인덱스 2와 4 사이를 1로 채우기arr.fill(1, 2, 4);console.log(arr); // [ 0, 0, 1, 1, 0 ]; Array 생성자와 fill 메소드를 사용하면, 큰 배열을 만들고 값을 채워넣는 일을 쉽게 할 수 있다. 12// 1000칸의 빈칸이 있는 배열을 만들고 5로 배열을 가득 채운다.new Array(1000).fill(5); // [5, 5, 5, 5, ...] 배열의 끝 부분에서 요소를 추가/제거하기배열의 오른쪽 끝 부분에서 요소를 추가/제거하기push 메소드와 pop 메소드를 사용하면 배열의 오른쪽 끝 부분에서 요소를 추가하거나 제거할 수 있다.push 메소드 - 배열의 오른쪽에 요소를 추가한다. - push 메소드에 여러 개의 인수를 동시에 넘길 수도 있다.pop 메소드 - 배열의 오른쪽 맨 끝에 있는 값을 끄집어내서 반환한다. - 배열의 오른쪽 맨 끝에 있는 요소를 삭제한다. 123456789101112const arr = [];arr.push(\"one\"); // 1 (요소가 추가된 후의 배열의 길이를 반환)arr.push(\"two\", \"three\"); // 결과값: 3// 배열의 오른쪽에 요소를 추가한다.console.log(arr); // [ 'one', 'two', 'three' ]// 배열의 요소 삭제하기arr.pop(); // 'three'arr.pop(); // 'two'arr.pop(); // 'one'arr.pop(); // undefined (더 이상 배열에 요소가 남아있지 않으면 `undefined`를 반환) 배열의 왼쪽 끝 부분에서 요소를 추가/제거하기 반대로 unshift, shift 메소드를 사용해 배열의 시작 부분(왼쪽 부분)에서 요소를 추가하거나 제거할 수도 있다. 기능은 push 메소드와 pop 메소드와 같으나 방향만 다름.(왼쪽 부분부터) 요소를 배열 중간에 삽입하기 splice메소드: 열에 속해있는 연속된 여러 요소, 즉 배열의 일부분을 통째로 바꿔버릴 수 있다. splice메소드 끄집어 낸(바꿔치기 당한) 요소를 끄집어내서 반환한다. 배열의 요소들을 바꿔치치 한다. arr.splice(시작 index 번호, 바꿀 요소의 개수, 바꿔서 채울 요소); splice는 반드시 같은 개수의 요소만 바꿔치기 할 수 있는 게 X.끄집어내는 개수와 채우는 개수가 달라도 된다. 123let arr = [1, 2, 3, 4, 5];arr.splice(1, 3, \"three\"); // [2, 3, 4]console.log(arr); // [ 1, 'three', 5] 바꿀 요소의 개수 자리에 0을 넣으면 해당 index의 요소를 빼기만 하고 채워지는 건 X. 이렇게 splice 메소드를 배열의 중간 부분에 있는 요소를 제거하는 데도 활용할 수 있다. splice의 두 번째 인수로 0을 사용하면, 특정 위치에 여러 요소를 삽입할 수도 있다. 1234// 인덱스가 `1`인 요소 앞에 여러 요소를 추가합니다.const arr = [1, 5];arr.splice(1, 0, 2, 3, 4); // []console.log(arr); // [ 1, 2, 3, 4, 5] 배열 뒤집기 reverse 메소드: 원본 배열을 거꾸로 뒤집어 버린다. 뒤집은 원본 배열을 반환한다. sort 메소드 뭐가 앞에 와야하는지, 뒤에 와야하는지 그 기준이 있어야 한다. sort 메소드를 쓸 때는 비교 함수를 넘겨주어야 한다. 오름차순: 작 -&gt; 큰 내림차순: 큰 -&gt; 작 비교 함수를 인수로 넘겨주지 않으면, sort메소드는 먼저 요소를 전부 문자열올 변환한 후, 유니코드 코드 포인트를 비교하는 방식으로 정렬한다. 12345678910[20, 3, 100].sort(); // [100, 20, 3]&lt;!-- 각 숫자를 문자열로 변환 후 첫글자를 비교. --&gt;&lt;!-- 100은 첫글자가 1, 20의 첫글자: 2, 3의 첫글자: 3이므로 --&gt;&lt;!-- 유니코드 코드 포인트순으로 정렬 해서 [100, 20, 3]임 --&gt;['abc', 'DEF', 'aBC'].sort(); // [ 'DEF', 'aBC', 'abc' ]// 대문자의 유니코드 코드 포인트가 소문자보다 작으므로 'DEF'가 가장 첫 번째 배열의 요소로 정렬된다.['abc', 'DEF', 'aBC'].sort((x, y) =&gt; x.localeCompare(y)); // [ 'abc', 'aBC', 'DEF' ]// 사전순 비교를 하려면 localeCompare 메소드를 사용한다. 배열의 길이 length 속성: 배열의 길이가 변하면서 length 속성의 값도 자동으로 달라진다. 12345// 배열의 길이 줄이기 (줄어든 만큼 뒤쪽에 있는 요소들은 버려집니다.)// 이렇게 사용하는건 권장되지 X. push, pop, shift, unshift 사용해서 할 것.arr.fill(1);arr.length = 2;console.log(arr); // [1, 1] 배열 순회하기for 구문forEach 메소드 ES5에 추가된 메소드 forEach 메소드를 사용하면, 배열의 각 요소에 대해 함수를 호출할 수 있다.const arr = [1, 2, 3]; 123arr.forEach(item =&gt; &#123; console.log(`현재 요소 $&#123;item&#125;에 대해 함수가 실행되고 있습니다.`);&#125;); 1234const arr = [1, 2, 3];arr.forEach((item, index, array) =&gt; &#123; console.log(`현재 $&#123;index + 1&#125;번째 요소에 대해 함수가 실행되고 있습니다.`);&#125;); for..of 구문 현재 가장 많이 사용됨 ES6에 추가된 메소드 배열도 반복가능한 객체이다. index가 들어오는 매개변수가 없다. index가 필요없는 경우- for..of 구문을 사용하고, index가 필요한 경우 for 구문이나 forEach 구문을 사용하자. 코드의 실행 속도가 가장 빠른 건 for 구문이다. ex) 게임 같이 실행 속도가 중요할 경우에는 for구문을 사용한다. 12345const arr = [1, 2, 3, 4, 5];for (let item of arr) &#123; console.log(item);&#125; 123456const arr = [1, 2, 3];for (const item of arr) &#123; console.log(item);&#125;// for of 구문에서는 const로 써도 된다. 변수를 매번 새로 생성하기 때문에.// 변수가 블록 스코프에서만 유효하다. 배열로부터 새로운 값 생성slice 원본 배열에 변화를 주지 않고, 배열을 복사하고 싶을 때 slice를 사용해서 새로운 배열을 만들고 그 새로운 배열로 작업한다. ex) 원본 배열에 sort하면 원본 배열이 바뀜 slice는 얕은 복사를 한다. 배열의 일부분에 해당하는 새로운 배열을 반환한다. 원본 배열에는 아무 변화 X. 첫 번째 인수의 기본값은 0, 두 번째 인수의 기본값은 배열의 length 속성입니다. 즉, 인수 없이 호출하면 배열 전체가 복사된다. arr.slice();와 arr(0, 5);는 같게 작동한다. const는 재대입이 되지 않는 키워드다. 값이 변하지 않는 걸 보장하는 게 X. 123const arr = [3, 1, 2, 4, 5];// arr.sort()하면 원본 배열이 바뀌므로 const로 변수를 만든다고 해서// 그 값이 변하지 않는 게 X. map map 메소드는 배열의 각 요소에 함수를 적용해서, 그 반환값을 요소로 갖는 새로운 배열을 만듭니다. forEach와 비슷해 보이지만, 새로운 배열을 만든다는 점이 다르다. concat concat 메소드는 여러 배열을 연결해서 새 배열을 만들 때 사용된다.- filter 새로운 배열을 생성한다. 원본 배열을 변경하지 않는다. filter 역시 (현재 요소, 인덱스, 배열)의 세 인수를 받는다. join join 메소드는 배열의 요소들을 문자열로 변환 한 후, 메소드에 주어진 구분자(separator)를 이용해 하나의 문자열로 결합하여 반환한다. 123const arr = [1, 2, 3];arr.join(\"&amp;\"); // '1&amp;2&amp;3' 구분자를 넘기지 않으면, , 문자가 구분자로 사용된다. 123const arr = [1, 2, 3];arr.join(); // '1,2,3' 요소 찾기 indexOf 메소드: 배열의 왼쪽부터 lastIndexOf 메소드: 오른쪽부터 검색해서 처음 만나는 요소의 인덱스를 반환 12345678const arr = [\"a\", \"b\", \"c\", \"b\", \"a\"];arr.indexOf(\"b\"); // 1arr.lastIndexOf(\"b\"); // 3arr.indexOf(\"z\"); // -1// 예전에는 이 값이 -1인지 아닌지를 확인해서 이 요소가 배열에 있는지 없는지를 판별했었음.arr.lastIndexOf(\"z\"); // -1 find findIndex 배열이 특정 조건을 만족하는지 판별하기 includes 메소드 배열이 특정 요소를 포함하고 있는지를 판별 진리값을 반환 every 메소드 모든 요소가 조건을 만족하면 true, 하나라도 조건을 만족하지 않으면 false를 반환 &amp;&amp;를 이어붙인 느낌 some 메소드 하나라도 조건을 만족하면 true, 모두 조건을 만족하지 않으면 false 반환 ||를 이어붙인 느낌 배열인지 아닌지 판별하기 Array.isArray 사용(중요하진 X) 문자열과 배열 문자열의 메소드 중에는 배열의 메소드 중에 몇몇과 이름이 같고 완전히 같은 방식으로 동작하는 것들이 있다. 12345\"hello\"[0]; // 'h'\"hello\".slice(2, 4); // 'll'for (let c of \"hello\") &#123; console.log(c);&#125; 다차원 배열 (Multidimensional Array) 표, 좌표, 게임판 등을 저장하기 위해서 많이 사용된다. 1234const table = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];table[0][1]; // 2table[2][0]; // 7","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"CSS 배경(Background)","slug":"css-background","date":"2019-01-15T09:45:41.000Z","updated":"2019-01-15T10:11:51.461Z","comments":true,"path":"2019/01/15/css-background/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/15/css-background/","excerpt":"","text":"CSS 배경(Background)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. CSS 배경(Background) 스타일링Background Design 요소의 배경(background)은 요소의 content-box, border-box 아래에 있는 영역이다.(margin-box 제외)모던 브라우저에서는 배경을 차지하는 영역을 background-clip 속성을 사용하여 변경할 수 있다. background-color: 배경색을 설정한다. background-image: 요소의 배경에 표시할 배경 이미지를 지정한다. background-position: 배경이 요소 배경 안에 표시되어야 하는 위치를 설정한다. positionbackground-position: left|right top|bottom;기본값: left top 2) 좌표(pixel) background-position: x축 좌표 y축 좌표 ex) background-position: 200px 200px; percentagebackground-position: x축 y축 ex) background-position: 20% 0%;background-position: 100% 0%;오른쪽 끝 background-repeat: 배경을 반복할지 여부를 설정한다. background-repeat: repeat | repeat-x | repeat-y | no-repeat 기본값: repeat; repeat repeat-x: x축으로 배경 이미지 반복 repeat-y: y축으로 배경 이미지 반복 no-repeat: 배경 이미지 반복하지 X background-attachment: 내용이 스크롤 될 때 요소의 배경 동작을 설정한다. ex) background-attachment: fixed; 배경 이미지가 고정된 형태로 그 자리에 머물러 있음. background: 배경 속성을 모아 작성하는 속기법 모든 배경 속성을 묶어서 쓰고 싶을 때, background를 사용. transparent는 기본값이기 떄문에 안 넣어줘도 상관 X. background-size: 배경 이미지의 크기를 동적으로 조정할 수 있다.background-size: width height ex) background-size: 100px 100px; background-clip background-origin 123456789101112131415161718192021222324252627282930313233body &#123;&#125;#css-background &#123;&#125;.bg-image &#123; background: url(\"../images/NewYork-US.jpg\") no-repeat center -20px; &lt;!-- background-size: 100%쓰면 이미지가 다 들어오기는 한다. But 비율이 맞지 않는다. 이미지가 작을 경우, 늘려서 끼워맞춰지게 됨. -&gt; 이미지가 왜곡됨 --&gt; &lt;!-- background-size: contain; 사용 --&gt; background-size: cover; &lt;!-- 이미지를 늘려서 끼워맞추는 게 X. 원래 비율대로 이미지를 넣되, 커버를 씌우듯이 이미지 넣을 공간만큼만 이미지를 넣는 것임. --&gt;&#125;.is-floral &#123;&#125;.is-model &#123;&#125;.background-clip &#123;&#125;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"배경","slug":"배경","permalink":"https://JihyeHwang09.github.io/tags/배경/"},{"name":"background","slug":"background","permalink":"https://JihyeHwang09.github.io/tags/background/"}]},{"title":"자바스크립트 3일차","slug":"javascript3","date":"2019-01-15T09:19:29.000Z","updated":"2019-01-15T10:07:01.860Z","comments":true,"path":"2019/01/15/javascript3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/15/javascript3/","excerpt":"","text":"null과 undefined 값이 대입되지 않은 변수 혹은 속성을 사용하려고 하면 undefined를 반환 null은 ‘객체가 없음’을 나타낸다. 12typeof null; // 'object'typeof undefined; // 'undefined' 변수를 선언한 적이 있는지 확인하고 싶을 때에도 typeof 연산자를 사용하고, 이 때, 변수를 선언한 적이 없다면 &#39;undefined&#39;가 반환된다. 저장을 한 적이 없는지와 내가 ‘없음’이라는 사실을 저장했는지를 구분하기 위해서는 undefined를 저장하면 구분이 안되므로, 명시적으로(확 드러나게) ‘없음’을 나타내고 싶다면 항상 null을 사용하는 것이 좋다. (법칙은 아니고 관례임. ) 다만, 객체를 사용할 때 어떤 속성의 부재를 null을 통해서 나타내는 쪽보다는, 그냥 그 속성을 정의하지 않는 방식이 간편하므로 더 널리 사용된다. 12345678910111213141516// 이렇게 하는 경우는 많지 않습니다.&#123; name: 'Seungha', address: null&#125;// 그냥 이렇게 하는 경우가 많습니다.&#123; name: 'Seungha'&#125;// 어쨌든 이렇게 하지는 말아주세요.&#123; name: 'Seungha', address: undefined&#125; Null Checkstrict equality=== 엄밀한 비교.abstract equality== 추상적인 비교. null check를 할 때는 ==를 쓰는 것이 편리하다. 123456789101112131415null === undefined; // falsenull == undefined; // truenull == null; // trueundefined == null; // trueundefined == undefined; // truenull == 1; // falsenull == \"hello\"; // falsenull == false; // falseundefined == 1; // falseundefined == \"hello\"; // falseundefined == false; // false 즉, == 연산자는 한 쪽 피연산자에 null 혹은 undefined가 오면, 다른 쪽 피연산자에 null 혹은 undefined가 왔을 때만 true를 반환하고, 다른 모든 경우에 false를 반환한다. 따라서 null check를 할 때 만큼은 ==를 사용하는 것이 편합니다. 다른 모든 경우에는 ===를 사용하는 것이 좋다. 함수함수의 구성 요소매개변수와 인수 함수를 호출할 때 인수 자리에 변수를 써주면, 이 변수가 넘어가는 게 아니라 값이 넘어가는 것임. 이 표현식의 값이 넘어가는 것이지, 변수 자체가 넘어가는 게 X. 매개변수에는 재대입이 가능하다.(let으로 선언한 변수와는 미묘하게 다른 점이 있음.) 반환값 return 키워드 바로 다음에 오는 값이 함수 호출의 결과값으로 반환되며, 반환되는 즉시 함수 실행이 종료된다. 즉, return 다음에 오는 코드는 실행되지 않는다. return 뒤에 아무 값도 써주지 않거나, 아예 return 구문을 쓰지 않으면 함수는 undefined를 반환한다. 스코프 (Scope) 매개변수와 같이 함수 안에서 정의된 변수는 함수 바깥에서는 접근할 수 없기 때문에 함수 안에서만 사용할 수 있다. 즉, 변수는 코드의 일정 범위 안에서만 유효하다는 성질이 있다. 특정 변수가 유효한 코드 상의 유효 범위를 가지고 스코프(scope)라고 합니다. 매개변수는 함수 스코프를 갖습니다. 즉, 함수의 중괄호 안에서만 유효하다. 스코프 연쇄 (Scope Chain) 중첩된 스코프 안에서는 바깥 스코프의 변수를 가져다 쓸 수 있다. 코드의 실행 흐름이 변수 이름에 도달하면, 그 변수와 같은 이름을 갖는 변수를 현재 스포크에서 찾아보고, 만약 없으면 바로 바깥쪽, 없으면 바같쪽 스코프로 올라가서 계속 찾아보는 과정이 되풀이 된다. 바깥 스코프에서 찾을 때는 부모-부모-부모 …를 찾는 것이지, 다른 함수 안에서만 쓰인 변수를 가져다 쓸 수는 X. 가장 바깥에 있는 스코프를 최상위 스코프(top-level scope) 혹은 전역 스코프(global scope)라고 부른다. 12345678const five = 5;function add5(x) &#123; function add(y) &#123; `return` x + y; &#125; `return` add(five);&#125;add5(3); // 8 reference Error같은 게 뜨면, 내 변수가 스코프 안에서 잘 들어있는지 확인할 것! 변수 가리기 (Variable Shadowing) 안쪽 스코프의 변수가 바깥쪽 스코프에 있는 변수를 가리는 현상을 말한다. 바깥 스코프와 상관없이 매개변수를 자유롭게 사용할 수 있게끔 하는 성질이다. 바깥 스코프에 있는 변수를 일일히 기억하지 않고 사용하고 싶은 매개변수를 자유롭게 사용할 수 있도록 이런 성질이 존재한다. 123456789101112const x = 3;function add5(x) &#123; // `x`라는 변수가 다시 정의됨 function add(x, y) &#123; // `x`라는 변수가 다시 정의됨 `return` x + y; &#125; `return` add(x, 5);&#125;add5(x); 어휘적 스코핑 (Lexical Scoping) 스코프는 코드가 작성된 구조에 의해서 결정되는 것이지, 함수 호출의 형태에 의해 결정되는 것이 아니다. 12345678910function add5(x) &#123; const five = 5; `return` add(x);&#125;add5(3); // 8function add(x) &#123; `return` five + x; // ReferenceError: five is not defined&#125; add라는 함수가 add5라는 함수 안에서 호출되었다고 해서, add 함수 내부에서 add5 함수의 스코프 안에 있는 변수에 접근할 수 있는 것은 아니다. 스코프는 코드가 작성된 구조에 의해 결정되는 성질이다. 위 코드를 동작시키려면, 아래와 같이 작성해야 한다. 1234567function add5(x) &#123; const five = 5; function add(x) &#123; `return` five + x; &#125; `return` add(x);&#125; 값으로서의 함수 JavaScript에서는 함수도 값이다. cf) filter는 함수를 인수로 넘겨줘야 사용할 수 있는 메소드. 원본 배열을 변경시키지 X. 새 배열을 반환함. &#39;일급 객체&#39;라는 용어는 면접에 종종 나옴 자바스크립트의 객체는 일급 객체다. 조건: 변수나 데이터 구조안에 담을 수 있다. 파라미터로 전달 할 수 있다. 반환값(return value)으로 사용할 수 있다. 할당에 사용된 이름과 관계없이 구별이 가능하다 동적으로 프로퍼티 할당이 가능하다cf) c나 java의 함수는 일급 함수가 아니다. url(https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4) 익명 함수 (Anonymous Function) JavaScript에서 함수를 선언할 때 꼭 이름을 붙여주어야 하는 것은 아니다. 이름을 붙이지 않은 함수를 가지고 익명 함수(anonymous function)라고 한다. 익명 함수는 함수를 만든 쪽이 아니라 다른 쪽에서 그 함수를 호출할 때 많이 사용된다. 화살표 함수 (Arrow Function) function keyword 함수는 값을 반환하려면 반드시 return을 사용해야 한다. 화살표 함수의 경우 중괄호가 없으면 바로 반환이 된다. 코드의 길이나 표기법이 굉장히 간단해진다. 화살표 함수는 익명 함수 밖에 없다. 이름이 있는 화살표 함수는 없다. 123456789// 바로 반환시키지 않고 function 키워드를 통한 함수 정의처럼 여러 구문을 사용하려면 curly braces(&#123;...&#125;) 로 둘러싸주어야 한다.// `=&gt;` 다음 부분을 **중괄호로 둘러싸면**, 명시적으로 ``return`` 하지 않는 한 아무것도 반환되지 않습니다.const add = (x, y) =&gt; &#123; const result = x + y; `return` result;&#125;;//매개변수가 하나밖에 없다면, 매개변수 부분의 괄호를 쓰지 않아도 된다.const negate = x =&gt; !x; cf) function keyword 함수 vs 화살표 함수 비교 123[1, 2, 3, 4, 5].filter(function(x) &#123; `return` x % 2 === 0;&#125;); // [2, 4] 1[1, 2, 3, 4, 5].filter(x =&gt; x % 2 === 0); 제어 구문 if...else 구문에서 중괄호 내부에 있는 구문이 하나라면, 중괄호를 생략할 수 있으나 나중에 문장을 추가할 수도 있으니 항상 중괄호를 쓰는 습관을 들이자. switch 바로 뒤의 괄호의 값: ‘코드 실행 여부를 판별할 기준이 되는 값’, 이 기준이 되는 값과 case 바로 뒤에 오는 값이 일치하면 콜론(:) 뒤의 코드 영역이 실행된다. -case쪽의 코드 영역 마지막에 break를 써주지 않으면, 해당 case가 실행될 때 바로 뒤의 case 코드 영역이 뒤이어 실행되게 된다. -&gt; case문에 break를 꼭 써줘야 한다!! 1234567891011121314151617181920function translateColor(english) &#123; let result; switch (english) &#123; case \"red\": result = \"빨강색\"; break; // 이 break를 생략할 경우, 'red'를 넣었을 때 ,result = '빨강색';후에 result = '파랑색';으로 실행흐름이 넘어가서 '파랑색'이 결과값으로 나온다. case \"blue\": result = \"파랑색\"; break; case \"purple\": case \"violet\": // 이 코드 영역은 english 변수의 값이 'purple'일 때와 'violet'일 때 모두 실행됩니다. result = \"보라색\"; break; default: result = \"일치하는 색깔이 없습니다.\"; &#125; `return` result;&#125; do…while 구문 do…while 구문은 while 구문과 사용법은 크게 다르지 않으나, 내부 코드를 무조건 한 번은 실행시킨다는 차이점이 있다. 절대 true가 될 수 없는 구문을 무조건 한 번은 실행시킬 수 있다. 배열의 순회 배열의 각 항목을 방문하면서 차례대로 도는 것을 말한다. forEach메소드 - 배열의 각 항목을 차례대로 실행시키고 싶을 때 사용하는 메소드(ES5에 추가된 문법임) 12345const arr = [1, 2, 3, 4, 5];arr.forEach((item, index) =&gt; &#123; console.log(`배열의 $&#123;index + 1&#125; 번째 요소는 $&#123;item&#125; 입니다.`);&#125;); for 구문의 종류 for for...in 구문 for...of 구문 12345678910const arr = [1, 2, 3, 4, 5];for (let item of arr) &#123; console.log(`현재 요소는 $&#123;item&#125; 입니다.`);&#125;// 현재 요소는 1 입니다.// 현재 요소는 2 입니다.// 현재 요소는 3 입니다.// 현재 요소는 4 입니다.// 현재 요소는 5 입니다. arr의 요소(item)들이 순서대로 item이라는 변수에 들어가면서 차례대로 실행됨. break, continue12345678910111213alert(\"퀴즈를 시작합니다.\");while (true) &#123; const answer = prompt(\"빨강의 보색은 무엇일까요?\"); if (answer === \"초록\") &#123; alert(\"정답입니다! 🎉\"); break; // 루프를 종료하고 다음 코드로 넘어감 // break를 만나면 while 구문 아예 바깥으로 빠져나오게 됨. 따라서 정답인 // 초록을 입력했을 때는 정답입니다!를 출력하고 while문을 빠져나가서 alert('퀴즈가 끝났습니다.')로 실행흐름이 옮겨간다. &#125; else &#123; alert(\"틀렸습니다! 다시 시도해보세요.\"); &#125;&#125;alert(\"퀴즈가 끝났습니다.\"); continue를 만나면, 나머지 코드를 실행하지 않고 루프의 처음으로 되돌아가는 효과가 있다. 반복문의 시작(조건문)으로 돌아가게 된다. break는 break를 둘러싸고 있는 가장 가까운 루프만 종료시킨다. 가장 바깥의 루프까지 다 빠져나오는 게 X. 함수를 즉시 종료하기 return과 throw는 함수의 나머지 코드를 건너뛰고 함수를 즉시 종료시킨다는 걸 기억하라! switch구문을 쓸 때는 break를 써야 하지만, return이 있으면 함수의 나머지 코드를 건너뛰고 함수를 즉시 종료시킨다. 함수의 나머지 코드를 건너뛰고 즉시 종료시키는 결과를 낳기 때문에 break를 더 추가해서 쓸 필요가 X.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 2일차","slug":"javascript2","date":"2019-01-14T12:06:43.000Z","updated":"2019-01-20T16:11:52.164Z","comments":true,"path":"2019/01/14/javascript2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/14/javascript2/","excerpt":"","text":"string 타입문자열 리터럴 &#39;&#39; &quot;&quot; backtick(backquote) 따옴표는 표기법일 뿐, 실제 저장되는 값에 영향을 미치지는 X. ‘’ 안에 “”는 쓸 수 O “” 안에 ‘’는 쓸 수 O ‘’안에 ‘’는 쓰면 X. “”안에 “”는 쓸 수 X. -&gt; 서로 다른 따옴표는 안에 중첩되서 자유롭게 쓸 수 있다. 템플릿 리터럴 (Template Literal) ${} 변수 안에 들어있는 값이 문자열의 값으로 바꿔치기 됨. 동적으로 삽입하고 싶을 때 사용한다. 템플릿은 빈칸을 만들어두고 삽입할 때 사용하는 거니까 템플릿 리터럴이라고 부른다. 여러 줄로 이루어진 문자열을 쉽게 표현할 수 있다. 이 외의 경우에는 ‘’나 “”를 사용한다. 1234const name1 = \"Foo\";const name2 = \"Bar\";const sentence = `$&#123;name1&#125; meets $&#123;name2&#125;!`;console.log(sentence); 12345678`helloworldhellojavascript!`;// 일반적인 문자열 리터럴로는 아래와 같이 해야 합니다.(\"hello\\nworld\\nhello\\njavascript!\\n\"); Escape Sequence 잠깐 문자열 문법에서 탈출해서 표기를 한다는 뜻 \\ 하나를 넣었는데 잘 안될 경우, \\ 를 넣어볼 것.(\\ 하나 넣으면 잘 안될 때가 있음.) \\r\\n: 윈도우 개행문자 \\n: 맥, 리눅스 개행문자 운영체제에 따라 개행문자가 다르기 떄문에 협업할 때 문제가 생길 수 있다.(프로젝트 전에 통일할 필요가 있다.) &#39;&#39;안에 개행문자를 넣고 싶다면 \\n을 쓰자. 유니코드 문자는 Unicode Code Point를 가지고 문자를 넣을 수 있다. ‘\\uac00’로 ‘가’를 입력하든지 ‘가’ 문자열로 입력하든지 같은 것임. 이모티콘도 이제 유니코드에 포함되면서 정식 문자로 인정 받음. \\uXXXX: 4자리수 유니코드 문자 \\u{X...}: 5자리수 유니코드 문자 1console.log(\"\\u&#123;1F435&#125;\"); // 🐵 연산에서 문자열이 하나라도 들어있다고 해서 다 문자열로 변환되는 게 X. 문자열 이어붙이기를 할 때는 주의해야 함. 이럴 때는 템플릿 리터럴을 사용하는 것이 좋다. 1234\"number\" + 1 + 3;// =&gt; 'number13' 덧셈은 왼쪽부터 계산되니까 'number' + 1 먼저 계산됨.1 + 3 + \"number\";// =&gt; '4number' 연산 순서만 바뀌었는데 숫자 덧셈 계산이 먼저 일어나서 4가 되고 뒤에 문자열 'number'가 붙는다. 부등호로 문자열을 비교하면 유니코드 코드포인트의 크기를 기준으로 비교를 한다. 사전순 비교를 하고 싶을 때는 localeComapare 메서드를 사용한다. .localeComapare() 문자열을 배열로 바꾸기 12[...'hello'];&lt;!-- ['h', 'e', 'l', 'l', 'o'] --&gt; (최근에 추가된 기능). 객체나 배열에 대해서도 쓸 수 있는 연산자. 쓰임이 많음. MDNMDN 문서를 읽을 때 주의할 점 번역의 품질이 굉장히 떨어지는 경우가 있음. 번역된 버전이 옛날 버전인 경우를 주의해야 함. 되도록 영어 버전으로 읽는 게 좋다. 한국어 번역이 좋지 않을 경우 -&gt; 영어쪽으로 가서 번역기로 돌려서 비교해보면서 읽어볼 것. MDN 빠르게 mdn 문서에 접근하고 싶을 때: https://devdocs.io/ 개발 문서에서 사용하는 영어 문서에 사용되는 영어 단어나 문법은 많지 않다. 읽는 연습을 꾸준히 할 것. 속성 및 메소드 공백도 문자열로 취급함.‘hello javascript’.indexOf(‘java’); ‘hello javascript’.indexOf(‘python’); 예전에는 indexOf의 결과값이 -1인지 아닌지를 판별함으로써 문자열을 포함하고 있는지 여부를 판단했으나, includes 메소드가 나오면서 includes로 판별함. 문자열의 일부를 잘라낸 새 문자열 생성하기 1\"hello\".slice(2, 4); // 'll' 틈에다가 번호를 매긴다고 생각하면 쉽다. 끝까지 자르고 싶다면, 뒷자리 인수를 안주면 됨. 1-\"hello\".slice(2); // 2번째 자리부터 끝까지 자르겠다. slice 메소드는 원본 문자열을 변경하지 X! 12\"abc@gmail.com\".split(\"@\")[0];// =&gt; 'abc'.split한 후에 다 배열이기 떄문에 바로 뒤에 대괄호로 index 번호를 주면 배열안에 있는 값을 가져올 수 있다. split은 원본 데이터를 변경하지 X. toLowerCase, toUpperCase 대소문자 관계없이 비교하고 싶을 때 주로 사용함. 게시물 검색 기능에서 사용자가 소문자를 입력했다고 해서 대문자로 된 게시물을 보여주지 않으면 안되므로 유니코드와 UTF-8, UTF-16 문자열은 JavaScript 내부적으로 UTF-16 형식으로 인코딩된 값으로 다뤄진다. 유니코드와 UTF-8을 헷갈리면 안됨! 유니코드 - 문자 정보 데이터베이스, 문자 집합, 문자 인코딩 등 전 세계의 UTF-8은 인코딩 방식. 유니코드를 위한 가변 길이 문자 인코딩 방식 중의 하나임. 컴퓨터 내부적인 메모리 상에 저장할 때는 프로그래밍 해석기 안에서 계산을 할 때는 UTF-16으로 하는 게 UTF-8보다 더 속도가 빠름. (UTF-8처럼 압축하는 게 아니라 그대로 저장하므로) 웹에서는 UTF-8을 사용하는 게 약속임. 유니코드가 실무에서 중요한 건 아니지만, 면접에서 종종 물어봄. 유니코드가 무엇인지 UTF-8과 UTF-16의 장단점 boolean 타입논리연산자 !true not ture라고 읽음. !false not false라고 읽음. 긴 식 앞에 !를 사용할 수 있다. 삼항 연산자 (ternary operator) if else구문보다 축약된 느낌. 12345const result = if (true) &#123; 1&#125; else &#123; 2&#125; 1const result = true ? 1 : 2; if로 둘러싸여진 전체는 표현식이 X. 삼항연산자는 표현식임. if else구문에는 여러 개의 명령이 올 수 있지만, 삼항연산자에는 여러 개의 명령이 올 수 X. 특정 조건을 만족할 때 어떤 결과값을 바로 반환하고 싶다. -&gt; 삼항연산자 사용 특정 조건을 만족할 때 여러 개의 명령을 실행하고 싶으면 -&gt; if else 구문 사용 react할 때 삼항연산자를 많이 사용함. 연산자 우선순위 (Operator Precedence) &amp;&amp;와 ||에는 우선순위가 있기 떄문에 주의해야 함. 이 우선순위 때문에 버그가 생길 수 있음. 논리 연산의 여러 가지 법칙1!!a === a; not을 2번 붙이면 원래대로 돌아옴 // 분배 법칙 12* a || (b &amp;&amp; c) === (a || b) &amp;&amp; (a || c);* a &amp;&amp; (b || c) === (a &amp;&amp; b) || (a &amp;&amp; c); 우변에 잇는 식을 짧게 코드를 사용하고 싶을 때 좌변에 있는 식을 사용함. 논리 연산의 여러 가지 법칙들을 표를 그려서 확인해보기 truthy &amp; falsy true로 취급되는 값: truthy false로 취급되는 값: falsy falsy로 취급되는 값 꼭 외울 것! 이 외의 모든 값들은 truty이다. falsy로 취급되는 값 false null undefined 0 NaN &#39;&#39; cf) truthy에는 객체, 배열 등도 다 포함됨. (심지어 배열이 비어있더라도 truty임. ) 12345678910111213const input = prompt(\"이름이 무엇인가요?\")if (input) &#123;&lt;!-- truthy와 falsy의 성질을 이용해서 if의 조건식 부분에 input은 truethy라는 성질을 이용해서 짧게 코드를 줄일 수 있음. --&gt; alert(`안녕하세요, $&#123;input&#125;님!`)&#125; else &#123; alert('이름을 입력해주세요.')&#125;// if (input.length &gt; 0) &#123;// alert(`안녕하세요, $&#123;input&#125;님!`)// &#125; else &#123;// alert('이름을 입력해주세요.')// &#125; truthy와 falsy의 성질을 이용하면 편하지만, 논리의 허점이 생길 수 있다. 자바스크립트는 타입 체크를 하지 않는 언어임. 1234567function add(x, y) &#123; if (typeof x === \"number\" &amp;&amp; typeof y === \"number\") &#123; return x + y; &#125; else &#123; throw new Error(\"x 혹은 y의 타입이 number가 아닙니다.\"); &#125;&#125; javascript의 타입을 체크하는 방법 매번 이렇게 타입 체크하는 조건식을 쓸 수 없으므로 요즘은 타입스크립트를 많이 사용함. 타입스크립트는 타입 체크가 되는 자바스크립트의 확장 언어임. 대개 실무에서는 타입 스크립트를 많이 사용한다. throw하면 에러가 나면서 나머지 코드가 실행되지 X. 정적 타이핑 언어(statically-typed language) c, c++, java 등 동적 타이핑 언어(dynamically-typed language) javascript, python, ruby등 다른 타입의 값을 진리값으로 변환하기123456!\"hello\"; // false!!\"hello\"; // true// 'hello'가 truthy이기 때문에(true로 취급되었기 떄문에)!NaN; // true!!NaN; // false toString: 숫자를 문자열로 변환하는 메소드 12// if (str.includes('3' || '6' || '9')) &#123;// &#125; 틀린 것임. ‘3’이 truthy이기 떄문에 결과값이 ‘3’으로 나와버림.따라서 조건식을 이렇게 쓰면 X!!.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"CSS 타이포그래피(Typography)","slug":"css-typography","date":"2019-01-14T12:06:34.000Z","updated":"2019-01-14T12:42:49.713Z","comments":true,"path":"2019/01/14/css-typography/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/14/css-typography/","excerpt":"","text":"CSS 타이포그래피(Typography)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. CSS 타이포그래피(Typography)폰트(Fonts) 스타일 속성 폰트에 영향을 주는 속성으로 적용되는 모양, 크기, 굵기, 기울임 등. font-family: 글자 모양 font-size: 글자 크기 font-weight: 글자 굵기(두께) font-style: 글자 기울임 font-variant: 소문자를 작은 대문자로 바꾸는 속성 ※ 글자 색상은 color 속성으로 설정. color keywords: red, green, blue, pink, black hex color code: #RRGGBB / 0 ~ 9, a ~ f 예) #1868a7 rgb VS rgba의 차이 rgba는 불투명도까지 나타낸다. 각 256가지 색을 나타내고, 0부터 시작하기 떄문에 번호는 256까지 X. 256-1인 255까지가 정상적인 색으로 나옴! rgb, rgba: RED, GREEN, BLUE, ALPHA 예) rgba(127,255,0,1): a가 1이면 불투명한 색 rgba(127,255,0,0.3): a가 0.3이면 반투명한 색 hsl, hsla HUE(각도), `ATURATION(채도), LIGHTNESS(명도), ALPHA (투명도) 1hsla(360,60%,70%,1) saturation(채도): 100%면 순색(원색)에 가까움. lightness(명도): 0%에 가까우면, 검정색 100%에 가까우면, 흰색임. 웹브라우저는 운영체제가 지원하는 기본 폰트(웹 안전 폰트)만화면에 렌더링 한다. (참고: cssfontstack.com) 즉, 사용된 폰트가 사용자 컴퓨터에 없으면 렌더링 X. 웹 안전 폰트 Arial [sans-serif]: 고딕체 Verdana [sans-serif]: 고딕체 Courier New [monospace]: 코드체(공간이 동일) Georgia [serif]: 명조체 Times New Roman [serif]: 명조체 Trebuchet MS [serif]: 명조체 하지만 웹 안전 폰트만으로 디자인 하는 디자이너는 없다!Helvetica는 디자이너가 애용하는 폰트이지만…Windows는 기본 지원하지 않는다. (Mac OSX는 지원) ※ 비주얼 디자인 과정에서 적용 가능한 웹폰트를 사용해야 한다.폰트 저작권에 주의! (참고: hyundaicard.com) ※ 저작권 걱정 없는 폰트fonts.google.comgoogle.co.kr/search?q=무료+웹폰트 텍스트(Text) 레이아웃 속성 텍스트 간격 및 레이아웃 기능에 영향을 주는 속성으로 행간, 자간, 어간, 정렬, 변형, 꾸밈, 그림자 사용자가 읽기 편한 간격: 자간 &lt; 어간 &lt; 행간 순으로 넓어야 한다.-&gt; 염두에 두고 디자인할 것! line-height줄 높이를 정하는 속성 default: 1.25임. 1.5이상 줘야 글을 읽기가 용이해짐. 1ex)line-height: 1.5; letter-spacing 글자 사이의 간격(자간) default값: 0 1ex)letter-spacing: -0.024em; word-spacing 단어 사이의 간격픽셀 단위나 em으로 조정할 것 12ex)word-spacing: 1px;word-spacing: 0.02em; text-align 정렬 default값: 왼쪽 123456ex)text-align: center;/* 가운데 정렬 */text-align: right;/* 오른쪽 정렬 */text-align: left;/* 왼쪽 정렬 */ text-indent 들여쓰기 +값, -값 사용할 수 있음. +: 오른쪽으로 들여쓰기됨. -: 왼쪽으로 내어쓰기됨. 1234ex1)text-indent: 1em;/* 각 문단의 첫째줄만 들여쓰고 싶을 때 */cf)padding-left: 1em;/* 텍스트 전체를 들여쓰고 싶을 때 */ text-transform 대문자로 또는 소문자로 바꾸는 속성 1234text-transform: `uppercase`;/* 모두 대문자로 바꿈 */text-transform: lowercase;/* 모두 소문자로 바꿈 */ text-decoration 선으로 텍스트를 꾸미는 속성 12345678ex) text-decoration: underline;/* 밑줄 치기 글자를 판독하기 어렵게 하기 때문에 권장되지 X.*/text-decoration: overline underline line-through;text-decoration: overline /* 위에 공간을 만들어서 줄을 그어줌. */text-decoration: line-through;/* -&gt; 글씨 중간에 취소선을 그어줌. */ text-shadow 그림자x축 y축 blur sprea color; 12ex1)text-shadow: 4px -3px 10px #9bdbde;ex2)text-shadow: 0px 3px 10px #943978; white-space 공백을 처리하는 방법 white-space: pre white-space: pre-line; white-space: nowrap; nowrap은 가로 한줄로 쭈욱~ 나열됨. 단어의 분리를 어떻게 할 것인지 결정 (공백/띄어쓰기) 수고했어 오늘도(음절) 수 고 했 어 오 늘 도 word-break: break-all; 박스의 가로 영역을 넘친 단어 내에서임의의 분리 여부를 결정하여 줄바꿈에 관여 word-wrap 긴 단어 처리하는 방법 default: normal normal: 글자가 길어도 끊어지지 않고 한 줄에 나타냄 break-word: 강제로 끊어서 줄바꿈함","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"타이포그래피","slug":"타이포그래피","permalink":"https://JihyeHwang09.github.io/tags/타이포그래피/"},{"name":"Typography","slug":"typography","permalink":"https://JihyeHwang09.github.io/tags/typography/"}]},{"title":"자바스크립트 1일차","slug":"javascript1","date":"2019-01-13T14:54:55.000Z","updated":"2019-01-14T12:34:44.783Z","comments":true,"path":"2019/01/13/javascript1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/13/javascript1/","excerpt":"","text":"값과 리터럴 값으로 변환될 수 있는 부분을 모두 표현식이라 한다. 변수는 값에 붙이는 이름이다. html의 속성: attribute, javascript의 속성: property 객체 자바스크립트의 객체는 가변 길이이다. 자바스크립트는 자료구조의 유연성이 좋다. 객체의 속성 이름에는 x, ‘x’ 둘 다 쓸 수 있다. 다른 점은 차후에 설명해주실 예정. 속성 값에는 무엇이든 올 수 있다. 객체 안에 객체가 중첩될 수 있다. 123456789const obj = &#123; x: 0, y: &#123; x: 1, y: 2 &#125;&#125;;obj.y.x; 대입을 할 때는 = 오른쪽 식이 먼저 실행된다. 1234567let x = 1;x = x + 1;&lt;!-- x += 1;x *= 3;x /= 3; --&gt;console.log(x); delete 연산자: 객체의 속성을 삭제할 수 있다. 객체의 속성을 아예 없애버릴 수 있다. 123456789const obj = &#123; x: 0, y: 1&#125;delete obj.x;obj;&lt;!-- &#123;y: 1&#125; 객체의 x속성이 없어짐. --&gt; 메소드 객체 안에 있고, 객체의 속성을 통해서 사용하는 함수를 메소드라고 부른다. 12345678910111213141516171819const obj = &#123; x: 0, increaseX: function() &#123; this.x = this.x + 1; &#125;&#125;;const obj = &#123; x: 0, increaseX: function() &#123; this.x = this.x + 1; &lt;!-- this는 자기 자신을 가리키는 키워드. 실행하는 순간, this가 obj로 샤샤샥 바뀜. --&gt; &#125;&#125;;obj.increaseX();&lt;!-- 어떤 객체의 메소드 안에 this가 있으면, 그 this는 '메소드가 호출될 때' 해당 객체를 가리키게 된다. --&gt;console.log(obj.x); 객체와 배열의 차이객체는 속성 이름과 속성값이 연결되어 있다. 순서가 X . 배열은 순서가 있다.배열에 담는 객체는 요소(element) 혹은 항목(item)이라고 부른다. .점을 찍고 호출하는 함수를 메소드라고 한다. push메소드: 배열의 오른쪽 끝에 값을 추가한다. 12345const arr = [1, 2, 3];arr.push(4);arr.push(5);arr.push(6); slice 메소드: 특정 요소부터 한 개 혹은 여러 개의 요소를 지우고 싶을 때 사용ex) .slice(index값, 지우고 싶은 요소의 개수); 언어와 구동 환경 자바스크립트라는 언어와 구동 환경을 나누어서 생각해야 한다. ex) node.js에서는 alert를 쓸 수 X. 자바스크립트 언어, 자바스크립트를 돌릴 수 있는 구동환경에는 어떤 기능이 있는지를 배워야 한다. 프론트엔드 자바스크립트 개발자 vs 백엔드 자바스크립트 개발자 프론트엔드 자바스크립트 개발자는 자바스크립트 언어와 브라우저 구동환경을 배운다.vs 백엔드 자바스크립트 개발자는 자바스크립트 언어와 node.js 구동환경을 배운다. ES2015, 그 이후 ES5 2009년에 나온 자바스크립트 버전. ES2015 = ES6 값과 리터럴 값과 리터럴을 구분할 줄 알아야 한다. 리터럴: 값의 표기법을 말한다. 변수 (Variable) let, const, while, for등 프로그래밍에서 특별한 의미를 지니는 단어들을 키워드라고 부른다. let은 ES6에서 도입된 변수이다. ES6에서는 var를 쓰지 않고, let이나 const를 사용한다. ‘best practice: 좋은 관례’ 이다.(프로그래밍에서 많이 쓰이는 용어) let vs const let은 재대입이 가능. const는 재대입이 불가능한 변수. const는 재대입이 불가능하기 때문에 선언과 대입을 동시에 해줘야 한다. let은 선언, 대입을 따로 해도 된다. const로 변수를 선언할 때는 반드시 선언 시에 값을 대입해주어야 한다. 값 없이 선언만 하게 되면 에러가 발생한다. 또한 추후에 다른 값을 대입할 수 없다. let을 꼭 써야하는 경우가 아니라면, const를 사용하는 것이 좋다. let을 사용하면 의도치 않게 다른 값이 대입되어 버리는 일이 생길 수 있기 때문입니다. 정말로 재대입이 필요한 경우에만 let을 사용하는 것이 좋은 습관입니다. 특정 부분을 확신할 수 있으면 나머지 부분을 작성하기 쉬워지기 때문에 왠만하면 항상 const를 쓰는 습관을 들이는 것이 좋다. token은 프로그래밍에서 문자를 의미한다. Error 정리 SyntaxError: Unexpected token (28:7) 28번째 줄의 7번째 글자에 문법 에러가 있다는 뜻 SyntaxError: Assignment to constant variable: a at 29:0 29번째 줄의 첫번째 글자에 상수 변수에 대입을 했다는 에러가 있다. 12let seven = 7;let seven = 77; SyntaxError: Duplicate declaration “seven” at 33:4 변수 seven은 중복된 선언이라는 에러이다.** 식별자 변수의 이름은 식별자라고 한다. 식별자는 (‘’)없이 속성의 이름으로 이용할 수 있다. 식별자가 되기 위한 규칙들 숫자, 알파벳, 달러 문자(\\$), 언더스코어(_)가 포함될 수 있다. 단, 숫자로 시작되어서는 안 된다. 예약어는 식별자가 될 수 없다. ex) for, while, function 등은 사용할 수 X. 식별자로 쓸 수 없는 단어를 식별자로 사용하고 싶을 때’’로 묶는다. 12345678const obj = &#123; a: 1, '7seven': 7 &lt;!-- 식별자 규칙에 어긋나는 이름을 사용하려고 하므로 ''로 감싸줘야 에러나지 X --&gt;&#125;console.log(obj['7sever']);&lt;!-- 호출할 때도 ['']로 감싸줘야 한다. --&gt; 식별자는 한글로 쓸 수 있지만, 영어로 쓰는 것이 좋다. Camel Case ex) let helloWorldJavaScript 단어의 첫 글자를 소문자, 그 다음 단어부터 첫 글자를 대문자로 쓴다. 자바스크립트에서는 Camel Case로 쓰는 게 예의이고 관례이다. 1234567const one = 1;typeof 1 + 3;&lt;!-- 결과: 'number' + 3; --&gt;&lt;!-- typeof 1에 문자열 3이 붙어서 나온 것임. --&gt;&lt;!-- 연산자 우선순위가 typeof가 +보다 높다. --&gt;&lt;!-- 연산자 우선순위를 다 외우기가 너무 복잡하므로 우선 연산이 되었으면 하는 부분에 ()로 묶어주는 게 좋다. --&gt;typeof (1 + 3); 변수는 가장 첫 글자를 소문자로, 클래스는 첫 글자를 대문자로 쓰는 게 관례이다. number 타입number 타입 리터럴 리터럴이 다르더라도 값은 같을 수 있다. 자바스크립트는 정수와 실수를 별도의 타입으로 다루지 X. 정수와 실수 둘 다 number타입으로 구분하지만, 정수인지 실수인지 판별하기 위해서는 Number.isInteger를 사용한다. Number.isInteger(정수 or 실수); -&gt; 정수이면 true, 실수이면 false를 반환한다. number 타입에 대한 연산12* 2 ** 3;// 거듭제곱(거듭제곱 연산자는 ES2018에 추가됨) cf) 거듭제곱 함수 12Math.pow(2, 3);&lt;!-- 파이썬에서 가져온 함수임. --&gt; 자바스크립트에서 ==보다는 ===를 쓰는 게 더 좋다. 둘 다 되긴 하지만 ===를 쓰는 게 관례다. 123451 === '1'&lt;!--결과값: false --&gt;1 == '1'&lt;!-- 결과값: true 타입이 달라도 결과값이 true로 같다고 나오기 때문에 버그가 생기기 쉽다. --&gt; 12345let a = 1;a++; &lt;!-- 1 증가시키기 **전** 값을 표현식의 결과값으로 반환 --&gt;++a;&lt;!-- 1 증가시킨 **후**의 값을 표현식의 결과값으로 반환 --&gt; 1234let b = a++;&lt;!-- b에 증가하기 **전** 값인 1이 저장됨--&gt;let b = ++a;&lt;!-- b에 증가한 **후**의 값인 2가 저장됨--&gt; 연산자 우선순위 ()로 묶으면 우선순위가 가장 높기 때문에 가장 먼저 연산된다. typeof가 덧셈(+)보다 우선순위가 높기 때문에 +먼저 연산된 뒤에 문자열 3이 붙음. ex) typeof 1 + 3; 단항 연산자 ex) +1 다항 연산자 ex) 3 + 2 부동 소수점 (Floating Point) vs 고정 소수점 (Fixed Point) 컴퓨터에서 실수를 다루는 2가지 방식 부동 소수점 vs 고정 소수점 컴퓨터는 소수도 2진수로 저장하기 때문에 10진수 소수를 정확히 다룰 수 없다. 실수를 정확하게 나타내기 위해 사용하는 방법은 고정 소수점이다. 커리큘럼에서는 고정 소수점을 사용하는 라이브러리를 사용하지X. 컴퓨터로 실수를 다룰 때는 조심해야 한다. 컴퓨터는 실수를 정확하게 다룰 수 없기 때문에. number 타입의 특이한 값들NaN NaN은 Not a Number의 약자이다. 계산 불가능한 연산의 결과값을 나타내기 위해 사용한다. parseInt(‘’) 문자열을 숫자로 바꿔주는 함수 parseInt(‘’)에 이상한 문자열을 넣으면 NaN이 결과값으로 나온다. 12parseInt('asdf'); &lt;!--결과값: NaN --&gt; 어떤 값이 Nan인지 아닌지를 알고 싶을 때, ==를 쓰면 절대 X!! ===를 써야 됨. 꼭 기억!! ===는 숫자 비교에 특화되어 있는 연산자이다. “NaN은 숫자가 아니기 때문에, 어떤 숫자와도 같지 않다.”는 규칙이 있다. =&gt; 즉, NaN은 number 타입인 NaN가 같지 X ===NaN이 들어간 식은무조건 어떤 경우에도 false가 나오는 식임.(NaN은 자기자신과도 같지 X 때문에) 이거 때문에 버그 많이 생김. NaN은 JavaScript의 값들 중 유일하게 자기 자신과 같지 않은 값 1234 Number.isNaN(1);&lt;!-- 결과값: false --&gt; Number.isNaN(NaN);&lt;!-- 결과값: true --&gt; 12345678910111213141516171819202122const a = prompt(\"a: \");const b = prompt(\"b: \");const parsedA = parseInt(a);const parsedB = parseInt(b);// 이렇게 하면 안 됩니다!!!// if (parsedA === NaN || parsedB === NaN) &#123;// alert('숫자를 입력해주세요')// &#125; else &#123;// alert(parsedA + parsedB)// &#125;// \"NaN은 숫자가 아니기 때문에, 어떤 숫자와도 같지 않다.\" 는 규칙이 있다.// =&gt; 즉, NaN은 number 타입인 NaN과 같지 않다.if (Number.isNaN(parsedA) || Number.isNaN(parsedB)) &#123; alert(\"숫자를 입력해주세요\");&#125; else &#123; alert(parsedA + parsedB);&#125;1 + (2 + 3 + (4 + 5)); evaluate(평가)- 표현식을 값으로 반환하는 절차. 계산과 비슷 -0 자바스크립트의 세계에서 그냥 0과 -0은 다르다. 1234560 === -0; // true// 수의 세계에서 0*-1 한 거는 0이기 때문에 true로 나옴Object.is(0, -0);&lt;!-- 결과값: false. 자바스크립트 세계에서는 0과 -0을 다르게 취급함. --&gt; Object.is(,); 수의 세계에서 같은 지, 다른 지를 판별하는 게 x.자바스크립트 상에서 같은지, 다른지를 판별하는 것이다. 실무에서는 ===을 제일 많이 사용하는 편임!! Infinity 어떤 수가 Infinity인지 아닌지를 판별해야 할 때가 있음. Number.isFinite(): 유한한지 아닌지 판별 값이 유한하면 true, 무한하면 false를 반환함. 1234567if (Number.isNaN(parsedA) || Number.isNaN(parsedB)) &#123; alert(\"숫자를 입력해주세요\");&#125; else if (Number.isFinite(parsedA / parsedB)) &#123; alert(parsedA / parsedB);&#125; else &#123; alert(\"0으로 나눌 수 없습니다.\");&#125; isFinite(‘1’);쓰지 말고, 버전업된 Number.isFinite();를 써라. parseInt, parseFloat parseInt: 문자열 -&gt; 정수 parseFloat: 문자열 -&gt; 실수 1parseInt(\"110\", 2); // 6 (문자열 '110'을 2진수로 해석하겠다. 문자열을 2진수로 간주한다.) 되도록 숫자는 숫자랑만 연산한다. 문자열을 숫자로 바꾼 후에 연산한다. 숫자랑 문자열 연산을 하지 않는다. (아주 간단한 문자열끼리 이어붙이기 정도 빼고는) 사용자로부터 입력받은 데이터는 undefined 혹은 문자열일 가능성이 높다. 수와 문자열 계산은 반드시 전부 다 숫자로 안전하게 변환한 뒤에 연산할 것! Math 객체123456789101112131415161718192021Math.floor(-3.6);// 더 작은 숫자인 -4가 됨.Math.trunc(-3.6);// 더 큰 숫자인 -3이 됨.Math.max(1, 2);&lt;!-- 결과값: 2;들어온 숫자들 중에 제일 큰 숫자를 반환해준다.--&gt;Math.min(1, 2);&lt;!-- 결과값: 1;들어온 숫자들 중에 제일 작은 숫자를 반환해준다.--&gt;Math.random(); // 0과 1 사이의 값이 임의로 반환됩니다. Math.random() * 10; &lt;!-- 0과 10 사이의 실수를 반환함. 10을 넘을 수 X. --&gt; Math.floor(Math.random() * 10); &lt;!-- 0부터 9까지의 정수가 똑같은 확률로 나오게 만드는 식 --&gt; 주사위 만들기(1-6까지 나옴) 12Math.ceil(Math.random() * 6);Math.floor(Math.random() * 6) + 1; 카드 게임(A, B, C 중에 1장 나오는 게임) 123const CARDS = [\"A\", \"B\", \"C\"];CARDS[Math.floor(Math.random() * 3)]; number 타입의 메소드 number 타입은 객체가 아니지만, 마치 객체처럼 메소드를 사용할 수 있다. 매개변수 (parameter) 코드를 실행하다가 return을 만나면 실행 흐름을 종료시킨다. 1234567891011121314151617function evenOrOdd(x) &#123; // 만약 x가 짝수면 'x: 짝수' 라고 출력 if (x%2 === 0) &#123; console.log(x + ': 짝수'); &#125; else &#123; console.log(`$&#123;x&#125;: 홀수`); &#125; // 아니면 'x: 홀수'라고 출력&#125;for (let i = 0; i &lt; 20; i++) &#123; evenOrOdd(i + 1);&#125;`$&#123;&#125;` 사이에 어떤 값을 집어넣을 수 있다.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"CSS 상속(Inheritance)과 케스케이드(Cascade)","slug":"css-inheritance&cascade","date":"2019-01-12T14:31:47.000Z","updated":"2019-01-15T10:14:41.549Z","comments":true,"path":"2019/01/12/css-inheritance&cascade/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/12/css-inheritance&cascade/","excerpt":"","text":"CSS 상속(Inheritance)과 케스케이드(Cascade)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. CSS 상속 (Inheritance)상속되는 속성 (글자색, 글자 디자인에 관련된 것) color: 글자 색상 (배경색은 상속되지 X) font-size: 글자 크기 font-family: 글자의 모양(글꼴) letter-spacing: 자간 상속되지 않는 속성 (공간에 관련된 것) outline: 외곽 테두리선 margin: 외곽 영역의 공간 border: 테두리 padding: 테두리 안쪽의 공간 CSS 케스케이드(Cascade) 케스케이딩(Cascading)이란? cascading: The process of combining several style sheetsand resolving conflicts between them. Håkon Wium Lie (CSS 공동 창시자)는 CSS에 관한PHD 논문에서“여러 스타일 시트를 결합하고 이들 사이의충돌을 해결하는 프로세스”라는 용어로 “Cascade”를말하고 있다. https://www.wiumlie.no/2006/phd/ CSS(Cascading Style Sheets )는 캐스케이드 개념이중요하다는 것을 약어에서 강조. 가장 기본적인 수준에서는규칙 순서가 중요하지만 그보다 더 복잡하다는 것을 말한다. 중요성 (Importance)!important 선언은 다른 모든 선언보다 우선권을 가진다. [NOTE]!important가 적용된 속성을 덮어 쓰려면, 다시 !important를사용해야 하기에 최대한(절대!!) 사용하지 않도록 노력해야 한다. 특성 (Specificity)선택자의 우선권에 대한 척도.각 척도를 1, 10, 100, 1000 단위로생각하면 이해하기 좋다. 요소 선택자 &lt; 클래스 선택자 &lt; ID 선택자 &lt; 인라인 스타일0,0,0,1 0,0,1,0 0,1,0,0 1,0,0,0 [NOTE]*, &gt;, +, ~ 등 콤비네이터(Combinators),:not() 가상 클래스는 특성에 영향을 주지 X! [예시]* – 0000 a – 0001 (a요소는 요소선택자이기 때문에 1점) a.link – 0011 (a요소: 1점 + link라는 이름의 클래스니까 10점) li:nth-child(2) a:hover – 0022 (li요소: 1점 + a요소: 1점 + li:nth-child(2)는 가상클래스이다.가상클래스도 클래스이기 때문에 10점 + :hover도 가상클래스이기 떄문에 10점) .nav:nth-child(2) a:hover – 0031 .nav: 실제 클래스 10점 + v:nth-child(2): 가상클래스 10점 + :hover 10점 + a요소 1점) #outer a – 0101 (#outer: id선택자 100점 + a요소: 1점) #outer #inner a – 0201 (#outer: id선택자 100점 + #inner: id선택자 100점 + a요소: 1점 ) style=&quot;color: tan&quot; – 1000 (inline 스타일 시트: 1000점) !important(inline 스타일 시트도 무력화 시키는 게 !important이다.!important를 쓰면 함께 지옥에 가는 것임. 안 쓰는 게 좋다!! 최대한 쓰지 않도록! ) 소스 코드의 순서: 중요성, 특성이 설정되지 않았거나 동일한 경우나중에 나온 소스의 스타일이 우선권을 가진다. [예시] 1234567891011121314151617p &#123; color: #930212; &#125;p &#123; color: #d5727e; &#125;/* 우선권을 가진다. */p.note &#123; color: #930212; &#125;/* note라는 클래스 10점 + p요소 1점= 11점이 되므로 -&gt; 우선권을 가진다. */p &#123; color: #d5727e; &#125;p.note &#123; color: #930212; &#125;/* .note 클래스: 10점 + p요소: 1점 = 11점 */#target p &#123; color: #d5727e; &#125; /* #target: id선택자 100점 + p요소 1점 = 101점 *//* 우선권을 가진다. */&lt;p style=\"color: maroon\"&gt; /* inline 스타일은 1000점 */ 가장 약한 점수를 가지고 있다고 해도 !important flag를 꽂게 되면,!important가 우선하게 된다. html 파일 요소에 직접 스타일링 하는 것이다. (inline 스타일)","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"상속","slug":"상속","permalink":"https://JihyeHwang09.github.io/tags/상속/"},{"name":"Inheritance","slug":"inheritance","permalink":"https://JihyeHwang09.github.io/tags/inheritance/"},{"name":"케스케이드","slug":"케스케이드","permalink":"https://JihyeHwang09.github.io/tags/케스케이드/"},{"name":"Cascade","slug":"cascade","permalink":"https://JihyeHwang09.github.io/tags/cascade/"}]},{"title":"CSS 선택자(Selectors)","slug":"css-selectors","date":"2019-01-11T14:30:19.000Z","updated":"2019-01-14T12:37:21.410Z","comments":true,"path":"2019/01/11/css-selectors/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/11/css-selectors/","excerpt":"","text":"CSS 선택자(Selectors)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. 선택자는 CSS뿐만 아니라 자바스크립트에서도 유용하게 사용될 수 있다. CSS는 HTML 요소를 선택하는데 있어 다양한 선택자 옵션을 제공한다. selector(대상) {property(속성):value(값)} 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; h1 &#123;font-size: 100%&#125; /* Element Type Selector */ a &#123;text-decoration:none&#125; img &#123;border: 0&#125; &lt;/style&gt;&lt;/head&gt; 123456789&lt;head&gt; &lt;style type=\"text/css\"&gt; h1, h2, h3, h4, h5,h6&#123;font-wieght: normal&#125; /* Grouping: 여러 개의 요소(태그 선택자)를 일괄적으로 묶어주고, 일괄적으로 디자인해주는 것 */ a, img, p &#123;border:none&#125; h3 span, h4 span&#123;position:fixed:left:-2em&#125; &lt;/style&gt;&lt;/head&gt; 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; * &#123;margin:0:padding:0&#125;; /* Universal Selector(전체 선택자): HTML에 존재하는 모든 요소에 일괄적으로 스타일링 주고자 할 때*/ html body * &#123;text-decoration:none&#125; p.declation * &#123;text-transform:capitalize&#125; &lt;/style&gt;&lt;/head&gt; 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; p.note&#123;&#125; /* Class Selector(클래스 선택자) */ .floatLeft&#123;&#125; .positionAbs&#123;&#125; &lt;/style&gt;&lt;/head&gt; 12345678910&lt;head&gt; &lt;style type=\"text/css\"&gt; p.note.floatLeft&#123;&#125; /* Multi Class Selector(말 그대로 여러 개의 클래스가 붙은 선택자) 단락 요소(p)가 note라는 클래스와 floatLeft라는 클래스를 둘 다 가질 때 .note와 .floatLeft 사이에 띄면 X! */ .section.article&#123;&#125; .positionAbs&#123;&#125; &lt;/style&gt;&lt;/head&gt; 123456789&lt;head&gt; &lt;style type=\"text/css\"&gt; ul#nav&#123;&#125; /* ID Selector(아이디 선택자) Hash(#)값을 통해서 아이디를 선택하게 된다.*/ div#figure&#123;&#125; #site_info&#123;&#125; &lt;/style&gt;&lt;/head&gt; 123456789101112&lt;head&gt; &lt;style type=\"text/css\"&gt; p strong&#123;&#125; /* Descendant Selector */ /* '단락 내부에 있는 strong을 찾아서 꾸며주세요~'라는 뜻 */ ul li a &#123;&#125; /* 비순차 목록인 ul 내부의 li 요소를 찾은 다음에 a 요소 결국 꾸며지는 건 ul도 X, li도 X!! a요소를 최종적으로 찾은 다음에 꾸민다. 맨 마지막에 나오는 요소를 꾸민다. */ h3 span &#123;&#125; &lt;/style&gt;&lt;/head&gt; CSS 선택자(Selector) 요소 선택자 (Element Type Selector)figure { … } 그룹핑 (Grouping)a, abbr, .note, #about-css { … } -&gt; class도 묶어 줄 수 있다. 전체 선택자 (Universal Selector) { … } -&gt;*를 사용해서 모든 요소를 선택할 때 쓴다. 특정 영역 내에 있는 모든 요소를 선택할 때도 쓸 수 있다.ex) #about-css * {} -&gt; id가 about-css 속성값을 가진 내부의 모든 요소를 가리키게 된다.section이라든가 body는 포함되지 X. 클래스 선택자 (Class Selector) 대소문자 구분하기 때문에 반드시 확인해야 한다..class { … } 멀티 클래스 선택자 (Multi Class Selector)&lt;비교&gt; 띄어쓰기에 따라 의미가 완전히 달라진다..class1.class2 { … }: 하나의 요소가 2개의 클래스를 가진 형태 (멀티 클래스 선택자).class1. class2 { … }: class1을 가진 요소가 내부에 class2를 가지고 있을 때 쓴다. (자손 선택자) ex) .note.box {} -&gt;note라는 클래스 가진 요소 중에 box라는 클래스를 가지고 있다면, note와 box 클래스 2개가 모두 가지고 있다면~ 아이디 선택자 (ID Seletor): id값이 동일한 대상을 찾는다.#id { … }ex) #about-css {} -&gt; id가 about-css인 요소에 적용한다. 자손 선택자 (Descendent Selector): 클래스 or 아이디를 이용해서 꾸밀 수 있다.h1 abbr { … } -&gt; ‘h1이 포함한 abbr을 찾아서 꾸며주세요~’ 라는 뜻.note abbr { … } 자식 선택자 (Descendent Selector): 부모의 직접적인 자식만 나타낸다..parent &gt; .child { … } 자손 선택자 vs 자식 선택자 자손 선택자: ex) 아들, 손주 자식 선택자: 직계 자식만 선택할 수 있음. ex) 아들 123456ex1) &lt;h1&gt; &lt;strong&gt; &lt;strong&gt; &lt;abbr&gt; h1의 자손 선택자: &lt;strong&gt;, &lt;strong&gt;, &lt;abbr&gt; h1의 자식 선택자: 바로 밑의 &lt;strong&gt;만 해당 됨. 123ex2) body * &#123;&#125; : body 요소 내부의 모든 자손 선택 body &gt; * &#123;&#125; : body 요소 내부의 모든 자식(Child) 선택 속성 선택자 (Attribute Selector): 속성 선택자[] 앞에 아무것도 붙어있지 않다면. *가 생략되어 있다고 보면 된다. [id] { … } -&gt; id 속성을 가지고 있다면~ex)a[id] { … } -&gt; a요소가 id 속성값을 가지고 있다면~ [class] { … }[title] { … }[shape] { … } [shape][title]{ … } -&gt; shape과 title 속성을 둘 다 가지고 있다면~ [class=”note box”] { … } -&gt; 정확하게 “note box”라는 이름의 클래스를 찾기 때문에클래스명이 “box note”일 경우에는 찾을 수 X. -&gt; class의 경우에는.box {}.note {}가 좀 더 유연하게 사용할 수 있다. [id=”about-css] { … } -&gt; id값이 about-css라면~ 해당 요소를 선택해서 꾸며주게 된다.이걸 쉽게 쓰라고 만들어진 표현법이 hash(#) 표현법이다. #about-css { … } [class=”note”] { … }.note { … } ^=&quot;&quot;: ~로 시작하는 것ex)[title^=”Scalable”] { … } -&gt; title 요소 중, “”안의 Scalable이라는 단어로 시작하는 것을 모두 찾고 싶을 때 $=&quot;&quot;: ~로 끝나는 것ex)[title$=”Language”] { … } -&gt; title 요소 중, “”안의 Language이라는 단어로 끝나는 것을 모두 찾고 싶을 때 *=&quot;&quot;: ~를 포함하는 것ex)[title*=”Markup”] { … } -&gt; title 요소 중, “”안의 Markup이라는 단어를 포함하는 것을 모두 찾고 싶을 때 -&gt; CSS는 완벽하게 대소문자를 구분하기 때문에 “Markup”과 “markup”을 다르게 받아들인다. [href^=”http://“] { … } -&gt; href 속성값이 ^로 시작한다면, 속성값이 “http://“로 (“”안의 단어로) 꼭 시작해야 한다. [src$=”.svg”] { … } -&gt; .svg는 확장자임(‘.’으로 시작하므로) 확장자가 svg인 파일들을 이미지로 불러오는 모든 요소들을 찾게되는 것이다. [src*=”phone”] { … } -&gt; src에 포함된 단어 중에 “phone”이 들어간 걸 모두 찾아온다. 고급 속성 선택자 가상 클래스 선택자(Link Pseudo-class)a:link, a:visited{}anchor element가 기본적으로 가지고 있는 상태는 link element이다.1번 이상 방문한 사이트는 표시가 되어야 한다. -&gt; visited 방문했다는 가상클래스를 사용할 수 있다. a:hover, a:active{}hover: 마우스가 올라간 상태active: 마우스로 클릭한 순간 -&gt; 마우스 클릭한 걸 떼게 되면 active가 해제되는 것임 p:hover{} input:focus -&gt; focus가 된 상태input:focus:hover -&gt; focus가 된 상태에서 마우스가 올라가면(hover)~ [가상 클래스(Pseudo Class)] :link { … }:visited { … } :hover { … } hover는 마우스에 의존하는 속성:active { … } :focus { … }:focus:hover { … } -&gt; keyboard에 focusing이 간 상태에서 마우스가 올라가게 되면, 디자인이 변경된다. :focus:active { … } -&gt; focus가 된 후에 클릭이 될 때 디자인이 변경된다. 가상 클래스는 연이어서 사용할 수 있다. :first-child { … } :first-child는 :nth-child(1)과 같다. :last-child { … } 자식이 4개 라면 -&gt; last-child와 nth-child(4)와 같다.:nth-child(n) { … }()안에는 공식이 사용될 수 있다.1st2nd3rd4th5th…nth ex)link-list last-child(2n-1) {}link-list last-child(odd) {} 홀수 번째link-list last-child(2n) {}link-list last-child(even) {}짝수 번째CSS에서는 단축해서 홀수는 (odd),(even)을 사용한다.link-list last-child(3n) {}3의 배수 번째에만 :lang(ko) { … } ex) 디자인 상에서 한글과 영문은 각기 다른 디자인을 적용해달라는 요구가 있을 수 있음. 그 나라의 언어에 맞게 폰트를 변경할 떄 가상클래스를 사용하면 된다. :lang(en) {font-family: “Times New Roman”; &lt;!– 명조계열체 - -&gt;}:lang(ko-KR) {font-family: “Spoqa Han Sans”;&lt;!– 고딕계열체 - -&gt;} 가상 요소(Pseudo Element): 가상 클래스와는 다르다.: 1개 사용 -&gt; 가상 클래스vs :: 2개 사용 -&gt; 가상 요소::first-letter { … }::first-line { … }::before { … }::after { … }","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"선택자","slug":"선택자","permalink":"https://JihyeHwang09.github.io/tags/선택자/"},{"name":"selector","slug":"selector","permalink":"https://JihyeHwang09.github.io/tags/selector/"}]},{"title":"주니어 개발자가 기억 & 주의해야 할 점","slug":"to-remember-things-for-junior-developer","date":"2019-01-10T14:13:52.000Z","updated":"2019-02-09T03:48:33.651Z","comments":true,"path":"2019/01/10/to-remember-things-for-junior-developer/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/10/to-remember-things-for-junior-developer/","excerpt":"","text":"이번에는 주니어 개발자가 기억해야 할 것과 주의해야 할 점에 대해 정리해봅시다. 주니어 개발자가 기억해야 할 것프로그래머는 복잡성(complexity)와 항상 싸워야 한다. 함수, 클래스, 모듈로 나누고 주석도 잘 쓰면 복잡성이 내려간다. 복잡성을 낮춰야 하는 이유와 방법 큰 프로그램을 작성하기 위해 필요 유지보수를 위해 필요 코드를 작성하고 한참 뒤에 코드를 추가하거나 수정할 때 협업을 위해서 필요하다. 다른 프로그래머가 사용하기 쉽도록 프로그램의 구조 자체를 잘 짜야 한다. (다른 개발자가 작성한 프로그램을 파악하기 위해서 전체 코드를 다 읽어봐야 한다면 시간이 너무 오래 걸린다.) 디자인 패턴이 잘 짜여진 React.js, Angular.js, Vue.js와 같은프레임워크 또는 라이브러리를 사용하면,프로젝트의 복잡도를 관리하기 보다 수월해질 수 있으며,장기적인 관점으로 보았을 때 유지보수를 하는데 도움이 되는 것 같다. 협업을 하는 다양한 방식 ex1) 주로 대기업에서 사용하는 협업 방식: 폭포수(waterfall) 개발 방법론 절차: 기획 -&gt; 디자인 -&gt; HTML -&gt; CSS -&gt; JS 장점: 쇼핑몰 만드는 것처럼 크게 변경할 부분이 없는 경우(비슷한 방식을 반복하는 경우)에는 속도가 더 빠르다. 단점: 속도가 느리다. 앞 단계에서 결정된 사항을 바꾸기 어렵다. 3개월 프로젝트 시간이 주어지면, 1개월 기획, 1개월 디자인, 1개월 개발로 나눌 수 있다. ex2) 주로 스타트업 기업에서 사용하는 협업 방식: 애자일(Agile)(기능별로 나누는 방식) 로그인 게임판 점수판 3개월 프로젝트 시간이 주어진다면, 2주 동안 6번 로그인, 게임판, 점수판 기능을 기획부터 JS까지 반복하자. 개발자들도 기획이나 디자인 단계에 참여해서 의견을 내고 서로 질문을 주고 받는다. 장점: 개발 단계에서 수정 사항이 생겨도 결정된 사항을 바꾸기 쉽기 때문에 실험적인 도전을 할 수 있다. 제품을 빨리 만들고 수정 사항을 반영해서 바꾸기에 적합하다. 단점: 개발자들이 기획이나 디자인 단계에도 참여하기 때문에 개발자들이 시간을 굉장히 많이 소비하게 된다. 전문 영역이라는 게 부족해지게 된다. -&gt; 그 결과로 제품의 퀄리티가 떨어질 수 있다. 취업 전에 애자일(Agile) 도서를 꼭 1권 이상 읽고 취업할 것을 추천 주니어 개발자가 프로젝트 진행시 주의할 점 프로젝트를 할 때는 해야 하는 일과 하고 싶은 일을 구분해야 한다. 주니어 개발자 때는 소요 시간을 예상하기 쉽지 않다. 할 일 목록을 쭉 적어놓고 일정을 잡기 자신이 예상한 시간에 X 2 X 3을 해서 사장님께 말씀 드리기 ex) 내 예상으로는 3시간 걸리는 기능이라면 9시간 걸릴 것 같다고 하고 일정 잡기 버그를 잡는 데 시간이 오래 걸릴 수 있다. 기술 a를 적용할 수 있다고 생각했는데,a를 적용 못해서 기술 b를 새로 배워서 적용해야 하는 경우가 분명히 생긴다. 꼭 해야 되는 일부터 해야 한다. MVP(Minimum Viable Product)(최소 기능 제품)을 먼저 만든 후에 그 뒤에 하고 싶은 기능을 만든다. MVP를 세워뒀다고 해도 시간이 부족할 수 있다.항상 플랜 B를 세워둬야 한다.이것보다 기능이 적어도 기능이 있어서 클라이언트에게 납품할 수 있는 결과물을 넘겨줘야 하기 때문에 어느 선까지는 꼭 만들 것인지 정해둬야 한다. ex) 목표: 오목 게임 꼭 구현해야 하는 기능 클릭 반응 승자 판별","categories":[{"name":"개발자","slug":"개발자","permalink":"https://JihyeHwang09.github.io/categories/개발자/"},{"name":"면접","slug":"개발자/면접","permalink":"https://JihyeHwang09.github.io/categories/개발자/면접/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"interview","slug":"interview","permalink":"https://JihyeHwang09.github.io/tags/interview/"}]},{"title":"순환(Recursion)의 개념과 기본 예제3","slug":"recursion3","date":"2019-01-09T02:42:47.788Z","updated":"2019-01-21T03:47:33.193Z","comments":true,"path":"2019/01/09/recursion3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/09/recursion3/","excerpt":"","text":"이번에는 지난 포스트에 이어서, 순환적 알고리즘 설계 방법에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 순환적 알고리즘 설계적어도 하나의 base case, 즉 순환되지 않고 종료되는 case가 있어야 함 모든 case는 결국 base case로 수렴해야 함 암시적(implicit) 매개변수를 명시적(explicit) 매개변수로 바꾸어라. 순차 탐색 이 함수의 미션은 data[0]에서 data[n-1] 사이에서 target을 검색하는 것이다. 하지만, 검색 구간의 시작 인덱스 0은 보통 생략한다. -&gt; 즉, 암시적 매개변수이다. 이 함수는 시작 위치는 0으로 암시, 끝 위치는 명시되어 있다. 12345678910// \"배열의 데이터가 n개이니까 당연히 인덱스 0부터 시작하겠지.\"라고// 암묵적으로 동의한 것이므로 생략됨// 배열의 시작지점이 명시적으로 0이라고 표현되어 있지 Xint search(int [] data, int n, int target) &#123; for (int i = 0; i &lt; n; i++) &#123; if (data[i] == target) return i; &#125; return -1;&#125; 매개변수의 명시화: 순차 탐색 이 함수의 미션은 data[begin]에서 data[end] 사이에서 target을 검색한다. 즉, 검색구간의 시작점을 명시적(explicit)으로 지정한다. 시작 위치가 begin으로 명시, 끝 위치는 end로 명시되어 있다. 이 함수를 search(data, 0, n-1, target)으로 호출한다면, 위의 순차 탐색에서 예시로 든 search함수와 완전히 동일한 일을 한다. 1234567891011int search(int [] data, int begin, int end, int target) &#123; // begin &gt; end이면, 데이터가 0개이다. if (begin &gt; end) &#123; return -1; // begin = end는 데이터가 1개라는 뜻&#125; else if (target == data[begin]) &#123; // end를 찾을 필요 없이 begin을 return한다. return begin;&#125; else if &#123; return search(data, begin + 1, end, target);&#125; 순차 탐색: 다른 버전 이 함수의 미션은 data[begin]에서 data[end] 사이에서 target을 검색한다. 즉, 검색구간의 시작점을 명시적(explicit)으로 지정한다. 예제1123456789int search(int [] data, int begin, int end, int target) &#123; if (begin &gt; end) &#123; return -1; &#125; else if (target == items[end]) &#123; return end; &#125; else &#123; return search(data, begin, end-1, target); &#125;&#125; 예제212345678910111213141516int search(int [] data, int begin, int end, int target) &#123; if (begin &gt; end) &#123; return -1; &#125; else &#123; int middel = (begin + end) / 2; if (data[middle] == target) &#123; return middle; &#125; int index = search(data, begin, middle - 1, target); if (index != -1) &#123; return index; &#125; else &#123; return search(data, middle + 1, end, target); &#125; &#125;&#125; 매개변수의 명시화: 최대값 찾기 이 함수의 미션은 data[begin]에서 data[end] 사이에서 최대값을 찾아 반환한다. begin &lt;= end라고 가정한다. 12345678910int findMax(int [] data, int begin, int end) &#123; // base case: 데이터가 0개 일 경우가 X. 1개일 경우이다. // 데이터가 0개일 경우, 최대값이 정의되지 X 때문이다. // begin = end일 경우, 데이터가 1개이다. if (begin == end) &#123; return data[begin]; &#125; else &#123; return Math.max(data[begin], findMax(data, begin + 1, end)); &#125;&#125; 최대값 찾기: 다른 버전12345678910int findMax(int [] data, int begin, int end) &#123; if (begin == end) &#123; return data[begin]; &#125; else &#123; int middle = (begin + end) / 2; int max1 = findMax(data, begin, middle); int max2 = findMax(data, middle + 1, end); return Math.max(max1, max2); &#125;&#125; 이진 탐색(Binary Search) items[begin]부터 items[end] 사이에서 target을 검색한다. 12345678910111213141516171819202122public static int binarySearch(String[] items,String target, int begin, int end) &#123; // base case: 데이터의 개수가 0일 경우 if (begin &gt; end) &#123; return -1; &#125; else &#123; int middle = (begin + end) / 2; // Java에서 문자열끼리의 비교는 compareTo() 메서드를 이용한다. // cf) s1.compareTo(s2) 메서드는 문자열의 사전적 값을 비교 // s1 &lt; s2일 경우, 음의 정수를 반환 // s1 == s2일 경우, 0을 반환 // s1 &gt; s2일 경우, 양의 정수를 반환 int compResult = target.compareTo(items[middle]); if (comResult == 0) &#123; return middle; &#125; else if (compResult &lt; 0) &#123; return binarySearch(items, target, begin, middle -1); &#125; else &#123; return binarySearch(items, target, middle + 1, end); &#125; &#125;&#125;","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"순환 함수 - recursion","slug":"순환-함수-recursion","permalink":"https://JihyeHwang09.github.io/tags/순환-함수-recursion/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"순환적 알고리즘 설계","slug":"순환적-알고리즘-설계","permalink":"https://JihyeHwang09.github.io/tags/순환적-알고리즘-설계/"},{"name":"명시적 매개변수","slug":"명시적-매개변수","permalink":"https://JihyeHwang09.github.io/tags/명시적-매개변수/"},{"name":"explicit","slug":"explicit","permalink":"https://JihyeHwang09.github.io/tags/explicit/"},{"name":"순차 탐색","slug":"순차-탐색","permalink":"https://JihyeHwang09.github.io/tags/순차-탐색/"},{"name":"최대값 찾기","slug":"최대값-찾기","permalink":"https://JihyeHwang09.github.io/tags/최대값-찾기/"},{"name":"이진 탐색","slug":"이진-탐색","permalink":"https://JihyeHwang09.github.io/tags/이진-탐색/"},{"name":"Binary Search","slug":"binary-search","permalink":"https://JihyeHwang09.github.io/tags/binary-search/"}]},{"title":"순환(Recursion)의 개념과 기본 예제2","slug":"recursion2","date":"2019-01-08T10:16:09.508Z","updated":"2019-01-21T03:47:36.953Z","comments":true,"path":"2019/01/08/recursion2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/08/recursion2/","excerpt":"","text":"이번에는 지난 포스트에 이어서, 순환적으로 사고하기와 문자열의 길이 계산, 배열의 합 등의 예제에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 순환적으로 사고하기(Recursive Thinking)Recursion은 수학함수 계산에만 유용한가? 수학함수 뿐 아니라 다른 많은 문제들을 recursion으로 해결할 수 있다. 문자열의 길이 계산 문자열의 길이를 계산하고 싶다면, 첫 번째 문자열을 뺀 나머지 문자열의 길이를 계산 1을 더하면 된다. 12345678// base case: 문자열의 길이가 0인 경우// -&gt; 첫 번째 문자열이 존재하지 Xif the string is empty return 0;// 첫 번째 문자열을 제거한 그 문자열의 길이를 계산한 다음, 1을 더한다.else return 1 plus the length of the string that excludes the first character; 1234567int length(char *str) &#123; if (*str == '\\0') &#123; return 0; &#125; else &#123; return 1 + length(str + 1); &#125;&#125; 12345678910111213141516171819// 문자열 str을 입력받아 길이를 계산하는 메서드 lengthpublic static int length(String str) &#123; // base case: 문자열의 길이가 0인 문자열과 동일하다면 // -&gt; 즉, 문자열의 길이가 0라면 if (str.equals(\"\")) &#123; return 0; &#125; else &#123; // Java에서 substring(n)은 // index값이 n보다 작은(앞에 있는) 문자열을 제거한 문자열을 반환한다. // str.substring(1)은 // str에서 index값이 1인 위치 이후부터의 문자열을 가져온다. // -&gt; 즉, 입력받은 str에서 // index값이 0인 첫 글자를 제외한 문자열을 반환한다. // 1 + length(str.substring(1))는 그것의 길이를 계산한 다음, // 1을 더해서 반환한다. return 1 + length(str.substring(1)); &#125;&#125; 문자열의 프린트123456789101112// 입력한 하나의 문자열을 출력하는 메서드 printCharspublic static void printChars(String str) &#123; if (str.length() == 0) &#123; return; &#125; else &#123; // 문자열의 첫 글자를 화면에 출력한다. // Java에서 str.charAt(n)은 인덱스 n의 위치에 해당되는 문자를 추출해준다. System.out.print(str.charAt(0)); // 첫 글자를 제외한 나머지 문자열을 화면에 출력한다. printChars(str.substring(1)); &#125;&#125; 문자열을 뒤집어 프린트 이 문자열을 뒤집어 프린트하려면, 먼저 첫 글자를 제외한 문자열을 뒤집어 프린트 한다. 마지막으로, 첫 글자를 프린트 한다. 123456789101112public static void printCharsReverse(String str) &#123; // base case: 입력된 문자열 str의 길이가 0라면, 아무 일도 일어나지 X if (str.length() == 0) return; // 문자열의 길이가 1 이상이라면, else &#123; // 1. 먼저 첫 글자를 제거한 문자열을 화면에 뒤집어서 출력한다. printCharsReverse(str.substring(1)); // 2. 마지막으로, 원래 문자열의 첫 글자를 화면에 출력한다. System.out.print(str.charAt(0)); &#125;&#125; 2진수로 변환하여 출력12345678910111213// 음이 아닌 정수 n을 이진수로 변환하여 출력한다.public void printInBinary(int n) &#123; if (n &lt; 2) &#123; System.out.print(n); &#125; else &#123; // n을 2로 나눈 몫을 먼저 2진수로 변환하여 출력한다. // 마지막 비트를 제외한 나머지 비트가 표현하는 숫자이다. printInBinary(n/2); // n을 2로 나눈 나머지를 출력한다. // 마지막 비트를 표현하는 숫자이다. System.out.print(n%2); &#125;&#125; 배열의 합 구하기1234567891011121314// n개인 data의 합 구하기// data[0]에서 data[n-1]까지의 합을 구하여 반환한다.public static int sum(int n, int[] data) &#123; if (n &lt;= 0) return 0; else //sum(n-1, data) 을 호출하면, // data[0]에서 data[n-2]까지 데이터의 합을 구한다. // 그 후, 마지막 데이터인 data[n-1]을 더해준다. // recursion이 1씩 줄어들다가 0이 될 때, 빠져나온다. // -&gt; 무한루프에 빠질 일이 X return sum(n-1, data) + data[n-1];&#125; 데이터 파일로부터 n개의 정수 읽어오기실제로 자주 쓰는 코드 형태는 Xrecursion 예제로만 참고 123456789101112131415// Scanner in이 참조하는 파일로부터 n개의 정수를 입력받아// 배열 data의 data[0], ..., data[n-1]에 저장한다.public void readFrom(int n, int [] data, Scanner in) &#123; // base case: n이 0일 때는 아무것도 하지 X if (n == 0) &#123; return; &#125; else &#123; // 1. n-1개의 데이터를 읽어온다. // -&gt; data[0], ..., data[n-2]에 저장한다. readFrom(n-1, data, in); // 2. 마지막 한 개의 데이터를 읽어온다. // -&gt; 읽어온 데이터를 data[n-1]에 저장한다. data[n-1] = in.nextInt(); &#125;&#125; Recursion vs Interation 모든 순환함수는 반복문(interation)으로 변경 가능 그 역도 성립함. 즉, 모든 반복문은 순환함수(recursion)으로 표현 가능함 순환함수는 복잡한 알고리즘을 단순하고 알기쉽게 표현하는 것을 가능하게 함 하지만, 함수 호출에 따른 오버헤드가 있음(매개변수 전달, 액티베이션 프레임 생성 등)","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://JihyeHwang09.github.io/tags/알고리즘/"},{"name":"순환 함수 - recursion","slug":"순환-함수-recursion","permalink":"https://JihyeHwang09.github.io/tags/순환-함수-recursion/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"Computer Science","slug":"computer-science","permalink":"https://JihyeHwang09.github.io/tags/computer-science/"},{"name":"Algorithms","slug":"algorithms","permalink":"https://JihyeHwang09.github.io/tags/algorithms/"},{"name":"Recursion Function","slug":"recursion-function","permalink":"https://JihyeHwang09.github.io/tags/recursion-function/"},{"name":"수학적 귀납법","slug":"수학적-귀납법","permalink":"https://JihyeHwang09.github.io/tags/수학적-귀납법/"},{"name":"Mathematical Induction","slug":"mathematical-induction","permalink":"https://JihyeHwang09.github.io/tags/mathematical-induction/"},{"name":"Interation","slug":"interation","permalink":"https://JihyeHwang09.github.io/tags/interation/"}]},{"title":"순환(Recursion)의 개념과 기본 예제1","slug":"recursion1","date":"2019-01-07T08:51:43.427Z","updated":"2019-01-21T03:47:39.434Z","comments":true,"path":"2019/01/07/recursion1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/07/recursion1/","excerpt":"","text":"순환 함수란 무엇이며, 무한 루프에 빠지지 않으려면 어떤 경우가 존재해야 하는지 그리고 수학적 귀납법에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 순환이란? recursion은 항상 무한루프에 빠질까? 12345678910111213// 1 ~ n까지의 합을 구한다.int main() &#123; int result = func(4);&#125;int func(int n) &#123; if (n == 0) &#123; return 0; &#125; else &#123; return n + func(n-1); &#125;&#125; 무한루프에 빠지지 않으려면? &amp; recursion의 해석123456789101112// 이 함수의 mission은 0 ~ n까지의 합을 구하는 것이다.int func(int n) &#123; // Base case: 적어도 하나의 recursion에 빠지지 않는 경우가 존재해야 한다. // n = 0이라면, 합은 0이다. if (n == 0) return 0; else // Recursive case: recursion을 반복하다보면 결국 base case로 수렴해야 한다. // n이 0보다 크다면, // 0에서 n까지의 합은 0에서 n-1까지의 합에 n을 더한 것이다. return n + func(n-1);&#125; 순환함수와 수학적 귀납법정리: func(int n)은 음이 아닌 정수 n에 대해서 0에서 n까지의 합을 올바르게 계산한다.증명: n=0인 경우: n=0인 경우 0을 반환한다. 올바르다. 임의의 양의 정수 k에 대해서 n &lt; k인 경우, 0에서 n까지의 합을 올바르게 계산하여 반환한다고 가정하자. n = k인 경우를 고려해보자. func은 먼저 func(k-1) 호출하는데 2번의 가정에 의해서0에서 k-1까지의 합을 올바르게 계산하여 반환한다.메서드 func은 그 값에 n을 더해서 반환한다.따라서 메서드 func는 0에서 k까지의 합을 올바로 계산하여 반환한다. 12345678910111213141516171819package lec00.algorithm;public class Alg02 &#123; public static void main(String[] args) &#123; int n = 4; func(n); &#125; public static void func(int k) &#123; if (k &lt;= 0) return;// Base case: 적어도 하나의 recursion에 빠지지 않는 경우가 존재해야 한다. else &#123; System.out.println(\"Hello...\"); func(k-1);// Recursive case: recursion을 반복하다보면 결국 base case로 수렴해야 한다. &#125; &#125;&#125;// recursion이 항상 무한루프에 빠지는 것은 아니다. 123456789101112131415161718192021222324252627282930package lec00.algorithm;// 1 ~ n까지의 합을 구한다.public class Alg03 &#123; public static void main(String[] args) &#123; int result = func(4); System.out.println(result); &#125; public static int func(int n) &#123; if(n &lt;= 0) return 0; else &#123; return n + func(n-1); &#125; /* public static int func(int n) &#123;// 이 함수의 mission은 0~n까지의 합을 구하는 것이다. if (n == 0) return 0;// n=0이라면 합은 0이다. else return n + func(n-1);// n이 0보다 크다면 0에서 n까지의 합은// 0에서 n-1까지의 합에 n을 더한 것이다.&#125;*/ &#125;&#125; Factorial: n! 12345678int factorial(int n)&#123; if (n == 0) &#123; return 1; &#125; else &#123; return n* factorial(n-1); &#125;&#125; 정리: factorial(int n)은 음이 아닌 정수 n에 대해서 n!을 올바르게 계산한다.증명: n = 0인 경우: n=0인 경우 1을 반환한다. 올바르다. 임의의 양의 정수 k에 대해서 n &lt; k인 경우 n!을 올바르게 계산한다고 가정하자. n = k인 경우를 고려해보자. factorial은 먼저 factorial(k-1) 호출하는데 2번의 가정에 의해서 (k-1)!을 올바르게 계산하여 반환한다. 따라서 메서드 factorial은 k \\* (k-1)! = k!을 반환한다. 123456public static int factorial(int n)&#123; if (n == 0) return 1; else return n * factorial(n-1);","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://JihyeHwang09.github.io/tags/알고리즘/"},{"name":"순환 함수 - recursion","slug":"순환-함수-recursion","permalink":"https://JihyeHwang09.github.io/tags/순환-함수-recursion/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"Computer Science","slug":"computer-science","permalink":"https://JihyeHwang09.github.io/tags/computer-science/"},{"name":"Algorithms","slug":"algorithms","permalink":"https://JihyeHwang09.github.io/tags/algorithms/"},{"name":"Recursion Function","slug":"recursion-function","permalink":"https://JihyeHwang09.github.io/tags/recursion-function/"},{"name":"수학적 귀납법","slug":"수학적-귀납법","permalink":"https://JihyeHwang09.github.io/tags/수학적-귀납법/"},{"name":"Mathematical Induction","slug":"mathematical-induction","permalink":"https://JihyeHwang09.github.io/tags/mathematical-induction/"}]},{"title":"카르노 도표(KARNAUGH MAP)","slug":"karnaugh-map","date":"2019-01-06T13:53:35.896Z","updated":"2019-01-07T10:33:28.058Z","comments":true,"path":"2019/01/06/karnaugh-map/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/06/karnaugh-map/","excerpt":"","text":"부울함수의 간소화 방법 중의 하나인 카르노 도표(KARNAUGH MAP)에 대해 알아봅시다. 카르노 도표 방법 카르노 도표는 여러 개의 사각형으로 된 다이어그램 사각형은 각각 하나의 최소항이나 최대항을 의미 여섯 개 이하의 변수를 가진 부울함수에 사용 카르노 도표는 부울함수의 입력변수의 수에 따라서 기본 도표의 형태가 결정됨 입력변수의 수가 n인 경우를 n변수 카르노 도표라고 하며, 2^n개의 사각형으로 구성됨 카르노 도표를 이용하면, 정규형 부울 함수 -&gt; 표준형 부울함수로 간소화할 수 있음 카르노 도표를 이용해서 부울함수의 각 항들을 곱이나 합 형태로 간소화 최소항의 합 -&gt; 곱의 합 최대항의 곱 -&gt; 합의 곱 형태로 간소화 됨 최소항의 합형을 곱의 합형으로 간소화하는 순서 입력변수의 수 n에 따라 n변수 카르노 도표 작성(도표는 2^n개의 정사각형) 최소항의 인덱스에 대응되는 사각형을 1로 표시 1로 표시된 사각형들 중 서로 인접한 사각형끼리 묶음 (주의! 이때 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.) 각 묶음이 입력변수 각각에 대해 도표상의 어떤 위치에 있는지 파악 4)에서 구한 각 묶음에 대한 곱항들을 논리합(OR)으로 연결시키면, 간소화된 표준형(곱의 합형)이 구해진다. 최대항의 곱형을 합의 곱형으로 간소화하는 순서 입력변수의 수 n에 따라 n변수 카르노 도표 작성(도표는 2^n개의 정사각형) 최소항의 인덱스에 대응되는 사각형을 0으로 표시 0으로 표시된 사각형들 중 서로 인접한 사각형끼리 묶음 (주의! 이때 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.) 각 묶음이 입력변수 각각에 대해 도표상의 어떤 위치에 있는지 파악 4)에서 구한 각 묶음에 대한 합항들을 논리곱(AND)으로 연결시키면, 간소화된 표준형(합의 곱형)이 구해진다. 인접 사각형의 정의 카르노 도표에서 각 정사각형은 하나의 최소항(또는 최대항)을 의미 따라서, 인접 사각형이란 두 정사각형에 대응되는 각 최소항(또는 최대항)의 구성변수 중 다른 모든 변수는 동일하되 오직 하나의 변수만 서로 보수관계에 있을 때 두 정사각형은 서로 인접한다”라고 정의 ex) 입력변수가 X, Y, Z 3개의 경우 인접 사각형끼리 묶는 방법 한 묶음 내의 정사각형의 수는 2^n(n = 0, 1, 2... n)개가 되도록 묶는다. 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"카르노 도표","slug":"카르노-도표","permalink":"https://JihyeHwang09.github.io/tags/카르노-도표/"},{"name":"카르노 맵","slug":"카르노-맵","permalink":"https://JihyeHwang09.github.io/tags/카르노-맵/"},{"name":"karnaugh map","slug":"karnaugh-map","permalink":"https://JihyeHwang09.github.io/tags/karnaugh-map/"}]},{"title":"논리게이트(LOGIC GATE)","slug":"logic-gate","date":"2019-01-05T09:18:57.757Z","updated":"2019-01-07T10:28:28.084Z","comments":true,"path":"2019/01/05/logic-gate/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/05/logic-gate/","excerpt":"","text":"논리게이트(LOGIC GATE)의 종류에는 어떤 것들이 있는지와 각 논리게이트에 대한 기호, 진리표, 입출력 파형에 대해 알아봅시다. 논리게이트(LOGIC GATE)의 종류기본 논리게이트 AND 게이트 OR 게이트 NOT 게이트 NAND 게이트와 NOR 게이트 NAN 게이트 NOR 게이트 XOR 게이트와 XNOR 게이트 XOR 게이트 XNOR 게이트 논리게이트(LOGIC GATE)의 기호와 진리표, 입출력 파형1. 기본 논리게이트1) AND 게이트 반달 모양으로 표현 입력값이 둘 다 1일 경우에만 1이 출력되고, 나머지 경우에는 결과값이 0이 된다. 2) OR 게이트 반달 모양이되, 입력 부분이 움푹 들어간 모양으로 표현 입력값이 둘 다 0일 경우에만 결과값이 0이 되고,나머지 경우에는 결과값이 1이 된다. 3) NOT 게이트 세모 모양으로 표현, 출력부분에 작은 원을 그려준다. 입력값과 반대값이 출력된다. 2. NAND 게이트와 NOR 게이트1) NAND 게이트 AND 게이트의 반대 입력값이 둘 다 1일 경우에만 0이 출력되고, 나머지 경우에는 결과값이 1이 된다. 2) NOR 게이트 OR 게이트의 반대 입력값이 둘 다 0일 경우에만 1이 출력되고, 나머지 경우에는 결과값이 0이 된다. 반달 모양이되, 출력부분에 작은 원을 그려준다. 3. XOR 게이트와 XNOR 게이트1) XOR 게이트 입력값이 서로 다른 값이 들어온 경우에만 결과값이 1이 된다. 나머지 경우에는 0이 출력된다. 2) XNOR 게이트 입력값으로 서로 다른 값이 들어온 경우에만 결과값이 0이 된다. 나머지 경우에는 1이 출력된다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"논리게이트","slug":"논리게이트","permalink":"https://JihyeHwang09.github.io/tags/논리게이트/"},{"name":"logic gate","slug":"logic-gate","permalink":"https://JihyeHwang09.github.io/tags/logic-gate/"}]},{"title":"불 대수(Boolean algebra)","slug":"boolean-algebra","date":"2019-01-03T17:20:57.925Z","updated":"2019-01-07T10:30:50.797Z","comments":true,"path":"2019/01/04/boolean-algebra/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/04/boolean-algebra/","excerpt":"","text":"2진 디지털 시스템에서 입출력 관계를 표현하는 방법과 불 대수의 기본 개념 및 공식에 대해서 알아보고, 불 함수의 대수적 간소화에 대해서 공부해봅시다. 1. 2진 디지털 시스템에서 입출력 관계를 표현하는 방법1) 그래프나 진리표로 표시 2) 논리함수로 표시 입력에 따라 변수가 어떻게 변하는지를 나타내는 함수로 표현 입력이 2진 논리값이므로 논리함수로 나타낸다. 2. 불 대수의 기본 개념1) 불 대수(Boolean Algebra): 0과 1의 값을 갖는 논리변수와 논리연산을 다루는 대수 불 대수(Boolean algebra)는 하나의 명제가 참 또는 거짓인지를 판별하기 위해 이용되는 수학적 방법으로 19세기 중반 영국의 수학자 조지 불(George Boole)에 의해 개발되었다. 컴퓨터는 참과 거짓을 나타내기 위해 0과 1의 두 가지 상태로 표현하는 2진 논리회로로 구성되어 있다. 이러한 논리회로를 간략하게 표현할 때 불 대수가 사용된다. 2) 불 함수(Boolean Function): 논리변수의 상호관계를 나타내기 위해 불 변수, 불 연산기호, 괄호 및 등호 등으로 나타내는 대수적인 표현 AND 연산 입력값이 모두 1일 경우에만 결과값이 1이 된다. 표현법 X AND Y 또는 XY로 표현한다. 점으로 표시, 생략 가능 OR 연산 입력값 중 한 개라도 1일 경우 결과값이 1이 된다. 표현법 X OR Y 또는 X + Y로 표현한다. 덧셈 기호(+)로 표시 NOT 연산 입력값의 반대값이 출력된다. 표현법: NOT X 또는 X&#39;로 표현 변수 위에 줄(-)을 그어 표시 3. 불 대수의 기본 공식교환법칙, 결합법칙, 분배법칙, 드모르간의 법칙, 흡수 법칙 등을 이용하여회로를 쉽게 간소화할 수 있다. 4. 불 함수(논리식)의 대수적 간소화불 대수의 기본 공식을 이용해서 논리식을 간소화한다. 1) 합의 곱 표현을 곱의 합표현으로 변환한다. 합의 곱: (A + B)(C + D) 곱의 합: AC + AD + BC + BD 2) 공통 인수를 뽑아서 묶는다.3) 기본 공식 형태로 유도해서 식을 줄여 나간다.항 결합 X + X&#39; = 1이라는 성질을 이용한다. 문자 소거","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"boole","slug":"boole","permalink":"https://JihyeHwang09.github.io/tags/boole/"},{"name":"boolean algebra","slug":"boolean-algebra","permalink":"https://JihyeHwang09.github.io/tags/boolean-algebra/"}]},{"title":"Hexo를 이용한 블로그 만들기","slug":"hexo-blog","date":"2019-01-03T09:09:51.675Z","updated":"2019-01-06T14:35:43.749Z","comments":true,"path":"2019/01/03/hexo-blog/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/03/hexo-blog/","excerpt":"","text":"지난 포스트에서 정적블로그 플랫폼의 종류와 차이에 대해 소개했습니다.이번에는 Hexo를 이용한 블로그 만드는 방법에 대해 정리해봅시다. 1. Git, Nods.js 설치하기Hexo 블로그를 만들기 전, Git과 Node.js가 설치되어 있어야 합니다.Git과 Node.js가 이미 설치되어 있으신 분들은 2번부터 읽으시면 됩니다:) 1) Git 설치Git 다운로드 페이지 2) Node.js 설치Node.js 다운로드 페이지 2. GitHub 프로젝트(Repository) 만들기블로그의 포스트를 관리할 GitHub Repository를 만드는 과정입니다. GitHub 홈페이지 GitHub에 회원가입 후, 로그인을 합니다. 로그인 후, 우측 상단에 있는 초록색의 New를 눌러줍니다. Repository name에는 GitHub 계정명과 동일한 username을 사용하여 username.github.io로 작성한 후, Create repository 버튼을 누릅니다. 3. Hexo 설치하기 Git을 설치하면,Git Bash가 있으실 겁니다. 1) Git Bash를 실행시킵니다. 2) 터미널 화면에 $를 제외한 부분을 작성하고 Enter를 누르면,Hexo가 설치됩니다.1$ npm install -g hexo-cli 3) 블로그를 만들고 싶은 폴더 위치로 이동합니다. 그 후, 아래 코드를 입력합니다.blog 자리에 자신이 원하는 블로그 이름을 넣습니다.1$ hexo init blog 4) 자신이 원하는 폴더 위치에 blog 이름으로 된 폴더가 생성됩니다.현재 위치에서 블로그 이름으로 된 폴더로 이동합니다.1$ cd blog 5) npm을 설치합니다.1$ npm install 4. Hexo 실행해보기1$ hexo server 로컬서버인 http://localhost:4000로 접속하면, Hexo 블로그가 만들어진 것을 확인할 수 있습니다. Hexo 서버를 종료하려면, Ctrl + C를 눌러줍니다. Tip! 코드를 복사하고 싶은 경우에는 Ctrl + C가 아닌, Ctrl+Ins를 눌러줍니다. 5. Hexo 포스트 작성하기위와 같이 Hexo 설치가 완료되었다면, 이제 포스트를 작성해볼까요? 기본 명령어와 축약 명령어 중에 편하신 명령어를 입력해 줍니다. hexo new나 hexo n 뒤에는 포스트 제목을 적어줍니다. 1234$ hexo new firstpost// 기본 명령어$ hexo n firstpost// 축약 명령어 위의 명령어를 실행하여, firstpost.md라는 마크다운 파일을 생성합니다. 1$ code . 현재 생성된 firstpost.md파일을 Visual Studio Code로 열어줍니다. 위와 같은 디렉토리에 firstpost.md이라는 마크다운 파일이 생성된 것을 확인할 수 있습니다. firstpost.md 파일을 열면, 다음과 같이 작성되어 있습니다. 12345---title: firstpostdate: 2019-01-03 19:42:59tags:--- title은 자동으로 파일명과 똑같이 설정됩니다. 원하는 title로 수정한 후,아래의 ---의 다음 줄부터 마크다운 문법을 이용하여 글을 작성하시면 됩니다. 글 작성시, 실시간으로 포스팅한 모습을 확인하고 싶을 때는 터미널에 아래와 같은 명령어를 입력해줍니다. 1234$ hexo server// 기본 명령어$ hexo s// 축약 명령어 웹 브라우저에서 localhost:4000 경로로 접속하시면, 블로그의 모습을 실시간으로 확인할 수 있습니다. 포스트를 작성한 후, 실제로 서버에 올라갈 정적 페이지를 생성해줍니다. 1234$ hexo generate// 기본 명령어$ hexo g// 축약 명령어 터미널에서 위 코드를 실행하면, blog/public/ 디렉토리 아래에 실제 서버에 올라갈 웹페이지가 생성된 것을 확인할 수 있습니다. 6. GitHub과 Hexo를 연결해주기 로컬 외에 외부에서도 볼 수 있도록 서버에 올립니다. 1) GitHub에 Deploy 해 줄 플러그인을 설치합니다.1$ npm install --save hexo-deployer-git 2) Hexo 설정파일인 _config.yml를 열어서 #URL부분과 #Deployment부분을 수정해 줍니다. #URL부분을 위와 같이 수정해줍니다. #Deployment부분 역시 위와 같이 수정해줍니다. 3) GitHub 서버에 파일 올리기 터미널에서 명령어를 실행하여, GitHub 서버에 블로그 파일을 올려줍니다. 1234$ hexo deployment// 기본 명령어$ hexo d// 축약 명령어 Tip! 정적 페이지 생성과 배포를 함께 하고 싶다면, 아래 코드를 입력해줍니다.1$ hexo g -d 포스트 작성시 참고한 링크 [블로그 프레임워크 Hexo]:https://mechanickim.github.io/2018/03/17/20180317_blog_hexo/index.html [Github pages와 Hexo를 이용하여 블로그 만들기]:http://blog.lattecom.xyz/2016/06/28/hexo-blog-github-pages [GitLab Pages에 Hexo 블로그 설치하기]:http://inote.gitlab.io/2017/GitLab%EC%97%90%EC%84%9C%20Hexo%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0 [Hexo 블로그 만들기 1]:https://wonheesoo.github.io/2018/01/13/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-1-%EC%84%9C%EB%A1%A0-Hexo%EC%99%80-Github-Page-%EC%A1%B0%ED%95%A9%ED%95%98%EA%B8%B0 [Hexo, 정말 쉬운 블로그 프레임워크]:https://m.blog.naver.com/future_creator/220722153999 [Hexo로 Github 블로그 만들기]:https://medium.com/@dongmi.public/why-hexo-67070b1e0cc3 Reference [Hexo 공식 홈페이지 문서(한글)]:https://hexo.io/ko/docs/ [마크다운 문서 작성법]:https://gist.github.com/ihoneymon/652be052a0727ad59601","categories":[{"name":"Blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/categories/blog/"},{"name":"Hexo","slug":"blog/hexo","permalink":"https://JihyeHwang09.github.io/categories/blog/hexo/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/tags/blog/"},{"name":"framework","slug":"framework","permalink":"https://JihyeHwang09.github.io/tags/framework/"},{"name":"platform","slug":"platform","permalink":"https://JihyeHwang09.github.io/tags/platform/"},{"name":"hexo","slug":"hexo","permalink":"https://JihyeHwang09.github.io/tags/hexo/"},{"name":"Static Web Generator","slug":"static-web-generator","permalink":"https://JihyeHwang09.github.io/tags/static-web-generator/"},{"name":"git","slug":"git","permalink":"https://JihyeHwang09.github.io/tags/git/"},{"name":"node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"정적블로그 플랫폼(Static Web Generator)의 비교","slug":"blog-platform","date":"2019-01-02T08:09:11.680Z","updated":"2019-01-06T14:38:26.538Z","comments":true,"path":"2019/01/02/blog-platform/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/02/blog-platform/","excerpt":"","text":"정적 블로그 플랫폼 설명에 앞서,정적 웹페이지와 동적 웹페이지란 무엇이며 어떤 차이가 있는지를 살펴봅시다. 정적 페이지 VS 동적 페이지정적(static) 페이지 단순히 사이트 관리자가 미리 만들어놓은 웹 페이지를 볼 수 있는 사이트 데이터베이스(DB)를 사용하지 않음 Jekyll, Hexo, Hugo 등 동적(dynamic) 페이지 컨텐츠 내용이 서버에 있는 DB에 저장-&gt; 그 결과가 웹페이지에 반영되는 형태로 동작 일반적인 게시판 형태의 사이트들이 사용하는 방식 티스토리, 네이버 블로그 등 정적블로그 플랫폼(Static Web Generator)의 비교(Jekyll, Hexo, Hugo) Jekyll 특징 Ruby 기반 Github Page에 Git History 충돌 없이 포스트 버전관리 가능 GitHub Page는 Jekyll에 최적화되어 있음 한글 레퍼런스가 가장 많음 현재 가장 많은 사용자를 보유(Github 별 개수가 가장 많음) 단점 Ruby기반으로 초기 구축에 어려움이 있음(Ruby를 모르면, 플러그인 등 커스터마이징 하는데 불편할 수 있음) 윈도우 공식 지원 안됨 컴파일 속도가 느림 Hugo 특징 Golang 기반 컴파일 속도가 빠름(Jekyll, Hexo와 비교시 가장 빠름) 문서화가 잘 되어 있음 단점: 한글 레퍼런스가 거의 없음 Hexo 특징 자바스크립트(node.js) 기반 Node.js가 설치되어 있어야 하며, 기본적인 npm 사용 방법을 알아야 함 마크다운 문서로 만든 포스팅을 하는 방법이 간단함 윈도우 지원됨 컴파일 속도가 빠름 단점 Git으로 포스트 버전관리가 불가능함-&gt; 버전 관리를 위해서는 두 가지 브랜치를 따서 관리해야 함 Node.js의 템플릿 엔진을 그대로 사용 불가능(Github Page에는 Jekyll이 내장되어 있기 때문) 영어보다는 중국어로 된 질의응답이 많음 결론 앞서 살펴보았듯이 블로그 플랫폼 각각이 장단점을 가지고 있기 때문에우위를 따질 수는 없는 것 같습니다. 다만, 각 플랫폼의 장단점을 고려한 후, 본인에게 맞는 블로그 플랫폼을 선택하시는 게 좋겠죠:) 저는 비교적 익숙한 언어인 JavaScript 기반인 Hexo로 블로그를 시작하고, 차후에 Hugo로 이전을 고려해보는 방향으로 가닥을 잡았습니다. 포스트 작성시 참고한 링크 [정적 웹페이지 vs 동적 웹페이지]: http://snowdeer.github.io/blog/2016/03/21/static-dynamic-webpage [jekyll 블로그 프레임워크 비교, 왜 지킬인가? (feat. jekyll, hexo, hugo)]: https://qvil.github.io/blog/why-jekyll/#what [hugo + github 블로그 만들기 (feat. hugo &amp; github page)]: https://github.com/Integerous/Integerous.github.io [깃헙을 이용하여 호스팅하기]: https://www.slideshare.net/ssuser458523/ss-77033329 [정적 블로그, hexo 설치]: https://engineering.huiseoul.com/%EC%A0%95%EC%A0%81-%EB%B8%94%EB%A1%9C%EA%B7%B8-hexo-%EC%84%A4%EC%B9%98-f8df865a693a [웹의 이해 정적 페이지,동적 페이지 ]: http://coashanee5.blogspot.com/2017/07/blog-post_25.html","categories":[{"name":"Blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/categories/blog/"},{"name":"Hexo","slug":"blog/hexo","permalink":"https://JihyeHwang09.github.io/categories/blog/hexo/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/tags/blog/"},{"name":"framework","slug":"framework","permalink":"https://JihyeHwang09.github.io/tags/framework/"},{"name":"platform","slug":"platform","permalink":"https://JihyeHwang09.github.io/tags/platform/"},{"name":"Jekyll","slug":"jekyll","permalink":"https://JihyeHwang09.github.io/tags/jekyll/"},{"name":"hexo","slug":"hexo","permalink":"https://JihyeHwang09.github.io/tags/hexo/"},{"name":"Hugo","slug":"hugo","permalink":"https://JihyeHwang09.github.io/tags/hugo/"},{"name":"Static Web Generator","slug":"static-web-generator","permalink":"https://JihyeHwang09.github.io/tags/static-web-generator/"}]}]}