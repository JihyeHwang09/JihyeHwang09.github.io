{"meta":{"title":"꿈꾸는 지구별 개발자, Phang","subtitle":"꿈꾸는 지구별 개발자, Phang's IT Blog","description":"Phang's IT Blog using Hexo","author":"Phang","url":"https://JihyeHwang09.github.io"},"pages":[],"posts":[{"title":"CSS 배경(Background)","slug":"css-background","date":"2019-01-15T09:45:41.000Z","updated":"2019-01-15T10:11:51.461Z","comments":true,"path":"2019/01/15/css-background/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/15/css-background/","excerpt":"","text":"CSS 배경(Background)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. CSS 배경(Background) 스타일링Background Design 요소의 배경(background)은 요소의 content-box, border-box 아래에 있는 영역이다.(margin-box 제외)모던 브라우저에서는 배경을 차지하는 영역을 background-clip 속성을 사용하여 변경할 수 있다. background-color: 배경색을 설정한다. background-image: 요소의 배경에 표시할 배경 이미지를 지정한다. background-position: 배경이 요소 배경 안에 표시되어야 하는 위치를 설정한다. positionbackground-position: left|right top|bottom;기본값: left top 2) 좌표(pixel) background-position: x축 좌표 y축 좌표 ex) background-position: 200px 200px; percentagebackground-position: x축 y축 ex) background-position: 20% 0%;background-position: 100% 0%;오른쪽 끝 background-repeat: 배경을 반복할지 여부를 설정한다. background-repeat: repeat | repeat-x | repeat-y | no-repeat 기본값: repeat; repeat repeat-x: x축으로 배경 이미지 반복 repeat-y: y축으로 배경 이미지 반복 no-repeat: 배경 이미지 반복하지 X background-attachment: 내용이 스크롤 될 때 요소의 배경 동작을 설정한다. ex) background-attachment: fixed; 배경 이미지가 고정된 형태로 그 자리에 머물러 있음. background: 배경 속성을 모아 작성하는 속기법 모든 배경 속성을 묶어서 쓰고 싶을 때, background를 사용. transparent는 기본값이기 떄문에 안 넣어줘도 상관 X. background-size: 배경 이미지의 크기를 동적으로 조정할 수 있다.background-size: width height ex) background-size: 100px 100px; background-clip background-origin 123456789101112131415161718192021222324252627282930313233body &#123;&#125;#css-background &#123;&#125;.bg-image &#123; background: url(\"../images/NewYork-US.jpg\") no-repeat center -20px; &lt;!-- background-size: 100%쓰면 이미지가 다 들어오기는 한다. But 비율이 맞지 않는다. 이미지가 작을 경우, 늘려서 끼워맞춰지게 됨. -&gt; 이미지가 왜곡됨 --&gt; &lt;!-- background-size: contain; 사용 --&gt; background-size: cover; &lt;!-- 이미지를 늘려서 끼워맞추는 게 X. 원래 비율대로 이미지를 넣되, 커버를 씌우듯이 이미지 넣을 공간만큼만 이미지를 넣는 것임. --&gt;&#125;.is-floral &#123;&#125;.is-model &#123;&#125;.background-clip &#123;&#125;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"배경","slug":"배경","permalink":"https://JihyeHwang09.github.io/tags/배경/"},{"name":"background","slug":"background","permalink":"https://JihyeHwang09.github.io/tags/background/"}]},{"title":"자바스크립트 3일차","slug":"javascript3","date":"2019-01-15T09:19:29.000Z","updated":"2019-01-15T10:07:01.860Z","comments":true,"path":"2019/01/15/javascript3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/15/javascript3/","excerpt":"","text":"null과 undefined 값이 대입되지 않은 변수 혹은 속성을 사용하려고 하면 undefined를 반환 null은 ‘객체가 없음’을 나타낸다. 12typeof null; // 'object'typeof undefined; // 'undefined' 변수를 선언한 적이 있는지 확인하고 싶을 때에도 typeof 연산자를 사용하고, 이 때, 변수를 선언한 적이 없다면 &#39;undefined&#39;가 반환된다. 저장을 한 적이 없는지와 내가 ‘없음’이라는 사실을 저장했는지를 구분하기 위해서는 undefined를 저장하면 구분이 안되므로, 명시적으로(확 드러나게) ‘없음’을 나타내고 싶다면 항상 null을 사용하는 것이 좋다. (법칙은 아니고 관례임. ) 다만, 객체를 사용할 때 어떤 속성의 부재를 null을 통해서 나타내는 쪽보다는, 그냥 그 속성을 정의하지 않는 방식이 간편하므로 더 널리 사용된다. 12345678910111213141516// 이렇게 하는 경우는 많지 않습니다.&#123; name: 'Seungha', address: null&#125;// 그냥 이렇게 하는 경우가 많습니다.&#123; name: 'Seungha'&#125;// 어쨌든 이렇게 하지는 말아주세요.&#123; name: 'Seungha', address: undefined&#125; Null Checkstrict equality=== 엄밀한 비교.abstract equality== 추상적인 비교. null check를 할 때는 ==를 쓰는 것이 편리하다. 123456789101112131415null === undefined; // falsenull == undefined; // truenull == null; // trueundefined == null; // trueundefined == undefined; // truenull == 1; // falsenull == \"hello\"; // falsenull == false; // falseundefined == 1; // falseundefined == \"hello\"; // falseundefined == false; // false 즉, == 연산자는 한 쪽 피연산자에 null 혹은 undefined가 오면, 다른 쪽 피연산자에 null 혹은 undefined가 왔을 때만 true를 반환하고, 다른 모든 경우에 false를 반환한다. 따라서 null check를 할 때 만큼은 ==를 사용하는 것이 편합니다. 다른 모든 경우에는 ===를 사용하는 것이 좋다. 함수함수의 구성 요소매개변수와 인수 함수를 호출할 때 인수 자리에 변수를 써주면, 이 변수가 넘어가는 게 아니라 값이 넘어가는 것임. 이 표현식의 값이 넘어가는 것이지, 변수 자체가 넘어가는 게 X. 매개변수에는 재대입이 가능하다.(let으로 선언한 변수와는 미묘하게 다른 점이 있음.) 반환값 return 키워드 바로 다음에 오는 값이 함수 호출의 결과값으로 반환되며, 반환되는 즉시 함수 실행이 종료된다. 즉, return 다음에 오는 코드는 실행되지 않는다. return 뒤에 아무 값도 써주지 않거나, 아예 return 구문을 쓰지 않으면 함수는 undefined를 반환한다. 스코프 (Scope) 매개변수와 같이 함수 안에서 정의된 변수는 함수 바깥에서는 접근할 수 없기 때문에 함수 안에서만 사용할 수 있다. 즉, 변수는 코드의 일정 범위 안에서만 유효하다는 성질이 있다. 특정 변수가 유효한 코드 상의 유효 범위를 가지고 스코프(scope)라고 합니다. 매개변수는 함수 스코프를 갖습니다. 즉, 함수의 중괄호 안에서만 유효하다. 스코프 연쇄 (Scope Chain) 중첩된 스코프 안에서는 바깥 스코프의 변수를 가져다 쓸 수 있다. 코드의 실행 흐름이 변수 이름에 도달하면, 그 변수와 같은 이름을 갖는 변수를 현재 스포크에서 찾아보고, 만약 없으면 바로 바깥쪽, 없으면 바같쪽 스코프로 올라가서 계속 찾아보는 과정이 되풀이 된다. 바깥 스코프에서 찾을 때는 부모-부모-부모 …를 찾는 것이지, 다른 함수 안에서만 쓰인 변수를 가져다 쓸 수는 X. 가장 바깥에 있는 스코프를 최상위 스코프(top-level scope) 혹은 전역 스코프(global scope)라고 부른다. 12345678const five = 5;function add5(x) &#123; function add(y) &#123; `return` x + y; &#125; `return` add(five);&#125;add5(3); // 8 reference Error같은 게 뜨면, 내 변수가 스코프 안에서 잘 들어있는지 확인할 것! 변수 가리기 (Variable Shadowing) 안쪽 스코프의 변수가 바깥쪽 스코프에 있는 변수를 가리는 현상을 말한다. 바깥 스코프와 상관없이 매개변수를 자유롭게 사용할 수 있게끔 하는 성질이다. 바깥 스코프에 있는 변수를 일일히 기억하지 않고 사용하고 싶은 매개변수를 자유롭게 사용할 수 있도록 이런 성질이 존재한다. 123456789101112const x = 3;function add5(x) &#123; // `x`라는 변수가 다시 정의됨 function add(x, y) &#123; // `x`라는 변수가 다시 정의됨 `return` x + y; &#125; `return` add(x, 5);&#125;add5(x); 어휘적 스코핑 (Lexical Scoping) 스코프는 코드가 작성된 구조에 의해서 결정되는 것이지, 함수 호출의 형태에 의해 결정되는 것이 아니다. 12345678910function add5(x) &#123; const five = 5; `return` add(x);&#125;add5(3); // 8function add(x) &#123; `return` five + x; // ReferenceError: five is not defined&#125; add라는 함수가 add5라는 함수 안에서 호출되었다고 해서, add 함수 내부에서 add5 함수의 스코프 안에 있는 변수에 접근할 수 있는 것은 아니다. 스코프는 코드가 작성된 구조에 의해 결정되는 성질이다. 위 코드를 동작시키려면, 아래와 같이 작성해야 한다. 1234567function add5(x) &#123; const five = 5; function add(x) &#123; `return` five + x; &#125; `return` add(x);&#125; 값으로서의 함수 JavaScript에서는 함수도 값이다. cf) filter는 함수를 인수로 넘겨줘야 사용할 수 있는 메소드. 원본 배열을 변경시키지 X. 새 배열을 반환함. &#39;일급 객체&#39;라는 용어는 면접에 종종 나옴 자바스크립트의 객체는 일급 객체다. 조건: 변수나 데이터 구조안에 담을 수 있다. 파라미터로 전달 할 수 있다. 반환값(return value)으로 사용할 수 있다. 할당에 사용된 이름과 관계없이 구별이 가능하다 동적으로 프로퍼티 할당이 가능하다cf) c나 java의 함수는 일급 함수가 아니다. url(https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4) 익명 함수 (Anonymous Function) JavaScript에서 함수를 선언할 때 꼭 이름을 붙여주어야 하는 것은 아니다. 이름을 붙이지 않은 함수를 가지고 익명 함수(anonymous function)라고 한다. 익명 함수는 함수를 만든 쪽이 아니라 다른 쪽에서 그 함수를 호출할 때 많이 사용된다. 화살표 함수 (Arrow Function) function keyword 함수는 값을 반환하려면 반드시 return을 사용해야 한다. 화살표 함수의 경우 중괄호가 없으면 바로 반환이 된다. 코드의 길이나 표기법이 굉장히 간단해진다. 화살표 함수는 익명 함수 밖에 없다. 이름이 있는 화살표 함수는 없다. 123456789// 바로 반환시키지 않고 function 키워드를 통한 함수 정의처럼 여러 구문을 사용하려면 curly braces(&#123;...&#125;) 로 둘러싸주어야 한다.// `=&gt;` 다음 부분을 **중괄호로 둘러싸면**, 명시적으로 ``return`` 하지 않는 한 아무것도 반환되지 않습니다.const add = (x, y) =&gt; &#123; const result = x + y; `return` result;&#125;;//매개변수가 하나밖에 없다면, 매개변수 부분의 괄호를 쓰지 않아도 된다.const negate = x =&gt; !x; cf) function keyword 함수 vs 화살표 함수 비교 123[1, 2, 3, 4, 5].filter(function(x) &#123; `return` x % 2 === 0;&#125;); // [2, 4] 1[1, 2, 3, 4, 5].filter(x =&gt; x % 2 === 0); 제어 구문 if...else 구문에서 중괄호 내부에 있는 구문이 하나라면, 중괄호를 생략할 수 있으나 나중에 문장을 추가할 수도 있으니 항상 중괄호를 쓰는 습관을 들이자. switch 바로 뒤의 괄호의 값: ‘코드 실행 여부를 판별할 기준이 되는 값’, 이 기준이 되는 값과 case 바로 뒤에 오는 값이 일치하면 콜론(:) 뒤의 코드 영역이 실행된다. -case쪽의 코드 영역 마지막에 break를 써주지 않으면, 해당 case가 실행될 때 바로 뒤의 case 코드 영역이 뒤이어 실행되게 된다. -&gt; case문에 break를 꼭 써줘야 한다!! 1234567891011121314151617181920function translateColor(english) &#123; let result; switch (english) &#123; case \"red\": result = \"빨강색\"; break; // 이 break를 생략할 경우, 'red'를 넣었을 때 ,result = '빨강색';후에 result = '파랑색';으로 실행흐름이 넘어가서 '파랑색'이 결과값으로 나온다. case \"blue\": result = \"파랑색\"; break; case \"purple\": case \"violet\": // 이 코드 영역은 english 변수의 값이 'purple'일 때와 'violet'일 때 모두 실행됩니다. result = \"보라색\"; break; default: result = \"일치하는 색깔이 없습니다.\"; &#125; `return` result;&#125; do…while 구문 do…while 구문은 while 구문과 사용법은 크게 다르지 않으나, 내부 코드를 무조건 한 번은 실행시킨다는 차이점이 있다. 절대 true가 될 수 없는 구문을 무조건 한 번은 실행시킬 수 있다. 배열의 순회 배열의 각 항목을 방문하면서 차례대로 도는 것을 말한다. forEach메소드 - 배열의 각 항목을 차례대로 실행시키고 싶을 때 사용하는 메소드(ES5에 추가된 문법임) 12345const arr = [1, 2, 3, 4, 5];arr.forEach((item, index) =&gt; &#123; console.log(`배열의 $&#123;index + 1&#125; 번째 요소는 $&#123;item&#125; 입니다.`);&#125;); for 구문의 종류 for for...in 구문 for...of 구문 12345678910const arr = [1, 2, 3, 4, 5];for (let item of arr) &#123; console.log(`현재 요소는 $&#123;item&#125; 입니다.`);&#125;// 현재 요소는 1 입니다.// 현재 요소는 2 입니다.// 현재 요소는 3 입니다.// 현재 요소는 4 입니다.// 현재 요소는 5 입니다. arr의 요소(item)들이 순서대로 item이라는 변수에 들어가면서 차례대로 실행됨. break, continue12345678910111213alert(\"퀴즈를 시작합니다.\");while (true) &#123; const answer = prompt(\"빨강의 보색은 무엇일까요?\"); if (answer === \"초록\") &#123; alert(\"정답입니다! 🎉\"); break; // 루프를 종료하고 다음 코드로 넘어감 // break를 만나면 while 구문 아예 바깥으로 빠져나오게 됨. 따라서 정답인 // 초록을 입력했을 때는 정답입니다!를 출력하고 while문을 빠져나가서 alert('퀴즈가 끝났습니다.')로 실행흐름이 옮겨간다. &#125; else &#123; alert(\"틀렸습니다! 다시 시도해보세요.\"); &#125;&#125;alert(\"퀴즈가 끝났습니다.\"); continue를 만나면, 나머지 코드를 실행하지 않고 루프의 처음으로 되돌아가는 효과가 있다. 반복문의 시작(조건문)으로 돌아가게 된다. break는 break를 둘러싸고 있는 가장 가까운 루프만 종료시킨다. 가장 바깥의 루프까지 다 빠져나오는 게 X. 함수를 즉시 종료하기 return과 throw는 함수의 나머지 코드를 건너뛰고 함수를 즉시 종료시킨다는 걸 기억하라! switch구문을 쓸 때는 break를 써야 하지만, return이 있으면 함수의 나머지 코드를 건너뛰고 함수를 즉시 종료시킨다. 함수의 나머지 코드를 건너뛰고 즉시 종료시키는 결과를 낳기 때문에 break를 더 추가해서 쓸 필요가 X.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 2일차","slug":"javascript2","date":"2019-01-14T12:06:43.000Z","updated":"2019-01-14T12:34:41.808Z","comments":true,"path":"2019/01/14/javascript2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/14/javascript2/","excerpt":"","text":"string 타입문자열 리터럴 &#39;&#39; &quot;&quot; &#39;&#39;backtick(backquote) 따옴표는 표기법일 뿐, 실제 저장되는 값에 영향을 미치지는 X. ‘’ 안에 “”는 쓸 수 O “” 안에 ‘’는 쓸 수 O ‘’안에 ‘’는 쓰면 X. “”안에 “”는 쓸 수 X. -&gt; 서로 다른 따옴표는 안에 중첩되서 자유롭게 쓸 수 있다. 템플릿 리터럴 (Template Literal) ${} 변수 안에 들어있는 값이 문자열의 값으로 바꿔치기 됨. 동적으로 삽입하고 싶을 때 사용한다. 템플릿은 빈칸을 만들어두고 삽입할 때 사용하는 거니까 템플릿 리터럴이라고 부른다. 여러 줄로 이루어진 문자열을 쉽게 표현할 수 있다. 이 외의 경우에는 ‘’나 “”를 사용한다. 1234const name1 = \"Foo\";const name2 = \"Bar\";const sentence = `$&#123;name1&#125; meets $&#123;name2&#125;!`;console.log(sentence); 12345678`helloworldhellojavascript!`;// 일반적인 문자열 리터럴로는 아래와 같이 해야 합니다.(\"hello\\nworld\\nhello\\njavascript!\\n\"); Escape Sequence 잠깐 문자열 문법에서 탈출해서 표기를 한다는 뜻 \\ 하나를 넣었는데 잘 안될 경우, \\ 를 넣어볼 것.(\\ 하나 넣으면 잘 안될 때가 있음.) \\r\\n: 윈도우 개행문자 \\n: 맥, 리눅스 개행문자 운영체제에 따라 개행문자가 다르기 떄문에 협업할 때 문제가 생길 수 있다.(프로젝트 전에 통일할 필요가 있다.) &#39;&#39;안에 개행문자를 넣고 싶다면 \\n을 쓰자. 유니코드 문자는 Unicode Code Point를 가지고 문자를 넣을 수 있다. ‘\\uac00’로 ‘가’를 입력하든지 ‘가’ 문자열로 입력하든지 같은 것임. 이모티콘도 이제 유니코드에 포함되면서 정식 문자로 인정 받음. \\uXXXX: 4자리수 유니코드 문자 \\u{X...}: 5자리수 유니코드 문자 1console.log(\"\\u&#123;1F435&#125;\"); // 🐵 연산에서 문자열이 하나라도 들어있다고 해서 다 문자열로 변환되는 게 X. 문자열 이어붙이기를 할 때는 주의해야 함. 이럴 때는 템플릿 리터럴을 사용하는 것이 좋다. 1234\"number\" + 1 + 3;// =&gt; 'number13' 덧셈은 왼쪽부터 계산되니까 'number' + 1 먼저 계산됨.1 + 3 + \"number\";// =&gt; '4number' 연산 순서만 바뀌었는데 숫자 덧셈 계산이 먼저 일어나서 4가 되고 뒤에 문자열 'number'가 붙는다. 부등호로 문자열을 비교하면 유니코드 코드포인트의 크기를 기준으로 비교를 한다. 사전순 비교를 하고 싶을 때는 localeComapare 메서드를 사용한다. .localeComapare() 문자열을 배열로 바꾸기 12[...'hello'];&lt;!-- ['h', 'e', 'l', 'l', 'o'] --&gt; (최근에 추가된 기능). 객체나 배열에 대해서도 쓸 수 있는 연산자. 쓰임이 많음. MDNMDN 문서를 읽을 때 주의할 점 번역의 품질이 굉장히 떨어지는 경우가 있음. 번역된 버전이 옛날 버전인 경우를 주의해야 함. 되도록 영어 버전으로 읽는 게 좋다. 한국어 번역이 좋지 않을 경우 -&gt; 영어쪽으로 가서 번역기로 돌려서 비교해보면서 읽어볼 것. MDN 빠르게 mdn 문서에 접근하고 싶을 때: https://devdocs.io/ 개발 문서에서 사용하는 영어 문서에 사용되는 영어 단어나 문법은 많지 않다. 읽는 연습을 꾸준히 할 것. 속성 및 메소드 공백도 문자열로 취급함.‘hello javascript’.indexOf(‘java’); ‘hello javascript’.indexOf(‘python’); 예전에는 indexOf의 결과값이 -1인지 아닌지를 판별함으로써 문자열을 포함하고 있는지 여부를 판단했으나, includes 메소드가 나오면서 includes로 판별함. 문자열의 일부를 잘라낸 새 문자열 생성하기 1\"hello\".slice(2, 4); // 'll' 틈에다가 번호를 매긴다고 생각하면 쉽다. 끝까지 자르고 싶다면, 뒷자리 인수를 안주면 됨. 1-\"hello\".slice(2); // 2번째 자리부터 끝까지 자르겠다. slice 메소드는 원본 문자열을 변경하지 X! 12\"abc@gmail.com\".split(\"@\")[0];// =&gt; 'abc'.split한 후에 다 배열이기 떄문에 바로 뒤에 대괄호로 index 번호를 주면 배열안에 있는 값을 가져올 수 있다. split은 원본 데이터를 변경하지 X. toLowerCase, toUpperCase 대소문자 관계없이 비교하고 싶을 때 주로 사용함. 게시물 검색 기능에서 사용자가 소문자를 입력했다고 해서 대문자로 된 게시물을 보여주지 않으면 안되므로 유니코드와 UTF-8, UTF-16 문자열은 JavaScript 내부적으로 UTF-16 형식으로 인코딩된 값으로 다뤄진다. 유니코드와 UTF-8을 헷갈리면 안됨! 유니코드 - 문자 정보 데이터베이스, 문자 집합, 문자 인코딩 등 전 세계의 UTF-8은 인코딩 방식. 유니코드를 위한 가변 길이 문자 인코딩 방식 중의 하나임. 컴퓨터 내부적인 메모리 상에 저장할 때는 프로그래밍 해석기 안에서 계산을 할 때는 UTF-16으로 하는 게 UTF-8보다 더 속도가 빠름. (UTF-8처럼 압축하는 게 아니라 그대로 저장하므로) 웹에서는 UTF-8을 사용하는 게 약속임. 유니코드가 실무에서 중요한 건 아니지만, 면접에서 종종 물어봄. 유니코드가 무엇인지 UTF-8과 UTF-16의 장단점 boolean 타입논리연산자 !true not ture라고 읽음. !false not false라고 읽음. 긴 식 앞에 !를 사용할 수 있다. 삼항 연산자 (ternary operator) if else구문보다 축약된 느낌. 12345const result = if (true) &#123; 1&#125; else &#123; 2&#125; 1const result = true ? 1 : 2; if로 둘러싸여진 전체는 표현식이 X. 삼항연산자는 표현식임. if else구문에는 여러 개의 명령이 올 수 있지만, 삼항연산자에는 여러 개의 명령이 올 수 X. 특정 조건을 만족할 때 어떤 결과값을 바로 반환하고 싶다. -&gt; 삼항연산자 사용 특정 조건을 만족할 때 여러 개의 명령을 실행하고 싶으면 -&gt; if else 구문 사용 react할 때 삼항연산자를 많이 사용함. 연산자 우선순위 (Operator Precedence) &amp;&amp;와 ||에는 우선순위가 있기 떄문에 주의해야 함. 이 우선순위 때문에 버그가 생길 수 있음. 논리 연산의 여러 가지 법칙1!!a === a; not을 2번 붙이면 원래대로 돌아옴 // 분배 법칙 12* a || (b &amp;&amp; c) === (a || b) &amp;&amp; (a || c);* a &amp;&amp; (b || c) === (a &amp;&amp; b) || (a &amp;&amp; c); 우변에 잇는 식을 짧게 코드를 사용하고 싶을 때 좌변에 있는 식을 사용함. 논리 연산의 여러 가지 법칙들을 표를 그려서 확인해보기 truthy &amp; falsy true로 취급되는 값: truthy false로 취급되는 값: falsy falsy로 취급되는 값 꼭 외울 것! 이 외의 모든 값들은 truty이다. falsy로 취급되는 값 false null undefined 0 NaN &#39;&#39; cf) truthy에는 객체, 배열 등도 다 포함됨. (심지어 배열이 비어있더라도 truty임. ) 12345678910111213const input = prompt(\"이름이 무엇인가요?\")if (input) &#123;&lt;!-- truthy와 falsy의 성질을 이용해서 if의 조건식 부분에 input은 truethy라는 성질을 이용해서 짧게 코드를 줄일 수 있음. --&gt; alert(`안녕하세요, $&#123;input&#125;님!`)&#125; else &#123; alert('이름을 입력해주세요.')&#125;// if (input.length &gt; 0) &#123;// alert(`안녕하세요, $&#123;input&#125;님!`)// &#125; else &#123;// alert('이름을 입력해주세요.')// &#125; truthy와 falsy의 성질을 이용하면 편하지만, 논리의 허점이 생길 수 있다. 자바스크립트는 타입 체크를 하지 않는 언어임. 1234567function add(x, y) &#123; if (typeof x === \"number\" &amp;&amp; typeof y === \"number\") &#123; return x + y; &#125; else &#123; throw new Error(\"x 혹은 y의 타입이 number가 아닙니다.\"); &#125;&#125; javascript의 타입을 체크하는 방법 매번 이렇게 타입 체크하는 조건식을 쓸 수 없으므로 요즘은 타입스크립트를 많이 사용함. 타입스크립트는 타입 체크가 되는 자바스크립트의 확장 언어임. 대개 실무에서는 타입 스크립트를 많이 사용한다. throw하면 에러가 나면서 나머지 코드가 실행되지 X. 정적 타이핑 언어(statically-typed language) c, c++, java 등 동적 타이핑 언어(dynamically-typed language) javascript, python, ruby등 다른 타입의 값을 진리값으로 변환하기123456!\"hello\"; // false!!\"hello\"; // true// 'hello'가 truthy이기 때문에(true로 취급되었기 떄문에)!NaN; // true!!NaN; // false toString: 숫자를 문자열로 변환하는 메소드 12// if (str.includes('3' || '6' || '9')) &#123;// &#125; 틀린 것임. ‘3’이 truthy이기 떄문에 결과값이 ‘3’으로 나와버림.따라서 조건식을 이렇게 쓰면 X!!.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"CSS 타이포그래피(Typography)","slug":"css-typography","date":"2019-01-14T12:06:34.000Z","updated":"2019-01-14T12:42:49.713Z","comments":true,"path":"2019/01/14/css-typography/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/14/css-typography/","excerpt":"","text":"CSS 타이포그래피(Typography)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. CSS 타이포그래피(Typography)폰트(Fonts) 스타일 속성 폰트에 영향을 주는 속성으로 적용되는 모양, 크기, 굵기, 기울임 등. font-family: 글자 모양 font-size: 글자 크기 font-weight: 글자 굵기(두께) font-style: 글자 기울임 font-variant: 소문자를 작은 대문자로 바꾸는 속성 ※ 글자 색상은 color 속성으로 설정. color keywords: red, green, blue, pink, black hex color code: #RRGGBB / 0 ~ 9, a ~ f 예) #1868a7 rgb VS rgba의 차이 rgba는 불투명도까지 나타낸다. 각 256가지 색을 나타내고, 0부터 시작하기 떄문에 번호는 256까지 X. 256-1인 255까지가 정상적인 색으로 나옴! rgb, rgba: RED, GREEN, BLUE, ALPHA 예) rgba(127,255,0,1): a가 1이면 불투명한 색 rgba(127,255,0,0.3): a가 0.3이면 반투명한 색 hsl, hsla HUE(각도), `ATURATION(채도), LIGHTNESS(명도), ALPHA (투명도) 1hsla(360,60%,70%,1) saturation(채도): 100%면 순색(원색)에 가까움. lightness(명도): 0%에 가까우면, 검정색 100%에 가까우면, 흰색임. 웹브라우저는 운영체제가 지원하는 기본 폰트(웹 안전 폰트)만화면에 렌더링 한다. (참고: cssfontstack.com) 즉, 사용된 폰트가 사용자 컴퓨터에 없으면 렌더링 X. 웹 안전 폰트 Arial [sans-serif]: 고딕체 Verdana [sans-serif]: 고딕체 Courier New [monospace]: 코드체(공간이 동일) Georgia [serif]: 명조체 Times New Roman [serif]: 명조체 Trebuchet MS [serif]: 명조체 하지만 웹 안전 폰트만으로 디자인 하는 디자이너는 없다!Helvetica는 디자이너가 애용하는 폰트이지만…Windows는 기본 지원하지 않는다. (Mac OSX는 지원) ※ 비주얼 디자인 과정에서 적용 가능한 웹폰트를 사용해야 한다.폰트 저작권에 주의! (참고: hyundaicard.com) ※ 저작권 걱정 없는 폰트fonts.google.comgoogle.co.kr/search?q=무료+웹폰트 텍스트(Text) 레이아웃 속성 텍스트 간격 및 레이아웃 기능에 영향을 주는 속성으로 행간, 자간, 어간, 정렬, 변형, 꾸밈, 그림자 사용자가 읽기 편한 간격: 자간 &lt; 어간 &lt; 행간 순으로 넓어야 한다.-&gt; 염두에 두고 디자인할 것! line-height줄 높이를 정하는 속성 default: 1.25임. 1.5이상 줘야 글을 읽기가 용이해짐. 1ex)line-height: 1.5; letter-spacing 글자 사이의 간격(자간) default값: 0 1ex)letter-spacing: -0.024em; word-spacing 단어 사이의 간격픽셀 단위나 em으로 조정할 것 12ex)word-spacing: 1px;word-spacing: 0.02em; text-align 정렬 default값: 왼쪽 123456ex)text-align: center;/* 가운데 정렬 */text-align: right;/* 오른쪽 정렬 */text-align: left;/* 왼쪽 정렬 */ text-indent 들여쓰기 +값, -값 사용할 수 있음. +: 오른쪽으로 들여쓰기됨. -: 왼쪽으로 내어쓰기됨. 1234ex1)text-indent: 1em;/* 각 문단의 첫째줄만 들여쓰고 싶을 때 */cf)padding-left: 1em;/* 텍스트 전체를 들여쓰고 싶을 때 */ text-transform 대문자로 또는 소문자로 바꾸는 속성 1234text-transform: `uppercase`;/* 모두 대문자로 바꿈 */text-transform: lowercase;/* 모두 소문자로 바꿈 */ text-decoration 선으로 텍스트를 꾸미는 속성 12345678ex) text-decoration: underline;/* 밑줄 치기 글자를 판독하기 어렵게 하기 때문에 권장되지 X.*/text-decoration: overline underline line-through;text-decoration: overline /* 위에 공간을 만들어서 줄을 그어줌. */text-decoration: line-through;/* -&gt; 글씨 중간에 취소선을 그어줌. */ text-shadow 그림자x축 y축 blur sprea color; 12ex1)text-shadow: 4px -3px 10px #9bdbde;ex2)text-shadow: 0px 3px 10px #943978; white-space 공백을 처리하는 방법 white-space: pre white-space: pre-line; white-space: nowrap; nowrap은 가로 한줄로 쭈욱~ 나열됨. 단어의 분리를 어떻게 할 것인지 결정 (공백/띄어쓰기) 수고했어 오늘도(음절) 수 고 했 어 오 늘 도 word-break: break-all; 박스의 가로 영역을 넘친 단어 내에서임의의 분리 여부를 결정하여 줄바꿈에 관여 word-wrap 긴 단어 처리하는 방법 default: normal normal: 글자가 길어도 끊어지지 않고 한 줄에 나타냄 break-word: 강제로 끊어서 줄바꿈함","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"타이포그래피","slug":"타이포그래피","permalink":"https://JihyeHwang09.github.io/tags/타이포그래피/"},{"name":"Typography","slug":"typography","permalink":"https://JihyeHwang09.github.io/tags/typography/"}]},{"title":"자바스크립트 1일차","slug":"javascript1","date":"2019-01-13T14:54:55.000Z","updated":"2019-01-14T12:34:44.783Z","comments":true,"path":"2019/01/13/javascript1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/13/javascript1/","excerpt":"","text":"값과 리터럴 값으로 변환될 수 있는 부분을 모두 표현식이라 한다. 변수는 값에 붙이는 이름이다. html의 속성: attribute, javascript의 속성: property 객체 자바스크립트의 객체는 가변 길이이다. 자바스크립트는 자료구조의 유연성이 좋다. 객체의 속성 이름에는 x, ‘x’ 둘 다 쓸 수 있다. 다른 점은 차후에 설명해주실 예정. 속성 값에는 무엇이든 올 수 있다. 객체 안에 객체가 중첩될 수 있다. 123456789const obj = &#123; x: 0, y: &#123; x: 1, y: 2 &#125;&#125;;obj.y.x; 대입을 할 때는 = 오른쪽 식이 먼저 실행된다. 1234567let x = 1;x = x + 1;&lt;!-- x += 1;x *= 3;x /= 3; --&gt;console.log(x); delete 연산자: 객체의 속성을 삭제할 수 있다. 객체의 속성을 아예 없애버릴 수 있다. 123456789const obj = &#123; x: 0, y: 1&#125;delete obj.x;obj;&lt;!-- &#123;y: 1&#125; 객체의 x속성이 없어짐. --&gt; 메소드 객체 안에 있고, 객체의 속성을 통해서 사용하는 함수를 메소드라고 부른다. 12345678910111213141516171819const obj = &#123; x: 0, increaseX: function() &#123; this.x = this.x + 1; &#125;&#125;;const obj = &#123; x: 0, increaseX: function() &#123; this.x = this.x + 1; &lt;!-- this는 자기 자신을 가리키는 키워드. 실행하는 순간, this가 obj로 샤샤샥 바뀜. --&gt; &#125;&#125;;obj.increaseX();&lt;!-- 어떤 객체의 메소드 안에 this가 있으면, 그 this는 '메소드가 호출될 때' 해당 객체를 가리키게 된다. --&gt;console.log(obj.x); 객체와 배열의 차이객체는 속성 이름과 속성값이 연결되어 있다. 순서가 X . 배열은 순서가 있다.배열에 담는 객체는 요소(element) 혹은 항목(item)이라고 부른다. .점을 찍고 호출하는 함수를 메소드라고 한다. push메소드: 배열의 오른쪽 끝에 값을 추가한다. 12345const arr = [1, 2, 3];arr.push(4);arr.push(5);arr.push(6); slice 메소드: 특정 요소부터 한 개 혹은 여러 개의 요소를 지우고 싶을 때 사용ex) .slice(index값, 지우고 싶은 요소의 개수); 언어와 구동 환경 자바스크립트라는 언어와 구동 환경을 나누어서 생각해야 한다. ex) node.js에서는 alert를 쓸 수 X. 자바스크립트 언어, 자바스크립트를 돌릴 수 있는 구동환경에는 어떤 기능이 있는지를 배워야 한다. 프론트엔드 자바스크립트 개발자 vs 백엔드 자바스크립트 개발자 프론트엔드 자바스크립트 개발자는 자바스크립트 언어와 브라우저 구동환경을 배운다.vs 백엔드 자바스크립트 개발자는 자바스크립트 언어와 node.js 구동환경을 배운다. ES2015, 그 이후 ES5 2009년에 나온 자바스크립트 버전. ES2015 = ES6 값과 리터럴 값과 리터럴을 구분할 줄 알아야 한다. 리터럴: 값의 표기법을 말한다. 변수 (Variable) let, const, while, for등 프로그래밍에서 특별한 의미를 지니는 단어들을 키워드라고 부른다. let은 ES6에서 도입된 변수이다. ES6에서는 var를 쓰지 않고, let이나 const를 사용한다. ‘best practice: 좋은 관례’ 이다.(프로그래밍에서 많이 쓰이는 용어) let vs const let은 재대입이 가능. const는 재대입이 불가능한 변수. const는 재대입이 불가능하기 때문에 선언과 대입을 동시에 해줘야 한다. let은 선언, 대입을 따로 해도 된다. const로 변수를 선언할 때는 반드시 선언 시에 값을 대입해주어야 한다. 값 없이 선언만 하게 되면 에러가 발생한다. 또한 추후에 다른 값을 대입할 수 없다. let을 꼭 써야하는 경우가 아니라면, const를 사용하는 것이 좋다. let을 사용하면 의도치 않게 다른 값이 대입되어 버리는 일이 생길 수 있기 때문입니다. 정말로 재대입이 필요한 경우에만 let을 사용하는 것이 좋은 습관입니다. 특정 부분을 확신할 수 있으면 나머지 부분을 작성하기 쉬워지기 때문에 왠만하면 항상 const를 쓰는 습관을 들이는 것이 좋다. token은 프로그래밍에서 문자를 의미한다. Error 정리 SyntaxError: Unexpected token (28:7) 28번째 줄의 7번째 글자에 문법 에러가 있다는 뜻 SyntaxError: Assignment to constant variable: a at 29:0 29번째 줄의 첫번째 글자에 상수 변수에 대입을 했다는 에러가 있다. 12let seven = 7;let seven = 77; SyntaxError: Duplicate declaration “seven” at 33:4 변수 seven은 중복된 선언이라는 에러이다.** 식별자 변수의 이름은 식별자라고 한다. 식별자는 (‘’)없이 속성의 이름으로 이용할 수 있다. 식별자가 되기 위한 규칙들 숫자, 알파벳, 달러 문자(\\$), 언더스코어(_)가 포함될 수 있다. 단, 숫자로 시작되어서는 안 된다. 예약어는 식별자가 될 수 없다. ex) for, while, function 등은 사용할 수 X. 식별자로 쓸 수 없는 단어를 식별자로 사용하고 싶을 때’’로 묶는다. 12345678const obj = &#123; a: 1, '7seven': 7 &lt;!-- 식별자 규칙에 어긋나는 이름을 사용하려고 하므로 ''로 감싸줘야 에러나지 X --&gt;&#125;console.log(obj['7sever']);&lt;!-- 호출할 때도 ['']로 감싸줘야 한다. --&gt; 식별자는 한글로 쓸 수 있지만, 영어로 쓰는 것이 좋다. Camel Case ex) let helloWorldJavaScript 단어의 첫 글자를 소문자, 그 다음 단어부터 첫 글자를 대문자로 쓴다. 자바스크립트에서는 Camel Case로 쓰는 게 예의이고 관례이다. 1234567const one = 1;typeof 1 + 3;&lt;!-- 결과: 'number' + 3; --&gt;&lt;!-- typeof 1에 문자열 3이 붙어서 나온 것임. --&gt;&lt;!-- 연산자 우선순위가 typeof가 +보다 높다. --&gt;&lt;!-- 연산자 우선순위를 다 외우기가 너무 복잡하므로 우선 연산이 되었으면 하는 부분에 ()로 묶어주는 게 좋다. --&gt;typeof (1 + 3); 변수는 가장 첫 글자를 소문자로, 클래스는 첫 글자를 대문자로 쓰는 게 관례이다. number 타입number 타입 리터럴 리터럴이 다르더라도 값은 같을 수 있다. 자바스크립트는 정수와 실수를 별도의 타입으로 다루지 X. 정수와 실수 둘 다 number타입으로 구분하지만, 정수인지 실수인지 판별하기 위해서는 Number.isInteger를 사용한다. Number.isInteger(정수 or 실수); -&gt; 정수이면 true, 실수이면 false를 반환한다. number 타입에 대한 연산12* 2 ** 3;// 거듭제곱(거듭제곱 연산자는 ES2018에 추가됨) cf) 거듭제곱 함수 12Math.pow(2, 3);&lt;!-- 파이썬에서 가져온 함수임. --&gt; 자바스크립트에서 ==보다는 ===를 쓰는 게 더 좋다. 둘 다 되긴 하지만 ===를 쓰는 게 관례다. 123451 === '1'&lt;!--결과값: false --&gt;1 == '1'&lt;!-- 결과값: true 타입이 달라도 결과값이 true로 같다고 나오기 때문에 버그가 생기기 쉽다. --&gt; 12345let a = 1;a++; &lt;!-- 1 증가시키기 **전** 값을 표현식의 결과값으로 반환 --&gt;++a;&lt;!-- 1 증가시킨 **후**의 값을 표현식의 결과값으로 반환 --&gt; 1234let b = a++;&lt;!-- b에 증가하기 **전** 값인 1이 저장됨--&gt;let b = ++a;&lt;!-- b에 증가한 **후**의 값인 2가 저장됨--&gt; 연산자 우선순위 ()로 묶으면 우선순위가 가장 높기 때문에 가장 먼저 연산된다. typeof가 덧셈(+)보다 우선순위가 높기 때문에 +먼저 연산된 뒤에 문자열 3이 붙음. ex) typeof 1 + 3; 단항 연산자 ex) +1 다항 연산자 ex) 3 + 2 부동 소수점 (Floating Point) vs 고정 소수점 (Fixed Point) 컴퓨터에서 실수를 다루는 2가지 방식 부동 소수점 vs 고정 소수점 컴퓨터는 소수도 2진수로 저장하기 때문에 10진수 소수를 정확히 다룰 수 없다. 실수를 정확하게 나타내기 위해 사용하는 방법은 고정 소수점이다. 커리큘럼에서는 고정 소수점을 사용하는 라이브러리를 사용하지X. 컴퓨터로 실수를 다룰 때는 조심해야 한다. 컴퓨터는 실수를 정확하게 다룰 수 없기 때문에. number 타입의 특이한 값들NaN NaN은 Not a Number의 약자이다. 계산 불가능한 연산의 결과값을 나타내기 위해 사용한다. parseInt(‘’) 문자열을 숫자로 바꿔주는 함수 parseInt(‘’)에 이상한 문자열을 넣으면 NaN이 결과값으로 나온다. 12parseInt('asdf'); &lt;!--결과값: NaN --&gt; 어떤 값이 Nan인지 아닌지를 알고 싶을 때, ==를 쓰면 절대 X!! ===를 써야 됨. 꼭 기억!! ===는 숫자 비교에 특화되어 있는 연산자이다. “NaN은 숫자가 아니기 때문에, 어떤 숫자와도 같지 않다.”는 규칙이 있다. =&gt; 즉, NaN은 number 타입인 NaN가 같지 X ===NaN이 들어간 식은무조건 어떤 경우에도 false가 나오는 식임.(NaN은 자기자신과도 같지 X 때문에) 이거 때문에 버그 많이 생김. NaN은 JavaScript의 값들 중 유일하게 자기 자신과 같지 않은 값 1234 Number.isNaN(1);&lt;!-- 결과값: false --&gt; Number.isNaN(NaN);&lt;!-- 결과값: true --&gt; 12345678910111213141516171819202122const a = prompt(\"a: \");const b = prompt(\"b: \");const parsedA = parseInt(a);const parsedB = parseInt(b);// 이렇게 하면 안 됩니다!!!// if (parsedA === NaN || parsedB === NaN) &#123;// alert('숫자를 입력해주세요')// &#125; else &#123;// alert(parsedA + parsedB)// &#125;// \"NaN은 숫자가 아니기 때문에, 어떤 숫자와도 같지 않다.\" 는 규칙이 있다.// =&gt; 즉, NaN은 number 타입인 NaN과 같지 않다.if (Number.isNaN(parsedA) || Number.isNaN(parsedB)) &#123; alert(\"숫자를 입력해주세요\");&#125; else &#123; alert(parsedA + parsedB);&#125;1 + (2 + 3 + (4 + 5)); evaluate(평가)- 표현식을 값으로 반환하는 절차. 계산과 비슷 -0 자바스크립트의 세계에서 그냥 0과 -0은 다르다. 1234560 === -0; // true// 수의 세계에서 0*-1 한 거는 0이기 때문에 true로 나옴Object.is(0, -0);&lt;!-- 결과값: false. 자바스크립트 세계에서는 0과 -0을 다르게 취급함. --&gt; Object.is(,); 수의 세계에서 같은 지, 다른 지를 판별하는 게 x.자바스크립트 상에서 같은지, 다른지를 판별하는 것이다. 실무에서는 ===을 제일 많이 사용하는 편임!! Infinity 어떤 수가 Infinity인지 아닌지를 판별해야 할 때가 있음. Number.isFinite(): 유한한지 아닌지 판별 값이 유한하면 true, 무한하면 false를 반환함. 1234567if (Number.isNaN(parsedA) || Number.isNaN(parsedB)) &#123; alert(\"숫자를 입력해주세요\");&#125; else if (Number.isFinite(parsedA / parsedB)) &#123; alert(parsedA / parsedB);&#125; else &#123; alert(\"0으로 나눌 수 없습니다.\");&#125; isFinite(‘1’);쓰지 말고, 버전업된 Number.isFinite();를 써라. parseInt, parseFloat parseInt: 문자열 -&gt; 정수 parseFloat: 문자열 -&gt; 실수 1parseInt(\"110\", 2); // 6 (문자열 '110'을 2진수로 해석하겠다. 문자열을 2진수로 간주한다.) 되도록 숫자는 숫자랑만 연산한다. 문자열을 숫자로 바꾼 후에 연산한다. 숫자랑 문자열 연산을 하지 않는다. (아주 간단한 문자열끼리 이어붙이기 정도 빼고는) 사용자로부터 입력받은 데이터는 undefined 혹은 문자열일 가능성이 높다. 수와 문자열 계산은 반드시 전부 다 숫자로 안전하게 변환한 뒤에 연산할 것! Math 객체123456789101112131415161718192021Math.floor(-3.6);// 더 작은 숫자인 -4가 됨.Math.trunc(-3.6);// 더 큰 숫자인 -3이 됨.Math.max(1, 2);&lt;!-- 결과값: 2;들어온 숫자들 중에 제일 큰 숫자를 반환해준다.--&gt;Math.min(1, 2);&lt;!-- 결과값: 1;들어온 숫자들 중에 제일 작은 숫자를 반환해준다.--&gt;Math.random(); // 0과 1 사이의 값이 임의로 반환됩니다. Math.random() * 10; &lt;!-- 0과 10 사이의 실수를 반환함. 10을 넘을 수 X. --&gt; Math.floor(Math.random() * 10); &lt;!-- 0부터 9까지의 정수가 똑같은 확률로 나오게 만드는 식 --&gt; 주사위 만들기(1-6까지 나옴) 12Math.ceil(Math.random() * 6);Math.floor(Math.random() * 6) + 1; 카드 게임(A, B, C 중에 1장 나오는 게임) 123const CARDS = [\"A\", \"B\", \"C\"];CARDS[Math.floor(Math.random() * 3)]; number 타입의 메소드 number 타입은 객체가 아니지만, 마치 객체처럼 메소드를 사용할 수 있다. 매개변수 (parameter) 코드를 실행하다가 return을 만나면 실행 흐름을 종료시킨다. 1234567891011121314151617function evenOrOdd(x) &#123; // 만약 x가 짝수면 'x: 짝수' 라고 출력 if (x%2 === 0) &#123; console.log(x + ': 짝수'); &#125; else &#123; console.log(`$&#123;x&#125;: 홀수`); &#125; // 아니면 'x: 홀수'라고 출력&#125;for (let i = 0; i &lt; 20; i++) &#123; evenOrOdd(i + 1);&#125;`$&#123;&#125;` 사이에 어떤 값을 집어넣을 수 있다.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"CSS 상속(Inheritance)과 케스케이드(Cascade)","slug":"css-inheritance&cascade","date":"2019-01-12T14:31:47.000Z","updated":"2019-01-15T10:14:41.549Z","comments":true,"path":"2019/01/12/css-inheritance&cascade/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/12/css-inheritance&cascade/","excerpt":"","text":"CSS 상속(Inheritance)과 케스케이드(Cascade)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. CSS 상속 (Inheritance)상속되는 속성 (글자색, 글자 디자인에 관련된 것) color: 글자 색상 (배경색은 상속되지 X) font-size: 글자 크기 font-family: 글자의 모양(글꼴) letter-spacing: 자간 상속되지 않는 속성 (공간에 관련된 것) outline: 외곽 테두리선 margin: 외곽 영역의 공간 border: 테두리 padding: 테두리 안쪽의 공간 CSS 케스케이드(Cascade) 케스케이딩(Cascading)이란? cascading: The process of combining several style sheetsand resolving conflicts between them. Håkon Wium Lie (CSS 공동 창시자)는 CSS에 관한PHD 논문에서“여러 스타일 시트를 결합하고 이들 사이의충돌을 해결하는 프로세스”라는 용어로 “Cascade”를말하고 있다. https://www.wiumlie.no/2006/phd/ CSS(Cascading Style Sheets )는 캐스케이드 개념이중요하다는 것을 약어에서 강조. 가장 기본적인 수준에서는규칙 순서가 중요하지만 그보다 더 복잡하다는 것을 말한다. 중요성 (Importance)!important 선언은 다른 모든 선언보다 우선권을 가진다. [NOTE]!important가 적용된 속성을 덮어 쓰려면, 다시 !important를사용해야 하기에 최대한(절대!!) 사용하지 않도록 노력해야 한다. 특성 (Specificity)선택자의 우선권에 대한 척도.각 척도를 1, 10, 100, 1000 단위로생각하면 이해하기 좋다. 요소 선택자 &lt; 클래스 선택자 &lt; ID 선택자 &lt; 인라인 스타일0,0,0,1 0,0,1,0 0,1,0,0 1,0,0,0 [NOTE]*, &gt;, +, ~ 등 콤비네이터(Combinators),:not() 가상 클래스는 특성에 영향을 주지 X! [예시]* – 0000 a – 0001 (a요소는 요소선택자이기 때문에 1점) a.link – 0011 (a요소: 1점 + link라는 이름의 클래스니까 10점) li:nth-child(2) a:hover – 0022 (li요소: 1점 + a요소: 1점 + li:nth-child(2)는 가상클래스이다.가상클래스도 클래스이기 때문에 10점 + :hover도 가상클래스이기 떄문에 10점) .nav:nth-child(2) a:hover – 0031 .nav: 실제 클래스 10점 + v:nth-child(2): 가상클래스 10점 + :hover 10점 + a요소 1점) #outer a – 0101 (#outer: id선택자 100점 + a요소: 1점) #outer #inner a – 0201 (#outer: id선택자 100점 + #inner: id선택자 100점 + a요소: 1점 ) style=&quot;color: tan&quot; – 1000 (inline 스타일 시트: 1000점) !important(inline 스타일 시트도 무력화 시키는 게 !important이다.!important를 쓰면 함께 지옥에 가는 것임. 안 쓰는 게 좋다!! 최대한 쓰지 않도록! ) 소스 코드의 순서: 중요성, 특성이 설정되지 않았거나 동일한 경우나중에 나온 소스의 스타일이 우선권을 가진다. [예시] 1234567891011121314151617p &#123; color: #930212; &#125;p &#123; color: #d5727e; &#125;/* 우선권을 가진다. */p.note &#123; color: #930212; &#125;/* note라는 클래스 10점 + p요소 1점= 11점이 되므로 -&gt; 우선권을 가진다. */p &#123; color: #d5727e; &#125;p.note &#123; color: #930212; &#125;/* .note 클래스: 10점 + p요소: 1점 = 11점 */#target p &#123; color: #d5727e; &#125; /* #target: id선택자 100점 + p요소 1점 = 101점 *//* 우선권을 가진다. */&lt;p style=\"color: maroon\"&gt; /* inline 스타일은 1000점 */ 가장 약한 점수를 가지고 있다고 해도 !important flag를 꽂게 되면,!important가 우선하게 된다. html 파일 요소에 직접 스타일링 하는 것이다. (inline 스타일)","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"상속","slug":"상속","permalink":"https://JihyeHwang09.github.io/tags/상속/"},{"name":"Inheritance","slug":"inheritance","permalink":"https://JihyeHwang09.github.io/tags/inheritance/"},{"name":"케스케이드","slug":"케스케이드","permalink":"https://JihyeHwang09.github.io/tags/케스케이드/"},{"name":"Cascade","slug":"cascade","permalink":"https://JihyeHwang09.github.io/tags/cascade/"}]},{"title":"CSS 선택자(Selectors)","slug":"css-selectors","date":"2019-01-11T14:30:19.000Z","updated":"2019-01-14T12:37:21.410Z","comments":true,"path":"2019/01/11/css-selectors/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/11/css-selectors/","excerpt":"","text":"CSS 선택자(Selectors)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. 선택자는 CSS뿐만 아니라 자바스크립트에서도 유용하게 사용될 수 있다. CSS는 HTML 요소를 선택하는데 있어 다양한 선택자 옵션을 제공한다. selector(대상) {property(속성):value(값)} 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; h1 &#123;font-size: 100%&#125; /* Element Type Selector */ a &#123;text-decoration:none&#125; img &#123;border: 0&#125; &lt;/style&gt;&lt;/head&gt; 123456789&lt;head&gt; &lt;style type=\"text/css\"&gt; h1, h2, h3, h4, h5,h6&#123;font-wieght: normal&#125; /* Grouping: 여러 개의 요소(태그 선택자)를 일괄적으로 묶어주고, 일괄적으로 디자인해주는 것 */ a, img, p &#123;border:none&#125; h3 span, h4 span&#123;position:fixed:left:-2em&#125; &lt;/style&gt;&lt;/head&gt; 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; * &#123;margin:0:padding:0&#125;; /* Universal Selector(전체 선택자): HTML에 존재하는 모든 요소에 일괄적으로 스타일링 주고자 할 때*/ html body * &#123;text-decoration:none&#125; p.declation * &#123;text-transform:capitalize&#125; &lt;/style&gt;&lt;/head&gt; 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; p.note&#123;&#125; /* Class Selector(클래스 선택자) */ .floatLeft&#123;&#125; .positionAbs&#123;&#125; &lt;/style&gt;&lt;/head&gt; 12345678910&lt;head&gt; &lt;style type=\"text/css\"&gt; p.note.floatLeft&#123;&#125; /* Multi Class Selector(말 그대로 여러 개의 클래스가 붙은 선택자) 단락 요소(p)가 note라는 클래스와 floatLeft라는 클래스를 둘 다 가질 때 .note와 .floatLeft 사이에 띄면 X! */ .section.article&#123;&#125; .positionAbs&#123;&#125; &lt;/style&gt;&lt;/head&gt; 123456789&lt;head&gt; &lt;style type=\"text/css\"&gt; ul#nav&#123;&#125; /* ID Selector(아이디 선택자) Hash(#)값을 통해서 아이디를 선택하게 된다.*/ div#figure&#123;&#125; #site_info&#123;&#125; &lt;/style&gt;&lt;/head&gt; 123456789101112&lt;head&gt; &lt;style type=\"text/css\"&gt; p strong&#123;&#125; /* Descendant Selector */ /* '단락 내부에 있는 strong을 찾아서 꾸며주세요~'라는 뜻 */ ul li a &#123;&#125; /* 비순차 목록인 ul 내부의 li 요소를 찾은 다음에 a 요소 결국 꾸며지는 건 ul도 X, li도 X!! a요소를 최종적으로 찾은 다음에 꾸민다. 맨 마지막에 나오는 요소를 꾸민다. */ h3 span &#123;&#125; &lt;/style&gt;&lt;/head&gt; CSS 선택자(Selector) 요소 선택자 (Element Type Selector)figure { … } 그룹핑 (Grouping)a, abbr, .note, #about-css { … } -&gt; class도 묶어 줄 수 있다. 전체 선택자 (Universal Selector) { … } -&gt;*를 사용해서 모든 요소를 선택할 때 쓴다. 특정 영역 내에 있는 모든 요소를 선택할 때도 쓸 수 있다.ex) #about-css * {} -&gt; id가 about-css 속성값을 가진 내부의 모든 요소를 가리키게 된다.section이라든가 body는 포함되지 X. 클래스 선택자 (Class Selector) 대소문자 구분하기 때문에 반드시 확인해야 한다..class { … } 멀티 클래스 선택자 (Multi Class Selector)&lt;비교&gt; 띄어쓰기에 따라 의미가 완전히 달라진다..class1.class2 { … }: 하나의 요소가 2개의 클래스를 가진 형태 (멀티 클래스 선택자).class1. class2 { … }: class1을 가진 요소가 내부에 class2를 가지고 있을 때 쓴다. (자손 선택자) ex) .note.box {} -&gt;note라는 클래스 가진 요소 중에 box라는 클래스를 가지고 있다면, note와 box 클래스 2개가 모두 가지고 있다면~ 아이디 선택자 (ID Seletor): id값이 동일한 대상을 찾는다.#id { … }ex) #about-css {} -&gt; id가 about-css인 요소에 적용한다. 자손 선택자 (Descendent Selector): 클래스 or 아이디를 이용해서 꾸밀 수 있다.h1 abbr { … } -&gt; ‘h1이 포함한 abbr을 찾아서 꾸며주세요~’ 라는 뜻.note abbr { … } 자식 선택자 (Descendent Selector): 부모의 직접적인 자식만 나타낸다..parent &gt; .child { … } 자손 선택자 vs 자식 선택자 자손 선택자: ex) 아들, 손주 자식 선택자: 직계 자식만 선택할 수 있음. ex) 아들 123456ex1) &lt;h1&gt; &lt;strong&gt; &lt;strong&gt; &lt;abbr&gt; h1의 자손 선택자: &lt;strong&gt;, &lt;strong&gt;, &lt;abbr&gt; h1의 자식 선택자: 바로 밑의 &lt;strong&gt;만 해당 됨. 123ex2) body * &#123;&#125; : body 요소 내부의 모든 자손 선택 body &gt; * &#123;&#125; : body 요소 내부의 모든 자식(Child) 선택 속성 선택자 (Attribute Selector): 속성 선택자[] 앞에 아무것도 붙어있지 않다면. *가 생략되어 있다고 보면 된다. [id] { … } -&gt; id 속성을 가지고 있다면~ex)a[id] { … } -&gt; a요소가 id 속성값을 가지고 있다면~ [class] { … }[title] { … }[shape] { … } [shape][title]{ … } -&gt; shape과 title 속성을 둘 다 가지고 있다면~ [class=”note box”] { … } -&gt; 정확하게 “note box”라는 이름의 클래스를 찾기 때문에클래스명이 “box note”일 경우에는 찾을 수 X. -&gt; class의 경우에는.box {}.note {}가 좀 더 유연하게 사용할 수 있다. [id=”about-css] { … } -&gt; id값이 about-css라면~ 해당 요소를 선택해서 꾸며주게 된다.이걸 쉽게 쓰라고 만들어진 표현법이 hash(#) 표현법이다. #about-css { … } [class=”note”] { … }.note { … } ^=&quot;&quot;: ~로 시작하는 것ex)[title^=”Scalable”] { … } -&gt; title 요소 중, “”안의 Scalable이라는 단어로 시작하는 것을 모두 찾고 싶을 때 $=&quot;&quot;: ~로 끝나는 것ex)[title$=”Language”] { … } -&gt; title 요소 중, “”안의 Language이라는 단어로 끝나는 것을 모두 찾고 싶을 때 *=&quot;&quot;: ~를 포함하는 것ex)[title*=”Markup”] { … } -&gt; title 요소 중, “”안의 Markup이라는 단어를 포함하는 것을 모두 찾고 싶을 때 -&gt; CSS는 완벽하게 대소문자를 구분하기 때문에 “Markup”과 “markup”을 다르게 받아들인다. [href^=”http://“] { … } -&gt; href 속성값이 ^로 시작한다면, 속성값이 “http://“로 (“”안의 단어로) 꼭 시작해야 한다. [src$=”.svg”] { … } -&gt; .svg는 확장자임(‘.’으로 시작하므로) 확장자가 svg인 파일들을 이미지로 불러오는 모든 요소들을 찾게되는 것이다. [src*=”phone”] { … } -&gt; src에 포함된 단어 중에 “phone”이 들어간 걸 모두 찾아온다. 고급 속성 선택자 가상 클래스 선택자(Link Pseudo-class)a:link, a:visited{}anchor element가 기본적으로 가지고 있는 상태는 link element이다.1번 이상 방문한 사이트는 표시가 되어야 한다. -&gt; visited 방문했다는 가상클래스를 사용할 수 있다. a:hover, a:active{}hover: 마우스가 올라간 상태active: 마우스로 클릭한 순간 -&gt; 마우스 클릭한 걸 떼게 되면 active가 해제되는 것임 p:hover{} input:focus -&gt; focus가 된 상태input:focus:hover -&gt; focus가 된 상태에서 마우스가 올라가면(hover)~ [가상 클래스(Pseudo Class)] :link { … }:visited { … } :hover { … } hover는 마우스에 의존하는 속성:active { … } :focus { … }:focus:hover { … } -&gt; keyboard에 focusing이 간 상태에서 마우스가 올라가게 되면, 디자인이 변경된다. :focus:active { … } -&gt; focus가 된 후에 클릭이 될 때 디자인이 변경된다. 가상 클래스는 연이어서 사용할 수 있다. :first-child { … } :first-child는 :nth-child(1)과 같다. :last-child { … } 자식이 4개 라면 -&gt; last-child와 nth-child(4)와 같다.:nth-child(n) { … }()안에는 공식이 사용될 수 있다.1st2nd3rd4th5th…nth ex)link-list last-child(2n-1) {}link-list last-child(odd) {} 홀수 번째link-list last-child(2n) {}link-list last-child(even) {}짝수 번째CSS에서는 단축해서 홀수는 (odd),(even)을 사용한다.link-list last-child(3n) {}3의 배수 번째에만 :lang(ko) { … } ex) 디자인 상에서 한글과 영문은 각기 다른 디자인을 적용해달라는 요구가 있을 수 있음. 그 나라의 언어에 맞게 폰트를 변경할 떄 가상클래스를 사용하면 된다. :lang(en) {font-family: “Times New Roman”; &lt;!– 명조계열체 - -&gt;}:lang(ko-KR) {font-family: “Spoqa Han Sans”;&lt;!– 고딕계열체 - -&gt;} 가상 요소(Pseudo Element): 가상 클래스와는 다르다.: 1개 사용 -&gt; 가상 클래스vs :: 2개 사용 -&gt; 가상 요소::first-letter { … }::first-line { … }::before { … }::after { … }","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"선택자","slug":"선택자","permalink":"https://JihyeHwang09.github.io/tags/선택자/"},{"name":"selector","slug":"selector","permalink":"https://JihyeHwang09.github.io/tags/selector/"}]},{"title":"주니어 개발자가 기억 & 주의해야 할 점","slug":"to-remember-things-for-junior-developer","date":"2019-01-10T14:13:52.000Z","updated":"2019-01-14T11:23:52.950Z","comments":true,"path":"2019/01/10/to-remember-things-for-junior-developer/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/10/to-remember-things-for-junior-developer/","excerpt":"","text":"이번에는 주니어 개발자가 기억해야 할 것과 주의해야 할 점에 대해 정리해봅시다. 주니어 개발자가 기억해야 할 것프로그래머는 복잡성(complexity)와 항상 싸워야 한다. 함수, 클래스, 모듈로 나누고 주석도 잘 쓰면 복잡성이 내려간다. 복잡성을 낮춰야 하는 이유와 방법 큰 프로그램을 작성하기 위해 필요 유지보수를 위해 필요 코드를 작성하고 한참 뒤에 코드를 추가하거나 수정할 때 협업을 위해서 필요하다. 다른 프로그래머가 사용하기 쉽도록 프로그램의 구조 자체를 잘 짜야 한다. (다른 개발자가 작성한 프로그램을 파악하기 위해서 전체 코드를 다 읽어봐야 한다면 시간이 너무 오래 걸린다.) React를 사용하면 복잡성을 내릴 수 있다. 협업을 하는 다양한 방식 ex1) 주로 대기업에서 사용하는 협업 방식: 폭포수(waterfall) 개발 방법론 절차: 기획 -&gt; 디자인 -&gt; HTML -&gt; CSS -&gt; JS 장점: 쇼핑몰 만드는 것처럼 크게 변경할 부분이 없는 경우(비슷한 방식을 반복하는 경우)에는 속도가 더 빠르다. 단점: 속도가 느리다. 앞 단계에서 결정된 사항을 바꾸기 어렵다. 3개월 프로젝트 시간이 주어지면, 1개월 기획, 1개월 디자인, 1개월 개발로 나눌 수 있다. ex2) 주로 스타트업 기업에서 사용하는 협업 방식: 애자일(Agile)(기능별로 나누는 방식) 로그인 게임판 점수판 3개월 프로젝트 시간이 주어진다면, 2주 동안 6번 로그인, 게임판, 점수판 기능을 기획부터 JS까지 반복하자. 개발자들도 기획이나 디자인 단계에 참여해서 의견을 내고 서로 질문을 주고 받는다. 장점: 개발 단계에서 수정 사항이 생겨도 결정된 사항을 바꾸기 쉽기 때문에 실험적인 도전을 할 수 있다. 제품을 빨리 만들고 수정 사항을 반영해서 바꾸기에 적합하다. 단점: 개발자들이 기획이나 디자인 단계에도 참여하기 때문에 개발자들이 시간을 굉장히 많이 소비하게 된다. 전문 영역이라는 게 부족해지게 된다. -&gt; 그 결과로 제품의 퀄리티가 떨어질 수 있다. 취업 전에 애자일(Agile) 도서를 꼭 1권 이상 읽고 취업할 것을 추천 주니어 개발자가 프로젝트 진행시 주의할 점 프로젝트를 할 때는 해야 하는 일과 하고 싶은 일을 구분해야 한다. 주니어 개발자 때는 소요 시간을 예상하기 쉽지 않다. 할 일 목록을 쭉 적어놓고 일정을 잡기 자신이 예상한 시간에 X 2 X 3을 해서 사장님께 말씀 드리기 ex) 내 예상으로는 3시간 걸리는 기능이라면 9시간 걸릴 것 같다고 하고 일정 잡기 버그를 잡는 데 시간이 오래 걸릴 수 있다. 기술 a를 적용할 수 있다고 생각했는데, a를 적용 못해서 기술 b를 새로 배워서 적용해야 하는 경우가 분명히 생긴다. 꼭 해야 되는 일부터 해야 한다. MVP(Minimum Viable Product)(최소 기능 제품)을 먼저 만든 후에 그 뒤에 하고 싶은 기능을 만든다. MVP를 세워뒀다고 해도 시간이 부족할 수 있다. 항상 플랜 B를 세워둬야 한다. 이것보다 기능이 적어도 기능이 있어서 클라이언트에게 납품할 수 있는 결과물을 넘겨줘야 하기 때문에 어느 선까지는 꼭 만들 것인지 정해둬야 한다. ex) 목표: 오목 게임 꼭 구현해야 하는 기능 클릭 반응 승자 판별","categories":[{"name":"개발자","slug":"개발자","permalink":"https://JihyeHwang09.github.io/categories/개발자/"},{"name":"면접","slug":"개발자/면접","permalink":"https://JihyeHwang09.github.io/categories/개발자/면접/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"interview","slug":"interview","permalink":"https://JihyeHwang09.github.io/tags/interview/"}]},{"title":"순환(Recursion)의 개념과 기본 예제3","slug":"recursion3","date":"2019-01-09T02:42:47.788Z","updated":"2019-01-15T12:21:25.506Z","comments":true,"path":"2019/01/09/recursion3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/09/recursion3/","excerpt":"","text":"이번에는 지난 포스트에 이어서, 순환적 알고리즘 설계 방법에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 순환적 알고리즘 설계적어도 하나의 base case, 즉 순환되지 않고 종료되는 case가 있어야 함 모든 case는 결국 base case로 수렴해야 함 암시적(implicit) 매개변수를 명시적(explicit) 매개변수로 바꾸어라. 순차 탐색 이 함수의 미션은 data[0]에서 data[n-1] 사이에서 target을 검색하는 것이다. 하지만, 검색 구간의 시작 인덱스 0은 보통 생략한다. -&gt; 즉, 암시적 매개변수이다. 이 함수는 시작 위치는 0으로 암시, 끝 위치는 명시되어 있다. 12345678910// \"배열의 데이터가 n개이니까 당연히 인덱스 0부터 시작하겠지.\"라고// 암묵적으로 동의한 것이므로 생략됨// 배열의 시작지점이 명시적으로 0이라고 표현되어 있지 Xint search(int [] data, int n, int target) &#123; for (int i = 0; i &lt; n; i++) &#123; if (data[i] == target) return i; &#125; return -1;&#125; 매개변수의 명시화: 순차 탐색 이 함수의 미션은 data[begin]에서 data[end] 사이에서 target을 검색한다. 즉, 검색구간의 시작점을 명시적(explicit)으로 지정한다. 시작 위치가 begin으로 명시, 끝 위치는 end로 명시되어 있다. 이 함수를 search(data, 0, n-1, target)으로 호출한다면, 위의 순차 탐색에서 예시로 든 search함수와 완전히 동일한 일을 한다. 1234567891011int search(int [] data, int begin, int end, int target) &#123; // begin &gt; end이면, 데이터가 0개이다. if (begin &gt; end) &#123; return -1; // begin = end는 데이터가 1개라는 뜻&#125; else if (target == data[begin]) &#123; // end를 찾을 필요 없이 begin을 return한다. return begin;&#125; else if &#123; return search(data, begin + 1, end, target);&#125; 순차 탐색: 다른 버전 이 함수의 미션은 data[begin]에서 data[end] 사이에서 target을 검색한다. 즉, 검색구간의 시작점을 명시적(explicit)으로 지정한다. 예제1123456789int search(int [] data, int begin, int end, int target) &#123; if (begin &gt; end) &#123; return -1; &#125; else if (target == items[end]) &#123; return end; &#125; else &#123; return search(data, begin, end-1, target); &#125;&#125; 예제212345678910111213141516int search(int [] data, int begin, int end, int target) &#123; if (begin &gt; end) &#123; return -1; &#125; else &#123; int middel = (begin + end) / 2; if (data[middle] == target) &#123; return middle; &#125; int index = search(data, begin, middle - 1, target); if (index != -1) &#123; return index; &#125; else &#123; return search(data, middle + 1, end, target); &#125; &#125;&#125; 매개변수의 명시화: 최대값 찾기 이 함수의 미션은 data[begin]에서 data[end] 사이에서 최대값을 찾아 반환한다. begin &lt;= end라고 가정한다. 12345678910int findMax(int [] data, int begin, int end) &#123; // base case: 데이터가 0개 일 경우가 X. 1개일 경우이다. // 데이터가 0개일 경우, 최대값이 정의되지 X 때문이다. // begin = end일 경우, 데이터가 1개이다. if (begin == end) &#123; return data[begin]; &#125; else &#123; return Math.max(data[begin], findMax(data, begin + 1, end)); &#125;&#125; 최대값 찾기: 다른 버전12345678910int findMax(int [] data, int begin, int end) &#123; if (begin == end) &#123; return data[begin]; &#125; else &#123; int middle = (begin + end) / 2; int max1 = findMax(data, begin, middle); int max2 = findMax(data, middle + 1, end); return Math.max(max1, max2); &#125;&#125; 이진 탐색(Binary Search) items[begin]부터 items[end] 사이에서 target을 검색한다. 12345678910111213141516171819202122public static int binarySearch(String[] items,String target, int begin, int end) &#123; // base case: 데이터의 개수가 0일 경우 if (begin &gt; end) &#123; return -1; &#125; else &#123; int middle = (begin + end) / 2; // Java에서 문자열끼리의 비교는 compareTo() 메서드를 이용한다. // cf) s1.compareTo(s2) 메서드는 문자열의 사전적 값을 비교 // s1 &lt; s2일 경우, 음의 정수를 반환 // s1 == s2일 경우, 0을 반환 // s1 &gt; s2일 경우, 양의 정수를 반환 int compResult = target.compareTo(items[middle]); if (comResult == 0) &#123; return middle; &#125; else if (compResult &lt; 0) &#123; return binarySearch(items, target, begin, middle -1); &#125; else &#123; return binarySearch(items, target, middle + 1, end); &#125; &#125;&#125;","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"순환 함수","slug":"순환-함수","permalink":"https://JihyeHwang09.github.io/tags/순환-함수/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"순환적 알고리즘 설계","slug":"순환적-알고리즘-설계","permalink":"https://JihyeHwang09.github.io/tags/순환적-알고리즘-설계/"},{"name":"명시적 매개변수","slug":"명시적-매개변수","permalink":"https://JihyeHwang09.github.io/tags/명시적-매개변수/"},{"name":"explicit","slug":"explicit","permalink":"https://JihyeHwang09.github.io/tags/explicit/"},{"name":"순차 탐색","slug":"순차-탐색","permalink":"https://JihyeHwang09.github.io/tags/순차-탐색/"},{"name":"최대값 찾기","slug":"최대값-찾기","permalink":"https://JihyeHwang09.github.io/tags/최대값-찾기/"},{"name":"이진 탐색","slug":"이진-탐색","permalink":"https://JihyeHwang09.github.io/tags/이진-탐색/"},{"name":"Binary Search","slug":"binary-search","permalink":"https://JihyeHwang09.github.io/tags/binary-search/"}]},{"title":"순환(Recursion)의 개념과 기본 예제2","slug":"recursion2","date":"2019-01-08T10:16:09.508Z","updated":"2019-01-08T14:43:51.262Z","comments":true,"path":"2019/01/08/recursion2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/08/recursion2/","excerpt":"","text":"이번에는 지난 포스트에 이어서, 순환적으로 사고하기와 문자열의 길이 계산, 배열의 합 등의 예제에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 순환적으로 사고하기(Recursive Thinking)Recursion은 수학함수 계산에만 유용한가? 수학함수 뿐 아니라 다른 많은 문제들을 recursion으로 해결할 수 있다. 문자열의 길이 계산 문자열의 길이를 계산하고 싶다면, 첫 번째 문자열을 뺀 나머지 문자열의 길이를 계산 1을 더하면 된다. 12345678// base case: 문자열의 길이가 0인 경우// -&gt; 첫 번째 문자열이 존재하지 Xif the string is empty return 0;// 첫 번째 문자열을 제거한 그 문자열의 길이를 계산한 다음, 1을 더한다.else return 1 plus the length of the string that excludes the first character; 1234567int length(char *str) &#123; if (*str == '\\0') &#123; return 0; &#125; else &#123; return 1 + length(str + 1); &#125;&#125; 12345678910111213141516171819// 문자열 str을 입력받아 길이를 계산하는 메서드 lengthpublic static int length(String str) &#123; // base case: 문자열의 길이가 0인 문자열과 동일하다면 // -&gt; 즉, 문자열의 길이가 0라면 if (str.equals(\"\")) &#123; return 0; &#125; else &#123; // Java에서 substring(n)은 // index값이 n보다 작은(앞에 있는) 문자열을 제거한 문자열을 반환한다. // str.substring(1)은 // str에서 index값이 1인 위치 이후부터의 문자열을 가져온다. // -&gt; 즉, 입력받은 str에서 // index값이 0인 첫 글자를 제외한 문자열을 반환한다. // 1 + length(str.substring(1))는 그것의 길이를 계산한 다음, // 1을 더해서 반환한다. return 1 + length(str.substring(1)); &#125;&#125; 문자열의 프린트123456789101112// 입력한 하나의 문자열을 출력하는 메서드 printCharspublic static void printChars(String str) &#123; if (str.length() == 0) &#123; return; &#125; else &#123; // 문자열의 첫 글자를 화면에 출력한다. // Java에서 str.charAt(n)은 인덱스 n의 위치에 해당되는 문자를 추출해준다. System.out.print(str.charAt(0)); // 첫 글자를 제외한 나머지 문자열을 화면에 출력한다. printChars(str.substring(1)); &#125;&#125; 문자열을 뒤집어 프린트 이 문자열을 뒤집어 프린트하려면, 먼저 첫 글자를 제외한 문자열을 뒤집어 프린트 한다. 마지막으로, 첫 글자를 프린트 한다. 123456789101112public static void printCharsReverse(String str) &#123; // base case: 입력된 문자열 str의 길이가 0라면, 아무 일도 일어나지 X if (str.length() == 0) return; // 문자열의 길이가 1 이상이라면, else &#123; // 1. 먼저 첫 글자를 제거한 문자열을 화면에 뒤집어서 출력한다. printCharsReverse(str.substring(1)); // 2. 마지막으로, 원래 문자열의 첫 글자를 화면에 출력한다. System.out.print(str.charAt(0)); &#125;&#125; 2진수로 변환하여 출력12345678910111213// 음이 아닌 정수 n을 이진수로 변환하여 출력한다.public void printInBinary(int n) &#123; if (n &lt; 2) &#123; System.out.print(n); &#125; else &#123; // n을 2로 나눈 몫을 먼저 2진수로 변환하여 출력한다. // 마지막 비트를 제외한 나머지 비트가 표현하는 숫자이다. printInBinary(n/2); // n을 2로 나눈 나머지를 출력한다. // 마지막 비트를 표현하는 숫자이다. System.out.print(n%2); &#125;&#125; 배열의 합 구하기1234567891011121314// n개인 data의 합 구하기// data[0]에서 data[n-1]까지의 합을 구하여 반환한다.public static int sum(int n, int[] data) &#123; if (n &lt;= 0) return 0; else //sum(n-1, data) 을 호출하면, // data[0]에서 data[n-2]까지 데이터의 합을 구한다. // 그 후, 마지막 데이터인 data[n-1]을 더해준다. // recursion이 1씩 줄어들다가 0이 될 때, 빠져나온다. // -&gt; 무한루프에 빠질 일이 X return sum(n-1, data) + data[n-1];&#125; 데이터 파일로부터 n개의 정수 읽어오기실제로 자주 쓰는 코드 형태는 Xrecursion 예제로만 참고 123456789101112131415// Scanner in이 참조하는 파일로부터 n개의 정수를 입력받아// 배열 data의 data[0], ..., data[n-1]에 저장한다.public void readFrom(int n, int [] data, Scanner in) &#123; // base case: n이 0일 때는 아무것도 하지 X if (n == 0) &#123; return; &#125; else &#123; // 1. n-1개의 데이터를 읽어온다. // -&gt; data[0], ..., data[n-2]에 저장한다. readFrom(n-1, data, in); // 2. 마지막 한 개의 데이터를 읽어온다. // -&gt; 읽어온 데이터를 data[n-1]에 저장한다. data[n-1] = in.nextInt(); &#125;&#125; Recursion vs Interation 모든 순환함수는 반복문(interation)으로 변경 가능 그 역도 성립함. 즉, 모든 반복문은 순환함수(recursion)으로 표현 가능함 순환함수는 복잡한 알고리즘을 단순하고 알기쉽게 표현하는 것을 가능하게 함 하지만, 함수 호출에 따른 오버헤드가 있음(매개변수 전달, 액티베이션 프레임 생성 등)","categories":[{"name":"컴퓨터 과학(Computer Science)","slug":"컴퓨터-과학-computer-science","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학-computer-science/"},{"name":"알고리즘(Algorithms)","slug":"컴퓨터-과학-computer-science/알고리즘-algorithms","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학-computer-science/알고리즘-algorithms/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"Computer Science","slug":"computer-science","permalink":"https://JihyeHwang09.github.io/tags/computer-science/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://JihyeHwang09.github.io/tags/알고리즘/"},{"name":"Algorithms","slug":"algorithms","permalink":"https://JihyeHwang09.github.io/tags/algorithms/"},{"name":"순환 함수","slug":"순환-함수","permalink":"https://JihyeHwang09.github.io/tags/순환-함수/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"Recursion Function","slug":"recursion-function","permalink":"https://JihyeHwang09.github.io/tags/recursion-function/"},{"name":"수학적 귀납법","slug":"수학적-귀납법","permalink":"https://JihyeHwang09.github.io/tags/수학적-귀납법/"},{"name":"Mathematical Induction","slug":"mathematical-induction","permalink":"https://JihyeHwang09.github.io/tags/mathematical-induction/"},{"name":"Interation","slug":"interation","permalink":"https://JihyeHwang09.github.io/tags/interation/"}]},{"title":"순환(Recursion)의 개념과 기본 예제1","slug":"recursion1","date":"2019-01-07T08:51:43.427Z","updated":"2019-01-07T10:40:34.898Z","comments":true,"path":"2019/01/07/recursion1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/07/recursion1/","excerpt":"","text":"순환 함수란 무엇이며, 무한 루프에 빠지지 않으려면 어떤 경우가 존재해야 하는지 그리고 수학적 귀납법에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 순환이란? recursion은 항상 무한루프에 빠질까? 12345678910111213// 1 ~ n까지의 합을 구한다.int main() &#123; int result = func(4);&#125;int func(int n) &#123; if (n == 0) &#123; return 0; &#125; else &#123; return n + func(n-1); &#125;&#125; 무한루프에 빠지지 않으려면? &amp; recursion의 해석123456789101112// 이 함수의 mission은 0 ~ n까지의 합을 구하는 것이다.int func(int n) &#123; // Base case: 적어도 하나의 recursion에 빠지지 않는 경우가 존재해야 한다. // n = 0이라면, 합은 0이다. if (n == 0) return 0; else // Recursive case: recursion을 반복하다보면 결국 base case로 수렴해야 한다. // n이 0보다 크다면, // 0에서 n까지의 합은 0에서 n-1까지의 합에 n을 더한 것이다. return n + func(n-1);&#125; 순환함수와 수학적 귀납법정리: func(int n)은 음이 아닌 정수 n에 대해서 0에서 n까지의 합을 올바르게 계산한다.증명: n=0인 경우: n=0인 경우 0을 반환한다. 올바르다. 임의의 양의 정수 k에 대해서 n &lt; k인 경우, 0에서 n까지의 합을 올바르게 계산하여 반환한다고 가정하자. n = k인 경우를 고려해보자. func은 먼저 func(k-1) 호출하는데 2번의 가정에 의해서0에서 k-1까지의 합을 올바르게 계산하여 반환한다.메서드 func은 그 값에 n을 더해서 반환한다.따라서 메서드 func는 0에서 k까지의 합을 올바로 계산하여 반환한다. 12345678910111213141516171819package lec00.algorithm;public class Alg02 &#123; public static void main(String[] args) &#123; int n = 4; func(n); &#125; public static void func(int k) &#123; if (k &lt;= 0) return;// Base case: 적어도 하나의 recursion에 빠지지 않는 경우가 존재해야 한다. else &#123; System.out.println(\"Hello...\"); func(k-1);// Recursive case: recursion을 반복하다보면 결국 base case로 수렴해야 한다. &#125; &#125;&#125;// recursion이 항상 무한루프에 빠지는 것은 아니다. 123456789101112131415161718192021222324252627282930package lec00.algorithm;// 1 ~ n까지의 합을 구한다.public class Alg03 &#123; public static void main(String[] args) &#123; int result = func(4); System.out.println(result); &#125; public static int func(int n) &#123; if(n &lt;= 0) return 0; else &#123; return n + func(n-1); &#125; /* public static int func(int n) &#123;// 이 함수의 mission은 0~n까지의 합을 구하는 것이다. if (n == 0) return 0;// n=0이라면 합은 0이다. else return n + func(n-1);// n이 0보다 크다면 0에서 n까지의 합은// 0에서 n-1까지의 합에 n을 더한 것이다.&#125;*/ &#125;&#125; Factorial: n! 12345678int factorial(int n)&#123; if (n == 0) &#123; return 1; &#125; else &#123; return n* factorial(n-1); &#125;&#125; 정리: factorial(int n)은 음이 아닌 정수 n에 대해서 n!을 올바르게 계산한다.증명: n = 0인 경우: n=0인 경우 1을 반환한다. 올바르다. 임의의 양의 정수 k에 대해서 n &lt; k인 경우 n!을 올바르게 계산한다고 가정하자. n = k인 경우를 고려해보자. factorial은 먼저 factorial(k-1) 호출하는데 2번의 가정에 의해서 (k-1)!을 올바르게 계산하여 반환한다. 따라서 메서드 factorial은 k \\* (k-1)! = k!을 반환한다. 123456public static int factorial(int n)&#123; if (n == 0) return 1; else return n * factorial(n-1);","categories":[{"name":"컴퓨터 과학(Computer Science)","slug":"컴퓨터-과학-computer-science","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학-computer-science/"},{"name":"알고리즘(Algorithms)","slug":"컴퓨터-과학-computer-science/알고리즘-algorithms","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학-computer-science/알고리즘-algorithms/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"Computer Science","slug":"computer-science","permalink":"https://JihyeHwang09.github.io/tags/computer-science/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://JihyeHwang09.github.io/tags/알고리즘/"},{"name":"Algorithms","slug":"algorithms","permalink":"https://JihyeHwang09.github.io/tags/algorithms/"},{"name":"순환 함수","slug":"순환-함수","permalink":"https://JihyeHwang09.github.io/tags/순환-함수/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"Recursion Function","slug":"recursion-function","permalink":"https://JihyeHwang09.github.io/tags/recursion-function/"},{"name":"수학적 귀납법","slug":"수학적-귀납법","permalink":"https://JihyeHwang09.github.io/tags/수학적-귀납법/"},{"name":"Mathematical Induction","slug":"mathematical-induction","permalink":"https://JihyeHwang09.github.io/tags/mathematical-induction/"}]},{"title":"카르노 도표(KARNAUGH MAP)","slug":"karnaugh-map","date":"2019-01-06T13:53:35.896Z","updated":"2019-01-07T10:33:28.058Z","comments":true,"path":"2019/01/06/karnaugh-map/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/06/karnaugh-map/","excerpt":"","text":"부울함수의 간소화 방법 중의 하나인 카르노 도표(KARNAUGH MAP)에 대해 알아봅시다. 카르노 도표 방법 카르노 도표는 여러 개의 사각형으로 된 다이어그램 사각형은 각각 하나의 최소항이나 최대항을 의미 여섯 개 이하의 변수를 가진 부울함수에 사용 카르노 도표는 부울함수의 입력변수의 수에 따라서 기본 도표의 형태가 결정됨 입력변수의 수가 n인 경우를 n변수 카르노 도표라고 하며, 2^n개의 사각형으로 구성됨 카르노 도표를 이용하면, 정규형 부울 함수 -&gt; 표준형 부울함수로 간소화할 수 있음 카르노 도표를 이용해서 부울함수의 각 항들을 곱이나 합 형태로 간소화 최소항의 합 -&gt; 곱의 합 최대항의 곱 -&gt; 합의 곱 형태로 간소화 됨 최소항의 합형을 곱의 합형으로 간소화하는 순서 입력변수의 수 n에 따라 n변수 카르노 도표 작성(도표는 2^n개의 정사각형) 최소항의 인덱스에 대응되는 사각형을 1로 표시 1로 표시된 사각형들 중 서로 인접한 사각형끼리 묶음 (주의! 이때 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.) 각 묶음이 입력변수 각각에 대해 도표상의 어떤 위치에 있는지 파악 4)에서 구한 각 묶음에 대한 곱항들을 논리합(OR)으로 연결시키면, 간소화된 표준형(곱의 합형)이 구해진다. 최대항의 곱형을 합의 곱형으로 간소화하는 순서 입력변수의 수 n에 따라 n변수 카르노 도표 작성(도표는 2^n개의 정사각형) 최소항의 인덱스에 대응되는 사각형을 0으로 표시 0으로 표시된 사각형들 중 서로 인접한 사각형끼리 묶음 (주의! 이때 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.) 각 묶음이 입력변수 각각에 대해 도표상의 어떤 위치에 있는지 파악 4)에서 구한 각 묶음에 대한 합항들을 논리곱(AND)으로 연결시키면, 간소화된 표준형(합의 곱형)이 구해진다. 인접 사각형의 정의 카르노 도표에서 각 정사각형은 하나의 최소항(또는 최대항)을 의미 따라서, 인접 사각형이란 두 정사각형에 대응되는 각 최소항(또는 최대항)의 구성변수 중 다른 모든 변수는 동일하되 오직 하나의 변수만 서로 보수관계에 있을 때 두 정사각형은 서로 인접한다”라고 정의 ex) 입력변수가 X, Y, Z 3개의 경우 인접 사각형끼리 묶는 방법 한 묶음 내의 정사각형의 수는 2^n(n = 0, 1, 2... n)개가 되도록 묶는다. 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"카르노 도표","slug":"카르노-도표","permalink":"https://JihyeHwang09.github.io/tags/카르노-도표/"},{"name":"카르노 맵","slug":"카르노-맵","permalink":"https://JihyeHwang09.github.io/tags/카르노-맵/"},{"name":"karnaugh map","slug":"karnaugh-map","permalink":"https://JihyeHwang09.github.io/tags/karnaugh-map/"}]},{"title":"논리게이트(LOGIC GATE)","slug":"logic-gate","date":"2019-01-05T09:18:57.757Z","updated":"2019-01-07T10:28:28.084Z","comments":true,"path":"2019/01/05/logic-gate/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/05/logic-gate/","excerpt":"","text":"논리게이트(LOGIC GATE)의 종류에는 어떤 것들이 있는지와 각 논리게이트에 대한 기호, 진리표, 입출력 파형에 대해 알아봅시다. 논리게이트(LOGIC GATE)의 종류기본 논리게이트 AND 게이트 OR 게이트 NOT 게이트 NAND 게이트와 NOR 게이트 NAN 게이트 NOR 게이트 XOR 게이트와 XNOR 게이트 XOR 게이트 XNOR 게이트 논리게이트(LOGIC GATE)의 기호와 진리표, 입출력 파형1. 기본 논리게이트1) AND 게이트 반달 모양으로 표현 입력값이 둘 다 1일 경우에만 1이 출력되고, 나머지 경우에는 결과값이 0이 된다. 2) OR 게이트 반달 모양이되, 입력 부분이 움푹 들어간 모양으로 표현 입력값이 둘 다 0일 경우에만 결과값이 0이 되고,나머지 경우에는 결과값이 1이 된다. 3) NOT 게이트 세모 모양으로 표현, 출력부분에 작은 원을 그려준다. 입력값과 반대값이 출력된다. 2. NAND 게이트와 NOR 게이트1) NAND 게이트 AND 게이트의 반대 입력값이 둘 다 1일 경우에만 0이 출력되고, 나머지 경우에는 결과값이 1이 된다. 2) NOR 게이트 OR 게이트의 반대 입력값이 둘 다 0일 경우에만 1이 출력되고, 나머지 경우에는 결과값이 0이 된다. 반달 모양이되, 출력부분에 작은 원을 그려준다. 3. XOR 게이트와 XNOR 게이트1) XOR 게이트 입력값이 서로 다른 값이 들어온 경우에만 결과값이 1이 된다. 나머지 경우에는 0이 출력된다. 2) XNOR 게이트 입력값으로 서로 다른 값이 들어온 경우에만 결과값이 0이 된다. 나머지 경우에는 1이 출력된다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"논리게이트","slug":"논리게이트","permalink":"https://JihyeHwang09.github.io/tags/논리게이트/"},{"name":"logic gate","slug":"logic-gate","permalink":"https://JihyeHwang09.github.io/tags/logic-gate/"}]},{"title":"불 대수(Boolean algebra)","slug":"boolean-algebra","date":"2019-01-03T17:20:57.925Z","updated":"2019-01-07T10:30:50.797Z","comments":true,"path":"2019/01/04/boolean-algebra/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/04/boolean-algebra/","excerpt":"","text":"2진 디지털 시스템에서 입출력 관계를 표현하는 방법과 불 대수의 기본 개념 및 공식에 대해서 알아보고, 불 함수의 대수적 간소화에 대해서 공부해봅시다. 1. 2진 디지털 시스템에서 입출력 관계를 표현하는 방법1) 그래프나 진리표로 표시 2) 논리함수로 표시 입력에 따라 변수가 어떻게 변하는지를 나타내는 함수로 표현 입력이 2진 논리값이므로 논리함수로 나타낸다. 2. 불 대수의 기본 개념1) 불 대수(Boolean Algebra): 0과 1의 값을 갖는 논리변수와 논리연산을 다루는 대수 불 대수(Boolean algebra)는 하나의 명제가 참 또는 거짓인지를 판별하기 위해 이용되는 수학적 방법으로 19세기 중반 영국의 수학자 조지 불(George Boole)에 의해 개발되었다. 컴퓨터는 참과 거짓을 나타내기 위해 0과 1의 두 가지 상태로 표현하는 2진 논리회로로 구성되어 있다. 이러한 논리회로를 간략하게 표현할 때 불 대수가 사용된다. 2) 불 함수(Boolean Function): 논리변수의 상호관계를 나타내기 위해 불 변수, 불 연산기호, 괄호 및 등호 등으로 나타내는 대수적인 표현 AND 연산 입력값이 모두 1일 경우에만 결과값이 1이 된다. 표현법 X AND Y 또는 XY로 표현한다. 점으로 표시, 생략 가능 OR 연산 입력값 중 한 개라도 1일 경우 결과값이 1이 된다. 표현법 X OR Y 또는 X + Y로 표현한다. 덧셈 기호(+)로 표시 NOT 연산 입력값의 반대값이 출력된다. 표현법: NOT X 또는 X&#39;로 표현 변수 위에 줄(-)을 그어 표시 3. 불 대수의 기본 공식교환법칙, 결합법칙, 분배법칙, 드모르간의 법칙, 흡수 법칙 등을 이용하여회로를 쉽게 간소화할 수 있다. 4. 불 함수(논리식)의 대수적 간소화불 대수의 기본 공식을 이용해서 논리식을 간소화한다. 1) 합의 곱 표현을 곱의 합표현으로 변환한다. 합의 곱: (A + B)(C + D) 곱의 합: AC + AD + BC + BD 2) 공통 인수를 뽑아서 묶는다.3) 기본 공식 형태로 유도해서 식을 줄여 나간다.항 결합 X + X&#39; = 1이라는 성질을 이용한다. 문자 소거","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"boole","slug":"boole","permalink":"https://JihyeHwang09.github.io/tags/boole/"},{"name":"boolean algebra","slug":"boolean-algebra","permalink":"https://JihyeHwang09.github.io/tags/boolean-algebra/"}]},{"title":"Hexo를 이용한 블로그 만들기","slug":"hexo-blog","date":"2019-01-03T09:09:51.675Z","updated":"2019-01-06T14:35:43.749Z","comments":true,"path":"2019/01/03/hexo-blog/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/03/hexo-blog/","excerpt":"","text":"지난 포스트에서 정적블로그 플랫폼의 종류와 차이에 대해 소개했습니다.이번에는 Hexo를 이용한 블로그 만드는 방법에 대해 정리해봅시다. 1. Git, Nods.js 설치하기Hexo 블로그를 만들기 전, Git과 Node.js가 설치되어 있어야 합니다.Git과 Node.js가 이미 설치되어 있으신 분들은 2번부터 읽으시면 됩니다:) 1) Git 설치Git 다운로드 페이지 2) Node.js 설치Node.js 다운로드 페이지 2. GitHub 프로젝트(Repository) 만들기블로그의 포스트를 관리할 GitHub Repository를 만드는 과정입니다. GitHub 홈페이지 GitHub에 회원가입 후, 로그인을 합니다. 로그인 후, 우측 상단에 있는 초록색의 New를 눌러줍니다. Repository name에는 GitHub 계정명과 동일한 username을 사용하여 username.github.io로 작성한 후, Create repository 버튼을 누릅니다. 3. Hexo 설치하기 Git을 설치하면,Git Bash가 있으실 겁니다. 1) Git Bash를 실행시킵니다. 2) 터미널 화면에 $를 제외한 부분을 작성하고 Enter를 누르면,Hexo가 설치됩니다.1$ npm install -g hexo-cli 3) 블로그를 만들고 싶은 폴더 위치로 이동합니다. 그 후, 아래 코드를 입력합니다.blog 자리에 자신이 원하는 블로그 이름을 넣습니다.1$ hexo init blog 4) 자신이 원하는 폴더 위치에 blog 이름으로 된 폴더가 생성됩니다.현재 위치에서 블로그 이름으로 된 폴더로 이동합니다.1$ cd blog 5) npm을 설치합니다.1$ npm install 4. Hexo 실행해보기1$ hexo server 로컬서버인 http://localhost:4000로 접속하면, Hexo 블로그가 만들어진 것을 확인할 수 있습니다. Hexo 서버를 종료하려면, Ctrl + C를 눌러줍니다. Tip! 코드를 복사하고 싶은 경우에는 Ctrl + C가 아닌, Ctrl+Ins를 눌러줍니다. 5. Hexo 포스트 작성하기위와 같이 Hexo 설치가 완료되었다면, 이제 포스트를 작성해볼까요? 기본 명령어와 축약 명령어 중에 편하신 명령어를 입력해 줍니다. hexo new나 hexo n 뒤에는 포스트 제목을 적어줍니다. 1234$ hexo new firstpost// 기본 명령어$ hexo n firstpost// 축약 명령어 위의 명령어를 실행하여, firstpost.md라는 마크다운 파일을 생성합니다. 1$ code . 현재 생성된 firstpost.md파일을 Visual Studio Code로 열어줍니다. 위와 같은 디렉토리에 firstpost.md이라는 마크다운 파일이 생성된 것을 확인할 수 있습니다. firstpost.md 파일을 열면, 다음과 같이 작성되어 있습니다. 12345---title: firstpostdate: 2019-01-03 19:42:59tags:--- title은 자동으로 파일명과 똑같이 설정됩니다. 원하는 title로 수정한 후,아래의 ---의 다음 줄부터 마크다운 문법을 이용하여 글을 작성하시면 됩니다. 글 작성시, 실시간으로 포스팅한 모습을 확인하고 싶을 때는 터미널에 아래와 같은 명령어를 입력해줍니다. 1234$ hexo server// 기본 명령어$ hexo s// 축약 명령어 웹 브라우저에서 localhost:4000 경로로 접속하시면, 블로그의 모습을 실시간으로 확인할 수 있습니다. 포스트를 작성한 후, 실제로 서버에 올라갈 정적 페이지를 생성해줍니다. 1234$ hexo generate// 기본 명령어$ hexo g// 축약 명령어 터미널에서 위 코드를 실행하면, blog/public/ 디렉토리 아래에 실제 서버에 올라갈 웹페이지가 생성된 것을 확인할 수 있습니다. 6. GitHub과 Hexo를 연결해주기 로컬 외에 외부에서도 볼 수 있도록 서버에 올립니다. 1) GitHub에 Deploy 해 줄 플러그인을 설치합니다.1$ npm install --save hexo-deployer-git 2) Hexo 설정파일인 _config.yml를 열어서 #URL부분과 #Deployment부분을 수정해 줍니다. #URL부분을 위와 같이 수정해줍니다. #Deployment부분 역시 위와 같이 수정해줍니다. 3) GitHub 서버에 파일 올리기 터미널에서 명령어를 실행하여, GitHub 서버에 블로그 파일을 올려줍니다. 1234$ hexo deployment// 기본 명령어$ hexo d// 축약 명령어 Tip! 정적 페이지 생성과 배포를 함께 하고 싶다면, 아래 코드를 입력해줍니다.1$ hexo g -d 포스트 작성시 참고한 링크 [블로그 프레임워크 Hexo]:https://mechanickim.github.io/2018/03/17/20180317_blog_hexo/index.html [Github pages와 Hexo를 이용하여 블로그 만들기]:http://blog.lattecom.xyz/2016/06/28/hexo-blog-github-pages [GitLab Pages에 Hexo 블로그 설치하기]:http://inote.gitlab.io/2017/GitLab%EC%97%90%EC%84%9C%20Hexo%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0 [Hexo 블로그 만들기 1]:https://wonheesoo.github.io/2018/01/13/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-1-%EC%84%9C%EB%A1%A0-Hexo%EC%99%80-Github-Page-%EC%A1%B0%ED%95%A9%ED%95%98%EA%B8%B0 [Hexo, 정말 쉬운 블로그 프레임워크]:https://m.blog.naver.com/future_creator/220722153999 [Hexo로 Github 블로그 만들기]:https://medium.com/@dongmi.public/why-hexo-67070b1e0cc3 Reference [Hexo 공식 홈페이지 문서(한글)]:https://hexo.io/ko/docs/ [마크다운 문서 작성법]:https://gist.github.com/ihoneymon/652be052a0727ad59601","categories":[{"name":"Blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/categories/blog/"},{"name":"Hexo","slug":"blog/hexo","permalink":"https://JihyeHwang09.github.io/categories/blog/hexo/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/tags/blog/"},{"name":"framework","slug":"framework","permalink":"https://JihyeHwang09.github.io/tags/framework/"},{"name":"platform","slug":"platform","permalink":"https://JihyeHwang09.github.io/tags/platform/"},{"name":"hexo","slug":"hexo","permalink":"https://JihyeHwang09.github.io/tags/hexo/"},{"name":"Static Web Generator","slug":"static-web-generator","permalink":"https://JihyeHwang09.github.io/tags/static-web-generator/"},{"name":"git","slug":"git","permalink":"https://JihyeHwang09.github.io/tags/git/"},{"name":"node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"정적블로그 플랫폼(Static Web Generator)의 비교","slug":"blog-platform","date":"2019-01-02T08:09:11.680Z","updated":"2019-01-06T14:38:26.538Z","comments":true,"path":"2019/01/02/blog-platform/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/02/blog-platform/","excerpt":"","text":"정적 블로그 플랫폼 설명에 앞서,정적 웹페이지와 동적 웹페이지란 무엇이며 어떤 차이가 있는지를 살펴봅시다. 정적 페이지 VS 동적 페이지정적(static) 페이지 단순히 사이트 관리자가 미리 만들어놓은 웹 페이지를 볼 수 있는 사이트 데이터베이스(DB)를 사용하지 않음 Jekyll, Hexo, Hugo 등 동적(dynamic) 페이지 컨텐츠 내용이 서버에 있는 DB에 저장-&gt; 그 결과가 웹페이지에 반영되는 형태로 동작 일반적인 게시판 형태의 사이트들이 사용하는 방식 티스토리, 네이버 블로그 등 정적블로그 플랫폼(Static Web Generator)의 비교(Jekyll, Hexo, Hugo) Jekyll 특징 Ruby 기반 Github Page에 Git History 충돌 없이 포스트 버전관리 가능 GitHub Page는 Jekyll에 최적화되어 있음 한글 레퍼런스가 가장 많음 현재 가장 많은 사용자를 보유(Github 별 개수가 가장 많음) 단점 Ruby기반으로 초기 구축에 어려움이 있음(Ruby를 모르면, 플러그인 등 커스터마이징 하는데 불편할 수 있음) 윈도우 공식 지원 안됨 컴파일 속도가 느림 Hugo 특징 Golang 기반 컴파일 속도가 빠름(Jekyll, Hexo와 비교시 가장 빠름) 문서화가 잘 되어 있음 단점: 한글 레퍼런스가 거의 없음 Hexo 특징 자바스크립트(node.js) 기반 Node.js가 설치되어 있어야 하며, 기본적인 npm 사용 방법을 알아야 함 마크다운 문서로 만든 포스팅을 하는 방법이 간단함 윈도우 지원됨 컴파일 속도가 빠름 단점 Git으로 포스트 버전관리가 불가능함-&gt; 버전 관리를 위해서는 두 가지 브랜치를 따서 관리해야 함 Node.js의 템플릿 엔진을 그대로 사용 불가능(Github Page에는 Jekyll이 내장되어 있기 때문) 영어보다는 중국어로 된 질의응답이 많음 결론 앞서 살펴보았듯이 블로그 플랫폼 각각이 장단점을 가지고 있기 때문에우위를 따질 수는 없는 것 같습니다. 다만, 각 플랫폼의 장단점을 고려한 후, 본인에게 맞는 블로그 플랫폼을 선택하시는 게 좋겠죠:) 저는 비교적 익숙한 언어인 JavaScript 기반인 Hexo로 블로그를 시작하고, 차후에 Hugo로 이전을 고려해보는 방향으로 가닥을 잡았습니다. 포스트 작성시 참고한 링크 [정적 웹페이지 vs 동적 웹페이지]: http://snowdeer.github.io/blog/2016/03/21/static-dynamic-webpage [jekyll 블로그 프레임워크 비교, 왜 지킬인가? (feat. jekyll, hexo, hugo)]: https://qvil.github.io/blog/why-jekyll/#what [hugo + github 블로그 만들기 (feat. hugo &amp; github page)]: https://github.com/Integerous/Integerous.github.io [깃헙을 이용하여 호스팅하기]: https://www.slideshare.net/ssuser458523/ss-77033329 [정적 블로그, hexo 설치]: https://engineering.huiseoul.com/%EC%A0%95%EC%A0%81-%EB%B8%94%EB%A1%9C%EA%B7%B8-hexo-%EC%84%A4%EC%B9%98-f8df865a693a [웹의 이해 정적 페이지,동적 페이지 ]: http://coashanee5.blogspot.com/2017/07/blog-post_25.html","categories":[{"name":"Blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/categories/blog/"},{"name":"Hexo","slug":"blog/hexo","permalink":"https://JihyeHwang09.github.io/categories/blog/hexo/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/tags/blog/"},{"name":"framework","slug":"framework","permalink":"https://JihyeHwang09.github.io/tags/framework/"},{"name":"platform","slug":"platform","permalink":"https://JihyeHwang09.github.io/tags/platform/"},{"name":"Jekyll","slug":"jekyll","permalink":"https://JihyeHwang09.github.io/tags/jekyll/"},{"name":"hexo","slug":"hexo","permalink":"https://JihyeHwang09.github.io/tags/hexo/"},{"name":"Hugo","slug":"hugo","permalink":"https://JihyeHwang09.github.io/tags/hugo/"},{"name":"Static Web Generator","slug":"static-web-generator","permalink":"https://JihyeHwang09.github.io/tags/static-web-generator/"}]}]}