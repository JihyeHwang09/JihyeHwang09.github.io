{"meta":{"title":"꿈꾸는 지구별 개발자, Phang","subtitle":"꿈꾸는 지구별 개발자, Phang's IT Blog","description":"Phang's IT Blog using Hexo","author":"Phang","url":"https://JihyeHwang09.github.io"},"pages":[],"posts":[{"title":"4장 결과를 전달하는 HTTP 상태 코드","slug":"http-network-4","date":"2020-03-04T15:00:02.000Z","updated":"2020-03-04T16:17:17.902Z","comments":true,"path":"2020/03/05/http-network-4/","link":"","permalink":"https://JihyeHwang09.github.io/2020/03/05/http-network-4/","excerpt":"","text":"그림으로 배우는 HTTP &amp; Network(우에노 센 저 / 이병억 역 )을 읽고 정리한 내용입니다. 4. HTTP 상태 코드란 무엇인가? 4.1. 상태 코드는 서버로부터 리퀘스트를 전달한다 4.2. 2xx 성공(Success) 4.3. 3xx 리다이렉트(Redirection) 4.4. 4xx 클라이언트 에러(Client Error) 4.5. 5xx 서버 에러(Server Error) 4. HTTP 상태 코드란 무엇인가?클라이언트가 HTTP 리퀘스트를 보낸 결과(서버가 정상적으로 처리되었는지 또는 에러가 발생했는지)를 알려주는 것을 말한다. 4.1. 상태 코드는 서버로부터 리퀘스트를 전달한다리스폰스 상태 코드로 리퀘스트의 처리 결과를 알 수 있다.상태 코드의 역할: 클라이언트가 서버를 향해 리퀘스트를 보낼 때, 서버에서 그 결과가 어떻게 되었는지 알려주는 것 숫자 첫 번째 자리: 리스폰스의 클래스를 의미 나머지 2자리: 분류가 없다. 상태 코드 클래스 1xx (Informational): 리퀘스트를 받아들여 처리중 2xx (Success): 리퀘스트를 정상적으로 처리했음 3xx (Redirection): 리퀘스트를 완료하기 위해서 추가 동작이 필요 4xx (Client Error): 서버는 리퀘스트 이해 불가능 5xx (Server Error): 서버는 리퀘스트 처리 실패 4.2. 2xx 성공(Success)4.2.1. 200 OK: 클라이언트가 보낸 리퀘스트를 서버가 정상적으로 처리하였음을 의미4.2.2. 204 No Content 서버에서 리퀘스트를 받아서 처리하는 데는 성공했지만, 리스폰스에 엔티티 바디를 포함하지 않는다. 클라이언트에서 서버에 정보를 보내고, 서버측에서는 돌려줄 리소스가 없는 경우 사용한다. 4.2.3. 206 Partial Content 클라이언트에서 일부만 가지고 싶다고 서버에 리퀘스트한 경우를 말한다. Range에 의해서 범위가 지정된 리퀘스트에 의해서 서버가 부분적인 GET 리퀘스트를 받았음을 나타낸다. 리스폰스에는 Content-Range로 지정된 범위의 엔티티가 포함되게 된다. 4.3. 3xx 리다이렉트(Redirection)리퀘스트가 정상적으로 처리를 종료하기 위해 브라우저 측에서 특별한 처리를 수행해야 한다는 것을 나타낸다. 4.3.1. 301 Moved Permanently북마크를 변경하기 위한 리퀘스트를 보낸 경우이 때의 리스폰스는 리퀘스트된 리소스에 새로운 URI가 부여되어 있기 때문에이후로는 그 리소스를 참조하는 URI를 사용해야 한다는 것을 나타내고 있다. 따라서, 북마크하고 있는 경우,Location 헤더 필드에서 가리키고 있는 URI에 북마크를 다시 하는 게 좋다는 것을 나타내고 있다. ex) 디렉토리를 지정했을 때 마지막 부분에 슬래시(/)를 잊은 경우 request1http://example.com/sample 4.3.2. 302 Found리퀘스트된 리소스에 새로운 URI가 할당되어 있기 때문에 그 URI를 참조해 주길 바란다는 의미를 나타낸다.301과 비슷하지만, 302의 경우에는 영구적인 이동이 아니라 일시적인 이동을 의미한다.결국, 이동하는 곳의 URI는 앞으로 이동될 가능이 있다. ex) 북마크하고 있는 경우, 301의 경우와 같이 북마크를 변경하지 않는다.302를 돌려준 페이지에 대해서 북마크해야 한다. 4.3.3. 303 See Other이 리스폰스는 리퀘스트에 대한 리소스는 다른 URI에 있기 때문에 GET 메소드를 사용해서 얻어야 한다는 것을 나타낸다.302와 같은 기능이지만, 리다이렉트 장소를 GET 메소드로 얻어야 한다고 명확하게 되어 있는 점이 302와 다르다. ex) POST 메소드로 액세스한 CGI 프로그램을 실행한 후,처리 결과를 별도의 URI에 GET 메소드로 리다이렉트 시키고 싶은 경우 등에 303이 사용되고 있다.302 Found라도 같은 일이 가능하지만, 303을 사용하는 것이 바람직하다. 301, 302, 303 리스폰스 코드가 되돌아 오면,대부분 브라우저에서는 POST를 GET으로 바꾸어서 리퀘스트의 엔티티 바디를 삭제하고 리퀘스트를 자동적으로 재송신하도록 되어 있다.301, 302 사양은 POST를 GET 메소드로 바꾸는 것을 금지하고 있지만, 구현은 이렇게 되어 있는 경우가 대부분이다. 4.3.4. 304 Not Modified클라이언트가 조건부 리퀘스트를 했을 때 리소스에 대한 액세스는 허락하지만,조건이 충족되지 않음을 표시하고 있다. 4.3.5. 307 Temporary Redirect307에서는 브라우저 사양에 따라 POST에서 GET으로 치환을 하지 않는다.다만, 브라우저마다 리스폰스를 처리하는 동작이 다를 경우가 있다. 4.4. 4xx 클라이언트 에러(Client Error)4xx 리스폰스는 클라리언트의 원인으로 에러가 발생했음을 의미 4.4.1. 400 Bad Request리퀘스트 구문이 잘못되었음을 나타낸다.-&gt; 이 에러 발생시, 내용을 재검토한 후 재송신할 필요가 있다.브라우저는 이 400을 200 OK와 같이 취급한다. 4.4.2. 401 Unauthorized 리퀘스트 송신 -&gt; 최초의 401 리스폰스의 경우 이 페이지는 인증이 필요합니다 두 번째 401 리스폰스의 경우(이미 리퀘스트가 Authorization Required를 포함하고 있는 경우) 인증 실패 했습니다 이 리스폰스는 송신한 리퀘스트에 HTTP 인증(BASIC 인증, DIGEST 인증) 정보가 필요하다는 것을 나타낸다.또한, 이미 1번 리퀘스트가 이루어진 경우에는 유저 인증에 실패했음을 표시 401을 포함한 리스폰스를 되돌리는 경우리퀘스트 된 리소스에 적용된 challenge를 포함한 WWW-Authenticate 헤더 필드를 포함할 필요가 있다.브라우저에서 처음 401 리스폰스를 받은 경우: 인증을 위한 다이얼로그를 표시 4.4.3. 403 Forbidden리퀘스트된 리소스의 액세스가 거부되었음을 나타내고 있다.서버 측은 거부의 이유를 분명히 할 필요가 있는데, 이유를 명확하게 하는 경우에는 엔티티 바디에 기재해서 유저 측에 표시한다. 403이 발생한 원인: 파일 시스템의 퍼미션이 부여되지 않은 경우와액세스 권한에 문제(허가되지 않은 송신 IP 주소의 액세스 등)가 있는 것을 예로 들 수 있다. 4.5. 5xx 서버 에러(Server Error)리퀘스트한 리소스는 서버 상에 없다는 의미서버 측에 해당 리퀘스트를 거부하고 싶은 이유를 분명히 하고 싶은 경우와 그렇지 않은 경우에도 이용할 수 있다. 4.5.1. 500 Internal Server Error서버 원인으로 에러가 발생하고 있음을 의미한다.웹 애플리케이션에 에러가 발생한 경우 or 일시적인 경우도 있다. 4.5.2. 503 Service Unavailable일시적으로 서버가 과부하 상태이거나 점검중이기 때문에 현재 리퀘스트를 처리할 수 없음을 나타낸다.이 상태가 해소되기까지 시간이 걸리는 경우, Retry-After 헤더 필드에 따라 클라이언트에 전달하는 것이 바람직하다. 상태 코드가 현재 상황과 불일치할 수 있다.흔히 있는 상황으로 웹 애플리케이션에서 애플리케이션 에러가 발생한 경우에도상태 코드로는 200 OK가 되돌아오는 경우가 있다.","categories":[{"name":"Infra","slug":"infra","permalink":"https://JihyeHwang09.github.io/categories/infra/"},{"name":"http network","slug":"infra/http-network","permalink":"https://JihyeHwang09.github.io/categories/infra/http-network/"}],"tags":[{"name":"http network","slug":"http-network","permalink":"https://JihyeHwang09.github.io/tags/http-network/"},{"name":"그림으로 배우는 HTTP & Network","slug":"그림으로-배우는-http-network","permalink":"https://JihyeHwang09.github.io/tags/그림으로-배우는-http-network/"}]},{"title":"마크다운 문서 내의 목차 적용기","slug":"markdown-how-to-make-link","date":"2020-03-04T14:23:45.000Z","updated":"2020-03-04T16:10:36.827Z","comments":true,"path":"2020/03/04/markdown-how-to-make-link/","link":"","permalink":"https://JihyeHwang09.github.io/2020/03/04/markdown-how-to-make-link/","excerpt":"","text":"마크다운 문서 내의 목차가 필요하다 적용 방법 겪은 이슈와 해결한 방법 마크다운 문서 내의 목차가 필요하다블로그에 공부한 내용을 정리하면서 내용이 길 경우에는 어떤 내용이 있는지그 구조가 한 눈에 들어오지 않는 불편함이 있었다.목차의 제목을 클릭했을 때, 원하는 제목으로 바로 이동할 수 있도록 만들고 싶었다.검색해서 적용 방법을 알게 되었는지 검색 결과 그대로 적용하다가 문제가 발생해서해당 이슈에 대해서도 정리해보고자 한다. 적용 방법마크다운 문법으로 원하는 목차의 제목에 링크를 거는 방법을 알아보자.1. 띄어쓰기가 있는 부분은 -로 연결해주고,2. 영어는 모두 소문자로 만들어줘야 한다. 1[보여지는 내용](#이동하고자 하는 내용) 겪은 이슈와 해결한 방법이렇게 보면 적용 방법은 간단한데, 한 가지 문제가 발생했다.저장하기 전 상태에서는 문제가 없어 보였다. 저장 후의 모습이 아래와 같이 바뀌었다.링크를 감싸고 있는 소괄호() 안에 소괄호()가 중첩된 경우에 이슈가 발생했다. 목차명에 괄호나 점, 쉼표 등의 특수문자가 들어갔을 경우에는 무시하면 된다.특수문자를 제외하고 이동하고자 하는 링크의 내용만 적으면 된다는 점을 알게 되었다. ex) 이동하고자 하는 링크가 2xx 성공(Success)라면, 특수문자인 ()는 제외하고 이어서 써주면 된다.소괄호()안의 내용에는 2xx-성공success라고 적어주면 해당 링크로 매핑된다. 즉, 아래와 같이 작성하면 &lt;&gt;가 붙지 않고 링크가 정상적으로 작동한다.","categories":[{"name":"Tool","slug":"tool","permalink":"https://JihyeHwang09.github.io/categories/tool/"},{"name":"Blog","slug":"tool/blog","permalink":"https://JihyeHwang09.github.io/categories/tool/blog/"}],"tags":[{"name":"마크다운 문서 내의 목차 만드는 법","slug":"마크다운-문서-내의-목차-만드는-법","permalink":"https://JihyeHwang09.github.io/tags/마크다운-문서-내의-목차-만드는-법/"},{"name":"how to make list in markdown","slug":"how-to-make-list-in-markdown","permalink":"https://JihyeHwang09.github.io/tags/how-to-make-list-in-markdown/"}]},{"title":"3장 HTTP 정보는 HTTP 메시지에 있다","slug":"http-network-3","date":"2020-03-04T13:02:48.000Z","updated":"2020-03-04T13:08:13.217Z","comments":true,"path":"2020/03/04/http-network-3/","link":"","permalink":"https://JihyeHwang09.github.io/2020/03/04/http-network-3/","excerpt":"","text":"그림으로 배우는 HTTP &amp; Network(우에노 센 저 / 이병억 역 )을 읽고 정리한 내용입니다. HTTP 통신에는 클라이언트에서 서버로 보내는 리퀘스트와서버에서 클라이언트로 보내는 리스폰스가 있다.이 리퀘스트와 리스폰스가 어떻게 동작하는지 살펴보자. 3.1. HTTP 메시지3.2. 리퀘스트 메시지와 리스폰스 메시지의 구조 리퀘스트 라인: 리퀘스트에 사용하는 메소드, 리퀘스트 URI, HTTP 버전 상태 라인: 리스폰스 결과(상태 코드, 설명), HTTP 버전 헤더 필드: 일반, 리퀘스트, 리스폰스, 엔티티 헤더 필드 포함 그 외: HTTP의 RFC에는 없는 헤더 필드(쿠키 등)가 포함되는 경우가 있다. 3.3. 인코딩으로 전송 효율을 높이다3.3.1. 메시지 바디와 엔티티 바디의 차이 메시지(message): HTTP 통신의 기본 단위로 옥텟 시퀀스(Octet sequence, octet은 8비트) 엔티티(entity) 리퀘스트와 리스폰스의 페이로드(payload, 부가물)로 전송되는 정보 엔티티 헤더 필드와 엔티티 바디로 구성 HTTP 메시지 바디의 역할: 리퀘스트와 리스폰스에 관한 엔티티 바디를 운반하는 일 전송 코딩이 적용된 경우기본적으로 메시지 바디와 엔티티 바디는 같다.But, 전송 코딩이 적용된 경우, 엔티티 바디의 내용이 변화한다.-&gt; 메시지 바디와 엔티티 바디는 달라진다. 3.3.2. 압축해서 보내는 콘텐츠 코딩콘텐츠 코딩 엔티티에 적용하는 인코딩 서버에서 엔티티 정보를 유지한채로 압축한다. 콘텐츠 코딩된 엔티티는 수신한 클라이언트 측에서 디코딩한다. 주요 콘텐츠 압축 gzip(GNU zip) compress(UNIX 표준 압축) deflate(zlib) identity(인코딩 없음) 3.3.3. 분해해서 보내는 청크 전송 코딩HTTP 통신에서는 리퀘스트했었던 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면,브라우저에 표시되지 않는다.사이즈가 큰 데이터를 전송하는 경우에 데이터를 분할해서 조금씩 표시할 수 있다. 청크 전송 코딩(Chunked transfer Coding): 엔티티 바디를 분할하는 기능서버에서 엔티티 바디를 작게 쪼개고 나서 이 분해한 청크(덩어리)를 송신한다.수신한 클라이언트 측에서는 원래의 엔티티 바디로 디코딩한다. 3.4. 여러 데이터를 보내는 멀티 파트HTTP도 멀티파트에 대응하고 있어 하나의 메시지 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있다.주로 이미지, 텍스트 파일 등을 업로드할 때 사용한다. 멀티 파트의 종류 multipart/form-data: Web 폼으로부터 파일 업로드에 사용한다. multipart/byteranges: 상태 코드 206(Partial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용된다. HTTP 메시지로 멀티파트를 사용할 때는 Content-type 헤더 필드를 사용한다.멀티파트 각각의 엔티티를 구분하기 위해 “boundary” 문자열을 사용한다.각 엔티티의 선두에는 “boundary” 문자열 앞에 “--“를 삽입한다.ex) “–AaB03x”, “–THIS_STRING_SEPARATES” 멀티파트의 마지막에는 그 문자열의 마지막 부분에 “--“를 삽입해서 마무리한다.ex) “–AaB03x–”, “–THIS_STRING_SEPARATES–” 멀티파트는 파트마다 헤더 필드가 포함된다.파트의 중간에 멀티파트를 만드는 것과 같이 내부에 포함될 수 있다. 3.5. 일부분만 받는 레인지 리퀘스트리줌(resume): 이전에 다운로드를 한 곳에서부터 다운로드를 재개할 수 있는 기능이 기능을 실현하기 위해서는 엔티티의 범위를 지정해서 다운로드를 할 필요가 있다. 레인지 리퀘스트(Range Request): 범위를 지정해서 리퀘스트하는 것 레인지 리퀘스트를 사용할 경우, 전체 10,000 바이트 정도 크기의 리소스에서5,001 ~ 10,000 바이트의 범위(바이트 레인지)만을 리퀘스트할 수 있다. (한 이미지의 반절만 다운로드해 둔 후, 다음에 이어서 다운로드 가능) 레인지 리퀘스트를 할 때는 Range 헤더 필드를 사용해서 리소스의 바이트 레인지를 지정한다. 바이트 레인지의 형식 5,001 ~ 10,000 바이트 request1Range: bytes = 5001-10000 5,001 바이트 이상 request1Range: bytes=5001- 처음부터 3,000 바이트까지, 그리고 5,000 ~ 7,000 바이트까지의 복수 범위 request1Range: bytes=3000, 5000-7000 레인지 리퀘스트에 대한 리스폰스는 상태 코드 206 Partial Content라는 리스폰스 메시지가 되돌아온다.복수 범위의 레인지 리퀘스트에 대한 리스폰스는 multipart/byteranges로 리스폰스가 되돌아온다.서버가 레인지 리퀘스트에 지원하지 않는 경우, 상태 코드 200 OK라는 리스폰스 메시지로 완전한 엔티티가 되돌아온다. 3.6. 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션콘텐츠 네고시에이션(Content Negotiation)클라이언트와 서버가 제공하는 리소스의 내용에 대해서 교섭하는 것이다.클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조이다.콘텐츠 네고시에이션은 제공하는 리소스를 언어와 문자 세트, 인코딩 방식을 기준으로 판단하고 있다. 콘텐츠 네고시에이션의 종류 서버 구동형 네고시에이션(Server-driven Negotiation) 서버 측에서 네고시에이션하는 방식 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리한다. 브라우저가 보내는 정보를 근거로 하기 때문에 유저에게 정말로 적절한 것이 선택되었다고 보기 어렵다. 에이전트 구동형 네고시에이션(Agent-driven Negotiation) 클라이언트 측에서 네고시에이션하는 방식 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택한다.ex) JavaScript 등을 사용해서 웹 페이지에서 자동적으로 이것을 정하는 것도 있다.OS의 종류나 브라우저의 종류 등에 의해서 PC용과 스마크폰용 웹 페이지를 자동으로 전환하는 것 트랜스페어런트 네고시에이션(Transparent Negotiation) 서버 구동형과 에이전트 구동형을 혼합한 것 서버와 클라이언트가 각각 콘텐츠 네고시에이션을 하는 방식","categories":[{"name":"Infra","slug":"infra","permalink":"https://JihyeHwang09.github.io/categories/infra/"},{"name":"http network","slug":"infra/http-network","permalink":"https://JihyeHwang09.github.io/categories/infra/http-network/"}],"tags":[{"name":"http network","slug":"http-network","permalink":"https://JihyeHwang09.github.io/tags/http-network/"},{"name":"그림으로 배우는 HTTP & Network","slug":"그림으로-배우는-http-network","permalink":"https://JihyeHwang09.github.io/tags/그림으로-배우는-http-network/"}]},{"title":"ch2. 객체지향 프로그래밍","slug":"object-ch2","date":"2020-02-05T14:31:08.000Z","updated":"2020-02-05T22:36:59.774Z","comments":true,"path":"2020/02/05/object-ch2/","link":"","permalink":"https://JihyeHwang09.github.io/2020/02/05/object-ch2/","excerpt":"","text":"조영호님의 오브젝트: 코드로 이해하는 객체지향 설계를 읽고 정리한 내용입니다. 01. 영화 예매 시스템영화와 상영이라는 용어를 구분하자.두 용어의 차이가 중요한 이유는 사용자가 실제로 예매하는 대상은영화가 아니라, 상영이기 때문이다. 02. 객체지향 프로그래밍을 향해협력, 객체, 클래스이제부터는 예매 시스템보다는 객체 지향에 대해 알아보자.대부분의 사람들은 클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 고민한다.(객체 = 클래스라는 관점) -&gt; 객체지향의 본질과는 거리가 멀다.진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.객체들의 모양과 윤곽이 잡히면, 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고이 타입을 기반으로 클래스를 구현한다. 도메인의 구조를 따르는 프로그램 구조문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다.ex) 설계 순서의 예시일반적으로 RDB를 사용하는 실무에서의 설계 순서는 대부분 테이블을 만들고 그 테이블을기반으로 클래스를 만드는 설계하는 반면,이 책에서는 도메인을 먼저 구성한 후, 그 도메인을 기반으로 클래스를 설계하는 것이 좋다고 말한다.) 클래스 구현하기클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은어떤 부분을 외부에 공개하고 어떤 부분을 감출지 결정하는 것이다. 자율적인 객체두 가지 사실을 알아야 한다. 객체가 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재라는 것 객체가 스스로 판단하고 행동하는 자율적인 존재라는 것 객체지향 이전의 패러다임 VS 객체지향 객체지향 이전의 패러다임: 데이터와 기능이라는 독립적인 존재를 서로 엮어 프로그램을 구성 객체지향: 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음으로써 문제 영역의 아이디어를 적절하게 표현할 수 있게 함-&gt; 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 한다. 객체가 자율적인 존재로 우뚝 서기 위해서는 외부 간섭을 최소화해야 한다. 캡슐화와 접근 제어는 객체를 두 부분으로 나눈다. 퍼블릭 인터페이스(public interface): 외부에서 접근 가능한 부분 구현(implementation): 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분 프로그래머의 자유프로그래머의 역할을 클래스 작성자(class creator)와클라이언트 프로그래머(client programmer)로 구분하는 것이 유용하다.ex) 공통 코드를 만들어내는 플랫폼 개발자 -&gt; 클래스 작성자 객체 변경을 관리할 수 있는 기법 중에서 가장 대표적인 접근 제어는 경험과 연습이 중요하다.ex) 모든 method를 처음에는 모두 private으로 만들고,클라이언트 프로그래머에게 공개가 필요할 경우에 해당 method를 public으로 open하는 식으로 연습하는 경우도 있다. 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.설계가 필요한 이유는 변경을 관리하기 위해서라는 것을 기억하라. 접근 제어 메커니즘 프로그래밍 언어 차원에서 클래스의 내부와 외부를 명확하게 경계 지을 수 있게 한다. 클래스 작성자가 내부 구현을 은닉할 수 있게 해준다. 클라이언트 프로그래머가 실수로 숨겨진 부분에 접근하는 것을 막아준다. 협력하는 객체들의 공동체협력에 관한 짧은 이야기메서드를 호출한다는 메시지를 전송한다로 말하는 것이 더 적절한 표현이다.메시지를 수신한 객체는 스스로 적절한 메서드를 선택한다. 03. 할인 요금 구하기할인 요금 계산을 위한 협력 시작하기123456789101112131415161718192021222324public class Movie &#123; private String title; private Duration runningTime; private Money fee; private DiscountPolicy discountPolicy; public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) &#123; this.title = title; this.runningTime = runningTime; this.fee = fee; this.discountPolicy = discountPolicy; &#125; public Money getFee() &#123; return fee; &#125; public Money caculateMovieFee(Screening screening) &#123; // interface인 discountPolicy에 calculateDiscountAmount 메시지를 전송한다. // -&gt; 할인 요금을 반환 받는다. // Movie는 기본 요금인 fee에서 반환된 할인 요금을 차감한다. return fee.minus(discountPolicy.calculateDiscountAmount(screening)); &#125;&#125; caculateMovieFee 메서드에는 한 가지 이상한 점이 있다.어떤 할인 정책을 사용할 것인지 결정하는 코드가 어디에도 존재하는 않는다는 것이다.이 코드에는 객체지향에서 중요하다고 여겨지는 두 가지 개념인상속(inheritance)과 다형성(Polymorphism)이 숨겨져 있다.그리고 그 기반에는 추상화(abstraction)이라는 원리가 숨겨져 있다. 할인 정책과 할인 조건부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를자식 클래스에게 위임하는 디자인 패턴을 TEMPLATE METHOD 패턴[GOF94]라고 부른다.cf) Spring도 TEMPLATE METHOD 패턴을 이용한 경우가 많다.(IoC, DI) 헐리우드 원칙 “Don’t call us, we’ll call you”.부모 클래스는 서브클래스에 정의된 연산을 호출할 수 있지만반대 방향의 호출은 안 된다는 의미 할인 정책 구성하기외부에서 의존성을 주입하면 코드가 유연해진다.ex) 스프링의 제어의 역전(Inversion of Control)스프링에서는 프로그램의 흐름을 프레임워크가 주도한다.제어권이 컨테이너로 넘어가게 되어 제어권의 흐름이 바뀌는 것이다.따라서 개발자가 프로그램 코드로 객체 생성을 하지 않고, 컨테이너나 프레임워크가 만들어준 객체를 사용한다. 04. 상속과 다형성컴파일 시간 의존성과 실행 시간(런타임) 의존성 어느 한 쪽에 치우쳐서는 안 된다.한 가지 간과해서는 안 되는 사실은 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록코드를 이해하기 어려워진다는 것이다. 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다는 사실을 기억하라.반면, 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만,재사용성과 확장 가능성은 낮아진다. 차이에 의한 프로그래밍상속은 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.상속은 바라보는 관점에 따라 상대적이다.ex) java.lang 패키지 내의 모든 클래스의 최상위 클래스는 Object이다.자식 클래스로 Throwable이 있고, Throwable은 Error와 Exception의 부모 클래스가 된다. 상속과 인터페이스상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를자식 클래스가 물려받을 수 있기 때문이다.(public 메서드를 의미하는 것 같다.) 다형성다시 한번 강조하지만, 메시지와 메서드는 다른 개념이다.코드 상에서는 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.이를 다형성이라고 한다. 메시지가 바뀌지 않아도 메서드는 바뀔 수 있다. 정적 바인딩 VS 동적 바인딩 동적 바인딩(dynamic binding): 이미 코드가 돌아가고 있는 시점에서 바인딩하는 것(지연 바인딩(lazy binding)) ex) AOP, Reflection, Generic 정적 바인딩(static binding): 전통적인 함수 호출처럼 컴파일 시점에실행될 함수나 프로시저를 결정하는 것(초기 바인딩(early binding)) 상속을 이용하면 동일한 인터페이스를 공유하는 클래스들을 하나의 타입 계층으로 묶을 수 있다.이런 이유로 대부분의 사람들은 다형성을 이야기할 때 상속을 함께 언급한다.그러나 클래스를 상속받는 것만이 다형성을 구현할 수 있는 유일한 방법은 아니다. 인터페이스와 다형성여기서의 다형성은 인터페이스, 추상 클래스만을 의미하지는 않는다. 05. 추상화와 유연성추상화의 힘할인 정책이나 할인 조건의 새로운 자식 클래스들은 추상화를 이용해서 정의한 상위의 협력 흐름을 그대로 따르게 된다.재사용 가능한 설계의 기본을 이루는 디자인 패턴(design pattern)이나 프레임워크(framework) 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용하고 있기 때문에매우 중요하다. 추상 클래스와 인터페이스 트레이드오프이상적으로는 인터페이스를 사용하도록 변경한 설계가 더 좋을 것이다.현실적으로는 NoneDiscountPolicy만을 위해 인터페이스를 추가하는 것이 과하다는 생각이 들 수도 있을 것이다. 여기서 이야기하고 싶은 사실은 구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다는 사실이다.(ex) 인터페이스 -&gt; 추상클래스, 추상클래스 -&gt; 인터페이스) 코드 재사용합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다. 상속상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이다. 상속이 설계에 안 좋은 영향을 미치는 두 가지 관점 캡슐화를 위반한다. 설계를 유연하지 못하게 만든다.(추상화가 덜 됐다는 의미)(상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다.-&gt; 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.) 상속보다 인스턴스 변수로 관계를 연결한 설계가 더 유연하다. 합성상속: 부모 클래스의 코드와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 강결합합성: 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법(약결합) 합성은 상속이 가지는 두 가지 문제점을 모두 해결한다.인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다. 그렇다고 해서 상속을 절대 사용하지 말라는 것은 아니다.대부분의 설계에서는 상속과 합성을 함께 사용해야 한다.이처럼 코드를 재사용하는 경우에는 상속보다 합성을 선호하는 것이 옳지만다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수 밖에 없다. 더 생각해 볼 것 추상화란 무엇인가? 내가 생각하는 추상화란 무엇인가? 추상화의 적정 depth는 어느 정도일까?","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Object","slug":"back-end/object","permalink":"https://JihyeHwang09.github.io/categories/back-end/object/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://JihyeHwang09.github.io/tags/오브젝트/"}]},{"title":"두려움과 도전","slug":"TIL-2020-01-26","date":"2020-01-26T12:15:54.000Z","updated":"2020-01-26T14:06:48.436Z","comments":true,"path":"2020/01/26/TIL-2020-01-26/","link":"","permalink":"https://JihyeHwang09.github.io/2020/01/26/TIL-2020-01-26/","excerpt":"","text":"세상에 완벽한 준비라는 건 애초에 존재하지 않는다.도전하지 않으면 쟁취할 수 없다.용기있다는 건 두려움이 없어서가 아니라,두려움에도 불구하고 도전하는 것이라 하지 않았는가. 지금 너무 실망하지 말자.좌절하는 건 사실이지만,결핍이 날 더 강하게 만들테니 부족한 부분을 채워나가면 된다. 내가 부족하다고 느끼는 부분들을 얼마만큼 채워야 하는지어떻게 공부해야 하는지를 알았다면,그저 묵묵히 꾸준히 해내면 된다. 외롭고 힘든 길이지만, 꾸준히 하면 된다.분명히 된다. 지금 그 시기가 오지 않은 것 뿐.미래의 한 시점에는 파편처럼 흩어진 이 지식들이 연결되어 있을 테니.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"},{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/tags/developer/"}]},{"title":"개발자 도전기- 처음 시작을 떠올려 본다.","slug":"TIL-2020-01-25","date":"2020-01-24T17:30:21.000Z","updated":"2020-01-26T15:45:25.550Z","comments":true,"path":"2020/01/25/TIL-2020-01-25/","link":"","permalink":"https://JihyeHwang09.github.io/2020/01/25/TIL-2020-01-25/","excerpt":"","text":"명절이 되니 처음 개발자가 되겠다고 했던 그 때가 떠오른다.내가 개발에 대해 흥미를 갖기 시작한 건 아이들이 하는 블록 코딩(드로그 앤 드롭으로 코딩 블록을 완성하는 코딩 게임)을 처음 접하고 나서부터 였다.세상에 이렇게 재밌는 게 있을까? 신기하고 놀라웠다. 그 당시 개발과 전혀 관련 없는 회사에 다니고 있었고, 나이도 서른이었다.개발자로 커리어 전환을 하기 위해 혼자서 공부와 회사 일을 병행하기에는어려움이 있다고 판단했고, 학원에서 포트폴리오를 만들어서 개발자로 첫발을 내딛어야 겠다고결심하고 회사를 그만뒀다. 회사를 그만둔다고 했을 때, 회사의 상사와 일부 사람들로부터“전공자도 아닌데 네가 무슨 개발자가 된다고?”“지금 개발 공부한다고 해서 그 나이에 널 신입으로 뽑겠니?”라는 말을 수도 없이 들었다. 나의 가족과 친한 친구들은 처음에는 걱정했지만,그렇게 좋아하고 원한다면 해보는 게 좋을 거 같다고 응원해주었다. 누군가는 자신이 가지 않은 길에 대해서 어디선가 듣고,“그 직업은 이렇다더라.”라든가, “내가 못했는데 네가 할 수 있을리가 없지.”라는 식으로 쉽게 부정적으로 바라보기도 한다. 회사에서는 승진과 연봉 상승을 제시했고, 갈림길에 놓였을 때 생각했다.‘내가 이 세상 떠나는, 눈 감는 순간에 이 일을 하지 않은 걸 후회하지 않을까?’후회 할 거라는 생각이 들었다.도전하지 않는다면, 정말 큰 후회로 남게 될 것이라는 생각이 들었다.도전해서 만약 개발자가 되지 못하더라도 후회하지 않겠노라고 다짐했다.‘마음 가는 대로 해보자.’ 라는 생각에 회사를 그만두고 도전을 시작했다. 회사를 그만두고 국비 지원 학원에서 공부하기 시작했다.국비 지원 학원에서 공부하면서 일주일에 3 ~ 4일 밤을 새고나머지 날들에는 2 ~ 3시간 자면서 공부했다.이렇게 공부해도 내 실력은 좀처럼 나아지지 않았다. 그 학원에서 내가 제일 못했었다. 그 못한다는 수준이 어느 정도였냐면,처음에 자바 문제를 주면 뭐부터 써야하는지 몰라서 모니터만 쳐다보고 있었다.강의실에 타닥타닥-! 키보드를 치는 소리가 울려퍼지고, 옆 사람들은 문제를 푸는데난 그 어떤것도 칠 수 없었다.프로그래밍적인 사고를 하기가 어려웠다.그건 단기간에 시간을 많이 쏟아붓는다고 해서 해결될 문제가 아니었다. ‘넌 프로그래밍쪽으로 재능이 없으니 그만두는 게 낫지 않겠니?’라는 얘기도 들었다.처음에는 내가 프로그래밍에 대한 이해가 느리다는 사실을 인정하고 싶지 않았다.‘이렇게 열심히 하는데, 왜 난 못하는 걸까?’라는 생각에 사로 잡혔다.그 부담감으로 더 힘든 게 사실이었다. 일주일에 3 ~ 4일 밤을 새기를 3개월 지속했더니 심장에 이상이 왔다.대학 병원에서 검사를 받았더니, 이렇게 잠 안자면 급성 과로사로 죽을 수 있다고 했다. 그렇게 학원을 그만 두고, 바람도 쐬고 휴식하면서 여러 생각이 들었다. 내 인생의 우선순위가 무엇인가, 내가 너무 프로그래밍을 잘하고 싶다는 생각만 한 건 아닐까?내가 왜 프로그래밍을 하고 싶었는가, 그 시작을 생각해 보았다.처음 그렇게 즐겁고 행복해했던 그 때를 떠올려 보았다.‘그래, 마음을 비우자. 이렇게 꾸준히 하다보면 언젠가 그 지식들이 연결되는 날이 오겠지.아직 그 때가 안온 것 뿐이야. 언젠간 되겠지.’ 이 위기가 내 인생의 터닝포인트가 되었다고 생각한다.내가 죽을 수도 있다는 생각이 들었을 때,비로소 내게 소중한 것이 무엇인지, 소중한 사람이 누구인지를 생각하는 계기가 되었다.‘내일은 눈 뜰 수 없을지도 모른다.’라는 생각에오늘 하루가 주어졌다는 것을 감사할 줄 알게 되었고,버스 창 밖으로 비치는 햇살의 따스함을 오롯이 느낄 줄 알게 되었다.소중한 사람들에게 에너지를 집중하고 함께 할 수 있어 행복감을 느꼈다.그렇게 살아있는 것에 감사하고, 내 두 다리로 자유롭게 어디든 걸어다니고자연을 느끼며 내 인생을 되돌아보게 되었다. 그렇게 마음을 비우고 다른 학원에 가서 다시 시작했다.‘건강을 해치지 않는 선에서만 최선을 다하자.’마음을 비우고 잠을 푹 자면서 5 ~ 6시간은 꼭 수면 시간을 지키면서 공부했다.국비지원 학원을 다닐 당시에 급성으로 심장에 무리가 온 것이라,지금은 건강하고 아무 이상 없어서 참 감사하다. 얼마전에 국비지원 학원에서 함께 공부했던 동기들을 만났는데,내가 개발자가 되어 일하고 있는 걸 보고 놀랍다고 했다.프로그래밍을 이해하기 어려워했으니,개발을 포기하고 개발자를 할 수 없을 거라고 생각했다고 한다. 사실 개발자가 된 지금도 어려운 일들이 많다.좌절도 많이 하고, 내 실력에 대해서 회의가 들 때도 있다.그렇지만 내가 좋아하는 개발 공부를 할 수 있고,그 공부를 좋은 사람들과 함께 할 수 있어 행복하다. 내가 하고 싶은 일을 할 수 있어 행복하다.처음 다른 이들이 말했던 것처럼나이가 많아서, 전공자가 아니라서 용기내지 않았다면, 지금은 어떻게 됐을까?가끔은 내가 개발자로 일하고 있는게 신기하다.개발을 하고 있는 것 자체가 기적처럼 느껴진다. 만약 나처럼 어려움을 겪고 있는 사람이 있다면, 이 글이 조그마한 위로가 되었으면 한다.개발을 처음 공부하면서 어려움을 겪고 있는 분들과 과거의 나의 어깨를 두드리며얘기를 건네고 싶다. 다른 사람이 뭐라 하든, 너의 길을 가면 돼.충분히 잘하고 있고, 앞으로도 잘 해낼 수 있어.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"},{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/tags/developer/"}]},{"title":"AWS Community Day 후기","slug":"seminar_aws-communityday-2020","date":"2020-01-21T04:38:30.000Z","updated":"2020-01-22T03:05:00.244Z","comments":true,"path":"2020/01/21/seminar_aws-communityday-2020/","link":"","permalink":"https://JihyeHwang09.github.io/2020/01/21/seminar_aws-communityday-2020/","excerpt":"","text":"AWS Community Day에서 인공지능/딥러닝의 세션들을 들었는데, 개인적으로 가장 인상깊었던 세션인자동으로 코드 리뷰를 자동화해주는 AI 서비스 CodeGuru에 대해 정리해보고자 한다. 자바를 잡아주는 GURU가 있다구? 우여명(백엔드 엔지니어, 아이스크림 에듀) CodeGru 개발자들의 코드 리뷰를 자동화해주는 서비스 현재 프리뷰 상태인 서비스 아마존에서 현재 사용중인 서비스 현실에서 코드 리뷰의 어려움 현실 세계에서의 코드 리뷰는 잘 안되는게 현실이다. 코딩 자동화 도구들 CodeGru의 특징 PR 기반의 코드 리뷰 도구인 CodeGuru Reviewer 에이전트가 수집한 데이터를 기반으로 성능(CPU) 관련 시각화 및 해결책을 제안하는 CodeGuru Profiler 아마존이 수십년간의 지식과 경험을 기반으로 학습한다. 확인된 문제를 고칠 수 있는 실행 가능한 구체적인 방법을 제공 현재 Java 언어만 지원 현재 Preview 상태 현재 Github과 AWS CodeCommit 소스 코드만 가능 실제 사람인 코드 리뷰어와 코드 그루 리뷰어 둘 다 코드 리뷰를 할 수 있다. 사람이 하는 코드 리뷰를 보완해준다.(사람이 하는 코드 리뷰를 대체하는 게 아님) 현재 사용가능한 리전: us-east-1, us-east-2, us-west-2, ap-southeast-2, eu-west-1 CodeGuru Reviewer가 다루는 영역 AWS 모범 사례: AWS API 사용 잘못 사용할 경우, 성능(ex) 폴링) 또는 정확성 및 안전성(ex) 페이징 처리) 문제 발생 동시성: 동시성 구조의 올바른 구현 잘못 사용할 경우, 정확성(ex) 동기화 누락) 또는 성능 문제(ex) 과도한 동기화)가 발생하여 가용성에 영향 리소스 누수: 올바른 리소스 처리 잘못 처리할 경우( ex) 데이터 베이스 연결을 해제하지 않음) 속도가 느려지고 가용성에 영향 민감 정보 유출: 개인 식별 정보 유출 민감한 정보가 유출되면(ex) 신용 카드 번호 기록) 컴플라이언스 이슈 발생 마이닝 데이터로 발견된 코드 결함: 찾기 어려운 결함들 문제를 해결할 경우(ex) 각 람다 호출마다 클라이언트를 만들지 않음) 코드 품질이 향상 리뷰어에 대한 아마존 개발자들의 피드백 중요한 코드에 숨어있는 오랜 레이스 컨디션을 파악할 수 있었다. 일반적으로 사용하지 않는 방식으로 Amazon DynamoDB 테이블을 사용하고 있었고 코드 리뷰에서 이를 놓쳤다.리뷰어는 작업이 전체 결과 대신 페이징된 결과를 반환하고 있음을 확인하여 문제를 잘 잡았고 좋은 해결책도 주었다. 리뷰어는 (DB 커넥션 같은) 리소스를 닫기 위해서 try-with-resources 구문을 사용할 것을 추천했고, 즉시 구현했다. CodeGuru Profiler 해결 가능성이 높은 성능 최적화 해결책을 찾도록 학습 긴 응답시간 &amp; 낮은 처리량 높은 CPU 사용률 어떻게 코드를 고칠 지 제안 아마존에서 수년 동안 축적된 성능 엔지니어링 경험으로 학습된 지능형 프로파일러 프로파일러에 대한 아마존 개발자들의 피드백Chris Butterfield, SDE 프로파일러가 제안한 해결책으로 CPU 시간의 55.97%를 사용하는 스레드 경합이 제거되었다. 수정 후 단일 호스트는 이전보다 최대 7.5배 더 많은 트래픽을 처리할 수 있다. 동일한 트래픽을 처리하면서 인스턴스 수를 75%까지 줄였다. Rajesh Konatham, SDE 프로파일러가 제안한 클론을 삭제하는 해결책으로 CPU 사용량이 크게 감소했다. 동기 플릿의 경우 40%, 비동기 플릿의 경우 67%가 감소했다. CodeGuru Profiler DEMO [CodeGuru Profiler-sample-application]: https://github.com/aws-samples/aws-codeguru-profiler-sample-application AI 기반 도구가 개발자에게 끼칠 영향 개발자의 삶에 스며 들고 있는 AI 유용하게 활용한다면 유의미한 생산성 증가 기대 코드 어시스턴트를 활용하여 코드 생산성 증가 기대 코드 리뷰 도구를 활용하여 실수와 성능 및 보안 문제 해결 기대 개발자가 좀 더 비즈니스 로직의 구현에 집중 현재 아쉬운 점 리뷰의 시작과 종료에 대한 알림이 없다. 댓글이 없을 경우, 리뷰가 정상적으로 진행된 것인지 확인하기 어렵다. 사용성 측면에서 개선 여지가 많다. AWS Community Day를 다녀오며 느낀점개인적으로는 서울 리전에서는 아직 프리뷰 상태라는 게 아쉽다.키노트 시간에 언급된 이야기 중 인상깊었던 부분이 있었다.아직 우리나라에서는 이제 막 도입하고 사용하고 있는 분위기인데,미국에서는 서버리스와 컨테이너가 당연하다고 한다.미국 최앞단의 시간과 우리나라에서의 IT의 시간은 다른 속도로 흐르는 것 같다.이미 아마존에서는 이 CodeGuru 서비스를 도입하고 실제 업무에서 사용하면서개발자들이 직접 하는 코드 리뷰를 보완하고 있다고 한다는 점이 놀라웠다.특히 리뷰어는 서울 리전에서 사용할 수 있게 되면, 직접 도입해서 사용해 보고 싶다는 생각이 들었다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Seminar & Conference","slug":"developer/seminar-conference","permalink":"https://JihyeHwang09.github.io/categories/developer/seminar-conference/"}],"tags":[]},{"title":"2장 간단한 프로토콜 HTTP","slug":"http-network-2","date":"2020-01-05T15:20:04.000Z","updated":"2020-01-05T15:33:08.130Z","comments":true,"path":"2020/01/06/http-network-2/","link":"","permalink":"https://JihyeHwang09.github.io/2020/01/06/http-network-2/","excerpt":"","text":"그림으로 배우는 HTTP &amp; Network(우에노 센 저 / 이병억 역 )을 읽고 정리한 내용입니다. HTTP 프로토콜의 구조주로 HTTP/1.1을 다룬다. HTTP는 클라이언트와 서버 간에 통신을 한다 리퀘스트와 리스폰스를 교환하여 성립 HTTP는 상태를 유지하지 않는 프로토콜 리퀘스트 URI로 리소스를 식별 서버에 임무를 부여하는 HTTP 메소드 GET: 리소스 획득 가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과이다. ex) 리소스가 텍스트 -&gt; 그대로 반환CGI와 같은 프로그램 -&gt; 실행해서 출력된 내용을 돌려준다. POST: 엔티티 전송 PUT: 파일 전송 HTTP/1.1 PUT 자체에는 인증 기능이 없어서 누구든지 파일을 업로드 가능하다. -&gt; 보안 문제 발생 일반적인 웹 사이트에서는 사용되지 않는다. PUT 메소드를 사용하는 경우 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우 REST(Representational State Transfer)와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용 HEAD: 메시지 헤더 취득 GET과 같은 기능이지만, 메시지 바디는 돌려주지 않는다. 목적: URI 유효성과 리소스 갱신 시간을 확인 DELETE: 파일 삭제 PUT 메소드와는 반대로 동작 Request URI로 지정된 리소스의 삭제를 요구한다. 일반적인 웹 사이트에서는 사용되지 않는다. DELETE 메소드를 사용하는 경우 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우 REST(Representational State Transfer)와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용 OPTIONS: 제공하고 있는 메소드의 문의 Request URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용 TRACE: 경로 조사 거의 사용되지 않는다. 크로스 사이트 트레이싱(XST)과 같은 공격을 일으키는 보안 상의 문제도 있다. CONNECT: 프록시에 터널링 요구 주로 SSL과 TLS 등의 프로토콜로 암호화 CONNECT 프록시 서버: 포트 HTTP 버전 2.6. 메소드를 사용해서 지시를 내리다메소드는 대문자와 소문자를 구별한다.(대문자로 기재할 필요가 있다.) 2.7. 지속 연결로 접속량을 절약HTTP 초기 버전: HTTP 통신을 한 번 할 때마다 TCP 연결 문제를 해결하기 위해서 지속 연결(Persistent Connections)이라는 방법을 고안함지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다. 지속 연결을 하는 이점 TCP 커넥션의 연결과 종료를 반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 적어진다. 오버헤드를 줄인 만큼 HTTP 리퀘스트와 리스폰스가 빠르게 완료되기 때문에 웹 페이지를 빨리 표시할 수 있다. 2.7.2. 파이프라인화Response를 기다리지 않고 바로 다음 Request를 보낼 수 있다.여러 리퀘스트를 병행해서 보내는 것이 가능하다. -&gt; 일일이 Response를 기다릴 필요가 없다. 2.8. 쿠키를 사용한 상태 관리HTTP를 스테이트리스(stateless) 프로토콜이다.-&gt; 과거에 교환했었던 Request와 Response의 상태를 관리하지 않는다.-&gt; 과거 상태를 근거로 해서 현재 Request를 처리하는 건 불가능하다. 스테이트리스(stateless) 프로토콜의 이점 상태를 유지 않는다는 점 -&gt; 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있다. 단순한 프로토콜이라는 점 -&gt; HTTP를 다양한 곳에서 이용할 수 있다. 쿠키Request와 Response에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템이다.쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 된다. 1) 쿠키를 가지지 않았을 때(1회째)의 리퀘스트 클라이언트 -&gt; 서버: 리퀘스트 송신(서버에서는 쿠키를 발행 누구에게 무엇을 전달했는지 기억해 둔다.) 서버 -&gt; 클라이언트: 리스폰스에 쿠키를 붙여서 송신 2) 쿠키를 가지고 있을 때(2회째 이후)의 리퀘스트 클라이언트 -&gt; 서버: 리퀘스트에 쿠키를 붙여서 송신 서버 -&gt; 클라이언트: 서버에서 발행했던 쿠키의 sid와 일치하는지 확인","categories":[{"name":"Infra","slug":"infra","permalink":"https://JihyeHwang09.github.io/categories/infra/"},{"name":"http network","slug":"infra/http-network","permalink":"https://JihyeHwang09.github.io/categories/infra/http-network/"}],"tags":[{"name":"http network","slug":"http-network","permalink":"https://JihyeHwang09.github.io/tags/http-network/"},{"name":"그림으로 배우는 HTTP & Network","slug":"그림으로-배우는-http-network","permalink":"https://JihyeHwang09.github.io/tags/그림으로-배우는-http-network/"}]},{"title":"1장 웹과 네트워크의 기본","slug":"http-network-1","date":"2020-01-05T14:30:28.000Z","updated":"2020-01-05T15:33:19.405Z","comments":true,"path":"2020/01/05/http-network-1/","link":"","permalink":"https://JihyeHwang09.github.io/2020/01/05/http-network-1/","excerpt":"","text":"그림으로 배우는 HTTP &amp; Network(우에노 센 저 / 이병억 역 )을 읽고 정리한 내용입니다. 1.3 네트워크의 기본 TCP/IP1.3.1. TCP/IP는 프로토콜의 집합1.3.2. 계층으로 관리하는 TCP/IP 애플리케이션 계층 트랜스포트 계층 네트워크 계층(인터넷 계층) 링크 계층(데이트 링크 게층, 네트워크 인터페이스 계층) 1.3.3. TCP/IP 통신의 흐름송신 측에서는 반드시 헤더로 불리는 해당 계층마다 그 계층에 필요한 정보를 추가한다.수신 측에서는 각 계층을 거칠 때마다 반드시 해당 계층마다 사용한 헤더를 삭제한다. 1.4. HTTP와 관계가 깊은 프로토콜은 IP/TCP/DNS1.4.1. 배송을 담당하는 IP 통신은 ARP를 이용하여 MAC 주소에서 한다 그 누구도 인터넷 전체를 파악하고 있지는 않다 1.4.2. 신뢰성을 담당하는 TCP1.4.2.1. 상대에게 데이터를 확실하게 보내는 것이 일이다과정을 진행하다가 어디선가 통신이 도중에 끊길 경우, TCP는 그와 동시에 같은 순서대로 패킷을 재전송한다. 1.5. 이름 해결을 담당하는 DNSDNS는 도메인명에서 IP 주소를 조사하거나 반대로 IP주소로부터 도메인명을 조사하는 서비스를 제공한다. 1.6. 각각과 HTTP와의 관계1.7. URI와 URL1.7.1. URI는 리소스 식별자 Uniform Resource Identifier IANA- Uniform Resource Identifier(URI) SCHEMES 1.7.2. URL 포맷 &#39;http:&#39;와 &#39;https:&#39; 같은 스키마를 사용해서 리소스를 얻기 위해 사용하는 프로토콜을 지시한다. 대문자와 소문자는 무시되고 마지막에 콜론(:)이 하나 붙는다. data:와 javascript:와 같이 데이터와 프로그램을 지정할 수 있다. 자격정보(크리덴셜): 서버로부터 리소스를 취득하려면 자격정보(크리덴셜)가 필요하다. 서버 주소: 완전 수식 형식인 URI에서는 서버 주소를 지정할 필요가 있다. 서버 포트 서버의 접속 대상이 되는 네트워크 포트 번호를 지정한다. 옵션 사항이며, 생략시, 디폴트 포트가 사용된다. 계층적 파일 패스 특정 리소스를 식별하기 위해서 서버 상의 파일 패스를 지정한다. UNIX 디렉토리 지정 방법과 비슷하다. 쿼리 문자열 파일 패스로 지정된 리소스에 임의의 파라미터를 넘겨주기 위해 쿼리 문자열을 사용한다. 옵션 사항 프레그멘트 식별자 주로 취득한 리소스에서 리소스(도큐먼트 중간에 위치)를 가리키기 위해서 프레그멘트 식별자를 사용한다. 옵션 사항","categories":[{"name":"Infra","slug":"infra","permalink":"https://JihyeHwang09.github.io/categories/infra/"},{"name":"http network","slug":"infra/http-network","permalink":"https://JihyeHwang09.github.io/categories/infra/http-network/"}],"tags":[{"name":"http network","slug":"http-network","permalink":"https://JihyeHwang09.github.io/tags/http-network/"},{"name":"그림으로 배우는 HTTP & Network","slug":"그림으로-배우는-http-network","permalink":"https://JihyeHwang09.github.io/tags/그림으로-배우는-http-network/"}]},{"title":"실전에서의 디자인 패턴","slug":"design-pattern-etc","date":"2019-12-28T08:32:59.000Z","updated":"2019-12-28T09:46:18.148Z","comments":true,"path":"2019/12/28/design-pattern-etc/","link":"","permalink":"https://JihyeHwang09.github.io/2019/12/28/design-pattern-etc/","excerpt":"","text":"Head First - Design Patterns(에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠 저 | 서환수 역)을 읽고 정리한 내용입니다. 디자인 패턴 정리 데코레이터 패턴: 객체를 감싸서 새로운 행동을 제공한다. 스테이트 패턴: 상태를 기반으로 한 행동을 캡슐화한 다음 위임을 통해서 필요한 행동을 선택한다. 이터레이터 패턴: 컬렉션이 어떤 식으로 구현되었는지 드러내진 않으면서도 컬렉션 내에 있는 모든 객체에 대한 반복 작업을 처리할 수 있게 해준다. 퍼사드 패턴: 일련의 클래스에 대해서 간단한 인터페이스를 제공한다. 스트래티지 패턴: 교환 가능한 행동을 캡슐화하고 위임을 통해서 어떤 행동을 사용할지 결정한다. 프록시 패턴: 객체를 감싸서 그 객체에 대한 접근을 제어한다. 팩토리 메서드 패턴: 생성할 구상 클래스를 서브클래스에서 결정한다. 어댑터 패턴: 객체를 감싸서 다른 인터페이스를 제공한다. 옵저버 패턴: 상태가 변경되면 다른 객체들한테 연락을 돌릴 수 있게 해준다. 템플릿 메서드 패턴: 알고리즘의 개별 단계를 구현하는 방법을 서브클래스에서 결정한다. 컴포지트 패턴: 클라이언트에서 객체 컬렉션과 개별 객체를 똑같이 다룰 수 있도록 해 준다. 싱글턴 패턴: 딱 한 객체만 생성되도록 한다. 추상 팩토리 패턴: 클라이언트에서 구상 클래스를 지정하지 않으면서도 객체 그룹을 생성할 수 있도록 해 준다. 커맨드 패턴: 요청을 객체로 감싼다. 디자인 패턴 분류하기디자인 패턴의 분류를 공부하고 외우는 건 우선 순위가 높은 지식은 아니므로가볍게 보도록 하자. 생성, 행동, 구조 관련 패턴으로 나누는 경우 클래스와 객체 패턴으로 나누는 경우 리팩토링(refactoring)리팩토링을 할 경우, 인터페이스가 변경되면 안 된다.클라이언트 코드를 변경해야 한다면, 리팩토링이라고 할 수 없다. public method를 변경해서 return 타입이 바뀔 경우는엄밀히 따지자면 리팩토링이라고 보기 어렵다.클라이언트에서 코드를 변경해야 하므로 스펙 변경이라고 볼 수 있다. 그럼 리팩토링이란 무엇일까? 리팩토링은 코드를 변경하되 외부에는 변경을 노출하지 않는 것이다. private method의 경우에는 return type이 바뀌는 것도 리팩토링이라고 할 수 있다.(코드 변경의 여파가 클라이언트까지 미치지 않기 때문이다. ) 패턴을 대하는 마음가짐초보자들은 언제나 패턴을 사용하는 경향이 있다.어떻게 패턴을 사용하면 좋을지 고민하는 성장의 과정이라고 볼 수 있다. 패턴을 쓰면 안 될 때디자인 패턴의 과다한 사용은 불필요하게 복잡한 코드를 초래한다. 안티 패턴1. 싱글톤싱글톤이 안티패턴인 이유? 상속이 불가능하다. 테스트가 어려워진다.Mocking은 기본적으로 상속을 이용하는 것이므로 테스트를 하기 어려워지게 된다.cf) 스프링- 싱글톤 레지스트리자바에서 싱글톤을 직접 구현할 일은 거의 없다. 2. optional 사용 Null 체크시, Optional 사용을 자제하자. 123456789String str = \"\";Optional o = Optional.of(str);// get() 메서드는 비어있는 Optional 객체를 대상으로 호출하면, 예외를 발생시킨다.// 따라서, 객체의 존재 여부를 bool 타입으로 반환하는// isPresent()라는 메소드를 통해 null 체크를 한다.if (o.isPresent()) &#123; o.get();&#125;o.map().map().map(); 위의 코드는 Optional을 이용해서 Null 체크를 하는 경우이다.이 코드가 하고 있는 Null 체크는 간단하게 아래와 같이 바꿀 수 있다. 1234String str = \"\";if (str != null) &#123; str;&#125; Optional을 어쩔 수 없이 써야하는 경우가 아니라면, 사용을 자제하자. 추천 도서 GoF의 디자인 패턴","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Design-pattern","slug":"back-end/design-pattern","permalink":"https://JihyeHwang09.github.io/categories/back-end/design-pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://JihyeHwang09.github.io/tags/design-pattern/"}]},{"title":"우아한 테크의 밤 후기","slug":"seminar_wootechnight-2019","date":"2019-12-24T11:16:23.000Z","updated":"2019-12-28T09:32:24.370Z","comments":true,"path":"2019/12/24/seminar_wootechnight-2019/","link":"","permalink":"https://JihyeHwang09.github.io/2019/12/24/seminar_wootechnight-2019/","excerpt":"","text":"김범준님배달의 민족 분당 288만 건의 트랜잭션(e-commerce 중 국내 최대 트랜잭션) 한 달에 4천만 건의 트랜잭션 음식 배달 서비스는 고객이 주문하고 싶은 그 시점에 반드시 주문이 가능해야 한다. -&gt; 장애가 나면 다른 커머스보다 더 크리티컬 하다.(음식점 사장님은 그 날 하루의 장사를 공치게 되고,고객은 먹고 싶은 그 시점에 주문이 불가능하기 때문) 오프라인 모드에서의 주문(기술적인 도전) 앱에 소비자가 최근에 실행했던 가게 정보를 앱 내의 local cache에 저장해서오프라인 모드에서도 나오게 구현 최악의 경우(통신 불가능)에 가게 정보에 전화번호를 띄워서고객이 직접 전화해서 주문할 수 있도록 만듦 B마트 당일에 한해 예약 배달도 가능 즉시 배달의 편리성(cf) 쿠팡 프레시, 마켓 컬리: 다음날 배송) 편의점보다 저렴한 가격으로 가격 경쟁력 확보 배달 로봇그 외 서비스: 만화경, 띠잉우아한 개발 조직 우아한 형제들에서는 기술 관리자(TM), 기술 전문가(TE) 나누어원하는 트랙으로 선택해서 커리어 진행 가능 비전 코드 덩어리가 아닌 가치를 만들고 스스로의 가치를 높이며 일한다. 우아한 아키텍처- 김영한님2015 하루 주문 5만 PHP, MS-SQL, ASP 리뷰 서비스 하나가 장애나면, 전체 서비스가 다 장애가 발생하는 문제가 있었음 2016 하루 주문수 10만 돌파 PHP -&gt; JAVA로 전환 첫 자바 마이크로 서비스 도전 시작 결제, 주문 중계 독립 2017 하루 주문수 20만 돌파 대 장애의 시대(매주 장애 발생) 메뉴, 정산, 가게 목록 시스템 독립 2018 상반기 탈루비의 시대 N광고 폭파 -&gt; 아키텍처 tf 창설 가게 상세 재개발(주요 장애 포인트) 비즈니스 프로젝트보다 탈루비가 더 중요하다고 판단 쿠폰, 포인트 탈루비 2018 하반기 주문 탈루비(MS-SQL) 이전 레거시 3대장 주문 데이터 지분 1위 하루 100만 데이터 가게/업주 시스템 연관도 1위 광고 프로시저 사용 1위 주문 이벤트 기반으로 아키텍처 변경 가게/업주 컬럼이 너무 많았음 ex) 가게 리뷰 카운트까지 한 테이블에 몽땅 같이 들어 있었음 배민의 좋은 문화 의견이 달라서 다투더라도 합리적인 의견이라면, 빨리 수긍하고 앞으로 나아간다. MSA 구조- 4년간의 MSA 전환기 현재 배민 아키텍처CQRS 핵심 비즈니스 명령(Command) 시스템과 조회(Query) 중심의 사용자 서비스 둘을 철저하게 분리 성능, 장애 격리, 데이터 동기화 설계 당시에는 AWS 카프카가 없었음 1. 성능 초당 15,000 트래픽을 버틸 수 있도록 설계 변경 2. 장애 격리 가게, 광고 같은 내부 서비스나 DB에 장애가 발생해도 고객 서비스는 유지해야 함 3. 이벤트 전파와 동기화 Eventually Consistency(최종적 일관성) 데이터는 언젠가는 다 맞추어진다. 데이터 싱크 1~3초(주문 확인은 가게 사장님이 바로 확인하지 않으므로1~3초의 데이터 싱크 시간은 용인 가능하다고 판단함) 문제 발생시 해당 시스템 이벤트만 발생 ZERO-PAYLOAD 방식 가게 id만 Queue로 전달한 후, api로 최신 데이터를 가져와서 처리 최소 데이터 보관 원칙 주문에 필요한 데이터만 들고 있다. 데이터 저장소 조회(고성능) 가게 노출: DynamoDB(NoSQL), Redis(Cache) 광고리스팅, 검색: Elasticsearch(검색엔진) 바로결제 라이브: Redis(Cache) 명령 Aurora: 가게/업주(정합성이 중요한 도메인): RDB 조회(Query)에 특화된 서비스만 15,000TPS를 고민하면 된다. 명령(Command)와 조회성 서비스 분리 장애 격리 각 시스템이 내부에 필요한 데이터 보관 내부 서비스(광고, 검색)의 모든 변경 내역이 장애 데이터 싱크가 늦어져도 고객 서비스는 가능하도록 한다. 데이터 싱크 장애 대응 이벤트 재발행 전체 IMPORT API 제공 부분 IMPORT API 제공 싱크가 5분 늦어져도 서비스 가능(5분 단위로 전체 데이터 조회하는 api) 기타 적극적인 캐시 사용 서킷 브레이커 비동기 Non-Blocking 시스템 적용 스프링 Webflux, Reactor 정리 배달의 민족 시스템은 거대한 CQRS 성능이 중요한 외부 시스템과 비즈니스 명령이 많은 내부 시스템으로 분리 이벤트 발행을 통한 Eventually Consistency(최종적 일관성) 각 시스템은 API 또는 이벤트 기반 2019.11.1 탈루비(MS-SQL 탈피)!! 현재 16개의 서비스로 분리 패널 토크 1- 조영호님, 김민태님기존 프로젝트의 레거시를 안고 객체 지향으로 만드는 법- 조영호님 기술적 측면 도메인 영역에 기술적인 영역이 침투하지 않도록 만들어주는 프레임 워크를 선택하자.(영호님이 선택했던 방법) 조직적 측면 시스템에서 이 영역은 객체 지향적으로 만들어 인터페이스를 만들어서 끊어내자. 조금, 조금씩 지속적으로 배포하자. 큰 뭉텅이가 아니라 조금씩 배포해야, 바로바로 장애를 인지하고 대처할 수 있다. -&gt; 회사에 문화 전파하기 반복의 중요성- 김민태님 뭔가를 성장시키려면, 큰 덩어리로 가기 어렵다. 문제가 보여야 해결할 수 있다! 명확하게 내가 어느 부분이 부족한지를 인지(자기 상태를 자가 진단) 해당하는 부분을 보안할 계획 세우기 피드백 나 자신 다른 사람 누구에게, 어떻게 피드백 받을 수 있을지 고민해 볼 것 전략 세우기 공부에 대한 방향, 커리어에 대한 조언- 김민태님 개발자로 끝까지 가르침을 받을 수 없다. 자가 발전 방법을 수립할 것 학교에서 배우듯이 차례대로 배우는 건 요즘 시대에 맞지 않다. ex) 알고리즘 -&gt; 자료구조 -&gt; 운영체제 이런식으로 차근차근 단계를 밟아서 배우는 것 지속하려면 전략을 세워야 한다. 짧고 넓은 범위로 학습한다.(야생 학습) 초기에 깊이, 넓이를 고민하지 말자. 금방 깊어지거나 넓어지지 않는다. 배움의 흥미를 유지할 수 있을 정도로 유지 아무 생각 없이 이것 저것 하는게 아니라, 짧은 사이클로 계획 -&gt; 실행 -&gt; 피드백을 반복 바라는 시니어 개발자의 모습(기준)조영호님 기본적인 역량인 개발을 잘 해야 한다. 시니어 개발자는 주니어 개발자와 기준이 좀 다르다. 강압적이지 않은 커뮤니케이션 사람을 키우는 것보다 그 팀이 함께 성장하고 있다는 것이 중점 ex) 어떤 기술을 도입하기 위해 우리 팀이 스터디를 해보자. “무조건 두 달 안에 할 수 있어요!”가 커뮤니케이션을 잘하는 게 아니다. ex) 한 시니어 개발자가 기한 안에 할 수 있다고 말한 뒤,중간 상황을 공유하지 않다가 기한이 되자 아무것도 하지 못한 일이 있었음 이런 경우, 회사 내에서 그 팀 전체의 이미지가 안 좋아질 수 있다. 같이 일했던 동료들이 그 시니어 개발자를 어떻게 평가하는지가 중요하다. 면접에서 5분 안에 강압적인 사람인지를 판단한다. 자기소개, 배민을 왜 지원 했는지 등의 질문을 했을 때,체계적으로 생각하면서 말하는지, 중언부언 하는지 (은연중에) 사용하는 단어, 말투 면접에서 강압적인 분위기를 파악한 후, 레퍼런스 체크 김민태님 긴장해서 대답을 못하는 경우와 싸한 느낌이 들 때를 구분하기 위해 연관된 질문을 계속 한다. ex) “~를 설명해주시는데, ~한 상황이라고 가정하고 얘기해주세요.”식의질문에 조건을 넣으면, 강압적인 분들은 이 제한 조건을 잘 듣지 못하고 대답하는 경우가 대부분이었다. 패널 토크 2- 이동욱님, 권용근님회사 일과 개인 공부 병행하는 법이동욱 님 개인 공부를 할 때, 회사 공부에 관련 없는 공부는 하지 않는다. 사용하고 있는 오픈 소스의 JDK도 수정할 수 있을 정도의 실력을 위해서는곧 이런 기술을 회사에서 사용하겠다 싶은 기술, 회사에서 적용해 볼만한 기술을 공부한다.(버그를 고칠 수 있을 만큼의 수준으로 공부) 공부 방법 책을 보고, 깡통 서버를 띄우거나 하는 식으로 직접 만들어 본다. 블로그에 나만의 해석으로 책 내용을 정리한다.(그냥 책 내용을 적기만 하면 복붙에 불과하다.) 공부 시간대: 아침 일찍 회사에서 출근해서 공부 권용근님 공식 문서 위주로 공부한다. 라이브러리를 직접 까보면서 공부하는 편 책은 보조적으로 사용한다. 야생 학습법 개발자들에게 효율적이었다. 먼저 코드를 쳐보면서 만들어본다. 실질적인 프로젝트를 만들면서 반복적으로 실패를 경험하고 성장해 나간다. 공부 시간대: 새벽 2,3시까지 공부 토이 프로젝트- 권용근님 챗봇, 코덕: 운영한 지 1년 넘었다. 1년 밖에 안됐지만 레거시 코드가 되어 직접 개선하는 경험을 하고 있다. DDD, Test Code, JPA를 중심으로 레거시를 개선하는 토이 프로젝트를 진행하고 있다. 사수의 역할, 사수 없이 일한 경험- 이동욱님 내 옆에 있는 사수는 언제든 떠날 수 있다. 있을 때, 배울 거 하나라도 빼먹자. 사수가 없을 경우의 장점도 있다. ex) 테스트 코드를 당연히 짜야한다고 하면서 좋은 문화를 도입해보는 경험을 할 수 있다. 신입 개발자의 마음가짐- 권용근님 기술을 쫓는 개발자가 되면 안된다. 기본 소양이 굉장히 중요하다. 토이 프로젝트 &lt; 기본 소양 기술은 언제든지 바뀔 수 있다. 기본 소양 없이 기술만 쌓아 올리면, 무너질 수 있다. ex) 테스트 코드 짜기 -&gt; 코드 품질 챙기기 토이 프로젝트를 하려면, TDD로 해보는 것을 추천 코드 품질 VS 비즈니스적인 요구사항 구현- 이동욱님 나만의 학습 방법을 신입 때 갖춰 놓아야, 어느 기술이든 빠르게 배울 수 있게 된다. 테스트 코드이동욱님 배달의 민족의 정산 서비스만 테스트 코드가 1,400개 테스트 코드가 문서의 역할을 하고 있다. ex) 정산시스템팀에서는 A라는 상황에서 B라는 메서드 실행시 C라는결과가 나와야 한다는 식으로 한글로 테스트 코드 메서드명을 짓고 있다. 일정 산정시, 개발자가 직접 기한을 말할 수 있어야 한다. 톰캣 재실행하는 것보다 테스트 코드 돌리는 게 훨씬 더 빠르다. 톰캣 2~3번 띄울 시간에 단위 + 통합 테스트(1,400개) 돌릴 수 있다.(약 7분 소요) 테스트 코드에 대한 리팩토링도 계속 진행 중이다. ex) 1조원에서 1원 차이나면, 찾을 수 있나? 테스트 코드를 짜지 않는 것을 죄악시한다. 우아한 형제들 팀 중에서는 Jenkins에서 코드 커버리지가 떨어지면, push를 못하게 막는 팀도 있다. 정산팀은 보통 코드 커버리지 80% 유지하고, 배치 등의 코어는 특히 관리한다. 설계나 디자인이 잘되어야 테스트 코드 짜기도 용이하다. 권용근님 팀의 현재 테스트 코드는 1,100개 테스트 코드 작성의 장점 테스트를 잘 짜지 못하더라도 개발자의 공포감을 없애주고 자신감을 갖게 해준다. 새로운 기술 도입에 대한 우아한 형제들의 개발 문화이동욱님기술 선택의 자유도가 있다.회사의 기조는 장애가 났을 때, 장애할 수 있으면 된다는 것 느낀점캐주얼한 분위기의 세미나는 처음이었다.우아한 형제들에서 베스트 셀러 저자분들과 블로그, 유튜브에서 유명한 개발자분들을직접 뵙고 얘기를 들을 수 있어서 좋았다.푸짐한 케이터링과 함께 우아한 형제들의 서비스가 좀 더 좋은 방향으로 가기 위해어떤 선택들을 하고 노력해왔는지를 알 수 있는 시간이었다.패널 토크에서는 학습법에 대한 여러 방안들을 알 수 있었고, 다양한 방법들을시도해보고 나에게 맞는 나만의 학습 방법을 찾아가고자 한다.또한, 테스트 코드의 중요성을 다시 한 번 느꼈다.공포감을 없애준다는 권용근님의 말이 와닿았다.테스트 코드에 대해 좀 더 고민해보고 적용해 나가자. 참고 링크 우아한 테크의 밤 참석후기, 정리[진짜 개발자가 되자.] 우아한 테크의 밤 - 요약(정리중)[허원철의 개발 블로그]","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Seminar & Conference","slug":"developer/seminar-conference","permalink":"https://JihyeHwang09.github.io/categories/developer/seminar-conference/"}],"tags":[{"name":"우아한 테크의 밤","slug":"우아한-테크의-밤","permalink":"https://JihyeHwang09.github.io/tags/우아한-테크의-밤/"}]},{"title":"데브그라운드 주니어 2019 후기","slug":"seminar-habit-devground-junior-2019","date":"2019-12-24T10:59:37.000Z","updated":"2019-12-24T11:14:33.473Z","comments":true,"path":"2019/12/24/seminar-habit-devground-junior-2019/","link":"","permalink":"https://JihyeHwang09.github.io/2019/12/24/seminar-habit-devground-junior-2019/","excerpt":"","text":"개발자가 갖추어야 할 9가지 기술- 박종천 1년~ 5년 정도 Hard Skill을 익히는 게 중요하다. 회사에서 성공하는 사람은 남들이랑 잘 지내는 사람이다. 다른 사람들과 의견 소통을 하고 아이디어를 합치고 하는 것이 일을 잘하는 것이다. 이력서, 자기소개서에서 중점적으로 보는 부분 내가 왜 이 회사를 선택했는가라는 내용이 있는가를 본다. 왜 당신이 이 회사에 오고 싶은지 당신은 이 회사에 와서 무엇을 할 수 있는가 협업을 잘 하는가 채용의 목표는 잘하는 사람을 뽑는게 아니라, 못하는 사람을 안 뽑기 위한 것이다.이걸 아는 게 중요하다. 회사 입장에서는 뭘 알아서 와도 입사하면 새로 가르쳐야 한다. 무조건 공부하고 버리는 게 이 업계의 트렌드이다. 개발자에 대한 평가 이 사람이 빠르게 배울 수 있느냐 → 똑똑한가 부지런한가 착해야 한다.(다른 사람을 속이거나 하는 사람은 뽑지 X) Vision회사와 팀, 내 인생의 비전이 일치해야 일하기 편해진다. 벤자민- 나는 세상을 배우는 사람과 배우지 않는 사람으로 나눈다. 내가 그 일을 잘하는가 못하는가가 중요한 게 아니다.꾸준히 배우고 성장하는 게 중요하다. 개발자로서의 자기관리우리 조직 말고 다른 조직의 사람을 한 달에 한 명씩 1년만 만나봐라.사람을 만나는 게 중요하다.한 달에 책 한 권씩 읽어봐라.이렇게 2가지만해도 큰 변화다. 시간 관리자기관리는 시간관리다. (돈도 마찬가지) 필요한 데에 쓰는 것 낭비하는 것 투자하는 것 본인이 사용한 시간을 1주일동안 위의 3가지 항목으로 나눠서 분석해보고 계획하자. 낭비를 0으로 줄이고 투자를 극한으로 30%로 올려야 한다. ex) 책을 1주일에 1 권 읽고, 운동은 1주일에 1시간 주니어 시기에는 최대한 시간 투자를 해야 한다. 공부하고 사람들 만나고, 영어를 공부해라. 지금부터 영어를 미친듯이 해놓아야 나중에 돌아온다. AI: 막막해하는 당신에게- 임태규AI란 무엇인가?4차 산업혁명: 현재 진행형사람 대신 AI 1. 기본적으로 언어를 많이 알아야 한다.프로그래밍 언어 기본적인 언어를 잘 알되, 해석하는 능력을 키워야 한다. → 코드 리뷰를 잘해야 한다. 다른 사람의 코드를 보고 의도를 명확하게 파악하고,본인이 코드를 짰을 때 다른 사람이 의도를 명확하게 파악할 수 있게 짤 수 있어야 한다. 한 언어만 깊게 파서 잘 알아두면, 언어들은 비슷한 점이 많으므로 쉽게 배울 수 있게 된다. 2. 언어를 알고 있는데, 어떻게 활용하지? 기본적으로 Data Structure를 알고 있어야 한다. 어떨 때 어떤 자료구조를 써야 하지?가 중요하다. 연습 밖에 방법이 없다. 최소한 10문제 이상 풀어보기 이력서, 면접 나 자신을 잘 세일즈 해야 한다. (회사에서 원하는 기술과 방향으로) 반드시 프로젝트를 진행했을 때, 장점, 단점, 가치를 반드시 얘기할 수 있어야 한다. ex) 각각 이런 Function들이 있고, 이런 key들이 있고1초가 걸리는 이슈가 있었고, 이를 1/ms로 줄였다는 식으로 본인이 이슈를 해결한 경험을 얘기할 수 있어야 한다. 실패한 프로젝트는 없다. 끝내지 않은 프로젝트만 있을 뿐이다. 무슨 일이든 이것이 성공하든 실패하든 끝을 보자. (무얼 만들기로 했으면 그 끝을 보자.) 이 프로젝트에서 내가 얻은 게 뭐고, 실패했던 것, 보안할 것들을 &gt; 체크리스트로 만들고 보안해나가자. Time &amp; WorkTime management(30 minutes)출근을 하면, 16개의 셀(30분 단위)로 나누고 셀마다 할 일을 나누어 적기 Work management 해야 할 것 할 수 있는 것 하지 말아야 할 것- 내가 손대면 오늘 죽겠다하는 것들 하지 말아야 할 것이 줄어들고, 할 수 있는 것이 늘어날 수 있도록 시간 관리를 하자. So. What would you sell?능력은 무궁무진하다. 내 능력을 어떻게 세일즈할까를 잘 고민해보고 표현해야 한다. Q&amp;A파이썬을 중점적으로 깊게 파는 게 중요하다.선형대수, 확률, 물리수학을 모르고 라이브러리만 사용한다면, 한 단계를 더 나아갈 수 없다.수식을 알고 있다면, 머릿속에 있는 생각을 수식으로 만들고 알고리즘으로 표현할 수 있다. 내가 주니어 개발자 때 알았더라면 좋았을 것들Part1. 김태현 연봉을 떠나서 그 업계의 1위 회사를 가라. 다만 지역이 달라서 접근성이 떨어져서 그렇지 개발을 한국인이 못하는 것이 아니다. 비슷한 실력에 한국에서 잘하면 삼성이나 네이버 가는거고,미국에서 비슷한 실력이면 구글, 페이스북 등 가는 것이다. 30대 초반이라면, 직접 실리콘밸리에 가서 일하는 걸 추천한다. 꾸준히 코딩 공부를 하자. leetCode에서 준비를 함 (700~800 문제가 있음) 미디엄 레벨로 20분 안에 풀 수 있으면 통과할 수 있음 200~300문제를 풀면, 패턴이 보이기 때문에 이 정도 문제를 푼다. 코딩에 장점이 있는건 스크립트 언어가 편하다. 하루에 한 문제씩이라도 공부할 것 아마존도 분기나 반기마다 한 번씩 한국에 와서 개발자들을 채용한다. 일하면서 비자 문제가 해결되면 실리콘 밸리 어느 회사든지 가서 일할 수 있다. 가장 중요한 것: 영어 공부하라. 미리 준비하자.기회가 훨씬 더 많다.너무 좁은 시장 안에서 가둬서 생각하지 마라.시야를 넓혀라. part2. 정도현Learn and Be Curious와 Dive DeepLearn and Be Curious뭔가 궁금한 게 있을 때 궁금증을 가지고 최대한 밑바닥까지 파고 들어가자. Dive Deep호기심이야말로 개발자 힘의 원천이다.특정 주제를 깊이 있게 읽는 게 필요하다.어려운 책이라도 여러 번 반복해서 읽고 이해하려고 노력하라.자꾸 쉽고 얇은 책을 찾는데, 시간과 노력, 끈기를 충분히 투자해서 파보자. 멋진 이력을 가지는 법현재의 이력서와 미래의 이력서를 함께 유지하라.1년에 최소 2번은 업데이트 하자.미래에 내가 가지고 싶은 이력서를 만들자.이 2가지 이력서를 어떻게 일치시킬 것인가를 고민해보고,정기적으로 점검하자. 참고 링크:http://bit.ly/resume4developer 현재의 이력서에 도움이 되지 않는다면, 이직을 심각하게 고려해보자. 주니어 개발자일 때는 이직에 실패해도 그 데미지가 상대적으로 적다. 나중에는 당장 월급을 주는 곳으로 가게 된다. 주니어 때 이직을 적극적으로 해보자. 주니어 때 저축 꼭 하자. 돈을 많이 모아두지 않으면, 나중에 돈 때문에 하기 싫은 일도 해야 하기 때문이다. 글쓰기와 개발자좋은 개발자는 좋은 작가이다. 추천 도서 코딩호러가 들려주는 진짜 소프트웨어 개발 이야기 조엘 온 소프트웨어 코딩을 잘하기 위해서는 글쓰기를 열심히 하는 것도 도움이 된다.내가 하는 일과 배운 것들에 대해 체계적으로 정리하는 능력을 기르면, 개발에서 어떤 일을 하든지 도움이 된다. 최고의 학습법추천 학습법: 남을 가르쳐 봐라.남을 가르치는 것이야말로 가장 좋은 학습법이다.수업 듣는 건 실제로 머릿 속에 5% 밖에 남지 않는다. 가르치는 방법- 커뮤니티를 활용해보자.ex) AWSKRUG- 발표, 핸즈온100번 듣는거보다 1번 앞에서 발표하는 게 훨씬 더 가치있고 기억에 남는다. 스택오버플로우에 영어로 질문해보기질문하는 능력이 취약하다.모르는 거 있으면 모른다고 하자. 영어 공부영어로 된 커뮤니티가서 말을 붙여보자. 이직의 적정 주기1년 반이면 한 팀의 업무에 익숙해진다.2 ~ 3년이면 이직을 하자.(평균 3년)이직이 아니면, 회사 내에서 롤을 바꾸는 등의 사내에서 기회를 찾자. sns보다 잘하는 개발자들 github이나 블로그를 follow를 하자. 기술적인 면에서 1년에 하나 정도 새로운 언어를 배우자. But, 그 중에 하나 정도는 깊게 이해하자.(자신만의 무기 만들기) 블로그를 가장 추천한다. 내가 오늘 뭘 배웠는지, 기술적으로 궁금한 것 등 학습 이력을 남기자! 성장을 바라는 프론트엔드 개발자를 위한 제언- 김민태성장을 바라보는 두 가지 시선1. 내가 생각하는 성장 VS 내가 상상하는 성장내가 상상하는 성장과 생각하는 성장의 괴리를 좁히는 것이 중요하다.나만의 호흡과 전략. 의미있는 훈련이 필요하다.굉장히 긴 마라톤이다.조급해하면 지는 것이다. 어떤 긴호흡? 목표, 실행, 피드백, 충전, 목표, 실행, 피드백, 충전, 목표… 가장 핵심적인 것 목표를 아주 작게 구체적으로 세우고, 실제로 실행하고, 실행한 것에 대해 반드시 피드백을 받아야 한다. 피드백을 받고 중간 목표를 다시 세우고… 마라톤이므로 중간에 멈추지 않고 달려가려면, 중간에 휴식이 있어야 한다. 개발자로 생활하면서 중간에 건강이 안좋아진다. 스스로 에너지가 바닥나서 번아웃이 오면 회복이 안될 수 있다. 2.타인이 바라보는 성장 VS 타인이 평가하는 성장타인이 바라보는 것이 스펙 성장을 위한 결심만으론 부족하고 객관화를 위한 측정 지표를 만들자. 결심한 목표와 형태가 적절한가? - 달성 기준은 무엇인가? - 성장 목적은 무엇인가?왜 그 기술을 선택했는지 등 Why에 대한 고민이 필요하다. 멘토에 대한 두 가지 생각멘토가 필요한 이유 VS 멘토가 없어야 하는 이유멘토링에서 효과적인 방법1:1 멘토링이 효과가 가장 좋다. Why? 코칭을 해주는 사람이 나에 대해 많이 알면 알수록 나의 문제점을 짚어줄 수 있다. 성장에 영향을 주는 환경중요도 순서대로 나열해보자.태도 &gt; 동료&gt; 회사&gt; 멘토 &gt; 기술 이 중에서도 태도를 배우는 게 가장 어렵다. 열정을 가지고 있어서 주위 사람들에게도 영감을 줄 수 있는가 상대적으로 가장 배우기 쉬운 건 기술이다. 배움을 가장 많이 주는 건 동료이다. 동료에게 배움을 받으려면 열린 마인드를 가지고 있어야 한다. 어떤 걸 배워야 할까? 나는 정말 어떤걸 배워야하는지 모르는가? 지름길은 없다. 하지만 시간은 없다. 조급해하지 마라! 시간은 우리의 편이다. 어차피 마라톤이다. 내 호흡에 맞는 시간 관리법을 만들자. 조언은 내것으로 만드는 게 중요하다. 성장 로드맵에 정답은 없다. 정리성장은 환경에 적응하는 것이다.환경은 시간이 흐르면 계속 바뀐다.만들어야하는 소프트웨어, 요구사항, 해결해야 하는 문제가 바뀐다.그러므로 성장해야만 한다.끊임없이 나 자신에게 질문하자.ex) 지금 핫한 기술도 내년에 망할 수 있다.ex) 변한 환경에서 내가 눈치채지 못하고 있는 것은 무엇이지? 본인만의 싸이클을 찾자. 어떻게 성장할 것인가? 싸이클이 2주짜리, 한 달짜리 등등 본인에게 맞는 싸이클이 있다. 해봐야 안다! 혼자 성장할 수 있는 상태를 만들어야 한다.(자가 학습이 가능한 상태) 다음에 배울 것을 내가 스스로 정하고, 실행하고 객관적으로 평가, 피드백하고이걸 끊임없이 반복하면서 성장해나가는 과정 홀로서기할 수 있는 상태로 어떻게 만들 것인가. 개인 프로젝트를 반드시 하라. 주변 동료들이 불편해하는 걸 살펴봐서 그런걸 만든다. 동료들에게 제공해준다. 오픈소스 속에서 성장하기- 강대명 회사 업무를 통해 성장하자. 토이 프로젝트https://github.com/naver/arcus Redishttps://github.com/antirez/redis 딱 주제와 상관없는 다른 것들은 굳이 고치지 말자. 남들이 올리는 이슈에서 간접적으로 겪을 수 있다. 오픈 소스 접근 방법 내가 많이 쓰는 오픈소스를 고르자.(결국 볼 수 밖에 없다.) 내가 충분히 익숙한 언어로 구현되었는가? (익숙한 언어가 아니면 공부해야함) Kafka: Scala(core)/Java Kubernates: Go 기반 지식을 충분히 이해하고 있는가? Linux는 운영체제, Spark는 분산처리에 대해 알아야 함 전체 모든 지식이 아니라 필요한 부분의 배경 지식이 필요하다. ex)Timing Attack 커뮤니티는 활발한가? PR을 던졌을 때 리뷰를 받을 수 있어야 한다. 좋은 답변 얻을 수 있다. 오픈 소스 공부의 세속적인 장점 업무에 필요한 툴에 대한 이해도가 더 높아진다. 취업이나 이직시, 내가 이 부분을 공부하고 있다는 근거가 되어준다. 해당 기술을 구현하는 오픈소스에 공헌하고 있다. 오픈 소스 학습법장애가 났을 때, 전체를 한 번에 보려고 하지 말고 그 부분만 보는 연습을 하자. 지식의 특징배워서 남주면, 더 이해도가 높아진다. 데브그라운드 주니어를 다녀온 후 느낀 점먼저 개발자의 길을 걷고 있는 분들의 다양한 경험담들을 들을 수 있어 즐거웠던 세미나였다.주니어들이 가장 많은 고민을 하는 학습 방법이나 다각도의 방향에 대해 알 수 있었다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Seminar & Conference","slug":"developer/seminar-conference","permalink":"https://JihyeHwang09.github.io/categories/developer/seminar-conference/"}],"tags":[{"name":"devground junior 2019","slug":"devground-junior-2019","permalink":"https://JihyeHwang09.github.io/tags/devground-junior-2019/"}]},{"title":"프록시 패턴(Proxy pattern)","slug":"design-pattern-proxy","date":"2019-12-23T11:54:32.000Z","updated":"2019-12-23T12:26:53.820Z","comments":true,"path":"2019/12/23/design-pattern-proxy/","link":"","permalink":"https://JihyeHwang09.github.io/2019/12/23/design-pattern-proxy/","excerpt":"","text":"Head First - Design Patterns(에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠 저 | 서환수 역)을 읽고 정리한 내용입니다. 프록시 패턴(Proxy pattern)의 정의어떤 객체에 대한 접근을 제어하기 위한 용도로,실제 객체의 메서드를 호출하면 그 호출을 중간에 가로채는 패턴 Tip&gt;책에 나온 프록시의 종류들 즉 용어 하나하나를 아는 건 중요하지 않다.프록시 패턴의 용도와 쓰임새를 보자. 프록시 패턴은 스프링의 AOP에 많이 쓰인다. AOP 구현 방법 XML 스키마 기반의 POJO 클래스를 이용한 AOP구현 AspectJ에서 정의한 @Aspect 애노테이션 기반의 AOP구현 스프링 API를 이용한 AOP구현 위의 3가지 방식 중 어떤 방식을 사용하더라도 내부적으로 프록시를 이용하여 AOP가 구현된다. 따라서, 프록시를 통한 메소드 호출만 AOP를 적용할 수 있다.ex) 내부클래스 내에서 다른 메소드를 호출시,이 경우에는 프록시를 거쳐 가는것이 아니기 때문에 AOP가 적용되지 않는다. 프록시 객체 생성 방법 JDK Dynamic Proxy service에 꼭 인터페이스를 만들 필요는 없다. 인터페이스가 있어야 작동할 수 있다. 인터페이스를 기반으로 프록시 객체를 생성하기 때문에인터페이스에 정의되어 있지 않은 메서드에 대해서는 AOP가 적용되지 않는다! CGLIB 라이브러리를 이용하는 방법 대상 클래스를 상속 받아서 프록시를 구현한다. 클래스가 final일 경우, 프록시를 생성할 수 없다! 인터페이스가 없어도 된다. cf) Kotlin은 기본이 final이다.(기본적으로 상속이 불가능하다. 상속하기 위해서는 접근제어자를 붙여줘야 한다. ) ex) Kotlin에서 상속하기 위해 open을 붙여준 예시123open class A &#123; // ...&#125; 프록시 패턴의 클래스 다이어그램 Subject RealSubject와Proxy 클래스 모두 이 Subject 인터페이스를 구현한다. 똑같은 인터페이스를 구현함으로써,RealSubject가 들어갈 자리에 Proxy를 대신 집어넣을 수 있다. RealSubject: Spring에서의 Service에 해당하는 클래스 Proxy 실제로 작업을 처리하는 객체 대한 레퍼런스가 들어 있다. 실제 객체가 필요할 경우, 그 레퍼런스를 이용해서 요청을 전달한다. 가상 프록시클라이언트에서는 RealSubject를 직접 호출하지 않고, Proxy를 호출한다. 클라이언트에서는 호출하는 게 RealSubject인지, Proxy인지 알 필요가 없다. 프록시 VS 데코레이터프록시(Proxy) 실제 객체의 메서드를 호출하면, 그 호출을 중간에 가로챈다. 결과는 건드리지 않고, 앞 뒤에 추가하는 패턴 어떤 클래스에 대한 접근을 제어하기 위한 용도 데코레이터(Decorator) 결과값을 보정하는데 초점을 두는 패턴 클래스에 새로운 행동을 추가하기 위한 용도 To study more gRPC AOP 참고 링크 [Java] AOP 구현 방법 비교정리 [Spring &amp; Design Pattern]Spring에서 발견한 디자인패턴_Proxy Pattern Spring-AOP, Proxy 란?","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Design-pattern","slug":"back-end/design-pattern","permalink":"https://JihyeHwang09.github.io/categories/back-end/design-pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://JihyeHwang09.github.io/tags/design-pattern/"},{"name":"proxy pattern","slug":"proxy-pattern","permalink":"https://JihyeHwang09.github.io/tags/proxy-pattern/"}]},{"title":"스테이트 패턴(State pattern)","slug":"design-pattern-state","date":"2019-12-22T11:46:58.000Z","updated":"2019-12-23T12:30:04.881Z","comments":true,"path":"2019/12/22/design-pattern-state/","link":"","permalink":"https://JihyeHwang09.github.io/2019/12/22/design-pattern-state/","excerpt":"","text":"Head First - Design Patterns(에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠 저 | 서환수 역)을 읽고 정리한 내용입니다. 스테이트 패턴의 정의 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있다. 상태를 별도의 클래스로 캡슐화한 다음,현재 상태를 나타내는 객체에게 행동을 위임하기 때문이다. 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있다. 클라이언트에서 사용하는 객체의 행동이 완전히 달라질 수 있기 때문이다. 스테이트 패턴의 클래스 다이어그램 Context 클래스: 여러 가지 내부 상태가 들어있을 수 있다. ex) 책 예시에서의 BumballMachine이 Context에 해당된다. state.handle: Context의 request() 메서드가 호출되면,그 작업이 상태 객체에게 맡겨진다. State 인터페이스: 모든 구상 상태 클래스에 대한 공통 인터페이스를 정의 ConcreateStateA, ConcreateStateB Context로부터 전달된 요청을 처리한다. 요청을 처리하는 방법을 나름의 방식으로 구현한다. Context에서 상태를 바꾸기만 하면, 행동도 바뀌게 된다. 구상 상태 클래스는 얼마든지 많이 만들 수 있다. Kotlin sealed class 스테이트 패턴(State pattern)과 비슷 추상 클래스를 다 구현할 수 있는게 아니라, 정해진 구현체만 구현 가능하다. 다른 패키지에서는 구현할 수 없다. JDBC 트랜잭션(Transaction)setAutoCommit(boolean autoCommit) 대표적으로 스테이트 패턴 적용된 예시 setAutoCommit(true || false)에 따라서 JDBC의 상태가 바뀐다. 스테이트 VS 스트래티지 VS 템플릿 메서드스테이트 패턴(State Pattern) 내부에 의존 관계를 들고 있는 거라서 요즘은 잘 쓰이지 않는다. 내부에서 의존성을 주입하기 때문에 추가 확장성이 없다. 상태를 기반으로 하는 행동을 캡슐화하고, 행동을 현재 상태에게 위임한다. 스트래티지 패턴(Stategy Pattern) 외부에서 의존성을 주입한다. 구성을 통해 행동을 정의하는 객체의 유연성을 극대화한다. 객체 지향의 꽃이라고 불리며 스테이트 패턴에 비해 실무에서 훨씬 많이 쓰인다. 알고리즘의 각 단계를 구분하는 방법을 서브클래스에서 구현한다. 템플릿 메서드 패턴(Templete Method Pattern) 바꿔 쓸 수 있는 행동을 캡슐화 한 다음, 실제 행동은 다른 객체에 위임한다. To Study More Kotlin sealed class 의존성 주입(Dependency Injection) JDBC 트랜잭션 To do Java Servlet에 직접 간단한 게시판 만들어서 구현해보기(이 과정을 통해 Spring을 왜 사용하는지 편리함을 느끼고 이해할 수 있게 될 것이다.) 참고 링크 [JSP] JDBC 에서의 트랜잭션 처리 [개발이 하고 싶어요]","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Design-pattern","slug":"back-end/design-pattern","permalink":"https://JihyeHwang09.github.io/categories/back-end/design-pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://JihyeHwang09.github.io/tags/design-pattern/"},{"name":"state pattern","slug":"state-pattern","permalink":"https://JihyeHwang09.github.io/tags/state-pattern/"}]},{"title":"이터레이터(iterator)와 컴포지트(composite) 패턴","slug":"design-pattern-iterator-composite","date":"2019-12-11T10:37:53.000Z","updated":"2019-12-11T12:46:04.107Z","comments":true,"path":"2019/12/11/design-pattern-iterator-composite/","link":"","permalink":"https://JihyeHwang09.github.io/2019/12/11/design-pattern-iterator-composite/","excerpt":"","text":"Head First - Design Patterns(에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠 저 | 서환수 역)을 읽고 정리한 내용입니다. 이터레이터 패턴(iterator pattern)객체를 저장하는 방식은 보여주지 않으면서도클라이언트가 객체들에게 일일이 접근할 수 있게 해주는 방법인이터레이터 패턴(iterator pattern)에 대해 알아보자. 이터레이터 패턴을 사용하면 모든 항목에 일일이 접근하는 작업을컬렉션 객체가 아닌 반복자 객체에서 맡게 된다. 반복을 캡슐화하자. 바뀌는 부분은 캡슐화한다.반복 작업을 캡슐화해서 Iterator라는 객체를 만든다.이터레이터(Iterator) 패턴에서 중요한 것은 Iterator라는 인터페이스에 의존한다는 것이다.Iterable과 Iterator를 잘 구분하자. java.util.Iterator 인터페이스객체 컬렉션에서 어떤 항목을 제거하는 기능을 제공하고 싶지 않을 때remove() 메서드를 반드시 제공해야 하는 건 아니다.대신 remove()를 쓸 수 없도록 만들고 싶다면,런타임에 java.lang.UnsupportedOperationException을 던지도록 하면 된다.컴파일 타임에 제어하는 방법은 없고, 위와 같이 런타임에 제어하는 방법은 많이 사용된다. 반복자 코드를 웨이트리스에 적용시키기123public interface Menu &#123; public Iterator createIterator();&#125; Iterator를 인자로 받아들이는 printMenu() 메서드를 만든다.각 메뉴의 getIterator() 메서드를 사용해서 Iterator를 받은 후,새로운 메소드를 넘긴다. 123456789101112131415161718192021222324252627282930313233343536import java.util.Iterator;public class Waitress &#123; // 타입이 Menu로 같은 값이 2개 이상이다. // -&gt; 변화에 유연하기 위해 List로 만드는 게 좋다. Menu pancakeHouseMenu; Menu dinerMenu; // 생성자에서 두 메뉴를 인자로 받아온다. public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) &#123; this.pancakeHouseMenu = pancakeHouseMenu; this.dinerMenu = dinerMenu; &#125; public void printMenu() &#123; // printMenu()에서 두 개의 반복자를 생성한다. // (메뉴마다 하나씩 만들어야 하므로) Iterator pancakeIterator = pancakeHouseMenu.createIterator(); Iterator dinerIterator = dinewMenu.createIterator(); System.out.println(\"메뉴\\n---\\n아침 식사\"); System.out.println(\"\\n점심 식사\"); // 각 반복자를 가지고 오버로드된 printMenu()를 호출한다. printMenu(dinerIterator); &#125; private void printMenu(Iterator iterator) &#123; // 항목이 더 남았는지 확인 while (iterator.hasNext()) &#123; // 다음 항목을 가져온다. MenuItem menuItem = (MenuItem) iterator.next(); System.out.println(menuItem.getName() + \",\"); System.out.println(menuItem.getPrice( + \" -- \")); System.out.println(menuItem.getDescription()); &#125; &#125; // 기타 메서드&#125; 불변 리스트 만들기자바 컬렉션에서 리스트를 더 이상 추가, 삭제를 막기 위해서는java.util.Collections.unmodifiableList를 사용한다. 읽기 전용으로 List를 생성하며,메서드를 막을 때 많이 사용한다.인터페이스로 만들면 반드시 오버라이딩해야만 하므로 이를 피하면서,지금은 구현하고 싶지 않을 때 주로 사용한다. Enhanced For Loop향상된 For문이라는 의미로, Java 5 이상에서 지원하는 for문기존의 For문과는 달리, Index가 없다는 단점이 있다. 123for (대입받을 변수 정의 : 배열) &#123; // 실행할 문장&#125; ex) 1234String[] strArr = &#123;\"a\", \"b\", \"c\", \"d\"&#125;for (String arr : strArr) &#123; System.out.println(arr);&#125; 자바8 이상에서는 stream이나 Enhanced For Loop를 사용한다. 이터레이터 패턴의 정의 이터레이터 패턴은 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는모든 항목에 접근할 수 있게 해주는 방법을 제공해 준다. 이터레이터 패턴의 클래스 다이어그램 Aggregate: 공통적인 인터페이스 Iterator 모든 반복자에서 구현해야 하는 인터페이스를 제공한다. 컬렉션에 들어있는 원소들에 돌아가면서 접근할 수 있게 해 주는 메서드들을 제공한다. ConcreteAggregate 객체 컬렉션이 들어있고, 그 안에 들어있는 컬렉션에 대한 Iterator를 리턴하는 메서드를 구현한다. 모든 ConcreteAggregate는 그 안에 있는 객체 컬렉션에 대해 돌아가면서 반복 작업을 처리할 수 있게 해주는 ConcreteIterator의 인스턴스를 만들 수 있어야 한다. ConcreteIterator: 반복작업 중에 현재 위치를 관리한다. 내부(iternal) 반복자와 외부(external) 반복자내부(iternal) 반복자 반복을 제어하는 주체: 반복자 자신에 의해 제어한다.반복자가 자신이기 때문에 다음 원소에 대해서 어떤 작업을 직접 처리한다. -&gt; 따라서 반복자에게 모든 원소에 대해서 어떤 일을 할지 직접 알려줘야 한다. 내부 반복자는 클라이언트가 반복작업을 마음대로 제어할 수 없기 때문에외부 반복자보다 유연성이 떨어진다. But, 할 일을 넘겨주기만 하면, 나머지는 전부 알아서 해준다. ex) stream에서 내부적으로 for문을 돌리는 것내부 반복자를 사용하면, 반복문에서 조건을 잘못 줘서 루프를 1번 더 돈다거나멈춰야하는데 안 멈추거나 하는 실수를 방지할 수 있다. 외부(external) 반복자 반복을 제어하는 주체: 클라이언트가 반복작업을 제어한다. 클라이언트에서 next()를 호출해서 다음 항목을 가져온다. 단일 역할 원칙 디자인 원칙: 클래스를 바꾸는 이유는 한 가지 뿐이어야 한다.이 원칙에 따라 한 클래스에서는 한 가지 역할만 맡도록 해야 한다. But, 실제로는 클래스를 바꾸는 이유 그 한 가지를 정의하기 어렵다. ex) 식사를 예로 들자면,개발자1: ‘밥을 먹는다’ -&gt; 한 가지로 본다.개발자2: ‘밥을 차린다 + 밥을 먹는다 + 정리한다’ -&gt; 한 가지로 본다.사람마다 그 한가지 이유의 기준이 다를 수 있기 때문이다. 컴포지트 패턴(Composite pattern)컴포지트 패턴의 정의컴포지트 패턴을 이용하면, 객체들을 트리 구조로 구성해서 부분과 전체를 나타내는 계층 구조를 만들 수 있다.클라이언트에서 개별 객체와 다른 객체들로 구성된 복합 객체(compoiste)를 똑같은 방법으로 다룰 수 있다. 컴포지트 패턴의 클래스 다이어그램 컴포지트 패턴을 이용하면, 복합 객체와 개별 객체를 구분할 필요가 없어진다.복합 구조에 들어있는 것을 구성요소라고 부른다.구성요소에는 복합 객체와 잎(leaf) 노드가 있다.잎(leaf) 노드든 아니든 똑같이 구현할 수 있게 되는 것이다. 컴포지트 패턴을 이용한 메뉴 디자인MenuComponent가 MenuItem(Leaf)와 Menu(Composite)에서 쓰이는 인터페이스 역할을 한다. 복합 반복자CompositeIterator는MenuItem에 대해서 반복작업을 할 수 있게 해주는 기능을 제공한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.*;// 다른 반복자들과 마찬가지로 java.util.Iterator 인터페이스를 구현한다.public class CompoisteIterator implements Iterator &#123; Stack stack = new Stack(); // 반복작업을 처리할 대상 중에서 최상위 복합 객체의 반복자가 전달된다. // 그 반복자는 스택에 집어넣는다. public CompoisteIterator(Iterator iterator) &#123; stack.push(iterator); &#125; public Object next() &#123; // 클라이언트에서 다음 원소를 요청하려면, // 우선, hasNext()를 호출해서 다음 원소가 남아있는지 확인해야 한다. // 다음 원소가 있다면, 스택에서 현재 반복자를 꺼낸 후 그 다음 원소를 구한다. if (hasNext()) &#123; // stack.peek(): 읽기. stack의 top이 가리키는 데이터를 반환 Iterator iterator = (Iterator) stack.peek(); MenuComponent component = (MenuComponent) iterator.next(); // 그 원소가 메뉴일 경우(또 다른 객체가 추가된 것이므로) if (component instanceof Menu) &#123; // 스택에 집어 넣는다. stack.push(component.createIterator()); &#125; // 원소가 메뉴든 아니든 구성요소 자체는 리턴한다. return component; &#125; else &#123; return null; &#125; &#125; // public boolean hasNext() &#123; // if (stack.empty()) &#123; // return false; // &#125; else &#123; // Iterator iterator = (Iterator) stack.peek(); // if (!iterator.hasNext()) &#123; // stack.pop(); // return hasNext(); // &#125; else &#123; // return true; // &#125; // &#125; // &#125; public boolean hasNext() &#123; // 스택이 비어있는지를 확인하여 다음 원소가 있는지 살펴본다. if (stack.empty()) &#123; return false; &#125; Iterator iterator = (Iterator) stack.peek(); if (!iterator.hasNext()) &#123; stack.pop(); return hasNext(); &#125; return true; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; 컴포지트 패턴의 구현 문제장점 클라이언트를 단순화시킬 수 있다.(복합 객체를 사용하고 있는지 잎(left) 객체를 사용하고 있는지에 대해 신경쓰지 않아도 되기 때문이다.) 메서드 하나만 호출하면, 전체 구조에 대해서 반복해서 작업을 처리할 수 있는 경우도 자주 있다. 1. 컴포지트 패턴에서 아무 의미가 없는 메서드가 생기는 경우아무일도 하지 않거나 널(Null) 또는 false를 상황에 맞게 리턴하는 방법이 있다.또는 예외를 던질 수 있다. 2. 복합 구조를 탐색하는데 너무 복잡할 경우복합 노드를 캐싱해두는 게 효과적이다. 결론 컴포지트 패턴을 적용할 때는 여러 가지 장단점을 고려해야 한다.상황에 따라 투명성과 안전성 사이에서 적절한 평형점을 찾아야 한다. 참고 링크 이터레이터 패턴 (iterator pattern)[정리정리정리] Head First: Design Patterns - 제9장 Iterator 와 Composite 패턴","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Design-pattern","slug":"back-end/design-pattern","permalink":"https://JihyeHwang09.github.io/categories/back-end/design-pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://JihyeHwang09.github.io/tags/design-pattern/"},{"name":"iterator pattern","slug":"iterator-pattern","permalink":"https://JihyeHwang09.github.io/tags/iterator-pattern/"},{"name":"composite pattern","slug":"composite-pattern","permalink":"https://JihyeHwang09.github.io/tags/composite-pattern/"}]},{"title":"템플릿 메소드 패턴(Template Method Pattern)","slug":"design-pattern-template-method","date":"2019-11-24T11:55:23.000Z","updated":"2019-11-24T13:53:42.963Z","comments":true,"path":"2019/11/24/design-pattern-template-method/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/24/design-pattern-template-method/","excerpt":"","text":"Head First - Design Patterns(에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠 저 | 서환수 역)을 읽고 정리한 내용입니다. 템플릿 메소드 패턴(Template Method Pattern)매우 많이 쓰이는 패턴이며 특히 프레임워크를 만들 때 좋은 디자인 도구인템플릿 메소드 패턴에 대해 알아보자. 여기에 커피와 차를 만들기 위한 클래스가 있다.우선 커피 클래스를 보자. 1234567891011121314151617181920212223public class Coffee &#123; void prepareRecipe() &#123; boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); &#125; // 알고리즘의 각 단계를 구현하는 메소드들 public void boilWater() &#123; System.out.println(\"물 끓이는 중\"); &#125; public void brewCoffeeGrinds() &#123; System.out.println(\"필터를 통해서 커피를 우려내는 중\"); &#125; public void pourInCup() &#123; System.out.println(\"컵에 따르는 중\"); &#125; public void addSugarAndMilk() &#123; System.out.println(\"설탕과 우유를 추가하는 중\"); &#125;&#125; 다음은 홍차를 만들기 위한 Tea 클래스를 보자. 123456789101112131415161718192021222324public class Coffee &#123; void prepareRecipe() &#123; boilWater(); steepTeaBag(); pourInCup(); addLemon(); &#125; // Coffee 클래스와 있는 메서드와 완전히 똑같다. public void boilWater() &#123; System.out.println(\"물 끓이는 중\"); &#125; // 차 전용 메서드 public void steepTeaBag() &#123; System.out.println(\"차를 우려내는 중\"); &#125; // Coffee 클래스와 있는 메서드와 완전히 똑같다. public void pourInCup() &#123; System.out.println(\"컵에 따르는 중\"); &#125; // 차 전용 메서드 public void addLemon() &#123; System.out.println(\"레몬을 추가하는 중\"); &#125;&#125; Tea 클래스에서 Coffee 클래스에 있는 boilWater과 pourInCup 메서드가 중복되고 있다.이 두 클래스가 거의 똑같으므로 공통적인 부분을 추상화시켜서베이스 클래스를 만드는 게 좋지 않을까?그렇다면 어떤 식으로 베이스 클래스를 만드는 게 좋을까? 추상화 방법보통 이와 같이 추상화하는 경우가 많다.이렇게 코드 재사용을 목적으로 추상화를 했다. boilWater()와 pourInCup() 메서드가 두 클래스에서 중복되므로 수퍼클래스에서 정의한다. prepareRecipe() 메서드 클래스마다 다르므로 추상 메서드로 선언한다. 각 서브클래스에서 prepareRecipe() 메서드를 오버라이드해서 구현한다. Coffee와 Tea에만 있는 메서드들은 서브클래스에 그대로 남겨둔다. 문제점brewCoffeeGrinds(), steepTeaBag() 등 메서드명이 너무 구체적으로 명시되어 있다.이렇게 메서드명이 구체적일 경우 추상화가 어려워진다. 상속을 이용하는 두 가지 목적 cf) 출처: 조영호, 오브젝트(위키북스), 13장 서브클래싱과 서브타이핑 참고 서브클래싱과 서브타이핑을 나누는 기준은 상속을 사용하는 목적이다. 서브클래싱(subclassing) 자식 클래스가 부모 클래스의 코드를 재사용할 목적으로 상속을 사용한 경우 자식 클래스와 부모 클래스의 행동이 호환되지 않는다.-&gt; 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다. 클래스의 내부 구현 자체를 상속받는 것에 초점을 맞춘다. 구현 상속(implementation inheritance) or 클래스 상속(class inheritance)이라고도 부른다. 서브타이핑(subtyping) 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용할 목적으로상속을 사용한 경우이다. 타입 계층을 구성하기 위해 상속을 사용하는 경우 서브타이핑에서는 자식 클래스와 부모 클래스의 행동이 호환된다.-&gt; 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. 슈퍼타입 인스턴스를 요구하는 모든 곳에서 서브타입의 인스턴스를 대신 사용하기 위해만족해야 하는 최소한의 조건은 서브타입의 퍼블릭 인터페이스가 슈퍼타입에서 정의한 퍼블릭 인터페이스와동일하거나 더 많은 오퍼레이션을 포함해야 한다는 것이다. -&gt; 서브타입이 슈퍼타입의 퍼블릭 인터페이스를 상속받는 것처럼 보인다. 인터페이스 상속(interface inheritance)이라고도 부른다. 서브타이핑이 서브클래싱보다 좋다. 좀 더 추상화된 관점에서 접근해 보자.Coffe와 Tea 사이에 또 다른 공통점은 없을까?뜨거운 물을 이용해서 커피 또는 홍차를 우려낸다.-&gt; 두 가지 만드는 법의 알고리즘이 똑같다는 것을 알 수 있다.prepareRecipe()까지 추상화할 수 있는 방법을 찾아보자. prepareRecipe() 추상화하기1. 첫 번째 문제점Coffee에서는 brewCoffeeGrinds()와 addSugarAndMilk()를 사용하고,Tea에서는 steepTeaBag()과 addLemon()를 사용한다. 커피를 우려내는 것과 티백을 우리는 것은 비슷하므로brew()라는 이름을 가진 메서드를 만들고 두 클래스에서 사용하도록 하자. 설탕과 우유를 추가하는 것과 레몬을 추가하는 것은 음료에 뭔가를 추가하는 것이므로addCondiments()라는 이름의 메서드를 만들어서 양쪽에서 사용하자. 직접적으로 무엇을 한다는 걸 메서드 네이밍에 구체적으로 넣으면 추상화할 수 없다. 메서드 이름만 바꿔도 추상화를 할 수 있다. 2. prepareRecipe() 메서드를 코드에 집어넣자.조금 다른 방식으로 구현해야 하는 부분은 있지만,Coffee 클래스와 Tea 클래스를 일반화하여 CaffeineBeverage클래스로 만들자.달라져야 하는 부분만 추상 메서드로 만들어보자. 123456789101112131415161718public abstract class CaffeineBeverage &#123; final void prepareRecipe() &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125; abstract void brew(); abstract void addCondiments(); void boilWater() &#123; System.out.println(\"물 끓이는 중\"); &#125; void pourInCup() &#123; System.out.println(\"컵에 따르는 중\"); &#125;&#125; brew()와 addCondiments() 이 두 메서드는 각 클래스에서서로 다른 방식으로 처리하기 때문에 추상 메서드로 선언한다.서브클래스에서 알아서 하도록 하자. 3. Coffee와 Tea 클래스에서 brew()와 addCondiments()를 처리한다.두 클래스에서 음료를 만드는 방법은 CaffeineBeverage에서 결정된다.우려내는 부분인 brew()와 첨가물을 추가하는 부분인 addCondiments()는베이스 클래스인 CaffeineBeverage에서 추상 메서드로 선언되었으므로이를 오버라이딩해서 구현한다. 12345678public class Tea extends CaffeineBeverage &#123; public void brew() &#123; System.out.println(\"차를 우려내는 중\"); &#125; public void addCondiments() &#123; System.out.println(\"레몬을 추가하는 중\"); &#125;&#125; 12345678public class Coffee extends CaffeineBeverage &#123; public void brew() &#123; System.out.println(\"필터를 통해서 커피를 우려내는 중\"); &#125; public void addCondiments() &#123; System.out.println(\"설탕과 우유를 추가하는 중\"); &#125;&#125; 템플릿 메소드 패턴(Template Method Pattern)처음 만들었던 Tea와 Coffee 클래스에서는 중복된 코드가 있으며,새로운 확장을 하려면, 또 중복 코드를 추가해야하는 상황이었다.(알고리즘이 바뀔 경우 서브클래스를 일일이 열어서 여러 군데를 고쳐야하는 문제점) 템플릿 메소드 패턴은 견본 자체가 나와 있고,알고리즘 중에서 변경되어야 하는 부분만 변경하는 경우에 사용하는 패턴이다. 템플릿 메소드 패턴에서는 메서드에서 알고리즘의 골격을 정의한다.알고리즘의 여러 단계 중 일부는 서브클래스에서 구현할 수 있다.템플릿 메서드를 이용하면, 알고리즘의 구조는 그대로 유지하면서서브클래스에서 특정 단례를 재정의할 수 있다. 구현 방법: 여러 단계 중에서 하나 이상이 추상 메서드로 정의되며,그 추상 메서드는 서브 클래스에서 구현한다. 장점: 서브 클래스에서 일부분을 구현할 수 있도록 하면서도알고리즘의 구조는 바꾸지 않아도 될 수 있도록 한다. 추상 클래스 하나, 구현 클래스는 여러 개 있을 수 있다. Abstract Class가 어떻게 정의되는지 더 자세히 보자. 12345678910111213141516171819202122abstract class AbstractClass &#123; final void templateMethod() &#123; // 서브클래스에서 알고리즘을 바꾸지 못하게 하기 위해 // 템플릿 메서드를 final로 선언한다. final void templateMethod() &#123; primitiveOperation1(); primitiveOperation2(); concreteOperation(); hook(); &#125; // 서브 클래스에서 구현할 추상 메서드 abstract void primitiveOperation1(); // 서브 클래스에서 구현할 추상 메서드 abstract void primitiveOperation2(); final void concreteOperation() &#123; // concreteOperation 구현 코드 &#125; // hook은 구상 메서드인데 아무 기능도 없다. void hook() &#123;&#125; &#125;&#125; concreteOperation()는 이미 구현된 코드이므로서브 클래스에서 오버라이딩 하지 말자. 템플릿 메서드와 후크hook()에 대해 더 알아보자.구상 메서드인데도 구현이 안된 빈 body로 되어 있다.hook()이 꼭 존재해야 하는 메서드는 아니다.필요하면 호출해서 사용하라는 optional한 느낌으로 제공하는 메서드이다.hook()를 한 개가 아닌 여러 개를 넣을 수도 있다. hook()을 빈 코드로 제공하는 이유하위 클래스에서 자유롭게 오버라이딩하거나 하지 않거나 할 수 있게 만들기 위해서이다.사용하고 싶을 때만 오버라이딩 한다.만일 abstract를 붙여서 추상 메서드로 만들었다면,하위 클래스에서 강제적으로 구현해야 하기 때문이다. hook() 메서드 네이밍을 더 구체적으로 할 수는 없을까?hook() 메서드는 빈 body로 만들어지므로 무슨 일을 할지 모른다.따라서 구체적인 네이밍을 할 수 없다. 헐리우드 원칙헐리우드 원칙을 사용하면, 저수준 구성요소에서 시스템에 접속을 할 수는 있지만,언제 어떤 식으로 그 구성요소들을 사용할지는 고수준 구성요소에서 결정한다. 고수준인 추상 클래스에서 저수준인 하위(구현) 클래스의 메서드를 호출한다. this VS super this 동적인 디스패치 (Dynamic Dispatch) 런타임에 바꿀 수 있다. super 정적인 디스패치 (Static Dispatch) super가 지칭하는 클래스는 런타임에 바꿀 수 없다.(컴파일 시점에 결정) 그 자체로 강결합이다. 템플릿 메서드 패턴 VS 스트래티지 패턴 템플릿 메서드 패턴 상속을 사용 스트래티지 패턴 컴포지션을 사용 객체 구성을 사용하기 때문에 더 유연하다. 정리 템플릿 메서드: 알고리즘의 단계들을 정의할 때,서브클래스에서 구현하도록 할 수 있다. 후크(hook) 추상 클래스에 들어 있으며,아무 일도 하지 않거나 기본 행동을 정의하는 메서드 서브클래스에서 오버라이드를 선택적으로 할 수 있다. 서브클래스에서 템플릿 메서드에 들어있는 알고리즘을바꾸지 못하게 하고 싶다면 템플릿 메서드를 final로 선언한다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Design-pattern","slug":"back-end/design-pattern","permalink":"https://JihyeHwang09.github.io/categories/back-end/design-pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://JihyeHwang09.github.io/tags/design-pattern/"},{"name":"전략 패턴","slug":"전략-패턴","permalink":"https://JihyeHwang09.github.io/tags/전략-패턴/"},{"name":"template method pattern","slug":"template-method-pattern","permalink":"https://JihyeHwang09.github.io/tags/template-method-pattern/"},{"name":"템플릿 메소드 패턴","slug":"템플릿-메소드-패턴","permalink":"https://JihyeHwang09.github.io/tags/템플릿-메소드-패턴/"}]},{"title":"어댑터 패턴(Adapter pattern)과 퍼사드 패턴(Pacade pattern)","slug":"design-pattern-adapter-pacade","date":"2019-11-17T06:50:22.000Z","updated":"2019-11-18T13:59:03.888Z","comments":true,"path":"2019/11/17/design-pattern-adapter-pacade/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/17/design-pattern-adapter-pacade/","excerpt":"","text":"Head First - Design Patterns(에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠 저 | 서환수 역)을 읽고 정리한 내용입니다. 어댑터 패턴(Adapter pattern) 어댑터 패턴(Adapter pattern): 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다.어댑터를 이용하면, 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을연결해서 쓸 수 있다. 클래스 다이어그램1. 객체 어댑터 Client에서는 Target 인터페이스를 볼 수 있다. Adapter에서 Target 인터페이스를 구현한다. Adapter는 Adaptee로 구성되어 있다. 모든 요청이 Adaptee로 위임된다. 어댑티를 새로 바뀐 인터페이스로 감쌀 때 객체 구성(composition)을 활용한다. 장점: 어댑티의 모든 서브 클래스에서도 어댑터를 쓸 수 있다.클라이언트를 특정 구현이 아니라 인터페이스에 연결시킨다. 따라서, 타겟 인터페이스만 제대로 지키면 나중에 다른 구현을 추가하는 것도 가능하다. 2. 클래스 어댑터 클래스 어댑터를 사용하려면, 다중 상속이 필요한데 자바에서는 다중 상속이 불가능하다. 객체를 한 두 개 더 만들더라도 객체 구성(composition)을 활용하자. 어댑터 실전 예제Enumeration과 IteratorEnumeration은 Collection 객체의 멤버 객체들을 나열하기 위한 인터페이스이다.일반적으로 Vector나 Hashtable 객체에서 제공하는 메소드로 그 객체를 생성한다.Enumeration은 Collection Framework가 나온 이후 (Java 1.2 이후)부터 사용하지 않고,Enumeration 대신 Iterator를 사용한다. cf)Vector -&gt; ArrayListHashtable -&gt; HashMapEnumeration -&gt; Iterator 자바에서의 동기화Vector와 Hashtable와 같은 클래스들은 자체적으로 동기화 처리가 되어있다.그러나 멀티쓰레드 프로그래밍이 아닌 경우에는 불필요하기 때문에 성능을 떨어뜨리는 요인이 된다.그래서 새로 추가된 ArrayList와 HashMap과 같은 컬렉션은 동기화를 자체적으로 처리하지 않고필요한 경우에만 java.util.Collections 클래스의 동기화 메서드를 이용해서 동기화 처리가 가능 하도록 한다. ArrayList, HashSet, HashMap 은 멀티스레드 환경에서 안전하지 않다.Collections.synchronizedList를 사용하면, 동기화된 컬렉션을 리턴한다. 1234567// List를 동기화된 List로 리턴List list = Collections.synchronizedList(new ArrayList());// Map을 동기화된 Map으로 리턴Map map = Collections.synchronizedMap(new HashMap());// Set을 동기화된 Set으로 리턴Set set = Collections.synchronizedSet(new HashSet()); 동기화된(synchronized) 컬렉션은 멀티 스레드 환경에서하나의 스레드가 요소를 안전하게 처리하도록 도와주지만,전체 요소를 빠르게 처리하지는 못한다.스레드가 병렬적으로 요소들을 처리할 수 없어서 스레드가 작업을 할 때 락이 발생하기 때문이다. java.util.concurrent 패키지를 이용하자.자바에서는 멀티스레드 환경에서 안전하면서도 스레드가 병렬적으로 작업을 처리할 수 있도록java.util.concurrent 패키지에서CopyOnArrayList, ConcurrentHashMap, ConcurrentLinkedQueue를 제공한다. CopyOnWriteArrayList: read (select) 시는 아무런 동기화 문제가 없기 때문에 놔두고변경이 일어날 때, 객체를 clone 해서 다루자는 전략이다.따라서 읽기행위가 많이 일어나는 곳에서 사용하기 좋다. ConcurrentHashMap: HashMap을 thread-safe 하도록 만든 클래스가 ConcurrentHashMap이다.하지만 HashMap과는 다르게 key, value에 null을 허용하지 않는다.또한 putIfAbsent라는 메소드를 가지고 있다. -ConcurrentLinkedQueue: ConcurrentLinkedQueue는 큐에 꺼낼 원소가 없다면 즉시 리턴하고 다른 일을 수행하러 간다.따라서, ConcurrentLinkedQueue는 생산자-소비자 producer-consumer 모델에서소비자가 많고 생산자가 하나인 경우에 사용하면 좋다. EnumerationIterator 어댑터 코드Enumerator 인터페이스를 사용하는 구형 코드가 있다.새로 만드는 코드에서는 Iterator만 사용한다.이런 경우에 어댑터 패턴을 적용하면 좋다. 어댑터 패턴에 익숙해지기 위해아래의 EnumerationIterator 어댑터 코드 예제는 책을 안보고 직접 구현해보도록 하자. 123456789101112131415161718192021222324/* Enumeration을 Iterator에 적응시키기 위해 Iterator 인터페이스를 구현한다. 겉에서 볼 때는 Iterator로 보여야 한다.*/public class EnumerationIterator implements Iterator &#123; Enumeration enum; public EnumerationIterator(Enumeration enum) &#123; this.enum = enum; &#125; public boolean hasNext() &#123; return enum.hasMoreElements(); &#125; public Object next() &#123; return enum.nextElement(); &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; 퍼사드 패턴(Pacade pattern)커맨드 패턴 VS 퍼사드 패턴 커맨드 패턴(Command pattern) 메서드 1개만 노출 캡슐화해서 접근하지 못함 tight 퍼사드 패턴(Pacade pattern) 메서드 여러 개 노출 서브 시스템을 캡슐화하지 않음 loose 스마트 커맨드와 비슷 어댑터 패턴 VS 퍼사드 패턴 공통점: 여러 개의 클래스를 감쌀 수 있다. 차이점 어댑터 패턴: 인터페이스를 다른 인터페이스로 변환하기 위한 용도 퍼사드 패턴: 인터페이스를 단순화시키기 위한 용도 어댑터 패턴과 퍼사드 패턴의 차이는 감싸는 클래스 개수가 아니라,용도의 차이다. 퍼사드 패턴은 Spring MVC Service와 비슷하다. 압축된 인터페이스를 제공한다. 로직은 각각 도메인들이 가지고 있고, 서비스에서는 호출해서 가져온다. 서비스에서는 로직을 가지면 안된다. 퍼사드 패턴(Pacade pattern)의 정의 퍼사드 패턴(Pacade pattern): 어떤 서브시스템의 일련의 인터페이스에 대한통합된 인터페이스를 제공한다.퍼사드에서 고수준 인터페이스를 정의하기 때문에서브시스템을 더 쉽게 사용할 수 있다. 디미터 법칙(최소 지식 원칙) 디자인 원칙정말 친한 친구하고만 얘기하라. ex1) 디미터 법칙(최소 지식 원칙)을 따르지 않는 경우 123456public float getTemp() &#123; // station에서 thermometer라는 객체를 받아서 // 그 객체의 getTemperature() 메서드를 직접 호출해야 한다. Thermometer thermometer = station.getThermometer(); return thermometer.getTemperature();&#125; ex2) 디미터 법칙(최소 지식 원칙)을 따르는 경우 123456public float getTemp() &#123; // 디미터 법칙(최소 지식 원칙)을 적용해서 Station 클래스에 // thermometer에 요청을 해주는 메서드를 추가했다. // 이렇게 하면, 의존해야 하는 클래스의 개수를 줄일 수 있다. return station.getTemperature();&#125; 더 공부할 Keyword 디미터 법칙 참고 링크 &amp; 서적 자바를 다루는 기술- 김병부 저 [JAVA] 동기화된 컬렉션(thread-safe collection), 병렬처리 가능한 컬렉션 [ 개념정리 ] 동기화(Sycchronization)[양군&amp;우자] 자바 Concurrent 라이브러리 정리[HAMA 블로그] Hashtable, HashMap, ConcurrentHashMap 비교 자바 Concurrent 패키지의 Queue 알아보기","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Design-pattern","slug":"back-end/design-pattern","permalink":"https://JihyeHwang09.github.io/categories/back-end/design-pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://JihyeHwang09.github.io/tags/design-pattern/"},{"name":"adapter pattern","slug":"adapter-pattern","permalink":"https://JihyeHwang09.github.io/tags/adapter-pattern/"},{"name":"pacade pattern","slug":"pacade-pattern","permalink":"https://JihyeHwang09.github.io/tags/pacade-pattern/"},{"name":"어댑터 패턴","slug":"어댑터-패턴","permalink":"https://JihyeHwang09.github.io/tags/어댑터-패턴/"},{"name":"퍼사드 패턴","slug":"퍼사드-패턴","permalink":"https://JihyeHwang09.github.io/tags/퍼사드-패턴/"}]},{"title":"커맨드 패턴(Command Pattern)","slug":"design-pattern-command","date":"2019-11-16T11:56:07.000Z","updated":"2019-11-24T11:58:29.809Z","comments":true,"path":"2019/11/16/design-pattern-command/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/16/design-pattern-command/","excerpt":"","text":"Head First - Design Patterns(에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠 저 | 서환수 역)을 읽고 정리한 내용입니다. 커맨드 패턴(Command Pattern)이란 커맨드 패턴은 호출 캡슐화에 중점을 두는 패턴이다. 예를 들어, 리모컨 API 디자인에 대해 생각해보자.얼핏 생각하면 리모컨에는 ON/OFF 버튼만 있으면 될 것 같지만,클래스들과 메서드들이 다양하게 들어 있다.게다가 나중에 또 다른 제품이 추가될 경우에는 메서드가 또 추가될 것이다.어떻게 해야 할까? 리모컨 버튼을 눌렀을 때 자동으로 해야할 일을 처리하게 만들되,리모컨 자체에서는 욕조를 켜는 방법과 같이어떤 일을 수행하는지 자세한 내용을 모르도록 캡슐화 한다.복잡한 인터페이스를 간단하게 추상화함으로써 구현할 수 있다. 커맨드 객체는 특정 객체에 대한 특정 작업 요청을 캡슐화시켜준다.버튼마다 커맨드 객체를 저장해두고, 클라이언트가 버튼을 눌렀을 때 커맨드 객체를 통해서 작업을 처리하게 만든다.리모컨에서는 자세한 내용은 전혀 몰라도 된다.그저 리모컨에는 어떤 객체에 어떤 일을 시켜야 할지를 잘 알고 있는 커맨드 객체만 있으면 된다.리모컨과 전등 객체를 완전히 분리시키는 것이다. 리모컨 버튼이 눌렸을 때 호출되는 코드와 특정 업체에서 제공한,실제로 일을 처리하는 코드를 분리시켜야 한다.여기에서 포인트는 모든 일을 처리해주는 메서드를 만들어서 캡슐화한다는 것이다. 리모컨용 코드를 만들어보자. 1. Command 인터페이스 만들기커맨드 객체는 모두 같은 인터페이스를 구현해야 한다.일반적으로 excute() 메소드를 사용한다. 123public interface Command &#123; public void execute();&#125; 2. 전등을 켜기 위한 커맨드 클래스 구현전자제품 공급 업체에서 제공한 클래스를 보니 Light 클래스에 on()과 off() 두 개의 메서드가 있다.커맨드 객체를 만들기 위해 다음과 같이 작성한다. 12345678910111213141516// 커맨드 객체이므로 Command 인터페이스를 구현public class LightonCommand implements Command &#123; // 인스턴스 변수에 전등 객체를 저장한다. Light light; // 생성자에 이 커맨드 객체로 제어(on, off)할 전등 종류에 대한 정보가 전달된다. public LightonCommand(Light light) &#123; this.light = light; &#125; // execute() 메서드가 호출될 때, // Recevier 객체인 light 객체에 있는 on() 메서드가 호출된다. public void execute() &#123; light.on(); &#125;&#125; 커맨드 객체 사용하기버튼이 하나만 있는 리모컨이 있다고 가정하고 커맨드 객체를 사용하는 코드를 작성해보자. 123456789101112131415161718public class simpleRemoteControl &#123; // 커맨드를 넣을 하나의 슬롯으로 제어한다. Command slot; public simpleRemoteControl() &#123;&#125; // 클라이언트에서 리모컨의 명령을 바꾸고 싶다면, // 커맨드 객체를 바꿔 끼울 수 있다. public void setCommand(Command command) &#123; slot = command; &#125; // 버튼이 눌려지면 이 메서드가 호출된다. // 지금 연결되어 있는 커맨드 객체의 execute() 메서드가 호출된다. public void buttonWasPressed() &#123; slot.execute(); &#125;&#125; 리모컨을 사용하기 위한 간단한 테스트 클래스1234567891011121314151617181920// RemoteControlTest: 커맨드 패턴에서 클라이언트에 해당하는 부분public class RemoteControlTest &#123; public static void main(String[] args) &#123; // remote 변수가 인보커(Invoker) 역할 // 필요한 작업을 요청할 때 사용할 커맨드 객체를 인자로 받을 예정이다. SimpleRemoteControl remote = new SimpleRemoteControl(); //요청을 받아서 처리할 리시버(Receiver)인 Light 객체를 만든다. Light light = new Light(); LightOnCommand lightOn = new LightOnCommand(light); // 커맨드 객체를 인보커(remote 변수)에 전달 remote.setCommand(lightOn); // 인보커인 remote에서 buttonWasPressed 메서드가 실행되면, // 지금 리모컨에 연결되어 있는 커맨드 객체(버튼에 연결된)인 // lightOn 객체의 excute() 메서드를 실행한다. remote.buttonWasPressed(); &#125;&#125;// 실행 결과: Light is On 커맨드 패턴의 정의 커맨트 패턴: 요구사항을 객체로 캡슐화할 수 있으며,매개변수를 사용하여 여러 가지 다른 요구 사항을 집어넣을 수 있다.요청 내역을 큐에 저장하거나 로그로 기록할 수 있고, 작업취소 기능도 지원한다. 어떤 행동을 특정 리시버와 연결시킴으로써 요구 사항을 캡슐화한 것이다. 이를 구현하기 위해, 행동과 리시버를 한 객체에 넣고execute() 메서드 하나만 외부에 공개하는 방법을 사용한다. 특정 인터페이스만 구현되어 있다면 그 커맨드 객체에서 실제로 어떤 일을 하는지는신경 쓸 필요 없다. 클래스 다이어그램 Client는 ConcreteCommand를 생성하고 Reciver를 설정한다. Invoker에서는 명령이 들어있고, exceute() 메서드를 호출함으로써 커맨드 객체에게 특정한 작업을 수행해 달라고 한다. Command는 모든 커맨드 객체에서 구현해야 하는 인터페이스이다. ConcreteCommand는 특정 행동과 리시버 사이를 연결해준다. execute() 메서드에는 리시버에 있는 메서드를 호출하여 요청된 작업을 수행한다. Reciver는 요구 사항을 수행하기 위해서 어떤 일을 처리해야 하는지 알고 있는 객체 Light 객체를 사용할 때, 거실에 있는 전등과 부엌에 있는 전등을 구분하는 방법? 클라이언트가 버튼을 누를 때, 그냥 excuete() 메서드를 호출하는데,이를 구분하기 위해서는 서로 다른 구현체를 만든 후,Command 객체를 바꿔가면서 호출하면 된다. Stategy pattern도 적용된 것으로 생각하면 된다. 슬롯에 명령 할당하기 리모컨의 각 슬롯에 명령을 할당한다.리모컨이 인보커가 되는 것이다. 사용자가 버튼을 누르면, 그 버튼에 연결된 커맨드 객체의 execute()메서드가 호출된다. 리시버(전등, 선풍기, 오디오 등)에서 특정 행동을 하는 메서드가 실행되어 작업을 처리한다. 널 객체특정 슬롯을 사용하려고 할 때, 거기에 뭔가가 로딩되어 있는지 확인하려면null 체크하는 코드가 반복된다.ex) null 체크하는 코드 12345public void onButtonWasPushed(int slot) &#123; if (onCommands[slot] != null) &#123; onCommands[slot].execute(); &#125;&#125; 이 문제를 해결하기 위해서 아무것도 하지 않는 커맨드 클래스를 구현한다. 123public class NoCommand implements Command &#123; public void execute() &#123;&#125;&#125; 그 후, RemoteContorl 생성자에서 모든 슬롯에 기본 커맨드 객체로NoComamnd 객체를 집어넣는다. 12345Command noCommand = new NoCommand();for (int i = 0; i &lt; 7; i++) &#123; onCommands[i] = noCommand; offCommands[i] = noCommand;&#125; 모든 슬롯에 커맨드 객체가 들어있을 수 밖에 없게 된다.커맨드 객체를 대입하지 않은 슬롯에는 NoCommand가 들어가게 된다. NoCommand 객체NoCommand 객체는 일종의 널 객체이다.리턴할 객체는 없지만, 클라이언트 쪽에서 null을 처리하지 않아도 되도록 하고 싶을 때 널 객체를 활용하면 좋다. 작업 취소 기능UNDO 버튼을 지원하는 기능을 추가한다.거실 전등이 꺼져 있고, 리모컨에 ON 버튼이 눌렸다고 생각해보자.그럼 불이 켜진다. 이제 UNDO 버튼을 누르면 마지막으로 했던 작업이 취소되어야 한다.즉, 이 경우에는 켜졌던 거실 전등이 꺼져야 한다. 1. Command에 undo() 메서드를 만든다.커맨드에서 작업 취소 기능을 지원하기 위해 execute()와 비슷한 undo() 메서드를 만든다.execute()메서드에서 했던 것과 정반대의 작업을 처리하면 된다. 1234public interface Command &#123; public void execute(); public void undo();&#125; 2-1) LigntOnCommand에 undo()메서드를 추가한다.LightOnCommand에 undo()메서드가 호출되면 그 메서드에서는 light객체의 off()메서드를 호출해야 한다. 1234567891011121314public class LightOnCommand implements Command &#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; public void execute() &#123; light.on(); &#125; public void undo() &#123; light.off(); &#125;&#125; 2-2) LightOffCommand에 undo() 메서드를 추가한다.123456789101112131415public class LightOffCommand implements Command &#123; Light light; public LightOffCommand(Light light) &#123; this.light = light; &#125; public void execute() &#123; light.off(); &#125; public void undo() &#123; // 불이 꺼져있으면, 다시 켠다. light.on(); &#125;&#125; 3. RemoteControl 클래스에 작업 취소 기능을 추가한다.RemoteControl 클래스에 클라이언트가 마지막으로 누른 버튼을 기록하고,UNDO 버튼이 눌렸을 때 필요한 작업을 처리하기 위한 코드를 추가한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class RemoteControlWithUndo &#123; // 이 리모컨에서는 7개의 on/off 명령을 처리할 수 있으며 // 여러 개의 Command를 호출해야 하므로 배열로 나타낸다. Command[] onCommands; Command[] offCommands; /* undoCommand가 배열이 아닌 이유? 가장 최근 커맨드 객체 1개를 되돌리기 위해서 배열이 아닌 것이다. 참조를 지속해서 바꿔준다. 전체를 되돌리려면, Stack으로 구현한다. (Stack에서 pop()메서드로 빼내면 된다.) */ Command undoCommand; public RemoteControlWithUndo() &#123; onCommands = new Command[7]; offCommands = new Command[7]; Command noCommand = new NoCommand(); for (int i = 0; i &lt; 7; i++) &#123; onCommands[i] = noCommand; offCommands[i] = offCommand; &#125; // 클라이언트가 다른 버튼을 누르지 않은 상태에서 // UNDO 버튼을 누르더라도 문제가 생기지 않도록 만든다. undoCommand = noCommand; &#125; public void setCommand(int slot, Command onCommand, Command offCommand) &#123; undoCommands[slot] = onCommand; offCommands[slot] = offCommand; &#125; public void onButtonWasPushed(int slot) &#123; onCommands[slot].execute(); // 클라이언트가 버튼을 누르면, 슬롯에 연결된 커맨드 객체의 // execute()메서드를 호출한 후 // 그 객체의 참조를 undoCommand에 바꿔 끼워준다. undoCommand = onCommands[slot]; &#125; public void offButtonWasPushed(int slot) &#123; offCommands[slot].execute(); undoCommand = offCommands[slot]; &#125; // 클라이언트가 UNDO 버튼을 누르면, // undoCommand에 연결된 커맨드 객체의 // undo() 메서드를 호출한다. public void undoButtonWasPushed() &#123; // undo() 메서드가 실행되면, // 가장 최근에 했던 작업이 취소된다. undoCommand.undo(); &#125; public String toString() &#123; // toString 코드... &#125;&#125; 정리 커맨드 패턴은 요청을 하는 객체와 그 요청을 수행하는 객체를 분리시켜서 구현한다. 기존의 코드를 건드리지 않으면서 캡슐화하여호출한 객체 입장에서는 어떤 식으로 일을 처리하는지를 전혀 신경 쓰지 않는다. 정해진 한 개의 메서드인 excuete()를 호출만하면 된다.-&gt; 모든 일을 처리해주는 메서드를 만들어서 캡슐화한다. 작업 취소의 히스토리 기능은 Stack을 이용해 구현한다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Design-pattern","slug":"back-end/design-pattern","permalink":"https://JihyeHwang09.github.io/categories/back-end/design-pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://JihyeHwang09.github.io/tags/design-pattern/"},{"name":"command pattern","slug":"command-pattern","permalink":"https://JihyeHwang09.github.io/tags/command-pattern/"},{"name":"커맨드 패턴","slug":"커맨드-패턴","permalink":"https://JihyeHwang09.github.io/tags/커맨드-패턴/"}]},{"title":"번아웃 극복하기","slug":"TIL-2019-11-16","date":"2019-11-16T11:25:53.000Z","updated":"2019-11-16T11:50:08.161Z","comments":true,"path":"2019/11/16/TIL-2019-11-16/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/16/TIL-2019-11-16/","excerpt":"","text":"번아웃에 대한 나의 대처 방법나는 1월 2일부터 8개월가량 1일 1포스팅을 해왔었다.여행을 갔을 때도 노트북을 들고 가서 포스팅을 빠짐없이 했었다.그리고 지금은 그 방식에 무리가 있다고 판단하여1일 1포스팅이 아닌 1일1커밋으로 변경하고,출퇴근 길, 길을 걸을 때, 출근하기 전, 퇴근 후 등등하루의 모든 시간을 개발에 쏟아 부은지 3개월 가량이 되었는데, 이번주에 번아웃이 왔다.고민하다가 오늘 스터디를 함께하는 개발자 선배님들께 조언을 구했다.조급함을 갖지 말고 잠자는 시간을 더 늘리고 쉬어가며 하라는 말씀들을 많이 해주셨다.길게 가는 게 중요하다고 조언도 해주셨다.좋은 분들과 함께 고민을 나누니 힘이 되고 마음도 한결 가벼워졌다.조언을 구할 수 있는 멘토분들을 만났다는 건 참 감사하고 꿈만 같은 일이다.조급함을 가진다고 달라지지는 않는다.오늘의 내가 어제의 나보다 조금 더 성장한다면, 그걸로 만족하고 꾸준히 앞으로 나아가자.원래 정말 힘든거다. 다들 이 시기를 겪었고 이겨냈기에 계속 개발을 하실 수 있으리라.존경스러운 마음이 든다.개발 공부에 열중하되 휴식 시간을 적절히 분배해서 멘탈이 흔들리지 않도록 관리하자.우선은 중간 요일인 수요일 저녁과 토요일 저녁, 일요일 반나절은 오롯이 휴식 시간으로 사용해보자.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"},{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/tags/developer/"}]},{"title":"프로그래밍 학습의 어려움과 극복하는 방법(by 박재성님)","slug":"lecture-2019-11-16","date":"2019-11-16T11:03:27.000Z","updated":"2019-11-16T11:57:20.104Z","comments":true,"path":"2019/11/16/lecture-2019-11-16/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/16/lecture-2019-11-16/","excerpt":"","text":"해당 글은 박재성님의 프로그래밍 학습의 어려움과 극복하는 방법 영상에서제가 중요하게 여기는 부분을 요약 정리한 내용 입니다.전체 내용은 아래 링크의 원본 영상을 참고해주세요:) 각 단계를 극복하고 살아남는 방법 1단계 다양한 초보 강의를 검토한 후 하나를 선택해 학습 이 단계에서 대부분의 강의 내용은 비슷하기 때문에 하나를 선택해서 반복 학습 2단계(자신감이 떨어지는 단계) 초보라 할지라도 학습을 같이 할 동료를 구한다. 다른 사람의 코드 읽기 지속적으로 작은 코드를 시작하고 빌드하면서 디버깅에 대한 두려움을 제거한다. 처음부터 너무 거창한 목표를 세우고 크기가 큰 걸 만들려고 하지 마라. 문제가 발생했을 때, 아 해결할 수 있다!라는 자신감을 회복하기 만족감과 성취감을 느끼고, 그래야 노트북 앞에 앉아서 무엇이라도 해결해보고 싶다는 생각이 든다. 3단계(가장 길고 힘든 단계) 하나의 목표를 설정한 후 목표에 집중 내가 백엔드 프로그래머, 프론트엔드 프로그래머, 게임 프로그래머,모바일 프로그래머 등 어떤 프로그래머가 될 것인지를 정한다. 일정 시간 최소한 6개월 ~ 1년을 집중하자. 수박 겉핥기 식의 다양한 지식 습득이 아니라 한 분야에 대한 깊이 있는 지식 습득 웹했다가 모바일했다가 하는건 깊이를 더하기보다는 너무 얕은 단계를 다양하게 경험하는 것이다. 구체적인 목표 의식을 가지고 의식적인 연습을 함으로써 시간 낭비를 최소화 4단계 1~3단계는 동작하는 소프트웨어를 만드는 것에 관심을 가졌다면,4단계에서는 어떻게, 잘, 깔끔하게, 성능 좋게 만들 것인가에 중점을 둔다. Best practices를 찾아서 연습하고, 내가 부족하다고 생각하는 지식을 쌓는다. 자동화나 클린 코드와 같은 부분에서 자신을 한 단계 업그레이드 시킨다. 설계, 아키텍처, 배포와 같이 좋은 개발자가 되기 위한 연습이 단계를 극복하기 위한 핵심은 피드백을 받는 것이다. 코칭을 해줄 멘토나 동료를 찾는 것이 중요하다. 직접적이고 현실적인 조언 주변 정리를 하자. 프로그래머로 취업하고 싶다면 일단 주변 정리부터 시작한다. 일단 여기에 올인을 하자. 애인과의 만남 시간 조정. 예로 2주에 1회 친구들과의 관계 끊기 술자리 줄이기 모든 우선순위에서 프로그래밍 학습을 1순위 프로그래밍 관련 책만 읽기 TV 보지 않기 등 프로그래머 취업 과정 최소 1년 5, 6개월 정도 취업 가능하다. 직장 생활하면서 학습을 병행하는 것은 정말 힘들다. 학습하는 방법 온라인 상에 정말 좋은 컨텐츠가 많음하지만 의지력을 가지고 지속하기 힘듦 의지력이 약하다면 시작은 단기 속성 학원 활용 속성 학원에서 취업 가능한 상태를 만들기는 힘들다. 프로그래밍적인 사고로 바꾸는 것에는 시간이 많이 소요된다. 학원에서 반드시 배워야할 것은 프로그래밍 기초, 개발 환경, 무엇을 어떻게 학습할 것인가가 더 중요하다. 무엇을 어떻게 학습할 것인지에 대한 감을 잡으면 독학 시작 독학하는 방법 같이 학습할 사람을 만드는 것이 가장 중요하다.혼자하면 지치고 포기할 가능성이 높다. 스터디 그룹을 만드는 것도 좋은 방법. 누가 만들어 주기를 기다리지 말고 직접 만든다. 꾸준함이 중요 학습이 되든 안되든 일단 앉아 있는다. 매일 일정한 시간, 장소로 출퇴근을 하면서 학습, 무료로 학습할 공간을 찾는다. 멘탈 관리 다음 단계로 무엇을 학습할 것인지 모르겠거나, 포기하고 싶으면 기존 학원 강사나 온라인에서 취업 후기 남기는 개발자들에게 메일을 보내 조언을 구한다. 가끔씩 개발자 컨퍼런스 같은 곳에 참여 가끔씩 회사 인턴, 정직원으로 지원해 자신의 부족한 점을 파악하자. 출처 [프로그래밍 학습의 어려움과 극복하는 방법]:https://www.youtube.com/watch?v=fXIpMyrI3U8","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Lecture","slug":"developer/lecture","permalink":"https://JihyeHwang09.github.io/categories/developer/lecture/"}],"tags":[{"name":"박재성","slug":"박재성","permalink":"https://JihyeHwang09.github.io/tags/박재성/"},{"name":"프로그래밍 학습의 어려움과 극복하는 방법","slug":"프로그래밍-학습의-어려움과-극복하는-방법","permalink":"https://JihyeHwang09.github.io/tags/프로그래밍-학습의-어려움과-극복하는-방법/"}]},{"title":"스트래티지 패턴(Strategy Pattern)","slug":"design-pattern-strategy","date":"2019-11-10T07:46:28.000Z","updated":"2019-11-24T11:58:24.855Z","comments":true,"path":"2019/11/10/design-pattern-strategy/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/10/design-pattern-strategy/","excerpt":"","text":"Head First - Design Patterns(에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠 저 | 서환수 역)을 읽고 정리한 내용입니다. 스트래티지 패턴은 스프링 DI를 구현할 때 이용된 디자인 패턴이다. 스프링 프레임워크의 핵심 기능 중 하나인 DI를 구현할 때 이용된 스트래티지 패턴을 살펴보자. 오리 연못 시뮬레이션 게임을 만든다고 생각해보자.객체지향 기법을 사용해서 Duck이라는 수퍼클래스를 만든 후,그 클래스를 확장해서 다른 모든 종류의 오리를 만들었다. 모든 오리들의 모양이 다르기 때문에 Duck 클래스의 display() 메서드는 추상 메서드이다. MallardDuck과 RedheadDuck 외에도 오리 종류가 추가될 때마다Duck 클래스로부터 상속을 받는다. 오리들이 날아다닐 수 있게 만들라는 요구사항이 추가되었다. 상속을 활용하여 Duck 클래스에 fly()라는 메서드를 추가한 후,모든 오리들이 상속받게 만들었다. 첫 번째 부작용 발생 Duck의 모든 서브 클래스가 날 수 있는 건 아니라는 점을 잊고 넘어갔다. 수퍼클래스인 Duck에 fly() 메서드가 추가되면서몇몇 서브 클래스에는 맞지 않는 기능이 추가되었다. (ex) 고무 오리가 날아다니게 되었다.) 코드의 한 부분을 바꾸었는데 그 영향으로 프로그램 전체에 부작용이 발생하게 되었다. RubberDuck 클래스가 정말 fly() 메서드 상속받아야 하는지를 고민해봐야 한다. 상속에 대해 생각해보자.RubberDuck 클래스에서는 quack() 메서드에서 했던 것처럼fly()를 오버라이드 해서 아무것도 하지 않도록 만들 수 있다. 새로운 클래스를 추가해보자.나무로 만들어진 가짜 오리를 추가하면 어떻게 해야 할까?날 수도 없고 소리도 낼 수 없다. Duck 수퍼클래스를 상속받아 quack()과 fly() 메서드에오버라이드를 하고 빈 메서드로 만들어서 날지 않고 소리도 내지 않도록 만들었다. quack()과 fly() 메서드는 필요가 없는데 강제로 상속을 받았기 때문이다. Duck의 행동을 확장할 때, 상속을 사용하면 갖는 단점 서브클래스에서 코드가 중복된다. 모든 오리의 행동을 알기 힘들다. 실행시(런타임)에 특징을 바꾸기 힘들다. 상속 관계는 컴파일 시점에 정해진다.따라서, 런타임에 특징을 바꿀 수 없다.cf) setter를 통해서 런타임시에 의존성을 바꾸는 방법을 이용할 수 있다. 코드를 변경했을 때, 다른 오리들한테 원치 않는 영향을 끼칠 수 있다. 모든 코드가 Duck을 상속 받고 있기 때문에Duck에 메서드가 추가되었을 때,서브클래스들에 원하지 않는 기능이 추가될 수 있다. 상속은 올바른 해결책이 아니다.상속을 사용한다면, 오리 종류들이 추가될 때마다매번 Duck 서브 클래스의 fly()와 quack() 메서드를 일일이 살펴봐야 하고,상황에 따라 오버라이드하는 일을 반복하게 될 것이다.이를 통해,상속은 올바른 해결책이 아니라는 것을 알게 되었다. 인터페이스를 이용하자.그렇다면, 인터페이스를 이용하는 건 어떨까?fly()를 Duck 수퍼클래스에서 빼내서 fly() 메서드가 들어있는 Flyable 인터페이스를 만들어 보자.이렇게 할 경우 날 수 있는 오리들만 Flyable 인터페이스를 구현하도록 만들면 될 것이다.quack() 메서드도 마찬가지로 Quackable 인터페이스를 만들어서 소리를 내는 오리 종류들만이인터페이스를 구현하도록 만들자. 두 번째 부작용 발생위와 같이 Flyable과 Quackable 인터페이스를 이용했을 때 문제점이 있다.날아가는 동작을 조금 바꾸려면,Duck의 서브 클래스 중에 날아다닐 수 있는 코드들을 전부 고쳐야 하는 문제가 발생한다. 애플리케이션은 아무리 잘 디자인한다고 해도 시간이 지남에 따라 계속해서 성장하고 변화되어야 한다.나중에 고쳐야 할 때 코드에 미치는 영향을 최소한으로 줄이면서 작업을 할 수 있도록 만드는 방법을 무엇일까? 문제를 명확하게 파악하기1. 상속을 사용했을 때의 문제점서브클래스마다 오리의 행동이 바뀔 수 있는데도모든 서브 클래스에서 한 행동을 사용하도록 하는 건 그리 올바른 방법이 아니다. 2. Flyable과 Quackable 인터페이스를 사용했을 때의 문제점자바의 인터페이스에는 구현된 코드가 들어가지 않기 때문에한 행동을 바꿀 때마다 그 행동이 정의되어 있는 서로 다른 서브클래스들을전부 찾아서 코드를 일일이 수정해야 하고, 그 과정에서 새로운 버그가 발생할 수 있다. 디자인 원칙: 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시키자. 바뀌는 부분을 따로 뽑아서 나머지 코드에 영향을 주지 않도록 캡슐화 한다. 이렇게 하면, 나중에 바뀌지 않는 부분에 영향을 미치지 않고,해당 부분만 고치거나 확장할 수 있어서 코드의 복잡성을 낮출 수 있다. 바뀌는 부분을 분리하기 변화하는 부분과 그대로 있는 부분을 분리하기 위해Duck과는 완전히 별개인 두 개의 클래스 집합(set)을 만든다. 나는 것과 관련된 집합과 꽥꽥 소리를 내는 것에 관련된 부분이다. 각 클래스 집합에 각각의 행동을 구현한 것을 집어넣는다. ex) 꽥꽥 소리를 내는 것을 구현한 클래스, 삑삑 소리를 내는 것을 구현한 클래스,아무 소리도 내지 않는 것을 구현하는 클래스를 각각 만든다. fly()와 quack()은 Duck 클래스에서 오리마다 달라지는 부분이므로이 두 메소드를 Duck 클래스에서 꺼내서 각 행동을 나타내는 클래스 집합을 만들어보자. 오리의 행동 디자인나는 행동과 꽥꽥 거리는 행동을 구현하는 클래스 집합을 디자인하는 방법 Duck 인스턴스에 행동을 할당할 수 있게 만든다. ex1) MallardDuck 인스턴스를 새로 만들고 특정 형식의 나는 행동으로 초기화 한다.(생성자를 만들어서) ex2) 오리의 행동을 동적으로 바꿀 수 있도록Duck에 행동과 관련된 세터(setter) 메서드를 포함시켜서런타임 중에도 MallardDuck의 나는 행동을 바꿀 수 있게 만든다. 디자인 원칙: 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다. Duck의 행동은 특정한 행동 인터페이스를 구현한 별도의 클래스 안에 들어있게 된다. 상속이나 Flyable와 Quackable 인터페이스를 이용한 방법은항상 특정 구현에 의존했기 때문에 행동을 변경할 수 없었다. 이 디자인을 사용하면, 행동을 실제로 구현한 클래스에서 Duck 서브클래스에 국한되지 않는다. 인터페이스에 맞춰서 프로그래밍한다는 것은상위 형식에 맞춰서 프로그래밍 한다는 것을 의미한다. Duck의 행동을 구현하는 방법 날 수 있는 클래스에서는 무조건 FlyBehavior 인터페이스를 구현한다. 오리가 소리를 내는 것과 관련된 quack() 메서드가 들어있는 QuackBehavior 인터페이스를 구현한다. 이런 식으로 디자인할 경우, 다른 형식의 객체에서도 나는 행동과 꽥꽥 거리는 행동을 재사용할 수 있다. Duck 클래스 안에 이 행동들이 숨겨져 있지 않기 때문이다. 기존의 행동 클래스를 수정하거나 날아다니는 행동을 사용하는Duck 클래스를 전혀 건드리지 않고도 새로운 행동을 추가할 수 있다. Duck 행동 통합하기 포워딩용 메서드인 performQuack()과 performFly()의 메서드 이름은Quack(), Fly()로 써도 된다. 행동 변수는 행동 인터페이스 형식으로 선언한다. performQuack()를 구현해보자. 1234567891011public class Duck &#123; // 인터페이스 변수에 실행시에 특정 행동에 대한 레퍼런스가 저장된다. QuackBehavior quackBehavior; // 기타 코드 public void performQuack() &#123; // 꽥꽥 거리는 행동을 직접 처리하는 대신, // quackBehavior로 참조되는 객체에 그 행동을 위임한다. quackBehavior.quack(); &#125;&#125; 이렇게 하면, 객체의 종류에는 전혀 신경 쓸 필요 없이quack()을 실행시킬 줄 안다는 것만이중요해진다. 이제 flyBehavior와 quackBehavior 인스턴스 변수를 설정하는 방법에 대해 생각해보자. 123456789public class MallardDuck extends Duck &#123; public MallardDuck() &#123; // MallardDuck에서 꽥꽥거리는 소리를 처리할 때는 Quack 클래스를 사용한다. // 따라서, perfomQuack()이 되면, 꽥꽥거리는 행동은 Quack 객체에 위임된다. quackBehavior = new Quack(); // flyBehavior의 형식으로 FlyWithWings를 사용한다. flyBehavior = new FlyWithWings(); &#125;&#125; 생성자에서 직접 집어넣고 있다. 인터페이스 분리는 했는데, 아직 구현 클래스에 의존하고 있어서 불완전하다. 동적으로 행동을 지정하는 방법1. Duck 클래스에 메서드 2개를 새로 추가한다.123456public void setFlyBehavior (FlyBehavior fb) &#123; FlyBehavior = fb;&#125;public void setQuackBehavior (QuackBehavior qb) &#123; quackBehavior = qb;&#125; 오리의 행동을 즉석에서 바꾸고 싶다면, 언제든지 이 두 메서드를 호출하면 된다. 2. Duck의 서브 클래스를 새로 만든다. (ModelDuck.java)12345678910public class ModelDuck extends Duck &#123; public ModelDuck () &#123; flyBehavior = new FlyNoWay (); quackBehavior = new Quack(); &#125; public void display () &#123; System.out.println(\"저는 모형 오리입니다.\"); &#125;&#125; 3. FlyBehavior 형식의 클래스를 새로 만든다. (FlyRocketPowered.java)12345public class FlyRocketPowered implements FlyBehavior &#123; public void fly () &#123; System.out.println(\"로켓 추진으로 날아갑니다.\"); &#125;&#125; 4.테스크를 클래스를 수정한다.ModelDuck을 추가하고 ModelDuck에 로켓 추진 기능을 부여한다. 1234567891011121314public class MiniDuckSimulator &#123; public static void main (String[] args) &#123; Duck mallard = new MallardDuck(); mallard.performQuack(); mallard.performFly(); Duck model = new ModelDuck(); model.performFly(); // 구현체를 바꾼다. // 이렇게 하면, 행동 세터 메서드가 호출된다. model.setFlyBehavior(new FlyRocketPowered()); model.performFly(); &#125;&#125; 실행 중에 오리의 행동을 바꾸고 싶다면,원하는 행동에 해당하는 Duck의 세터 메서드를 호출하기만 하면 된다. 캡슐화된 행동을 큰 그림으로 바라보자. 클라이언트에서는 나는 행동과 꽥꽥거리는 행동 모두에 대해서 캡슐화된 알고리즘군을 사용한다. A는 B이다”보다 “A에는 B가 있다”가 나을 수 있다. 디자인 원칙상속보다는 구성을 활용한다. 구성을 이용해서 시스템을 만들면 유연성을 크게 향상시킬 수 있다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Design-pattern","slug":"back-end/design-pattern","permalink":"https://JihyeHwang09.github.io/categories/back-end/design-pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://JihyeHwang09.github.io/tags/design-pattern/"},{"name":"strategy pattern","slug":"strategy-pattern","permalink":"https://JihyeHwang09.github.io/tags/strategy-pattern/"},{"name":"스트래티지 패턴","slug":"스트래티지-패턴","permalink":"https://JihyeHwang09.github.io/tags/스트래티지-패턴/"},{"name":"전략 패턴","slug":"전략-패턴","permalink":"https://JihyeHwang09.github.io/tags/전략-패턴/"}]},{"title":"SQL 첫걸음- 13강","slug":"book-sql-first-steps-10","date":"2019-11-08T12:10:23.000Z","updated":"2019-11-09T05:16:39.722Z","comments":true,"path":"2019/11/08/book-sql-first-steps-10/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/08/book-sql-first-steps-10/","excerpt":"","text":"13강. 문자열 연산1+ || CONCAT SUBSTRING TRIM CHARACTER_LENGTH 1. 문자열 결합문자열 결합이란 문자열 데이터를 결합하는 연산을 말한다.문자열을 결합하는 연산자에는 데이터베이스 제품마다 방언이 있어서 차이가 있다. 1-1) 데이터베이스 제품별 문자열 결합 연산자 +: SQL Server ||: Oracle, DB2, PostgreSQ CONCAT: MySQL + 연산자, || 연산자, CONCAT함수로 문자열을 결합할 수 있다! 문자열 결합은 2개의 열 데이터를 모아서 1개의 열로 처리하고 싶은 경우에 자주 사용한다. 1-2) 문자열 결합 예시1SELECT * FROM sample35; no price quantity unit 1 100 10 개 2 230 24 캔 3 1980 5 장 위의 테이블 sample35에서 quantity열과 unit열의 데이터를 결합해보자. 123mysql&gt; SELECT CONCAT(quantity, unit) FROM sample35;oracle&gt; SELECT quantity || unit FROM sample35;sql server&gt; SELECT quantity + unit FROM sample35; CONCAT(quantity, unit) 10개 230캔 5장 sample35의 quantity열은 INTEGER형의 열이고, unit열은 문자열형이다.CONCAT함수를 이용해 두 열을 결합하였다.문자열과 수치형 데이터의 결합도 문제없이 연산할 수 있다. 단, 문자열과 수치형 데이터를 결합한 결과는 문자열형이 된다. 2. SUBSTRING 함수문자열의 일부분을 계산해서 반환해주는 함수데이터베이스에 따라서는 함수명이 SUBSTR인 경우도 있다. 2-1) 앞 4자리(년도) 추출12SUBSTRING(&apos;20140125001&apos;, 1, 4) -&gt; &apos;2014&apos;# SUBSTRING(&apos;문자열&apos;, 몇 째 자리부터, 추출할 개수) 2-2) 5째자리부터 2자리(월) 추출1SUBSTRING(&apos;20140125001&apos;, 5, 2) -&gt; &apos;01&apos; 3. TRIM 함수 문자열의 앞뒤로 여분의 스페이스가 있을 경우 이를 제거해주는 함수로문자열 도중에 존재하는 스페이스는 제거되지 않는다. 고정길이 문자열형에 대해 많이 사용하는 함수이다. 1TRIM(&apos;ABC &apos;) -&gt; &apos;ABC&apos; 4. CHARACTER_LENGTH 함수 OCTET_LENGTH 함수: 문자열의 길이를 바이트 단위로 계산해 돌려주는 함수 4-1) 문자세트 별 문자 수와 바이트 수 문자세트 문자 수 바이트 수 EUC-KR 12 19 UTF-8 12 26 문자열 데이터의 길이는 문자세트에 따라 다르다!","categories":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/categories/database/"},{"name":"MySQL","slug":"database/mysql","permalink":"https://JihyeHwang09.github.io/categories/database/mysql/"}],"tags":[{"name":"SQL 첫걸음","slug":"sql-첫걸음","permalink":"https://JihyeHwang09.github.io/tags/sql-첫걸음/"},{"name":"MySQL","slug":"mysql","permalink":"https://JihyeHwang09.github.io/tags/mysql/"}]},{"title":"SQL 첫걸음- 12강(2/2)","slug":"book-sql-first-steps-09","date":"2019-11-07T13:27:01.000Z","updated":"2019-11-09T05:16:33.511Z","comments":true,"path":"2019/11/07/book-sql-first-steps-09/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/07/book-sql-first-steps-09/","excerpt":"","text":"12강. 수치 연산4. WHERE 구에서 연산하기WHERE구에서 SELECT구에서와 같이 별명을 사용하면, 존재하지 않는다는 에러가 발생한다. 4-1) WHERE구에서 SELECT구의 내부처리 순서 WHERE구에서의 행 선택 SELECT구에서의 열 선택데이터베이스 서버 내부에서 WHERE구 -&gt; SELECT구의 순서로 처리된다.이는 서버 내부의 처리순서와 관련이 있다. WHERE구로 행이 조건에 일치하는지 아닌지를 먼저 조사한다.(행 추출) SELECT구에 지정된 열을 선택해, 결과로 반환하는 식으로 처리한다.(열을 선택해 별명을 붙인다.) SELECT구에서 지정한 별명은 WHERE구 안에서 사용할 수 없다! 5. NULL값의 연산 NULL + 1의 결과값은 1이 아닌 NULL이다. 1 / NULL을 계산하면 NULL이 0으로 처리되지 않기 때문에에러가 발생하지 않고, 결과는 NULL이 된다. 6. ORDER BY 구에서 연산하기ORDER BY 구에서도 연산할 수 있고, 결과값들 정렬이 가능하다. 6-1) ORDER BY 구의 내부처리 순서 ORDER BY 구는 서버에서 내부적으로 가장 나중에 처리된다. 따라서 WHERE구와는 달리,ORDER BY 구에서는 SELECT구에서 지정한 별명을 사용할 수 있다! 6-2) SELECT구, WHERE구, ORDER BY구의 서버 내부 처리 순서 WHERE구 -&gt; SELECT구(여기에서 별명을 지정)-&gt; ORDER BY구 7. 함수연산자 외에 함수를 사용해 연산할 수 있다. 1함수명 (인수1, 인수2...) 함수의 계산 대상은 인수로 지정한다. 인수는 함수명 뒤에 괄호로 묶어 표기한다. 7-1) 연산자와 함수는 서로 비슷하다. % 연산자(MySQL 등에서 사용 가능): 나머지값을 반환하는 연산자 110 % 4 -&gt; 2 MOD 함수(MySQL, Oracle 등에서 사용 가능) 함수명은 MOD이고, 인수로는 나뉘어질 수, 나눌 수 순으로 2개를 지정한다. 나머지 값을 반환한다. 1MOD(10, 4) -&gt; 2 함수도 연산자도 표기 방법이 다를 뿐, 같은 것이다! 8. ROUND 함수 DEMICAL형: INTEGER형(정수만 지정 가능)과는 달리정수부와 소수부의 자릿수를 지정할 수 있는 자료형 반올림 자릿수 지정 ROUND 함수는 기본적으로 소수점 첫쨰 자리를 기준으로 반올림한 값을 반환한다. 두 번째 인수로 반올림할 자릿수를 지정할 수 있다. 두 번째 인수를 생략할 경우, 0으로 간주되어 소수점 첫째 자리를 반올림한다. ex) 12mysql&gt; SELECT 컬럼명, ROUND(컬럼명, 1) FROM 테이블명;# 두 번째 인수로 1을 지정할 경우 소수점 둘째 자리를 기준을 반올림한다. 두 번째 인수를 음수로 지정해서 정수부의 반올림할 자릿수를 지정할 수 있다. ex) -1 지정할 경우 1단위를 반올림하며, -2를 지정하면 10단위를 반올림한다.","categories":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/categories/database/"},{"name":"MySQL","slug":"database/mysql","permalink":"https://JihyeHwang09.github.io/categories/database/mysql/"}],"tags":[{"name":"SQL 첫걸음","slug":"sql-첫걸음","permalink":"https://JihyeHwang09.github.io/tags/sql-첫걸음/"},{"name":"MySQL","slug":"mysql","permalink":"https://JihyeHwang09.github.io/tags/mysql/"}]},{"title":"SQL 첫걸음- 12강(1/2)","slug":"book-sql-first-steps-08","date":"2019-11-05T15:48:10.000Z","updated":"2019-11-09T05:16:30.304Z","comments":true,"path":"2019/11/06/book-sql-first-steps-08/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/06/book-sql-first-steps-08/","excerpt":"","text":"12강. 수치 연산2. SELECT구로 연산하기1SELECT 식1, 식2... FROM 테이블명; 3. 열의 별명별명이 중복되지 않게 지정한다. 별명은 예약어 AS를 사용해서 지정한다. SELECT구에서는 콤마(,)로 구분해서 복수의 식을 지정할 수 있고,각각의 식에 별명을 붙일 수 있다. MySQL에서는 별명을 중복해서 지정해도 에러는 발생하지 않는다.But, 프로그래밍 언어에서 결과값의 처리 방식에 따라 문제가 발생할 수 있다. 기본적으로 별명이 중복되지 않게 지정하자. 키워드 AS는 생략 가능하다. 단, 별명을 한글로 지정하는 경우에는 여러 가지로 오작동하는 경우가 많다. 더블쿼트(&quot;&quot;)로 감싸서 지정한다. (MySQL에서는 백쿼트(``)로 감싸준다!) 더블쿼트(&quot;&quot;)로 감싸주면, 데이터베이스 객체의 이름이라고 간주한다. 싱글쿼트(&#39;&#39;)로 감싸는 것은 문자열 상수이다. 이름에 ASCII 문자 이외의 것이 포함된다면,더블쿼트(“”)(MySQL에서는 백쿼트(``))로 감싸서 지정한다! 1) 데이터베이스 객체명1-a) MySQL 이외의 데이터베이스 더블쿼트(&quot;&quot;)로 둘러싼다. 1&quot;sample1&quot; &quot;sample26&quot; 1-b) MySQL 백쿼트(``)로 둘러싼다. 1`sample1` `sample26` 2) 문자열 상수 싱글쿼트(&#39;&#39;)로 둘러싼다. 1&apos;APPLE&apos; &apos;홍길동&apos; 예약어와 같은 이름은 지정할 수 없지만,더블쿼트(&quot;&quot;) (MySQL에서는 백쿼트 (``) )로 감싸주면 문제없이 지정할 수 있다. 1SELECT price * quantity AS SELECT FROM sample34; # 예약어 그대로 별명으로 사용 불가 ex) SELECT 는 예약어이므로 그대로 별명을 지정해서 사용할 수 없다.아래와 같이 예약어인 SELECT를 더블쿼트(&quot;&quot;) (MySQL에서는 백쿼트(``))로 감싸주면 사용 가능하다. 2-a) MySQL 이외의 데이터베이스 예약어인 SELECT를 더블쿼트(&quot;&quot;)로 둘러준다. 1SELECT price * quantity AS &quot;SELECT&quot; FROM sample34; 2-b) MySQL 예약어인 SELECT를 백쿼트(``)로 둘러준다. 1SELECT price * qunatity AS `SELECT` FROM sample34; 숫자로 시작하는 이름 이름을 붙일 때는 숫자로 시작할 수 없다. 이유: 이름이 숫자로 시작할 경우, 그것이 수치형 상수를 의미하는 것인지데이터베이스 객체명을 의미하는 것인지 구별할 수 없기 때문이다. cf) 이름이 예약어와 겹칠 때와 마찬가지로, 더블쿼트로 묶으면 에러를 피할 수 있다. 데이터베이스 제품별 허용 여부 MYSQL에서는 숫자로 시작하는 객체명이 허용된다. Oracle에서는 숫자로 시작하는 이름이 허용되지 않는다. cf) 더블쿼트로 감싸면 객체명으로 간주하는 룰은 표준 SQL에 규정되어 있다.","categories":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/categories/database/"},{"name":"MySQL","slug":"database/mysql","permalink":"https://JihyeHwang09.github.io/categories/database/mysql/"}],"tags":[{"name":"SQL 첫걸음","slug":"sql-첫걸음","permalink":"https://JihyeHwang09.github.io/tags/sql-첫걸음/"},{"name":"MySQL","slug":"mysql","permalink":"https://JihyeHwang09.github.io/tags/mysql/"}]},{"title":"SQL 첫걸음- 11강","slug":"book-sql-first-steps-07","date":"2019-11-03T09:12:08.000Z","updated":"2019-11-09T05:16:22.920Z","comments":true,"path":"2019/11/03/book-sql-first-steps-07/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/03/book-sql-first-steps-07/","excerpt":"","text":"11강. 결과 행 제한하기- LIMITLIMIT구1mysql&gt; SELECT 열명 FROM 테이블명 LIMIT 행수 [OFFSET 시작행]; 1. 행수 제한 LIMIT구는 표준 SQL은 아니다. MYSQL과 PostgreSQL에서 사용할 수 있는 문법 LIMIT구 문법1mysql&gt; SELECT 열명 FROM 테이블명 WHERE 조건식 ORDER BY 열명 LIMIT 함수; LIMIT 다음에는 최대 행수를 지정한다. 만약, 테이블에 1개의 행만 있다면, LIMIT 3으로 지정하더라도 1개의 행만 반환된다. LIMIT으로 제한하는 행수는 최대 행수이므로 존재하는 행이 더 적으면 존재하는 해당 행만큼반환된다! 정렬한 후 제한하기 LIMIT은 WHERE와는 기능과 내부처리 순서가 전혀 다르다! LIMIT 반환할 행수를 제한하는 기능 WHERE구로 검색한 후, ORDER BY로 정렬된 뒤 최종적으로 처리된다. LIMIT을 사용할 수 없는 데이터베이스에서의 행 제한SQL Server1SELECT TOP 최대행수 * FROM 테이블명; SQL Server에서는 TOP 뒤에 최대행수를 지정한다. ORACLE1SELECT * FROM 테이블명 WHERE ROWNUM &lt;= 행개수; ROWNUM: 클라이언트에게 결과가 반환될 때, 각 행에 할당되는 행 번호 단, ROWNUM으로 행을 제한할 때는 WHERE구로 지정하므로 정렬하기 전에 처리되어LIMIT구로 행을 제한한 경우와 결과값이 다르다! 2. 오프셋 지정 페이지 나누기 기능 OFFSET 지정 문법1mysql&gt; SELECT 열명 FROM 테이블명 LIMIT 행수 OFFSET 위치; OFFSET에 의한 시작 위치 지정은 LIMIT 뒤에 적는다. OFFSET의 위치 지정은 0부터 시작하기 때문에 시작할 행 -1로 적는다. ex) 4행부터 3건의 데이터를 표시한다면, 위치는 4행-1인 3으로 넣는다. 1mysql&gt; SELECT * FROM 테이블명 LIMIT 3 OFFSET 3;","categories":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/categories/database/"},{"name":"MySQL","slug":"database/mysql","permalink":"https://JihyeHwang09.github.io/categories/database/mysql/"}],"tags":[{"name":"SQL 첫걸음","slug":"sql-첫걸음","permalink":"https://JihyeHwang09.github.io/tags/sql-첫걸음/"},{"name":"MySQL","slug":"mysql","permalink":"https://JihyeHwang09.github.io/tags/mysql/"}]},{"title":"싱글턴 패턴(Singleton Pattern)","slug":"design-pattern-singleton","date":"2019-11-03T06:08:54.000Z","updated":"2019-11-24T11:58:20.704Z","comments":true,"path":"2019/11/03/design-pattern-singleton/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/03/design-pattern-singleton/","excerpt":"","text":"Head First - Design Patterns(에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠 저 | 서환수 역)을 읽고 정리한 내용입니다. 싱글턴 패턴(Singleton Pattern) 싱글턴 패턴은 요즘 거의 안티패턴으로 여겨지고 있는 패턴임을 염두에 두고 공부해보자. 안티패턴으로 여겨지는 이유 중 하나는 생성자가 private으로 선언되어 있어서브 클래스를 만들 수 없다는 점이다. 싱글턴 패턴의 정의 특정 클래스에 대해서 객체 인스턴스가 하나만 만들어질 수 있도록 해주는 패턴 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴 싱글턴 패턴을 적용하는 방법 클래스에서 자신의 단 하나뿐인 인스턴스를 관리하도록 만든다. 다른 어떤 클래스에서도 자신의 인스턴스를 추가로 만들지 못하도록 구현한다. 다른 객체에서 해당 인스턴스가 필요하면 언제든지 클래스한테 요청을 할 수 있고,요청이 들어오면 그 하나뿐인 인스턴스를 건네주도록 만든다. 고전적인 싱글턴 패턴 구현법12345678910111213141516171819public class Singleton &#123; // 싱글턴의 유일한 인스턴스가 저장되는 정적변수 private static Singleton uniqueInstance; // 생성자를 private으로 선언함으로써, Singleton에서만 클래스의 인스턴스 생성 가능 private Singleton()&#123;&#125; /* getInstance() : 클래스의 인스턴스를 만들어서 리턴해주는 메서드 getInstance()를 사용하면 언제 어디서든 이 메서드 호출 가능 -&gt; 전역 변수에 접근하는 것만큼이나 쉽다. 게으른 인스턴스 생성을 활용할 수 있다. */ public static Singleton getInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 일반적으로 Singleton 객체를 얻는 static 메서드명은 getInstance()로 이름 붙인다. 여기에서 getInstance()는 일반 메서드명이므로,반드시 이 메서드명으로 만들어야 하는 것은 아니다. getInstance()이 아닌 get()이나 다른 메서드명으로 만들어도 된다. 게으른 인스턴스 생성(lazy instantiation) 위의 코드에서 getInstance() 메서드 부분을 좀 더 자세히 살펴보자. 1234567891011121314151617public static Singleton getInstance() &#123; // uniqueInstance가 null이라면, // 아직 인스턴스가 생성되지 않았다는 것을 의미한다. if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); /* 인스턴스 생성 전이라면, private으로 선언된 생성자를 이용해서 Singleton 객체를 만든다. uniqueInstance에 그 생성된 객체를 대입한다. 이렇게 할 경우, 인스턴스가 필요하기 전까지는 아예 인스턴스를 생성하지 않는다. 이 방법을 게으른 인스턴스 생성이라고 한다. */ &#125; // uniqueInstance가 null이 아니라면, // 인스턴스가 존재하고 있다는 의미 -&gt; 그 인스턴스를 리턴하고 끝난다. return uniqueInstance;&#125; 싱글턴이 게으르게 생성되도록 구현할 수도 있는데,여기에서 게으르게(lazy)라는 표현은 필요할 때 만든다는 것을 의미한다. 멀티 스레드 환경에서의 문제점 두 개 이상의 스레드에서 위의 Singleton.getInstance() 메소드를 실행시킨다고 가정해보자. 두 개 이상의 스레드가 getInstance() 메서드에 진입하여 제어권이 번갈아가며넘어가는 과정에서 서로 다른 두 개의 객체가 만들어지는 상황이 발생할 수 있다. 멀티스레딩 문제 해결 방법1. getInstance()를 동기화 시키기12345678910111213public class Singleton &#123; private static Singleton uniqueInstance; private Singleton()&#123;&#125; public static synchronized Singleton getInstance() &#123; // 동기화가 필요한 시점 if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; // 이미 객체가 만들어진 후에는 동기화가 필요 없다. return uniqueInstance; &#125;&#125; 간단하게 getInstance() 메서드에 synchronized 키워드를 추가한다. 한 스레드가 메서드 사용을 끝내기 전까지 다른 스레드는 기다려야 하므로두 개 이상의 스레드가 동시에 실행되는 일을 방지할 수 있다. 동기화가 아깝다. 속도 저하가 일어날 수 있고, 동기화가 아깝다는 느낌이 들 수 있다. 여기에서 동기화가 아깝다는 의미는 동기화가 필요한 시점은 오직 인스턴스가 생성되기 전을 말한다. 인스턴스가 이미 만들어진 후에는 동기화가 더 이상 필요 없다. 2. 인스턴스를 필요할 때 생성하지 않고, 처음부터 만들기1234567891011public class Singleton &#123; // 정적 초기화 부분에서 singleton의 인스턴스를 생성한다. private static Singleton uniqueInstance = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance () &#123; // 이미 인스턴스가 있으므로 리턴만 하면 된다. return uniqueInstance; &#125;&#125; getInstance()가 호출되는지와 관련 없이 클래스가 로딩될 때,무조건 Singleton 인스턴스가 생성된다. 싱글톤 객체가 있든 없든 관계없이 클래스 로딩 시점에 무조건 생성되기 때문에메모리를 항상 차지하고 있어서 비효율적이다. 3. DCL(Double-checking Locking)을 써서 getInstance()에서 동기화되는 부분을 줄이기12345678910111213141516171819public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton () &#123;&#125; public static Singleton getInstance () &#123; // 동기화하지 않은 상태에서 null 체크 if (uniqueInstance == null) &#123; // 인스턴스가 없을 경우에만 동기화된 블럭으로 진입 synchronized (Singleton.class) &#123; // 다시 한 번 변수가 null인지 체크 후 인스턴스를 생성 if (uniqueInstance == null) &#123; uniqueInstance == new Singleton (); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; volatile 키워드를 사용하여 인스턴스가 생성되어 있는지 확인한 후,생성되어 있지 않을 때만 동기화할 수 있다. 자바 1.4 이전 버전에서는 사용할 수 없다. 현재는 broken idom이며 권고하지 않는 방법이다. 4. Initialization on demand holder idiom(Lazy Initialization)123456789101112131415161718192021/* Singleton 클래스가 로딩될 때, LazyHolder 클래스의 변수인 uniqueInstance가없기 때문에 LazyHolder 클래스는 초기화하지 않는다.*/public class Singleton &#123; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return LazyHolder.uniqueInstance; &#125; /* LazyHolder 클래스는 LazyHolder.uniqueInstance를 참조하는 순간 클래스가 로딩 되고 초기화가 진행된다. 클래스를 로딩하고 초기화하는 시점은 thread-safe를 보장하기 때문에 volatile이나 synchrozied같은 키워드 없이도 성능을 보장할 수 있다. */ private static class LazyHolder &#123; private static final Singleton uniqueInstance = new Singleton(); &#125;&#125; holder를 이용한 초기화 방법으로 현재 가장 많이 사용하는 방법이다. getInstance() 메서드가 처음으로 호출 될 때,클래스 로더에 의해 Singleton 객체를 생성하여 리턴한다. LazyHolder 안에 인스턴스가 static이기 때문에 클래스 로딩 시점에 한 번만 호출된다. final을 붙여서 값이 다시 할당되지 않도록 막는다. 5. Enum을 이용하기123456public enum Singleton &#123; uniqueInstance; public static Singleton getInstance() &#123; return uniqueInstance; &#125;&#125; 자바 1.5버전부터 지원하는 Enum을 이용하는 방법 모든 enum 타입은 프로그램 내에서 한 번만 초기화된다는 점을 이용해 싱글톤을 구현한다. Enum 사용의 장점 직렬화를 보장한다. 리플렉션을 통해서 싱글톤을 깨뜨리는 공격에 안전하다. Enum 사용의 단점 싱글톤을 초기화 과정에서 다른 의존성이 끼어들 수 있는 가능성이 있다. Enum의 초기화는 컴파일 타임에 결정되므로매번 메서드를 호출할 때 Context 정보를 넘겨야 하는 비효율적인 상황이 발생할 수 있다. 직렬화, 역직렬화 직렬화: 자바 시스템 내부에서 사용되는 객체 또는 데이터를외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술 역직렬화: 바이트로 변환된 데이터를 다시 객체로 변환하는 기술 결론 성능이 중요하다면, LazyHolder 기법을 이용해본다. 직렬화나 안정성이 중요하다면 Enum을 이용해본다. Executor를 이용한 스레드 실행 제어 현업에서는 최대 스레드의 개수를 조절하기 위해Executors.newFixedThreadPool(n)와 Executors.newSingleThreadExecutor()를 사용한다. 고정 크기: Executors.newFixedThreadPool(n) n개의 고정된 개수를 가진 쓰레드풀 사용자가 정의한 개수의 작업자 스레드를 유지 동적 크기: Executors.new CachedThreadPool() 처리할 태스크가 있을 때 새로운 스레드를 만든다. 60초 동안 작업이 없으면 Pool에서 제거한다. 싱글스레드 생성자: Executors.newSingleThreadExecutor() 태스크 처리를 위해서 하나의 작업자 스레드를 가진다. 더 공부해볼 것 [생활코딩]상수와 enum Executor 참고 사이트 wikipedia- Initialization-on-demand holder idiom 디자인패턴 - 싱글턴 패턴 (singleton pattern) [정리정리정리] Multi Thread 환경에서의 올바른 Singleton 멀티스레드 환경에서의 싱글톤 패턴 [Java] Singleton 생성 방법 정리[jobjava00] 자바 직렬화, 그것이 알고싶다. 훑어보기편 [용용의 안드로이드 교실]","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Design-pattern","slug":"back-end/design-pattern","permalink":"https://JihyeHwang09.github.io/categories/back-end/design-pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://JihyeHwang09.github.io/tags/design-pattern/"},{"name":"singleton pattern","slug":"singleton-pattern","permalink":"https://JihyeHwang09.github.io/tags/singleton-pattern/"},{"name":"싱글턴 패턴","slug":"싱글턴-패턴","permalink":"https://JihyeHwang09.github.io/tags/싱글턴-패턴/"}]},{"title":"SQL 첫걸음- 10강","slug":"book-sql-first-steps-06","date":"2019-11-02T14:01:31.000Z","updated":"2019-11-09T05:16:17.234Z","comments":true,"path":"2019/11/02/book-sql-first-steps-06/","link":"","permalink":"https://JihyeHwang09.github.io/2019/11/02/book-sql-first-steps-06/","excerpt":"","text":"10강. 복수의 열을 지정해 정렬하기ORDER BY구12mysql&gt; SELECT 열명 FROM 테이블명 WHERE 조건식 ORDER BY 열명1 [ASC | DESC], 열명2 [ASC | DESC]...; 복수의 열을 지정해 정렬하는 경우 ex) 상품코드와 해당 상품의 하위 번호까지 함께 고려하는 경우 정렬할 때 NULL값에 주의해야 한다! 1. 복수 열로 정렬 지정 ORDER BY구를 지정해도 1개의 열만으로는 정확히 순서를 결정할 수 없는 경우가 많다. 언제나 같은 순서로 결과를 얻고 싶다면, 반드시 ORDER BY구로 순서를 지정해야 한다. ORDER BY구로 복수 열 지정하기1mysql&gt; SELECT 열명 FROM 테이블명 ORDER BY 열명1, 열명2...; 값이 같아서 순서를 결정할 수 없는 경우에는 다음으로 지정한 열명을 기준으로 정렬한다. 위의 경우에는 첫번째 오는 열을 기준으로 값이 같은 경우가 있는 경우에는 다음 열명을 기준으로 가름한다. 2. 정렬방법 지정하기 복수 열을 지정한 경우 각 열에 대해 개별적으로 정렬방법을 지정할 수 있다. 각 열 뒤에 ASC나 DESC를 붙여준다. 복수 열 정렬1mysql&gt; SELECT 열명 FROM 테이블명 ORDER BY 열명1 [ASC | DESC], 열명2 [ASC | DESC]...; 구문 중에 []는 생략 가능 |: 둘 중에 하나 ..: 동일한 형태로 연속해서 지정 가능하다는 의미 복수열을 지정하는 경우에도 정렬방법 생략시, 기본값은 오름차순(ASC)이다. a열의 정렬 방식은 내림차순으로 지정해주었는데, b열의 정렬 방식은 생략되어 있는 경우1ORDER BY a DESC, b; 데이터베이스 제품에 따라 기본값이 달라서 내림차순이 될 수도, 오름차순이 될 수도 있다. 문장의 가독성을 높이기 위해서라도 가능한한 정렬방법을 생략하지 말고 지정하자! 3. NULL값의 정렬순서 NULL값은 그 특성상 대소비교를 할 수 없기 때문에 정렬 시에는 별도의 방법으로 취급한다. 특정 값보다 큰 값, 특정 값보다 작은 값으로 나눈다. ORDER BY로 지정한 열에서 NULL값을 가지는 행은 가장 먼저 표시되거나 가장 나중에 표시된다. NULL값에 대한 대소비교 방법은 표준 SQL에도 규정되어 있지 않기 때문에데이터베이스 제품에 따라 기준이 다르다. MySQL에서는 NULL값을 가장 작은 값으로 취급 -&gt; 오름차순에서 가장 먼저, 내림차순에서는 가장 나중에 표시","categories":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/categories/database/"},{"name":"MySQL","slug":"database/mysql","permalink":"https://JihyeHwang09.github.io/categories/database/mysql/"}],"tags":[{"name":"SQL 첫걸음","slug":"sql-첫걸음","permalink":"https://JihyeHwang09.github.io/tags/sql-첫걸음/"},{"name":"MySQL","slug":"mysql","permalink":"https://JihyeHwang09.github.io/tags/mysql/"}]},{"title":"SQL 첫걸음- 9강","slug":"book-sql-first-steps-05","date":"2019-10-30T12:37:56.000Z","updated":"2019-11-09T05:16:14.261Z","comments":true,"path":"2019/10/30/book-sql-first-steps-05/","link":"","permalink":"https://JihyeHwang09.github.io/2019/10/30/book-sql-first-steps-05/","excerpt":"","text":"3장. 정렬과 연산9강. 정렬- ORDER BYORDER BY구1MySQL&gt; SELECT 열명 FROM 테이블명 WHERE 조건식 ORDER BY 열명; SELECT 명령에 ORDER BY구를 지정할 경우, 검색 결과의 행 순서를 바꿀 수 있다. ORDER BY구를 지정하지 않으면 데이터베이스 내부에 저장된 순서대로 반환된다. 언제나 정해진 순서의 결과값을 얻기 위해서는 ORDER BY구를 지정해야 한다. 1. ORDER BY로 검색 결과 정렬하기 지정된 열의 값에 따라서 행의 순서가 변경된다. 검색 조건이 필요없는 경우에는 WHERE구 생략한다.WHERE구가 없을 때, ORDER BY구는 FROM구 뒤에 지정한다. WHERE구 없이 FROM구 뒤에 ORDER BY구를 지정하는 경우 2. DESC VS ASC내림차순 정렬1MySQL&gt; SELECT 열명 FROM 테이블명 ORDER BY 열명 DESC; 오름차순 정렬1MySQL&gt; SELECT 열명 FROM 테이블명 ORDER BY 열명 ASC; DESC나 ASC를 지정하지 않고 생략시, 기본값인 ASC로 간주되어 오름차순으로 정렬된다. 3. 대소관계대소관계 결정 기준 수치형 데이터, 날짜시간형 데이터: 숫자 크기로 결정 문자열형 데이터: 사전식 순서를 기준으로 결정 사전식 순서에서 주의할 점 수치형과 문자열형 데이터는 대소관계 계산 방법이 다르다. 데이터가 숫자값처럼 보이더라도 해당 열이 문자열형 데이터일 경우,대소관계를 사전식 순서로 비교하기 때문에 숫자 크기 순서대로 정렬되지 않는다. 숫자값처럼 보이더라도 해당 열의 데이터 타입이 문자열형이라면 주의! 4. ORDER BY는 테이블에 영향을 주지 않는다! ORDER BY를 이용해서 행 순서를 바꿀 수 있는데, 이 순서는 서버에서 클라이언트로 행 순서를 바꾸어 결과를 반환하는 것일 뿐이다. ORDER BY는 SELECT 명령과 사용하는데, 이는 데이터를 검색하는 명령으로 테이블의 데이터를 참조만하고 변경은 하지 않는다. 데이터베이스에 저장된 데이터의 행 순서를 변경하는 게 아니다!","categories":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/categories/database/"},{"name":"MySQL","slug":"database/mysql","permalink":"https://JihyeHwang09.github.io/categories/database/mysql/"}],"tags":[{"name":"SQL 첫걸음","slug":"sql-첫걸음","permalink":"https://JihyeHwang09.github.io/tags/sql-첫걸음/"},{"name":"MySQL","slug":"mysql","permalink":"https://JihyeHwang09.github.io/tags/mysql/"}]},{"title":"SQL 첫걸음- 7 ~ 8 강","slug":"book-sql-first-steps-04","date":"2019-10-28T11:42:03.000Z","updated":"2019-11-09T05:16:10.674Z","comments":true,"path":"2019/10/28/book-sql-first-steps-04/","link":"","permalink":"https://JihyeHwang09.github.io/2019/10/28/book-sql-first-steps-04/","excerpt":"","text":"2장. 테이블에서 데이터 검색7강. 조건 조합하기 AND: 교집합 OR: 합집합 AND와 OR를 사용할 경우 주의할 점 no열의 값이 2나 3인 행을 추출하고 싶을 때, 다음과 같이 입력한다면모든 행이 반환되어 올바른 결과를 얻을 수 없다. 1MySQL&gt; SELECT * FROM 테이블명 WHERE no = 2 OR 3; # 모든 행이 반환된다. 이유: 상수 3는 논리 연산으로 항상 참이 되기 때문에 모든 행을 반환하게 된다. 올바른 조건식은 아래와 같다. 1MySQL&gt; SELECT * FROM 테이블명 WHERE no = 2 OR no = 3; # no열의 값이 2 또는 3인 행이 추출된다. 연산자의 우선순위 AND가 OR보다 우선순위가 높다. 일반적으로 OR조건식은 괄호로 묶어서 지정하는 경우가 많다. NOT으로 조합 NOT 연산자 오른쪽에만 항목을 지정하는 단항 연산자이다. 오른쪽에 지정한 조건식의 반대값을 반환한다. 8강. 패턴 매칭에 의한 검색패턴 매칭(부분 검색) 특정 문자나 문자열이 포함되어 있는지를 검색하고 싶을 때 사용하는 부분 검색 1. LIKE로 패턴 매칭하기=연산자 VS LIKE 술어 =연산자: 열 값이 완전히 일치할 때 -&gt; 참 LIKE 술어: 열 값이 부분적으로 일치할 때 -&gt; 참 12열명 LIKE &apos;패턴&apos;# 매칭 대상 LIKE &apos;문자열&apos; LIKE에서 사용할 수 있는 메타문자 퍼센트(%): 임의의 문자열 언더스코어(_): 임의의 문자 하나 주의할 점 수치형 상수는 지정할 수 없다. 와일드카드로 자주 쓰이는 *는 LIKE에서는 사용할 수 없다. %의 특성 %는 임의의 문자열과 매치하며, 빈 문자열에도 매치한다! %의 위치에 따른 분류 전방 일치: 지정한 문자 뒤로 임의의 문자열이 존재 ex) ABC% 중간 일치: 지정한 문자열이 중간에 위치 ex) %ABC% 후방 일치: 지정한 문자 앞쪽에 임의의 문자열이 존재 ex) ABC% 2. LIKE로 %를 검색하기데이터 안에 %와 _가 포함되어 있을 경우, LIKE 검색하기 이스케이프를 이용해서 처리 %가 들어있는 데이터를 LIKE로 검색할 경우, \\% _를 LIKE 검색할 경우, \\_ 1WHERE 컬럼명 LIKE &apos;%\\%%&apos;; %(메타문자 = 임의의 문자열) \\%(% 그 자체의 문자) %(메타문자 = 임의의 문자열) 3. 문자열 상수 &#39;의 이스케이프 문자열 상수 안에 &#39;를 포함하고 싶을 경우&#39;&#39;를 2개 연속해서 적는 것으로 이스케이프 처리를 할 수 있다. ex) ‘I’m’ -&gt; ‘I’’m’ 문자열 상수 안에 &#39;을 넣고 싶을 때는 &#39;를 2번 연속한 &#39;&#39;를 적어준다.","categories":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/categories/database/"},{"name":"MySQL","slug":"database/mysql","permalink":"https://JihyeHwang09.github.io/categories/database/mysql/"}],"tags":[{"name":"SQL 첫걸음","slug":"sql-첫걸음","permalink":"https://JihyeHwang09.github.io/tags/sql-첫걸음/"},{"name":"MySQL","slug":"mysql","permalink":"https://JihyeHwang09.github.io/tags/mysql/"}]},{"title":"SQL 첫걸음- 6강","slug":"book-sql-first-steps-03","date":"2019-10-27T14:24:16.000Z","updated":"2019-11-09T05:16:07.658Z","comments":true,"path":"2019/10/27/book-sql-first-steps-03/","link":"","permalink":"https://JihyeHwang09.github.io/2019/10/27/book-sql-first-steps-03/","excerpt":"","text":"2장. 테이블에서 데이터 검색6강. 검색 조건 지정하기행 / 열 지정하기 행 선택: WHERE 구 사용 열 선택: SELECT 구 사용 2. WHERE구에서 행 지정하기구의 순서와 생략 SQL에서는 구의 순서가 정해져 있어 순서를 바꿔서 적을 경우, 에러가 발생한다. WHERE구로 행을 추출할 때,SELECT 구 -&gt; WHERE 구 -&gt; FROM 구의 순으로 적으면 에러 발생 12mysql&gt; SELECT 열 FROM 테이블명 WHERE 조건식;mysql&gt; SELECT 열 WHERE 조건식 FROM 테이블명 # 에러 발생 값이 서로 다른 경우 &lt;&gt; &lt;&gt;연산자: 서로 다른 값인지를 비교하는 연산자 3. 문자열형의 상수 수치형 비교할 숫자를 그대로 조건식에 표기 ex) 10 -2.5 문자열형 싱글쿼트(‘’)로 둘러싸 표기 ‘APPLE’, ‘HANA’ 날짜시간형: 싱글쿼트(‘’)로 둘러싸 표기 연월일: 하이픈(-)으로 구분 시각(시분초): 콜론(:)으로 구분 ex) ‘2019-10-27’ ‘2019-10-27 23:16:00’ 4. NULL값 검색 열 값이 NULL인 행이 있지만, 열 = NULL과 같은 조건식으로 검색할 수 없다. =연산자로는 NULL을 검색할 수 없다! IS NULL NULL값을 검색하기 위해서는 &#39;IS NULL&#39;을 사용한다.ex) 1mysql&gt; SELECT * FROM 테이블명 WHERE 열 IS NULL; 열 IS NULL로 사용한다. 좌변의 값이 NULL일 경우 참을 반환한다. NULL값이 아닌 행을 검색하려면, &#39;IS NOT NULL&#39;을 사용한다. 5. 비교 연산자 &gt;=, &lt;= 을 표기할 때, 사이에 스페이스를 넣어서는 안된다. &lt; =처럼 사이에 띄어쓰기를 할 경우, sql은 &lt;와 = 각각 연산자가2개라고 판단하여 에러가 발생한다.","categories":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/categories/database/"},{"name":"MySQL","slug":"database/mysql","permalink":"https://JihyeHwang09.github.io/categories/database/mysql/"}],"tags":[{"name":"SQL 첫걸음","slug":"sql-첫걸음","permalink":"https://JihyeHwang09.github.io/tags/sql-첫걸음/"},{"name":"MySQL","slug":"mysql","permalink":"https://JihyeHwang09.github.io/tags/mysql/"}]},{"title":"SQL 첫걸음- 4강 ~ 5강","slug":"book-sql-first-steps-02","date":"2019-10-26T14:24:16.000Z","updated":"2019-11-09T05:16:02.617Z","comments":true,"path":"2019/10/26/book-sql-first-steps-02/","link":"","permalink":"https://JihyeHwang09.github.io/2019/10/26/book-sql-first-steps-02/","excerpt":"","text":"2장. 테이블에서 데이터 검색4강. Hello World 실행하기1. SELECT * FROM 테이블명 실행12mysql&gt; SELECT*FROM테이블명; # 스페이스가 없어서 에러 발생mysql&gt; SELECT * FROM 테이블명; # 올바른 실행 스페이스를 넣지 않고 붙여서 입력할 경우 에러가 발생해서 실행할 수 없다. 2. 예약어와데이터베이스 객체명` 예약어와 데이터베이스 객체명은 대소문자를 구별하지 않는다. 4. Hello World를 실행한 결과 = 테이블 열은 하나의 자료형만 가질 수 있으며, 수치형의 열에 문자형의 데이터를 저장할 수 없다. 수치형 데이터: 오른쪽으로 정렬되어 표시된다. 문자열형데이터: 왼쪽으로 정렬되어 표시된다. 5강. 테이블 참조하기1. DESC 명령1mysql&gt; DESC 테이블명; DESC 명령을 통해서 테이블 구조를 참조할 수 있다. 테이블에 어떤 열이 정의되어 있는지 알 수 있다. cf) DESC는 SQL 명령어는 아니다. 2. 자료형문자열형 고정 길이 VS 가변 길이 CHAR형 고정 길이 문자열 자료형 따라서, 지정한 열의 최대 길이보다 작은 문자열을 저장하면,공백문자로 나머지를 채운 후에 저장한다. VARCHAR형 가변 길이 문자열 자료형 데이터 크기에 맞춰서 저장 공간의 크기가 변경된다.","categories":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/categories/database/"},{"name":"MySQL","slug":"database/mysql","permalink":"https://JihyeHwang09.github.io/categories/database/mysql/"}],"tags":[{"name":"SQL 첫걸음","slug":"sql-첫걸음","permalink":"https://JihyeHwang09.github.io/tags/sql-첫걸음/"},{"name":"MySQL","slug":"mysql","permalink":"https://JihyeHwang09.github.io/tags/mysql/"}]},{"title":"SQL 첫걸음- 1강 ~ 3강","slug":"book-sql-first-steps-01","date":"2019-10-25T13:46:19.000Z","updated":"2019-11-09T05:16:04.299Z","comments":true,"path":"2019/10/25/book-sql-first-steps-01/","link":"","permalink":"https://JihyeHwang09.github.io/2019/10/25/book-sql-first-steps-01/","excerpt":"","text":"1장. 데이터베이스와 SQL1강. 데이터베이스데이터베이스 비 휘발성 저장장치에 저장되는 영속된 데이터의 집합 데이터를 저장하며, 효율적으로 검색할 수 있도록 정리해준다. 데이터베이스 데이터를 비 휘발성 저장장치에 저장하는 이유? 데이터베이스 내의 데이터를 영구적으로 보존되어야 하는데,주기억장치에만 데이터를 저장하면 전원을 끄는 순간 모든 데이터가 날아가 버린다. 하드디스크나 플래시메모리(SSD) 등의 비 휘발성 저장장치에 저장해야 한다. DBMS 데이터베이스를 관리하는 시스템(소프트웨어) 사용하는 목적: 생산성 향상과 기능성, 신뢰성 확보 SQL SQL은 관계형 데이터베이스 관리 시스템(RDBMS: Relational Database Management System)에서 사용한다. 2강. 다양한 데이터베이스 계층형 데이터베이스 관계형 데이터베이스 행과 열을 가지는 표 형식 데이터를 저장하는 형태 객체지향 데이터베이스 가능하다면 객체 그대로를 데이터베이스의 데이터로 저장하는 형태 XML 데이터베이스 SQL 명령을 사용할 수 없다. XML 데이터를 검색할 때는 XQuery라는 전용 명령어를 사용 키-밸류 스토어(KVS) 키와 그에 대응하는 값인 밸류라는 단순한 형태의 데이터를 저장하는 형태 NoSQL(Not only SQL) 열 지향 데이터베이스 3강. 데이터베이스 서버 RDBMS는 클라이언트 / 서버 모델로 구성된다. 클라이언트는 데이터베이스 서버에 접속하여, SQL 명령을 실행하여 데이터베이스를 조작할 수 있다.","categories":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/categories/database/"},{"name":"MySQL","slug":"database/mysql","permalink":"https://JihyeHwang09.github.io/categories/database/mysql/"}],"tags":[{"name":"SQL 첫걸음","slug":"sql-첫걸음","permalink":"https://JihyeHwang09.github.io/tags/sql-첫걸음/"},{"name":"MySQL","slug":"mysql","permalink":"https://JihyeHwang09.github.io/tags/mysql/"}]},{"title":"로버트 마틴의 \"클린 코더\"","slug":"clean-coder","date":"2019-10-22T23:42:15.000Z","updated":"2019-11-03T14:51:08.712Z","comments":true,"path":"2019/10/23/clean-coder/","link":"","permalink":"https://JihyeHwang09.github.io/2019/10/23/clean-coder/","excerpt":"","text":"책 구매 링크 클린 코더(The Clean Coder)아샬님이 진행하시는 하시는 개발자, 한 달에 책 한 권 읽기 모임에 처음 참여했다.로버트 마틴의 클린 코더(The Clean Coder)를 읽고모임에 참여해서 여러 개발자 분들과 함께 이야기를 나누었다.인상깊었던 책의 구절들과 내가 느낀점들에 대해 정리하고자 한다. 1. 최소한의 기술 목록클린 코더의 p57, 58의 두 페이지에 걸쳐 최소한의 기술 목록이 나와 있다.디자인 패턴, 플로우 차트, UML 등등 다양한 기술들이 나와있는데, 최소한이라는 표현과이 기술들을 어느 정도의 깊이로 아는 것을 의미하는가 대해 집중적으로 얘기를 나누었다. 예를 들어, UML을 안다는 건 무엇을 의미하는 것일까?단순하게 UML 표기법을 의미하는 것일까?시스템을 설계할 때, UML을 그려서 다른 사람에게 내 의견을 전달할 수 있는지의 여부가 중요하다.우리가 UML을 공부하는 목적을 생각해보면, UML 표기법의 장인이 되는 것보다는함께 일하는 동료와 UML을 도구로 소통할 수 있다는 점이 중요하다고 생각한다. 추천 도서아샬님께서 UML에 관한 책으로 UML 실전에서는 이것만 쓴다를 추천해주셨고,이 책은 추후 읽은 후 리뷰하고자 한다. 2. 일정 관리일정에 쫓길수록 테스트 자동화를 해야 한다.FackBook은 매일 하루에 4번 배포를 하고 있으며, 구글은 QA 조직이 따로 없다.이렇게 할 수 있는 이유 중 하나는 자동화된 테스트가 계속해서 돌고 있기 때문이다. 3. TDD테스트를 하는 이유는 우리가 작성한 코드가 어떤 상태라는 걸 알 수 있기 때문이다.예를 들어, 기존의 코드를 바꾸었을 때 테스트가 줄줄이 깨질 경우는 설계가 잘못된 것이다.(-&gt; 의존성 관리가 제대로 되지 않고 있다는 것을 의미한다. ) 코드 커버리지가 100을 한 번 찍은 후, 코드 수정 후 코드 커버리지가 100 미만으로 떨어질 경우,TDD를 작성해 볼 수 있다. 4. 프로가 선을 그어야 할 자리다.(p102)로버트 마틴은 책에서 수년간의 경험을 통해 원칙을 깨면 느려질 뿐이라는 사실을 깨달았다고 한다.소프트웨어 프로그램을 처음 한 번 만들고 마는게 아니지 않은가?유지 보수를 위해서는 시간이 걸리더라도 소신있게 클린한 코드를 작성할 수 있도록 해야 한다. 5. 프로로서의 자세 (p63) 한다. 하지 않는다 둘 뿐이야. 해본다는 말은 없어. - 요다 처음에는 개발자로 일하면서 “해보겠습니다.”라는 말을 자주 했었다. 그게 신입의 자세라고 생각했고 열정을 보여줄 수 있는 말이라고 생각했었다. 그러나 프로 개발자라면, 갑자기 요구사항에서 없던 기능을 추가하거나불가능한 기한 안에 해내라는 압박을 받을 때, 아닌 건 아니라고 확실하게 말할 수 있는 용기가 필요하다.불가능한 일을 매일 야근을 하며 한 노력이 아닌 프로는 결과로 말한다. 기한이 코앞에 다가와서야 못한다고 하는 건 다른 팀에도 민폐를 끼치는 일이며 프로로서의 자세가 아니다. 확실한 의사 결정을 통한 협업이야말로 프로 개발자로서 중요한 자세라고 생각한다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Book","slug":"developer/book","permalink":"https://JihyeHwang09.github.io/categories/developer/book/"}],"tags":[{"name":"클린 코더","slug":"클린-코더","permalink":"https://JihyeHwang09.github.io/tags/클린-코더/"},{"name":"Clean Coder","slug":"clean-coder","permalink":"https://JihyeHwang09.github.io/tags/clean-coder/"}]},{"title":"1일 1포스팅을 내려놓다.","slug":"TIL-2019-10-01","date":"2019-10-01T14:44:20.000Z","updated":"2019-10-01T15:50:01.037Z","comments":true,"path":"2019/10/01/TIL-2019-10-01/","link":"","permalink":"https://JihyeHwang09.github.io/2019/10/01/TIL-2019-10-01/","excerpt":"","text":"이 명령어를 거의 한 달만에 써본다. Visual Studio로 작업하는 것도 오랜만이다.그동안은 intelliJ를 사용하며 지냈으니 오랜만에 만난 어릴적 친구처럼 어색하기도 반갑기도 하다.8월 말부터 지금까지 한 달하고 일주일 가량만에 블로그에 글을 올린다.그동안 많은 일들이 있었고, 일련의 일들을 겪으면서 1일 1포스팅을 내려놓기로 정했다.포스팅을 할 내용들(개발을 하면서 만난 에러, 공부한 내용) 등은 Notion에 차곡차곡 쌓아두고 있었다. 대처법 매일 블로그를 작성하면서 조금이라도 그날 알게된 내용들을 정리하는 점들이 좋았다. 다만, Notion에 먼저 정리할 내용들을 정리한 후에 블로그에 포스팅하는 방향으로 하고 매일 배우는 내용을 정리하는 건 1일 1커밋으로 변경하고자 한다. 단, 주말인 토요일과 일요일은 의무적으로 커밋하지 않고 자율적으로 커밋하고자 한다. 머리가 깨질 것 같은 두통이 와도 노트북을 붙잡고 블로그 글을 작성하면서 불현듯 우선순위가 잘못되었다는 생각이 들었다. 개발 뿐만 아니라, 그 어떤 일도 신체적인 건강을 해치면서까지 유지하는 건 도가 넘는다고 생각한다. 편안하게 휴식해서 에너지를 충전할 줄 알아야 건강하고 즐겁게 개발할 수 있을 것이라는 판단이 들었다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"},{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/tags/developer/"}]},{"title":"IntelliJ] Auto Import한 코드가 더 이상 필요 없을 때","slug":"TIL-2019-08-22","date":"2019-08-22T12:49:02.000Z","updated":"2019-08-22T13:53:00.969Z","comments":true,"path":"2019/08/22/TIL-2019-08-22/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/22/TIL-2019-08-22/","excerpt":"","text":"문제 상황 IntelliJ에서 auto import를 설정해두어서 코드 작성시, 필요한 부분을 자동으로 import되었다. import를 해두고 관련 코드를 지워서 사용하지 않는 부분이 있었다. import가 필요한 해당 부분의 코드를 지운다고 해서,import한 부분이 자동으로 사라지지는 않는다. Gitlab에 그대로 올라갈 경우 협업을 하는 동료가 pull 받았을 때build 에러가 유발할 수 있는 위험이 있다. 해결 방법 IntelliJ를 사용할 경우, 사용되지 않는 import 경로를 지우는 방법을 알아보자. 1. 폴더나 파일 단위로 import 상태 최적화 하기 window: ctrl + alt + O mac: cmd + alt + O단축키를 이용하여 import 상태를 최적화 시켜 준다. 2. 한 문장 단위로 Optimize imports 하기2-1. 커서의 위치를 import하는 부분에 두고, alt + enter를 눌러준다.2-2. 드롭다운에서 Optimize imports를 선택한다. 3. Git을 사용할 경우, commit할 때 사용되지 않는 import 제외하기3-1. [Git에 Commit] 메인 메뉴에서 VCS | Commit을 선택(단축키 ctrl + k)3-2. intelliJ에서 commit 할 때, 체크박스에서 Optimize imports 한다. 참고 링크 [intellij idea 2019.2- auto import #]: https://www.jetbrains.com/help/idea/creating-and-optimizing-imports.html","categories":[{"name":"Tool","slug":"tool","permalink":"https://JihyeHwang09.github.io/categories/tool/"},{"name":"IntelliJ","slug":"tool/intellij","permalink":"https://JihyeHwang09.github.io/categories/tool/intellij/"}],"tags":[{"name":"IntelliJ","slug":"intellij","permalink":"https://JihyeHwang09.github.io/tags/intellij/"}]},{"title":"Optional Property(선택적 프로퍼티)","slug":"typescript-2019-08-21","date":"2019-08-21T12:57:09.000Z","updated":"2019-08-21T13:50:53.945Z","comments":true,"path":"2019/08/21/typescript-2019-08-21/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/21/typescript-2019-08-21/","excerpt":"","text":"사용 시기 인터페이스의 프로퍼티는 반드시 구현해야 하는데,이 프로퍼티가 선택적으로 필요한 경우가 있을 수 있다. 사용 방법 Optional Property(선택적 프로퍼티)는 프로퍼티명 뒤에 ?를 붙인다. 함수를 호출할 때 생략 가능한 프로퍼티를 의미한다. ? 가 붙은 프로퍼티는 넣어도 안 넣어도 함수의 호출에 문제가 없다. 사용시 좋은 점 함수 내부에서 해당하는 프토퍼티의 유무를 검사하여 다른 동작을 수행할 수 있다. 사용 가능한 프로퍼티를 한 눈에 파악할 수 있다. 예시123456789function cook(ingredient: any, sugar?: boolean) &#123; if (salt) &#123; // ... &#125; // ...&#125;cook(&#123; onion: \"many\", wather: \"some\" &#125;); // OKcook(&#123; onion: \"many\", water: \"some\" &#125;, false); // OK 참고 링크 [TypeScript: 함수(Function)]: https://hyunseob.github.io/2016/11/18/typescript-function/ [12.5 TypeScript - Interface 인터페이스]: https://poiemaweb.com/typescript-interface","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"TypeScript","slug":"front-end/typescript","permalink":"https://JihyeHwang09.github.io/categories/front-end/typescript/"}],"tags":[{"name":"TypeScript","slug":"typescript","permalink":"https://JihyeHwang09.github.io/tags/typescript/"},{"name":"Optional Property","slug":"optional-property","permalink":"https://JihyeHwang09.github.io/tags/optional-property/"},{"name":"선택적 프로퍼티","slug":"선택적-프로퍼티","permalink":"https://JihyeHwang09.github.io/tags/선택적-프로퍼티/"}]},{"title":"테이블 생성과 컬럼 추가/수정/삭제/이름 변경","slug":"db-2019-08-20","date":"2019-08-19T15:36:19.000Z","updated":"2019-08-20T16:02:47.040Z","comments":true,"path":"2019/08/20/db-2019-08-20/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/20/db-2019-08-20/","excerpt":"","text":"테이블 생성CREATE TABLE 테이블명 (컬럼명1 데이터타입 DEFAULT형식,컬럼명2 데이터타입 DEFAULT형식,컬럼명3 데이터타입 DEFAULT형식); 테이블의 컬럼 추가 ALTER TABLE 테이블명 ADD(컬럼명 데이터타입(사이즈)); 테이블의 컬럼 수정 ALTER TABLE 테이블명 MODIFY(컬럼명 테이타타입(사이즈)); 테이블의 컬럼 삭제 ALTER TABLE 테이블명 DROP COLUMN 컬럼명 테이블의 컬럼 이름 변경 ALTER TABLE 테이블명 RENAME 기존 컬럼명 TO 바꿀 새로운 컬럼명 참고 링크 [[ORACLE] 오라클 테이블 컬럼 추가/수정/삭제/이름변경 하는 방법(ALTER 테이블 ADD/MODIFY/DROP/RENAME) [인 생]]: https://jwklife.tistory.com/5 [ORACLE SQL 기본 명령어]: https://weblogic.tistory.com/13 [[SQL] CREATE TABLE 테이블 생성, 제약조건(CONSTRAINT), 확인(DESC) [개발이 하고 싶어요]]: https://hyeonstorage.tistory.com/291","categories":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/categories/database/"},{"name":"Oracle","slug":"database/oracle","permalink":"https://JihyeHwang09.github.io/categories/database/oracle/"}],"tags":[{"name":"Database","slug":"database","permalink":"https://JihyeHwang09.github.io/tags/database/"},{"name":"Oracle","slug":"oracle","permalink":"https://JihyeHwang09.github.io/tags/oracle/"}]},{"title":"JavaScript- null VS falsy 예외 처리","slug":"js-2019-08-19","date":"2019-08-18T15:13:23.000Z","updated":"2019-08-20T15:59:17.704Z","comments":true,"path":"2019/08/19/js-2019-08-19/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/19/js-2019-08-19/","excerpt":"","text":"null에 대한 예외 처리 null에 대해서만 예외 처리를 한다. 123if (event.target.value == null) &#123; return;&#125; falsy에 대한 예외 처리 undefined, 빈문자열(&#39;&#39;), 숫자 0등 falsy에 다 예외처리한다. 123if (!event.target.value) &#123; return;&#125; falsy란? boolean 문맥에서 false로 평가되는 값을 의미한다. falsy의 종류 false null undefined 0 NaN &#39;&#39; 참고 링크 [mdn- falsy]: https://developer.mozilla.org/ko/docs/Glossary/Falsy [[JavaScript] Null check, 빈 값 체크 v2019 [이상학의 개발블로그]]: https://sanghaklee.tistory.com/58?category=610728","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"null Check","slug":"null-check","permalink":"https://JihyeHwang09.github.io/tags/null-check/"},{"name":"fasly","slug":"fasly","permalink":"https://JihyeHwang09.github.io/tags/fasly/"}]},{"title":"Data Binding","slug":"angular-2019-08-18","date":"2019-08-18T14:43:06.000Z","updated":"2019-08-20T15:30:39.485Z","comments":true,"path":"2019/08/18/angular-2019-08-18/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/18/angular-2019-08-18/","excerpt":"","text":"처음 Angular를 접했을 때, 단방향 바인딩인 React와는 다르게 Angular는 데이터 바인딩이 단방향과 양방향을 지원하고 있어색다른 면을 느꼈다. Angular에서 제공하는 데이터 바인딩에 대해 알아보자.아래의 표는 이웅모님의 Angular Essentials의 데이터 바인딩에 대한 표 정리한 내용이다. Data Binding Data Binding Expression Interporlation Component Class =&gt; Template Property Binding Component Class =&gt; Template [property]=”expression” Attribute Binding Component Class =&gt; Template [attr.attribute-name]=”expression” Class Binding Component Class =&gt; Template [class.class-name]=”expression” Style Binding Component Class =&gt; Template [style.style-name]=”expression” Event Binding Component Class &lt;= Template (event)=”statement” Two-way Data Binding Component Class &lt;=&gt; Template [(ngModel)]=”property” 참고 링크 [이웅모 angular essentials- 데이터 바인딩]: https://poiemaweb.com/angular-component-data-binding","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"Angular","slug":"front-end/angular","permalink":"https://JihyeHwang09.github.io/categories/front-end/angular/"}],"tags":[{"name":"Angular","slug":"angular","permalink":"https://JihyeHwang09.github.io/tags/angular/"},{"name":"Data Binding","slug":"data-binding","permalink":"https://JihyeHwang09.github.io/tags/data-binding/"}]},{"title":"2019-08-17_Dev English","slug":"dev-eng-2019-08-17","date":"2019-08-17T14:34:21.000Z","updated":"2019-08-20T15:06:08.222Z","comments":true,"path":"2019/08/17/dev-eng-2019-08-17/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/17/dev-eng-2019-08-17/","excerpt":"","text":"의존성: dependency 연관관계: Association 의존관계: Dependency 상속 관계: Inheritance 실체화 관계: Realization 접근 제한자: access modifier","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Dev English","slug":"developer/dev-english","permalink":"https://JihyeHwang09.github.io/categories/developer/dev-english/"}],"tags":[{"name":"Dev English","slug":"dev-english","permalink":"https://JihyeHwang09.github.io/tags/dev-english/"}]},{"title":"GET과 POST, PUT 요청의 Annotation 차이","slug":"spring-2019-08-16","date":"2019-08-16T14:22:23.000Z","updated":"2019-08-20T14:28:47.731Z","comments":true,"path":"2019/08/16/spring-2019-08-16/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/16/spring-2019-08-16/","excerpt":"","text":"GET 요청시 GET은 요청 주소에 파라미터를 같이 보낸다. GET 요청은@RequestParam이나 @PathVariable를 붙여준다. POST와 PUT 요청시 POST와 PUT은 GET과 달리,파라미터를 HTTP 패킷의 바디에 담아서 전송한다.@RequestBody는 메서드의 파라미터를 HTTP 바디에 담아서 보낸다. POST, PUT을 요청을 사용할 때는 @RequestBody를 붙여준다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Spring & Spring Boot","slug":"back-end/spring-spring-boot","permalink":"https://JihyeHwang09.github.io/categories/back-end/spring-spring-boot/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://JihyeHwang09.github.io/tags/spring/"},{"name":"Spring Boot","slug":"spring-boot","permalink":"https://JihyeHwang09.github.io/tags/spring-boot/"}]},{"title":"URL 매핑- @RequestMapping을 간단하게 줄이기","slug":"spring-2019-08-15","date":"2019-08-15T13:37:39.000Z","updated":"2019-08-22T13:57:32.533Z","comments":true,"path":"2019/08/15/spring-2019-08-15/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/15/spring-2019-08-15/","excerpt":"","text":"Spring에서 URL 매핑 방법에 대해 알아보자. Spring 4.3 버전에 추가된 내용 @RequestMapping(value = &quot;/..., method=&quot;...&quot;)를 더욱 간단하고직관적으로 사용하기 위해 만들어진 어노테이션이다. 종류 @GetMapping @PostMapping @DeleteMapping @PutMapping @PatchMapping 사용 방법 @GetMapping은@RequestMapping(Method=RequestMethod.GET)과동일하게 사용할 수 있다. [기존의 URL 매핑 방법] @RequestMapping(Method=RequestMethod.GET) 사용1@RequestMapping(value = \"/board\", method=RequestMethod.GET) @GetMapping 사용 방법1@GetMapping(\"/board\") 코드 길이가 줄어들고, 어떤 HTTP Method과 매핑되는지를 직관적으로알아볼 수 있다. 참고 링크 [@GetMapping, @PostMapping, DeleteMapping, @PutMapping, @PatchMapping]: https://toma0912.tistory.com/86 [Spring @RequestMapping을 간단히 줄인 @PostMapping @GetMapping @PutMapping @DeleteMapping @PatchMapping]: https://0penster.tistory.com/24 [Spring Boot Spring MVC의 간단한 사용법]: https://araikuma.tistory.com/14","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Spring & Spring Boot","slug":"back-end/spring-spring-boot","permalink":"https://JihyeHwang09.github.io/categories/back-end/spring-spring-boot/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://JihyeHwang09.github.io/tags/spring/"},{"name":"Spring Boot","slug":"spring-boot","permalink":"https://JihyeHwang09.github.io/tags/spring-boot/"}]},{"title":"MyBatis에서 parameter 여러 개일 경우","slug":"spring-2019-08-14","date":"2019-08-13T15:46:59.000Z","updated":"2019-08-19T16:35:57.587Z","comments":true,"path":"2019/08/14/spring-2019-08-14/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/14/spring-2019-08-14/","excerpt":"","text":"문제 상황 boardIdx, BoardApi api의 총 2개의 parameter를 Mapper에 넘기려고 하는데,MyBatis에서는 오직 parameter를 1개만 줄 수 있다. 해결 방법1. parameter로 보내기 전,먼저 boardIdx를 set을 해서 1개의 객체로 만들어주기1) api에 boardIdx를 set한다. 2) copyProperties로 api -&gt; entity로 복사해준다. 123456789@Override public void updateBoard(int boardIdx, BoardApi api) throws Exception &#123; // 1. api에 boardIdx를 set하고 // copyProperties로 api =&gt; entity로 복사해준다. api.setBoardIdx(boardIdx); BoardEntity entity = new BoardEntity(); BeanUtils.copyProperties(api, entity); boardMapper.updateBoard(entity); &#125; 2. copyProperties로 api -&gt; entity로 복사한 후,entity에 boardIdx를 set 해주기1) copyProperties로 api =&gt; entity로 복사한다. 2) entity에 boardIdx를 set 해준다. 123456789@Override public void updateBoard(int boardIdx, BoardApi api) throws Exception &#123; BoardEntity entity = new BoardEntity(); BeanUtils.copyProperties(api, entity); // 2. copyProperties로 api =&gt; entity로 복사한 후, // entity에 boardIdx를 set 해준다. entity.setBoardIdx(boardIdx); boardMapper.updateBoard(entity); &#125;","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Spring & Spring Boot","slug":"back-end/spring-spring-boot","permalink":"https://JihyeHwang09.github.io/categories/back-end/spring-spring-boot/"}],"tags":[{"name":"매개변수","slug":"매개변수","permalink":"https://JihyeHwang09.github.io/tags/매개변수/"},{"name":"Spring","slug":"spring","permalink":"https://JihyeHwang09.github.io/tags/spring/"},{"name":"Spring Boot","slug":"spring-boot","permalink":"https://JihyeHwang09.github.io/tags/spring-boot/"},{"name":"MyBatis","slug":"mybatis","permalink":"https://JihyeHwang09.github.io/tags/mybatis/"},{"name":"parameter 여러 개","slug":"parameter-여러-개","permalink":"https://JihyeHwang09.github.io/tags/parameter-여러-개/"}]},{"title":"더 나은 개발자로 성장하는 팁 \"나는 그런 개발자가 좋더라\"(by 백기선님)","slug":"lecture-2019-08-13","date":"2019-08-12T16:08:14.000Z","updated":"2019-11-16T11:25:03.907Z","comments":true,"path":"2019/08/13/lecture-2019-08-13/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/13/lecture-2019-08-13/","excerpt":"","text":"해당 글은 백기선님의 더 나은 개발자로 성장하는 팁 “나는 그런 개발자가 좋더라” 영상에서제가 중요하게 여기는 부분을 요약 정리한 내용 입니다.전체 내용은 아래 링크의 원본 영상을 참고해주세요:) 1. 로그를 잘 남기자.2. 에러 메시지를 읽자.3. 테스트 코드를 잘 작성하자. 책 [테스트 주도 개발] 읽으면서 책 내용을 직접 코딩해 볼 것 JUnit 공부하기 관련 프레임워크 사용하기 (ex) mockito) 4. DbUnit(DB 테스트), HtmlUnit(뷰단 테스트) 테스트 코드 작성에 익숙해지자. 테스트 코드를 항상 먼저 작성하라는 게 아니라, 테스트 코드의 중요성을 얘기하는 것이다. 테스트를 먼저, 후에 작성하는 순서가 중요한 게 아니라 테스트 코드를 작성하는 것이 중요하다!! 5. 디버거를 잘 사용하자. 참고 링크 [더 나은 개발자로 성장하는 팁 “나는 그런 개발자가 좋더라”]: https://www.youtube.com/watch?v=s_Zdl28NEM4&amp;list=PLfI752FpVCS-wPT1tpQ0y4NMyWr92bzgL&amp;index=2","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Lecture","slug":"developer/lecture","permalink":"https://JihyeHwang09.github.io/categories/developer/lecture/"}],"tags":[{"name":"백기선","slug":"백기선","permalink":"https://JihyeHwang09.github.io/tags/백기선/"}]},{"title":"개발자 포트폴리오 만드는 Tip(by 나동빈님)","slug":"lecture-2019-08-12","date":"2019-08-11T16:07:17.000Z","updated":"2019-11-16T11:24:54.699Z","comments":true,"path":"2019/08/12/lecture-2019-08-12/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/12/lecture-2019-08-12/","excerpt":"","text":"해당 글은 나동빈님의 초보 개발자를 위한, 개발자 포트폴리오 만드는 방법 영상에서제게 필요한 부분을 요약 정리한 내용 입니다.전체 내용은 아래 링크의 원본 영상을 참고해주세요:) 1. 프로젝트 잘 만들어진 프로젝트를 처음부터 끝까지 따라쳐보면서 해보기(step by step 형식의 강좌 ) 자신의 프로젝트에 맞게 바꾸면서 만들어보기 2. notion으로 프로젝트 진행 일정관리 하기 일정관리 앱을 사용한 경험 자체도 포트폴리오에 넣을 수 있다. 3. 프로젝트 배포 AWS에서 가장 기본적인 서비스인 EC2를 이용(나동빈님 강의 참고) 4. 포트폴리오 요약 기술 스펙 자세하게 정의 하자. SSA 인증서 달기 UI적으로도 완성된 프로젝트 만들기(부트스트랩 등을 이용) 참고 링크 [초보 개발자를 위한, 개발자 포트폴리오 만드는 방법]: https://www.youtube.com/watch?v=hElB_FY33xs","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Lecture","slug":"developer/lecture","permalink":"https://JihyeHwang09.github.io/categories/developer/lecture/"}],"tags":[{"name":"나동빈","slug":"나동빈","permalink":"https://JihyeHwang09.github.io/tags/나동빈/"},{"name":"개발자 포트폴리오","slug":"개발자-포트폴리오","permalink":"https://JihyeHwang09.github.io/tags/개발자-포트폴리오/"}]},{"title":"Json 형식으로 데이터를 주고받을 때, null이 있으면 제외하기","slug":"spring-2019-08-11","date":"2019-08-10T15:36:13.000Z","updated":"2019-08-19T15:45:14.263Z","comments":true,"path":"2019/08/11/spring-2019-08-11/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/11/spring-2019-08-11/","excerpt":"","text":"Json 형식으로 데이터를 주고받을 때,data들 중에서 null이 있으면 제외하는 방법을 알아보자. 12// 데이터 중에서 null이 있으면 제외한다.@JsonInclude(JsonInclude.Include.NON_NULL) 위와 같이 @JsonInclude(JsonInclude.Include.NON_NULL) 어노테이션을Json 데이터를 주고 받는 코드 위에 붙여주면 된다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Spring & Spring Boot","slug":"back-end/spring-spring-boot","permalink":"https://JihyeHwang09.github.io/categories/back-end/spring-spring-boot/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://JihyeHwang09.github.io/tags/spring/"},{"name":"Spring Boot","slug":"spring-boot","permalink":"https://JihyeHwang09.github.io/tags/spring-boot/"},{"name":"JsonInclude.Include.NON_NULL","slug":"jsoninclude-include-non-null","permalink":"https://JihyeHwang09.github.io/tags/jsoninclude-include-non-null/"}]},{"title":"변수를 선언하고, 초기화를 하지 않을 경우","slug":"java-2019-08-10","date":"2019-08-10T14:19:48.000Z","updated":"2019-08-19T14:39:37.244Z","comments":true,"path":"2019/08/10/java-2019-08-10/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/10/java-2019-08-10/","excerpt":"","text":"Java에서 변수를 선언하고 초기화를 하지 않았을 경우,각 타입별로 출력되는 기본 초기값에 대해 알아보자. 종류 데이터 타입 출력되는 초기값 정수타입 byte 0 short int long 0L char \\u0000 실수 타입 float 0.0 double 0.0F 논리 타입 boolean false String 포함 클래스/배열/인터페이스 null cf) JavaScript는 변수를 만든 후 초기화하지 않으면,undefined가 초기값으로 출력된다. 참고 링크 [자바(Java)〃필드와 변수의 선언위치와 초기값(전역변수,지역변수)]: https://hunit.tistory.com/154","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Java","slug":"back-end/java","permalink":"https://JihyeHwang09.github.io/categories/back-end/java/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://JihyeHwang09.github.io/tags/java/"}]},{"title":"Void elements do not have end tags \"hr\"","slug":"css-2019-08-09","date":"2019-08-09T13:53:03.000Z","updated":"2019-08-19T14:16:56.501Z","comments":true,"path":"2019/08/09/css-2019-08-09/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/09/css-2019-08-09/","excerpt":"","text":"에러 메시지12Error: Template parse errors:Void elements do not have end tags &quot;hr&quot; 문제 원인 hr태그는 여는 태그만 존재하는데,열고 닫는 태그를 각각 써줬기 때문에 에러가 발생했다. 해결 방법12&lt;hr /&gt;&lt;!-- &lt;hr&gt;&lt;/hr&gt;는 잘못된 표기법이다. --&gt; hr태그는 닫는 태그를 따로 써주지 않는다. 여는 태그만 사용한다.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"}]},{"title":"가로줄 넣기(hr태그)","slug":"css-2019-08-08","date":"2019-08-08T13:18:47.000Z","updated":"2019-08-19T14:09:38.381Z","comments":true,"path":"2019/08/08/css-2019-08-08/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/08/css-2019-08-08/","excerpt":"","text":"hr 태그는 기본적으로 border값이 매겨져 있으므로초기화를 먼저 해준다. 1border: 0; width: 수평선의 크기(가로 길이) 비율(%) | 숫자값(px) height : 수평선의 굵기 text-align: 선의 위치 left | center | right(default: center) background-color 또는 background: 수평선의 색깔 1234567hr &#123; border: 0; width: 50%; align: left; height: 10px; background: orange;&#125; 참고 링크 [HTML hr 태그 색, 굵기 조절 및 그림자 삭제 방법]: https://dasima.xyz/html-hr/","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"}]},{"title":"JAVA.SECURITY.INVALIDKEYEXCEPTION","slug":"spring-2019-08-07","date":"2019-08-07T13:05:48.000Z","updated":"2019-08-19T13:18:29.543Z","comments":true,"path":"2019/08/07/spring-2019-08-07/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/07/spring-2019-08-07/","excerpt":"","text":"에러 현상 Front에서는 값을 제대로 넘기는데,서버에서는 로그인 정보가 null로 넘어와서 로그인 되지 않음 AES256 암호화시,JAVA.SECURITY.INVALIDKEYEXCEPTION: ILLEGAL KEY SIZE 에러 메시지 확인 에러 확인 절차 local server를 바라보고 있는 Front에서는 값을 제대로 넘기는 것을 확인 [개발자 도구 - Network탭 - preview탭]을 확인 Project Settings에서 JDK home path가 제대로 되어있는지 확인 local_policy.jar, US_export_policy.jar 파일의 path가 제대로 되어 있는지 확인 해결 방법 JCE를 다운 받은 후, 다운 받은 파일안의 local_policy.jar, US_export_policy.jar 파일을 JAVA_HOME 아래에 있는 /jre/lib/security/폴더에 복사해서 파일을 덮어씌워 준다. C:\\Users\\CRS-P-60\\Desktop\\development\\JAVA\\jdk1.8.0_45\\jre\\lib\\security C:\\Users\\CRS-P-60\\Desktop\\development\\JAVA\\jre1.8.0_45\\lib\\security 참고 링크 [자바 AES256 암호화 관련 에러]: https://hongsii.github.io/2018/04/05/java-aes256-error/","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Spring & Spring Boot","slug":"back-end/spring-spring-boot","permalink":"https://JihyeHwang09.github.io/categories/back-end/spring-spring-boot/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://JihyeHwang09.github.io/tags/spring/"},{"name":"Spring Boot","slug":"spring-boot","permalink":"https://JihyeHwang09.github.io/tags/spring-boot/"},{"name":"JAVA.SECURITY.INVALIDKEYEXCEPTION","slug":"java-security-invalidkeyexception","permalink":"https://JihyeHwang09.github.io/tags/java-security-invalidkeyexception/"},{"name":"ILLEGAL KEY SIZE","slug":"illegal-key-size","permalink":"https://JihyeHwang09.github.io/tags/illegal-key-size/"}]},{"title":"DB에 datetime으로 넣은 값을 꺼낼 때, null을 반환하는 현상","slug":"spring-2019-08-06","date":"2019-08-06T12:33:31.000Z","updated":"2019-08-19T13:17:46.278Z","comments":true,"path":"2019/08/06/spring-2019-08-06/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/06/spring-2019-08-06/","excerpt":"","text":"세팅 DB: H2 SQL mapper: myBatis Framework: Spring Boot 문제 현상 DB에는 글 작성 시간을 나타내는 property인 created_datetime에 값이 들어있는데, DTO 역할을 하는 클래스에 글 작성시간을 나타내는 property가null을 반환하는 문제 발생(값을 가져오지 못함). 문제 원인 DB의 column과 Java 변수를 mapping 해주기 위해(DB는 snake_case인데, myBatis에서 return 받을 때 Camel Case로 받을 수 있도록 설정함)Spring Boot의 설정 파일인 application.yml에 아래의 설정을 했었다. 1234// application.ymlmybatis: configuration: map-underscore-to-camel-case: true DB에는 작성시간의 변수명을 created_datetime으로 설정해두고,DTO 역할을 하는 클래스인 entity와 api에는 createDatetime이라고 주고 있었다.(d를 사이에 빼먹음) DB에서 mapping되는 컬럼명이 없기 때문에 값을 가져오지 못해 null이 반환된 것이다. 해결 방법 DTO 역할을 하는 클래스의 작성시간을 나타내는 변수의 타입을 Date로 주고,java.util.Date를 import 한다. 테이블을 생성하는 코드의 작성시간을 나타내는 컬럼명과DTO역할의 entity, api클래스의 property명을 일치시켜 준다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Spring & Spring Boot","slug":"back-end/spring-spring-boot","permalink":"https://JihyeHwang09.github.io/categories/back-end/spring-spring-boot/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://JihyeHwang09.github.io/tags/spring/"},{"name":"Spring Boot","slug":"spring-boot","permalink":"https://JihyeHwang09.github.io/tags/spring-boot/"},{"name":"datetime","slug":"datetime","permalink":"https://JihyeHwang09.github.io/tags/datetime/"}]},{"title":"Unexpected closing tag","slug":"js-2019-08-05","date":"2019-08-05T11:59:16.000Z","updated":"2019-08-19T12:32:45.094Z","comments":true,"path":"2019/08/05/js-2019-08-05/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/05/js-2019-08-05/","excerpt":"","text":"에러 메시지12345ERROR Error: Uncaught (in promise): Error: Template parse errors:Unexpected closing tag &quot;form&quot;.It may happen when the tag has already been closed by another tag.For more info seehttps://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags 문제 원인 div태그를 여는 부분은 그대로 두고, 닫는 부분만 주석 처리했더니 parsing 에러가 발생 태그를 주석 처리할 때는 여는 태그와 닫는 태그 함께 주석처리 했는지 확인하기","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"Error","slug":"error","permalink":"https://JihyeHwang09.github.io/tags/error/"},{"name":"Template parse errors","slug":"template-parse-errors","permalink":"https://JihyeHwang09.github.io/tags/template-parse-errors/"},{"name":"Unexpected closing tag","slug":"unexpected-closing-tag","permalink":"https://JihyeHwang09.github.io/tags/unexpected-closing-tag/"}]},{"title":"쉴 땐 잘 쉬자.","slug":"TIL-2019-08-04","date":"2019-08-04T14:54:11.000Z","updated":"2019-08-06T12:41:29.924Z","comments":true,"path":"2019/08/04/TIL-2019-08-04/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/04/TIL-2019-08-04/","excerpt":"","text":"두통 때문에 머리가 깨질듯이 아팠다.쉬는 날이 없으니 당연한 결과다.퇴근 후에 개발 공부를 하는 것도 좋고 매일 블로그를 쓰는 것도 좋지만,쉴 때는 제대로 푹 쉬자.적어도 주말 하루는 아무 생각하지 말고 쉬도록 하자.휴식 후에는 더 집중력 있게 개발할 수 있을 것이다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"구체적인 피드백과 퍼포먼스","slug":"TIL-2019-08-03","date":"2019-08-03T13:41:35.000Z","updated":"2019-08-19T12:51:41.520Z","comments":true,"path":"2019/08/03/TIL-2019-08-03/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/03/TIL-2019-08-03/","excerpt":"","text":"나는 어디쯤 있는 걸까?끝이 보이지 않는 긴 터널을 걷는 기분이다.한치 앞도 보이지 않는 터널 속에서 손을 뻗어 겨우겨우 한발짝씩 나아가는 느낌이 든다. 회사에 들어와서 새로운 기술을 배우면서 적용하는 과정에서확실히 학원에서 배울 때와는 많이 다르다는 걸 느낀다. 회사에서는 내가 해당 기술에 대해 원리를 이해하는 것보다는이슈를 빨리 처리해 내는 것이 우선이 된다. 내 코드가 우선은 작동하는데 파급 효과가 어디까지 미칠지 아직은 감이 오질 않는다. 내 코드가 적절한지, 어떤 문제가 있는지 어떻게 알아봐야 할까? 알고리즘이나 자료구조 공부는 회사에서 진행하는 이슈를 처리하는 일에당장 큰 효과가 있어 보이지 않지만,꾸준히 해나간다면 훗날 도움이 되리라 생각한다. 다만 내가 실무에서 퍼포먼스를 보일 수 있도록 공부하려면, 어떤 방향으로 나아가야 할까? 함께 일하는 동료들의 짐을 나눌 수 있도록 오롯이 내 몫을 해내고 싶다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"블로그 7개월 간의 회고","slug":"TIL-2019-08-02","date":"2019-08-02T13:49:28.000Z","updated":"2019-08-19T12:50:07.695Z","comments":true,"path":"2019/08/02/TIL-2019-08-02/","link":"","permalink":"https://JihyeHwang09.github.io/2019/08/02/TIL-2019-08-02/","excerpt":"","text":"블로그를 시작한 지 7개월이 되는 시점에서 회고를 하는 시간을 가져보고자 한다. 매일 1일 1포스팅이 내게 주는 의미 1일 1포스팅은 사실 거창하지 않다.어쩌면 하찮아 보일 수도 있는 단순 반복적인 일처럼 보인다.꾸준히 공부하고 그 내용을 정리하면서 조금 더 개발자로서 성장하고 싶었다. 처음 블로그를 시작하던 7개월 전을 떠올려 보았다.그때의 나와 포스팅을 꾸준히 해온 지금의 내가 다른 점을 한 가지 꼽아보자면, 끈질김을 얻었다는 것이다. 개발을 하면서 수많은 에러에 부딪치고 넘어진다.넘어지자마자 바로 일어나지 못해도 괜찮다.그저 넘어지면 다시 일어나서 걸으면 된다.충분히 넘어져 울고 좌절해도 괜찮다.그저 툭툭 털고 일어나 다시 시작하면 된다. 그 뿐이다. 앞으로의 방향 꾸준히 공부 해나갈 수 있는 주제를 생각해보자. 회사에서 사용하는 기술인 Angular나 Spring, Spring Boot 위주로 공부하고 정리할 것이다. 코드업 기초 100문제를 3문제를 풀면 클리어하므로프로그래머스 레벨2에 해당하는 문제들부터 풀어나가고자 한다.레벨2인 문제는 2~3일에 1문제를 풀지 or 매일 풀 것인지 등문제 풀이 주기를 정하고 풀어 나가자.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"배열을 ArrayList로 변환하기","slug":"java-2019-07-31","date":"2019-07-31T13:40:11.000Z","updated":"2019-07-31T14:10:17.766Z","comments":true,"path":"2019/07/31/java-2019-07-31/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/31/java-2019-07-31/","excerpt":"","text":"배열을 ArrayList로 변환하는 법1List&lt;String&gt; list = Arrays.asList(arr); 일반적으로 배열을 ArrayList로 변환하기 위해 위의 코드와 같이 작성하는 경우가 있다. 이 코드는 문제점이 있다. 어떤 문제점이 있는지, 해결 방법은 무엇인지를 살펴보자. 문제점 고정된 길이의 list를 반환하기 때문에 사이즈를 바꿀 수 없다. set(), get(), contains() 메서드를 가지고 있으나 원소를 추가하는 메서드는가지고 있지 않기 때문이다. 해결 방법새로운 list를 만들면, list의 추가, 삭제가 가능해진다. 1ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arr)); 참고링크 [자바 프로그래머가 자주 실수 하는 10가지 - 1]: https://bestalign.github.io/2015/08/31/top-10-mistakes-java-developers-make-1/ [[Java] Arrays.asList]: http://iloveulhj.github.io/posts/java/java-Arrays.asList.html","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Java","slug":"back-end/java","permalink":"https://JihyeHwang09.github.io/categories/back-end/java/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://JihyeHwang09.github.io/tags/java/"},{"name":"배열","slug":"배열","permalink":"https://JihyeHwang09.github.io/tags/배열/"},{"name":"ArrayList","slug":"arraylist","permalink":"https://JihyeHwang09.github.io/tags/arraylist/"}]},{"title":"N-Queens Problem","slug":"recursion-n-queens-problem","date":"2019-07-29T15:00:01.000Z","updated":"2019-07-29T14:57:02.016Z","comments":true,"path":"2019/07/30/recursion-n-queens-problem/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/30/recursion-n-queens-problem/","excerpt":"","text":"이번에는 Recursion의 응용 - N-Queens Problem에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. N-Queens Problem 퀸 N개를 서로 공격할 수 없게 놓는다. 퀸은 가로줄, 세로줄, 대각선으로 같은 줄에 놓을 수 없다. 되추적 기법(Backtracking): 상태공간 트리를 깊이 우선 방식으로 탐색하여 해를 찾는 알고리즘을 말한다. Design Recursion123456789101112131415161718return-type queens(arguments) &#123; // 아래의 코드는 어떤 노드에 딱 도착했을 때 // 해야 할 일을 순서대로 기술한 것이다.// 이미 말들이 충돌되어서 확인할 필요가 없는 노드인가?// 꽝// (이 노드 뿐만 아니라 밑으로 내려가서 확인할 필요가 없는 노드)일 경우if non-promising // 즉시 되돌아 간다. report failure and return;// 이 노드가 찾던 답이 되는 노드인가else if success report answer and return;// 꽝도 아니고, 답도 아니라면else // 자식 노드들을 순환하며 방문한다. visit children recursively;&#125; queens라는 함수가 여러 번 호출된다. ‘이 함수가 호출되는 시기는 트리의 어떤 node에 딱 도착한 순간이다’라고 생각하면 된다. 매개변수(arguments): 트리 상에서 내가 지금 도착한 노드가어떤 노드인지를 판별할 수 있는 정보가 이 매개변수로 들어올 것이다. 123456789101112131415161718// 지금 트리상에서 어떤 노드에 있는지// 전역 변수인 cols와 매기변수인 level을 이용해서// 함수 queens에 정보를 줄 수 있다.int [] cols = new int [N+1];// 이 문제에서 행번호는 필요 없다.// cols[1]: 1번말이 놓인 열번호// cols[2]: 2번말이 놓인 열번호// ...// cols[level]return-type queens(int level) &#123; if non-promising report failure and return; else if success report answer and return; else visit children recursively;&#125; 매개변수 level은 현재 노드의 레벨을 표현한다. cols[i] = j는 i번 말이 (i행, j열)에 놓였음을 의미한다. 123456789int [] cols = new int [N+1];boolean queens(int level) &#123; if non-promising report failure and return; else if success report answer and return; else visit children recursively;&#125; return-type은 일단 boolean으로 하자. 즉, 성공인지 실패인지를 반환한다. 1234// 현재 도착한 이 노드가 꽝인지 아닌지를 판별해주는 함수 promising 있다고 가정하자.if(!promising(level))// 꽝이라면 false를 반환한다. return false; 노드가 어떤 경우에 non-promising할까? 일단 이 문제는 나중에 생각하자. 123456// 이 코드는 위의 promising 테스트를 통과해야만 도달할 수 있는 코드이다.// level이 N이라는 것은 어쨌든 모든 말이 다 놓였다는 의미//-&gt; 놓인 말들 사이에 충돌이 없다는 의미else if (level == N) return true; promising 테스트를 통과했다는 가정하에 level == N이면,모든 말이 놓였다는 의미이고 따라서 성공이다. 12345for(int i=1 i &lt;= N; i++) &#123; cols[level+1] = i; if(queens(level+1)) return true;&#125; level+1 번째 말을 각각의 열에 놓은 후, recursion을 호출한다. Promising Test 12345678910boolean promising(int level) &#123; for (int i = 1; i &lt; level; i++) &#123; // 같은 열에 놓였는지 검사 if(cols[i] == cols[level]) return false; // 같은 대각선에 놓였는지 검사 else if on the same diagonal return false; &#125;&#125; 123456789boolean promising(int level) &#123; for (int i-1; i &lt; level; i++) &#123; if(cols[i] == cols[level]) return false; // 같은 대각선에 놓였는지 검사 else if (level - i == Math.abs(cols[level] - cols[i])) return false; &#125;&#125; cols[i]와 cols[level] 중에 어떤 값이 큰지 모르기 때문에cols[level] - cols[i]에 절대값을 씌워준다. 정리12345678910111213141516171819202122232425int [] cols = new int [N+1];boolean queens(int level) &#123; // if non-promising // report failure and return; if(!promising(level)) return false; // else if success // report answer and return; else if (level == N) &#123; for(int i = 1; i &lt;= N; i++) &#123; System.out.println(\"(\" + i + \", + \" + cols[i] + \")\"); return true; &#125; &#125; // else // visit children recursively; for(int i = 1; i &lt;= N; i++) &#123; cols[level + 1] = i; if(queens(level + 1)) return true; &#125; return false;&#125; 처음에는 queens(0)으로 호출한다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"순환 함수","slug":"순환-함수","permalink":"https://JihyeHwang09.github.io/tags/순환-함수/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"recursion","slug":"recursion","permalink":"https://JihyeHwang09.github.io/tags/recursion/"}]},{"title":"CodeUp(코드업) 풀이 (1095번)","slug":"codeup-65","date":"2019-07-29T12:30:56.000Z","updated":"2019-07-29T12:50:30.170Z","comments":true,"path":"2019/07/29/codeup-65/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/29/codeup-65/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1095 : [기초-종합+배열] 이상한 출석 번호 부르기3문제 설명경기과학고 X 선생님은 오늘도 이상한 출석을 부른다. 경곽이는 오늘도 다른 생각을 해보았다. 출석 번호를 다 부르지는 않은 것 같은데… 가장 빠른 번호가 뭐였지? 출석 번호를 n번 무작위로 불렀을 때, 가장 빠른 번호를 출력해 보자. 입력번호를 부른 횟수(n)가 첫 줄에 입력된다.(n, 1 ~ 10000)부른 횟수 만큼 랜덤 번호(k)가 두 번째 줄에 공백을 사이에 두고 순서대로 입력된다.(k, 1~23) 출력출석을 부른 번호 중에 가장 빠른 번호를 1개만 출력한다. 입력 예시1010 4 2 3 6 6 7 9 8 5 출력 예시2 내 풀이123456789101112n = int(input());list = input().split();min = int(list[0]);for i in range(1, n): if min &gt; int(list[i]): min = int(list[i]); else: i += 1;print(min); 모범 답안1234567891011121314a=input()b=input().split()n=int(a)arr=[]for i in range(n) : arr.append(int(b[i]))m=23for i in range(n) : if m&gt;arr[i] : m=arr[i]print(m)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1094번)","slug":"codeup-64","date":"2019-07-28T11:27:22.000Z","updated":"2019-07-28T12:19:23.034Z","comments":true,"path":"2019/07/28/codeup-64/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/28/codeup-64/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1094 : [기초-종합+배열] 이상한 출석 번호 부르기2문제 설명경기과학고 X 선생님은 정보과학 수업을 시작하기 전에 이상한 출석을 부른다. 학생들의 얼굴과 이름을 빨리 익히기 위해 번호를 무작위(랜덤)으로 부르는데, 경곽이는 선생님이 부른 번호들을 기억하고 있다가 거꾸로 불러보는 연습을 해보고 싶어졌다. 출석 번호를 n번 무작위로 불렀을 때, 부른 번호를 거꾸로 출력해 보자. 입력번호를 부른 횟수(n)가 첫 줄에 입력된다.(n, 1 ~ 10000)부른 횟수 만큼 랜덤 번호(k)가 두 번째 줄에 공백을 사이에 두고 순서대로 입력된다.(k, 1~23) 출력출석을 부른 번호 순서를 바꾸어 공백을 두고 출력한다. 입력 예시1010 4 2 3 6 6 7 9 8 5 출력 예시5 8 9 7 6 6 3 2 4 10 내 풀이1 for in range에 증가폭을 음수로 주는 방법 12345678910111213n = int(input());a = input().split();numbers = [];for i in range(0, n): numbers.append(int(a[i])); # print(arr[i]);# n-1에서 0까지 역순으로 숫자 생성for i in range(n-1, -1, -1): print(numbers[i], end= ' '); range는 숫자가 증가하는 기본 값이 양수 1이기 때문에 역순으로 생성하려면, 증가 폭을 음수로 지정한다. 내 풀이 2 reversed를 이용한 방법 123456789101112n = int(input());a = input().split();numbers = [];for i in range(0, n): numbers.append(int(a[i]));# range에 reverse를 이용하여 숫자의 순서를 반대로 뒤집는다.# 9부터 0까지 10번 반복한다.for i in reversed(range(n)): print(numbers[i], end=' '); reversed를 이용하여 숫자의 순서를 반대로 뒤집어서 출력한다. 형태 for 변수 in reversed(range(횟수)) for 변수 in reversed(range(시작, 끝)) for 변수 in reversed(range(시작, 끝, 증가폭)) 모범 답안 while문을 이용해 거꾸로 출력 12345678910111213arr=[]a=input()b=input().split()n=int(a)for i in range(n) : arr.append(int(b[i]))i=n-1while i&gt;=0 : print(arr[i], end=' ') i-=1 참고 링크 [15.4 숫자를 감소시키기]: https://dojang.io/mod/page/view.php?id=1271","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1093번)","slug":"codeup-63","date":"2019-07-27T13:10:03.000Z","updated":"2019-07-28T12:18:39.836Z","comments":true,"path":"2019/07/27/codeup-63/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/27/codeup-63/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1093 : [기초-종합+배열] 이상한 출석 번호 부르기1문제 설명경기과학고 X 선생님은 정보과학 수업을 시작하기 전에 이상한 출석을 부른다. 선생님은 출석부를 보고 번호를 부르는데, 학생들의 얼굴과 이름을 빨리 익히기 위해 번호를 무작위(랜덤)으로 부른다. 그리고, 얼굴과 이름이 잘 기억되지 않는 학생들은 번호를 여러 번 불러 이름과 얼굴을 빨리 익히려고 하는 것이다. 출석 번호를 n번 무작위로 불렀을 때, 각 번호(1 ~ 23)가 불린 횟수를 각각 출력해보자. 입력첫 번째 줄에 출석 번호를 부른 횟수 정수 n이 입력된다.(1 ~ 10000) 두 번째 줄에는 무작위로 부른 n개의 번호(1 ~ 23)가 공백을 두고 순서대로 입력된다. 출력1번 부터 번호가 불린 횟수를 순서대로 공백을 두고 한 줄로 출력한다. 입력 예시101 3 2 2 5 6 7 4 5 9 출력 예시1 2 1 1 2 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 내 풀이12345678910n = int(input());a = input().split();# list를 0으로 초기화lst = [0 for _ in range(23)];for i in range(n): lst[int(a[i]) -1] += 1;for i in range(0, 23): print(lst[i], end=' '); 모범 답안123456789101112a=input()b=input().split()n=int(a)arr=[]for i in range(24) : arr.append(0)for i in range(n) : arr[int(b[i])]+=1for i in range(1, 24) : print(arr[i], end=' ')","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1092번)","slug":"codeup-62","date":"2019-07-26T13:10:03.000Z","updated":"2019-07-26T14:38:44.836Z","comments":true,"path":"2019/07/26/codeup-62/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/26/codeup-62/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1092 : [기초-종합] 함께 문제 푸는 날1문제 설명koistudy.net 에는 초등학생, 중학생, 고등학생, 대학생, 대학원생, 일반인, 군인, 프로그래머, 탑코더 등 아주 많은 사람들이 들어와 문제를 풀고 있는데, 가입하고 Guest Board를 통해 정회원으로 등업이 되어야 문제를 풀어볼 수 있다. 매 시간의 실시간 채점 정보는 메뉴의 Judge Status 를 통해 살펴볼 수 있다. 자! 여기서…잠깐.. 같은 날 동시에 가입한 3명의 사람들이 koistudy.net을 들어와 문제를 푸는 날짜가 매우 규칙적이라고 할 때, 다시 모두 함께 문제를 풀게 되는 그날은 언제일까? 예를 들어 3명이 같은날 가입/등업하고, 각각 3일 마다, 7일 마다, 9일 마다 한 번씩 들어온다면, 처음 가입하고 63일 만에 다시 3명이 함께 문제를 풀게 된다. 입력같은 날 동시에 가입한 인원 3명이 규칙적으로 방문하는, 방문 주기가 공백을 두고 입력된다. (단, 입력값은 100이하의 자연수이다.) 출력3명이 다시 모두 함께 방문에 문제를 풀어보는 날(동시 가입/등업 후 며칠 후?) 을 출력한다. 입력 예시3 7 9 출력 예시63 내 풀이123456789101112a, b, c = input().split();a = int(a);b = int(b);c = int(c);day = 1;while (day%a) != 0 or (day%b) != 0 or (day%c)!= 0: day += 1;# day %a == 0 and day %b == 0 and day %c == 0print(day); a, b, c로 나누어 떨어지는 최소공배수를 찾았을 때, 그날을 출력해준다. 12if day %a == 0 and day %b == 0 and day %c == 0:print(day); 따라서, while문의 조건 부분에는 이와 반대되는 조건을 적어주고, 아직 while문의 실행 부분으로 코드의 실행 흐름이 옮겨왔다는 것은 그날을 찾지 못했다는 의미이므로 day를 1 증가시켜준 후, while문의 조건을 검사한다. 모범 답안1234567891011a,b,c=input().split()x=int(a)y=int(b)z=int(c)d=1while (d%x!=0 or d%y!=0 or d%z!=0) : d+=1print(d)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1091번)","slug":"codeup-61","date":"2019-07-25T11:37:09.000Z","updated":"2019-07-25T12:03:51.078Z","comments":true,"path":"2019/07/25/codeup-61/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/25/codeup-61/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1091 : [기초-종합] 수 나열하기3문제 설명어떤 규칙에 따라 수를 순서대로 나열한 것을 수열이라고 한다. 예를 들어1 -1 3 -5 11 -21 43 … 은 1부터 시작해 이전에 만든 수에 -2를 곱한 다음 1을 더해 다음 수를 만든 수열이다. 이런 이상한 수열을 알게 된 경곽이는 또 궁금해 졌다. “그럼…. 13번째 나오는 수는 뭘까?” 경곽이는 물론 수학을 아주 잘 하지만 이런 문제는 본적이 거의 없었다… 그래서, 프로그램을 만들어 컴퓨터로 확인해 보고 싶어졌다. 시작 값(a), 곱할 값(m), 더할 값(d), 몇 번째 인지를 나타내는 정수(n)가 입력될 때, n번째 수를 출력하는 프로그램을 만들어보자. 입력시작 값(a), 곱할 값(m), 더할 값(d), 몇 번째 인지를 나타내는 정수(n)가 공백을 두고 입력된다.(a, m, d는 -50 ~ 50, n은 10이하의 자연수) 출력n번째로 만들어질 수를 출력한다. 입력 예시1 -2 1 8 출력 예시-85 내 풀이 while문을 이용한 풀이 1234567891011a, m, d, n= input().split();a = int(a);m = int(m);d = int(d);n = int(n);i = 1;while i &lt;= n-1: a = a * m + d; i+= 1;print(a); 모범 답안 for문을 이용한 풀이 1234567891011a,m,d,n=input().split()A=int(a)M=int(m)D=int(d)N=int(n)for i in range(N-1) : A = A*M+Dprint(A)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1090번)","slug":"codeup-60","date":"2019-07-24T12:36:03.000Z","updated":"2019-07-25T11:41:59.999Z","comments":true,"path":"2019/07/24/codeup-60/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/24/codeup-60/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1090 : [기초-종합] 수 나열하기2문제 설명어떤 규칙에 따라 수를 순서대로 나열한 것을 수열이라고 한다. 예를 들어2 6 18 54 162 486 … 은 2부터 시작해 이전에 만든 수에 3을 곱해 다음 수를 만든 수열이다. 이러한 것을 수학에서는 앞뒤 수들의 비율이 같다고 하여 등비(비율이 같다의 한문 말) 수열이라고 한다. 등비 수열을 알게된 경곽이는 갑자기 궁금해 졌다. “그럼…. 13번째 나오는 수는 뭘까?” 경곽이는 물론 수학을 아주 잘 하지만, 프로그램을 만들어 컴퓨터로 자동 계산하고 싶어졌다. 시작 값(a), 등비의 값(r), 몇 번째 인지를 나타내는 정수(n)가 입력될 때 n번째 수를 출력하는 프로그램을 만들어보자. 입력시작 값(a), 등비의 값(r), 몇 번째 인지를 나타내는 정수(n)이 공백을 두고 입력된다.(모두 0 ~ 7) 출력n번째로 만들어질 수를 출력한다. 입력 예시2 3 7 출력 예시1458 내 풀이 1123456a, r, n= input().split();a = int(a);r = int(r);n = int(n);print(a * r **(n-1)); 내 풀이 2 while문을 이용한 풀이 1234567891011a, r, n= input().split();a = int(a);r = int(r);n = int(n);i = 1;while i &lt;= n-1: a = a * r; i+= 1;print(a); 모범 답안 for문을 이용한 풀이 12345678910a,r,n=input().split()A=int(a)R=int(r)N=int(n)for i in range(N-1) : A = A * Rprint(A)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"기술의 부족함과 좌절감, 뛰어난 동료 개발자들","slug":"TIL-2019-07-24","date":"2019-07-24T12:02:28.000Z","updated":"2019-08-01T14:25:21.145Z","comments":true,"path":"2019/07/24/TIL-2019-07-24/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/24/TIL-2019-07-24/","excerpt":"","text":"2019년 7월 24일 (수)기술의 부족함과 좌절감을 어떻게 극복할 것인가? Spring boot와 Spring을 공부하면서 요즘 나의 부족함에 대해 느끼는 순간들이 많다. 가끔 좌절을 하기도 하고, 기초적인 부분을 놓칠 때면 부끄러움이 밀려들 때도 있다. 나의 부족함을 느끼고 좌절하고 웅크릴 것인지 아니면 이를 계기로 한 단계 더 도약할 지는오직 나 자신에게 달려있다. 대처 방안 자주 놓치는 부분들, 이슈들은 블로그에 정리해서 올린다. 출퇴근 시간에 Spring 전자책을 읽어 전체적인 흐름을 익힌다. 뛰어난 동료 개발자들이 많다. 프론트 엔드와 백엔드 양쪽에 뛰어난 동료 개발자분들이 많아서 놀라움을 느꼈다. 세상은 넓고 뛰어난 개발자는 많다. 본받고 배우되 나와 비교하고 의기소침해지지는 말자. 대처 방안 동료와 함께 기술에 대한 지식을 나누며 함께 성장해 나가자. 내가 게을러지지 않도록 만들어주는 좋은 자극제로 삼는다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"CodeUp(코드업) 풀이 (1089번)","slug":"codeup-59","date":"2019-07-23T12:55:31.000Z","updated":"2019-07-23T13:10:07.444Z","comments":true,"path":"2019/07/23/codeup-59/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/23/codeup-59/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1089 : [기초-종합] 수 나열하기1문제 설명어떤 규칙에 따라 수를 순서대로 나열한 것을 수열이라고 한다. 예를 들어1 4 7 10 13 16 19 22 25 … 은 1부터 시작해 이전에 만든 수에 3을 더해 다음 수를 만든 수열이다. 이러한 것을 수학에서는 앞뒤 수들의 차이가 같다고 하여 등차(차이가 같다의 한문 말) 수열이라고 한다. 수열을 알게된 경곽이는 갑자기 궁금해 졌다. “그럼…. 123번째 나오는 수는 뭘까?” 경곽이는 물론 수학을 아주 잘 하지만, 프로그램을 만들어 더 큰 수도 빠르게 계산하고 싶어졌다. 시작 값(a), 등차의 값(d), 몇 번째 인지를 나타내는 정수(n)가 입력될 때 n번째 수를 출력하는 프로그램을 만들어보자. 입력시작 값(a), 등차의 값(d), 몇 번째 인지를 나타내는 정수(n)이 공백을 두고 입력된다.(모두 0 ~ 100) 출력n번째로 만들어질 수를 출력한다. 입력 예시1 3 5 출력 예시13 내 풀이123456a, d, n= input().split();a = int(a);d = int(d);n = int(n);print(a + d*(n-1)); 모범 답안12345678910a,d,n=input().split()A=int(a)D=int(d)N=int(n)for i in range(N-1) : A = A + Dprint(A)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"에러는 안뜨는데 PUT 요청으로 글 수정이 안되는 경우","slug":"spring-2019-07-23-1","date":"2019-07-23T12:21:59.000Z","updated":"2019-08-20T15:09:44.802Z","comments":true,"path":"2019/07/23/spring-2019-07-23-1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/23/spring-2019-07-23-1/","excerpt":"","text":"현상: 글 수정 기능을 위해 PUT 요청을 보내고 응답 status는 200을 받았으나글이 수정되지 않는 현상이 발생 시도 방안: intelliJ debugger를 사용하여 break point를 찍어서한줄씩 값이 제대로 넘어가는지 확인 문제 원인: request URI로 넘어온 글 번호인 boardIdx를 controller에서 구분자로 인식은 했으나service단으로 넘겨주지 않아 수정할 글이 무엇인지를 찾을 수 없어서 발생 123456// Controller 영역// 수정 전@RequestMapping(value = \"/api/board/&#123;boardIdx&#125;\", method = RequestMethod.PUT) public void updateBoard(@RequestBody BoardApi api) throws Exception &#123; boardService.updateBoard(api); &#125; 해결방안: @PathVariable(“boardIdx”) int boardIdx를updateBoard 메소드의 parameter로 api와 함께 넘겨준다. path URI로 넘어온 boardIdx값은 타입이 String인데, 이 프로젝트에서는 int타입으로 정의했기 때문에 int 타입으로 바꿔주기 위해 @PathVariable(“boardIdx”) 뒤에 int boardIdx를 적어준다. 12345678// 수정 후/// URI로 들어오는 구분자 boardIdx값을 읽어온다.@RequestMapping(value = \"/api/board/&#123;boardIdx&#125;\", method = RequestMethod.PUT) // boardIdx값의 타입을 int값으로 변경한 후, // requestBody에 들어있는 api 객체(수정할 내용 객체)와 함께 Service영역으로 넘겨준다. public void updateBoard(@PathVariable(\"boardIdx\") int boardIdx, @RequestBody BoardApi api) throws Exception &#123; boardService.updateBoard(boardIdx, api); &#125; 참고 링크 [Spring에서 @RequestParam과 @PathVariable]: https://elfinlas.github.io/2018/02/18/spring-parameter/","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Spring & Spring Boot","slug":"back-end/spring-spring-boot","permalink":"https://JihyeHwang09.github.io/categories/back-end/spring-spring-boot/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://JihyeHwang09.github.io/tags/spring/"},{"name":"Spring Boot","slug":"spring-boot","permalink":"https://JihyeHwang09.github.io/tags/spring-boot/"},{"name":"PUT","slug":"put","permalink":"https://JihyeHwang09.github.io/tags/put/"},{"name":"PathVariable annotation","slug":"pathvariable-annotation","permalink":"https://JihyeHwang09.github.io/tags/pathvariable-annotation/"}]},{"title":"NULL not allowed for column","slug":"spring-2019-07-23","date":"2019-07-23T12:11:12.000Z","updated":"2019-07-23T12:54:22.681Z","comments":true,"path":"2019/07/23/spring-2019-07-23/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/23/spring-2019-07-23/","excerpt":"","text":"문제 원인: request body로 넘어온 내용을 꺼내는 코드가 없다. 123456// 수정 전// NULL not allowed for column \"TITLE\"; SQL statement 에러가 발생한 코드@RequestMapping(value = \"/api/board/&#123;boardIdx&#125;\", method = RequestMethod.PUT) public void updateBoard(BoardApi api) throws Exception &#123; boardService.updateBoard(api); &#125; 해결 방법: requestBody로 넘어온 json 객체를 꺼내기 위해 @ReqeustBody annotation을updateBoard 메소드의 매개변수인 BoardApi api에 붙여준다. 12345// 수정 후@RequestMapping(value = \"/api/board/&#123;boardIdx&#125;\", method = RequestMethod.PUT) public void updateBoard( @RequestBody BoardApi api) throws Exception &#123; boardService.updateBoard(api); &#125;","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Spring & Spring Boot","slug":"back-end/spring-spring-boot","permalink":"https://JihyeHwang09.github.io/categories/back-end/spring-spring-boot/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://JihyeHwang09.github.io/tags/spring/"},{"name":"Spring Boot","slug":"spring-boot","permalink":"https://JihyeHwang09.github.io/tags/spring-boot/"},{"name":"NULL not allowed for column \"TITLE\"; SQL statement","slug":"null-not-allowed-for-column-title-sql-statement","permalink":"https://JihyeHwang09.github.io/tags/null-not-allowed-for-column-title-sql-statement/"},{"name":"ReqeustBody annotation","slug":"reqeustbody-annotation","permalink":"https://JihyeHwang09.github.io/tags/reqeustbody-annotation/"}]},{"title":"There is no getter for property named","slug":"spring-2019-07-22","date":"2019-07-22T12:47:47.000Z","updated":"2019-07-23T12:29:45.268Z","comments":true,"path":"2019/07/22/spring-2019-07-22/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/22/spring-2019-07-22/","excerpt":"","text":"[Error] There is no getter for property namedproperty name에 맞는 getter가 없다는 에러가 발생했다. 1234567891011121314&lt;insert id=\"insertBoard\" parameterType=\"board.model.entity.BoardEntity\"&gt; INSERT INTO T_BOARD ( TITLE, CONTENTS, CREATOR_ID ) VALUES ( #&#123;TITLE&#125;, #&#123;CONTENTS&#125;, 'ADMIN' ); &lt;/insert&gt; mapper.xml 파일에 위의 코드를 작성했더니 Error가 발생했다. 원인: MyBatis 문법 에러로,parameterType으로 넘어온 BoardEntity 객체에 있는 property명과쿼리문의 #{변수명}이 일치하지 않아서 발생한 에러이다. cf) #{변수명}는 안에 있는 변수명과 일치하는 property를 찾아서 넣어주는 역할을 한다. 해결 방법: parameterType의 property명과 #{}안의 변수명을 일치시켜준다.나의 경우에는 property명이 소문자이고, 쿼리문의 변수명은 대문자라서 에러가 발생했다.따라서, BoardEntity에 써준 그대로 #{}안에 넣도록 수정하여 에러를 해결했다.(같은 단어라도 대소문자에 따라 다르게 인식된다.) #{TITLE} -&gt; #{title}, #{CONTENTS} -&gt; #{contents}로 수정 1234567891011121314&lt;insert id=\"insertBoard\" parameterType=\"board.model.entity.BoardEntity\"&gt; INSERT INTO T_BOARD ( TITLE, CONTENTS, CREATOR_ID ) VALUES ( #&#123;title&#125;, #&#123;contents&#125;, 'ADMIN' ); &lt;/insert&gt; 참고 링크[[Mybatis] getter for property named 에러 해결방법]]: https://yamea-guide.tistory.com/162","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Spring & Spring Boot","slug":"back-end/spring-spring-boot","permalink":"https://JihyeHwang09.github.io/categories/back-end/spring-spring-boot/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://JihyeHwang09.github.io/tags/spring/"},{"name":"Spring Boot","slug":"spring-boot","permalink":"https://JihyeHwang09.github.io/tags/spring-boot/"},{"name":"MyBatis","slug":"mybatis","permalink":"https://JihyeHwang09.github.io/tags/mybatis/"},{"name":"There is no getter for property named","slug":"there-is-no-getter-for-property-named","permalink":"https://JihyeHwang09.github.io/tags/there-is-no-getter-for-property-named/"}]},{"title":"CodeUp(코드업) 풀이 (1088번)","slug":"codeup-58","date":"2019-07-22T06:23:32.000Z","updated":"2019-07-22T12:47:25.742Z","comments":true,"path":"2019/07/22/codeup-58/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/22/codeup-58/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1088 : [기초-종합] 3의 배수는 통과?문제 설명1부터 입력한 정수까지 1씩 증가시켜 출력하는 프로그램을 작성하되, 3의 배수인 경우는 출력하지 않도록 만들어보자. 예를 들면, 1 2 4 5 7 8 10 11 13 14 … 와 같이 출력하는 것이다. 입력정수 한 개를 입력받는다.(1 ~ 100) 출력1부터 입력한 정수보다 작거나 같을 때까지 1씩 증가시켜 출력하되 3의 배수는 출력하지 않는다. 입력 예시10 출력 예시1 2 4 5 7 8 10 내 풀이 while문을 이용한 풀이 123456789num = int(input());i = 1;while i &lt;= num:# 3의 배수가 아닌 경우 if i % 3 != 0: print(i, end=' '); i += 1; 모범 답안 for in range를 이용한 풀이 12345678a=input()n=int(a)for i in range(1, n+1) : if i%3==0 : continue print(i, end=' ')","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1087번)","slug":"codeup-57","date":"2019-07-21T06:23:32.000Z","updated":"2019-07-21T16:47:00.038Z","comments":true,"path":"2019/07/21/codeup-57/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/21/codeup-57/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1087 : [기초-종합] 여기까지! 이제그만~문제 설명1, 2, 3 … 을 계속 더해나갈때, 그 합이 입력한 정수보다 같거나 작을 때까지,(0 ~ 1000) 계속 합하는 프로그램을 작성해보자. 즉, 1부터 n까지 정수를 계속 합해 간다고 할 때, 어디까지 합해야 같거나 넘어서는지 알아보고자하는 문제이다. 하지만, 이번에는 그 때의 합을 출력해야 한다. 예를 들어 57을 입력하면 1+2+3+…+8+9+10=55 에 다시 11을 더해 66일 때 66이 출력되어야 한다. 입력어느 정도까지 합을 계산할 지, 정수 한개를 입력받는다. (단, 입력되는 자연수는 100 000 000이하이다.) 출력1, 2, 3, 4, 5 … 계속 더해가다가, 입력된 정수보다 커지거나 같아지는 경우, 그 때 까지의 합을 출력한다. 입력 예시57 출력 예시66 내 풀이123456789num = int(input());sum = 0;i = 1;while sum &lt;= num: sum += i; i += 1;print(sum); 모범 답안1234567891011a=input()n=int(a)s=0i=1while s&lt;n : s+=i i+=1print(s)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1086번)","slug":"codeup-56","date":"2019-07-20T06:23:32.000Z","updated":"2019-07-21T16:30:22.352Z","comments":true,"path":"2019/07/20/codeup-56/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/20/codeup-56/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1086 : [기초-정보] 그림 파일 저장용량 계산하기문제 설명이미지가 컴퓨터에 저장될 때에도 디지털 데이터화 되어 저장된다. 가장 기본적인 방법으로는 그림을 구성하는 한 점(pixel, 픽셀)의 색상을 나타내기 위해 빨강(r), 녹색(g), 파랑(b) 의 3가지의 정도값을 이용한다. 예를 들어 r, g, b 각 각 8비트(0~255 가지 가능)를 사용한다고 하면, 한 점의 색상은 3가지 r, g, b의 8비트+8비트+8비트로 총 24비트로 표현하고 총 2^24 가지의 물감(색)을 사용할 수 있는 것이다. 한편, 그러한 점이 매우 많이 모여 하나의 큰 이미지를 저장하게 되는데, 가로로 1024 개, 세로로 768개의 점들을 사용할 수 있다. 이렇게,1024 * 768 사이즈에 각 점에 대해 24비트로 저장하면 그 이미지를 저장하기 위한 저장 용량을 계산할 수 있다. 이렇게 압축하지 않고 이미지의 원래(raw) 데이터를 그대로 저장하는 대표적인 이미지 파일이 *.bmp 파일이며 비트로 그림을 구성한다고 하여 비트맵 방식 또는 래스터 방식이라고 한다. 이미지의 가로 해상도 w, 세로 해상도 h, 한 픽셀을 저장하기 위한 비트(b) 주어질 때, 압축하지 않고 저장하기 위한 저장 용량을 계산하는 프로그램을 작성해 보자. 예를 들어일반적인 1024 _ 768 사이즈(해상도)의 각점에 대해 24비트(rgb 각각 8비트씩 3개)로 저장하려면1024 _ 768 * 24 bit의 저장공간이 필요하다. 실제 그런지 확인하려면, 간단한 그림 편집 수정 프로그램을 이용해 저장해 보면 된다. **8bit(비트) = 1byte(바이트) // 8bit=1Byte1024Byte(2^10 byte) = 1KB(킬로 바이트)1024KB(2^10 KB) = 1MB(메가 바이트)1024MB(2^10 MB) = 1GB(기가 바이트)1024GB(2^10 GB) = 1TB(테라 바이트) 입력w, h, b 가 공백을 두고 입력된다.(단, w, h는 모두 정수이고 1~1024 이다. b는 40이하의 4의 배수이다.) 출력필요한 저장 공간을 MB 단위로 바꾸어 출력한다.(단, 소수점 셋째 자리에서 반올림해 둘 째 자리까지 출력하고 단위 MB를 공백을 두고 출력한다.) 입력 예시1024 768 24 출력 예시2.25 MB 내 풀이1234567w, h, b =input().split()w = int(w);h = int(h);b = int(b);print(format((w*h*b/8/1024/1024),'0.2f'), 'MB'); 모범 답안1234567a,b,c=input().split()W=int(a)H=int(b)B=int(c)print('%.2f MB' % (W*H*B/8/1024/1024))","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1085번)","slug":"codeup-55","date":"2019-07-19T06:23:32.000Z","updated":"2019-07-21T16:21:18.003Z","comments":true,"path":"2019/07/19/codeup-55/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/19/codeup-55/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1085 : [기초-종합] 소리 파일 저장용량 계산하기문제 설명소리가 컴퓨터에 저장될 때에는 디지털 데이터화 되어 저장된다. 마이크를 통해 1초에 적게는 수십번 많게는 수만번 소리의 강약을 체크해 정수값으로 바꾸고, 정수값으로 저장될 때에는 비트를 사용하는 정도에 따라 세세한 녹음 정도를 저장할 수 있고, 좌우(스테레오)로 저장하면 2배… 5.1채널이면 6배… 의 저장공간이 필요하고 녹음 시간이 길면 그 시간만큼 저장공간이 필요하다. 1초 동안 마이크로 소리강약을 체크하는 수를 h (헤르쯔, Hz 는 1초에 몇 번? 체크하는 가를 의미한다.) 한 번 체크한 결과를 저장하는 비트 b(2비트를 사용하면 0 또는 1 두가지, 16비트를 사용하면 0~255가지.. 중 비슷한 것으로 저장) 좌우 등 소리를 저장할 트랙 개수인 채널 c(모노는 1개, 스테레오는 2개의 트랙으로 저장함을 의미한다.) 녹음할 시간 s가 주어질 때, 필요한 저장 용량을 계산하는 프로그램을 작성해보자. 실제로일반적인 CD 음질(44.1KHz, 16bit, 스테레오)로 1초 동안 저장하려면44100 _ 16 _ 2 * 1 bit의 저장공간이 필요하다. 이렇게 녹음하는 방식을 PCM(Pulse Code Modulation) 방법이라고 하는데, 압축하지 않은 순수한(raw) 소리 데이터 파일은 대표적으로 *.wav 가 있다. **8bit(비트) = 1byte(바이트) // 8bit=1Byte1024Byte(2^10 byte) = 1KB(킬로 바이트)1024KB(2^10 KB) = 1MB(메가 바이트)1024MB(2^10 MB) = 1GB((기가 바이트)…. 입력h, b, c, s 가 공백을 두고 입력된다.(단, h는 48,000이하의 자연수, b는 32이하의 자연수(단, 8의배수), c는 5이하의 자연수, s는 모두 정수이이고 6,000이하의 자연수이다.) 출력필요한 저장 공간을 MB 단위로 바꾸어 출력한다.(단, 소수점 둘째 자리에서 반올림해 첫 째 자리까지 출력하고 단위 MB를 공백을 두고 출력한다.) 입력 예시44100 16 2 10 출력 예시1.7 MB 내 풀이12345678h, b, c, s =input().split()h = int(h);b = int(b);c = int(c);s = int(s);print(format((h*b*c*s/8/1024/1024),'0.1f'), 'MB'); 모범 답안12345678a,b,c,d=input().split()H=int(a)B=int(b)C=int(c)S=int(d)print('%.1f MB' % (H*B*C*S/8/1024/1024))","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1084번)","slug":"codeup-54","date":"2019-07-18T06:23:32.000Z","updated":"2019-07-21T16:08:52.264Z","comments":true,"path":"2019/07/18/codeup-54/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/18/codeup-54/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1084 : [기초-종합] 물감만들기문제 설명빨강(red), 녹색(green), 파랑(blue) 물감을 섞어 여러 가지 물감을 만들어 내려고한다. 빨강(r), 녹색(g), 파랑(b) 물감의 종류(농도에 따라 0~ n-1 까지 n가지의 농도를 만들 수 있다.)가 주어질 때, 주어진 물감들을 농도를 다르게 섞어 만들 수 있는 모든 물감의 정보(r g b)와 그 최대 개수를 계산해보자. 입력빨녹파(r, g, b) 각 물감의 종류(농도) 개수가 공백을 사이에 두고 입력된다.(0 ~ 128) 예를 들어 3 3 3 은 각 색에 대해서 0~2까지 3가지 물감이 있음을 의미한다. 출력만들 수 있는 물감의 정보를 오름차순(계단을 올라가는 순, 12345… abcde…, 가나다라마…)으로 줄을 바꿔 모두 출력하고, 마지막에 그 개수를 출력한다. 입력 예시2 2 2 출력 예시0 0 00 0 10 1 00 1 11 0 01 0 11 1 01 1 18 내 풀이12345678910111213r, g, b = input().split();r = int(r);g = int(g);b = int(b);count = 0;for i in range(r): for j in range(g): for k in range(b): print(i, j, k); count += 1;# for문을 빠져나와서 count에 누적된 값 출력print(count); 모범 답안1234567891011121314a,b,c=input().split()R=int(a)G=int(b)B=int(c)c=0for i in range(R) : for j in range(G) : for k in range(B) : c+=1 print(i, j, k)print(c)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1083번)","slug":"codeup-53","date":"2019-07-17T06:23:32.000Z","updated":"2019-07-21T15:51:17.296Z","comments":true,"path":"2019/07/17/codeup-53/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/17/codeup-53/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1083 : [기초-종합] 3 6 9 게임의 왕이 되자!문제 설명3 6 9 게임을 하던 경곽이는 3 6 9 게임에서 잦은 실수로 계속해서 벌칙을 받게 되었다. 3 6 9 게임의 왕이 되기 위한 마스터 프로그램을 작성해 보자. 입력10보다 작은 정수 한 개가 입력된다.(1 ~ 10) 출력1 부터 그 수까지 순서대로 공백을 두고 수를 출력하는데, 3 또는 6 또는 9인 경우 그 수 대신 영문 대문자 X 를 출력한다. 입력 예시9 출력 예시1 2 X 4 5 X 7 8 X 내 풀이1234567n = int(input());for i in range(1, n+1): if i % 3 == 0: print('X', end=' '); else: print(i, end=' '); 모범 답안123456789a=input()n=int(a)for i in range(1, n+1) : if i%3==0 : print('X', end=' ') else : print(i, end=' ')","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1081번)","slug":"codeup-52","date":"2019-07-16T06:23:32.000Z","updated":"2019-07-21T15:31:57.774Z","comments":true,"path":"2019/07/16/codeup-52/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/16/codeup-52/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1081 : [기초-종합] 주사위를 2개 던지면?문제 설명1부터 n까지, 1부터 m 까지 숫자가 적힌 색이 서로 다른 주사위 2개를 던졌을 때, 나올 수 있는 모든 경우를 출력해보자. 입력서로 다른 주사위의 면의 개수 n, m이 공백을 두고 입력된다. (단, n, m은 10이하의 자연수) 출력나올 수 있는 주사위의 숫자가 한 세트씩 줄을 바꿔 모두 출력된다. 첫 수는 n, 두번째 수는 m으로 고정해 출력하도록 한다. 입력 예시2 3 출력 예시1 11 21 32 12 22 3 내 풀이1234567n, m = input().split(' ');n = int(n);m = int(m);for i in range(1, n+1): for j in range(1, m+1): print(i, j); 모범 답안12345678a,b=input().split()n=int(a)m=int(b)for i in range(1, n+1) : for j in range(1, m+1) : print(i, j)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1080번)","slug":"codeup-51","date":"2019-07-15T06:23:32.000Z","updated":"2019-07-21T14:13:28.583Z","comments":true,"path":"2019/07/15/codeup-51/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/15/codeup-51/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1080 : [기초-종합] 언제까지 더해야할까?문제 설명1, 2, 3 … 을 계속 더해나갈때, 그 합이 입력한 정수보다 크거나 같을 때까지,(0 ~ 1000) 계속 합하는 프로그램을 작성해보자. 즉, 1부터 n까지 정수를 계속 합해 간다고 할 때, 어디까지 합해야 같거나 넘어서는지 알아보고자하는 문제이다. 입력어느 정도까지 합을 계산할 지, 정수 한개를 입력받는다. 출력1, 2, 3, 4, 5 … 계속 더해가다가, 입력된 정수보다 커지거나 같아지는 경우, 마지막에 더해진 정수를 출력한다. 입력 예시55 출력 예시10 내 풀이1234567891011num = int(input());i = 1;sum = 0;while True: sum += i; if sum &gt;= num: print(i); break; i += 1; 모범 답안1234567891011a=input()n=int(a)i=0s=0while s&lt;n : i+=1 s+=iprint(i)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1079번)","slug":"codeup-50","date":"2019-07-14T06:23:32.000Z","updated":"2019-07-21T13:58:17.978Z","comments":true,"path":"2019/07/14/codeup-50/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/14/codeup-50/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1079 : [기초-종합] 원하는 문자 입력할 때까지 반복 출력하기문제 설명영문자 q 가 입력될 때까지 계속 반복하는 프로그램을 작성해보자. 입력영문자가 한 개씩 계속 입력된다. 출력영문자 q가 입력될 때까지 입력한 문자를 줄을 바꿔 계속 출력한다. 입력 예시x b k d l q g a c 출력 예시xbkdlq 내 풀이123456alpha =input().split();for i in alpha: print(i); if i =='q': break; 모범 답안123456a=input().split()for c in a : print(c) if c=='q' : break","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1078번)","slug":"codeup-49","date":"2019-07-13T06:23:32.000Z","updated":"2019-07-21T06:51:39.304Z","comments":true,"path":"2019/07/13/codeup-49/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/13/codeup-49/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1078 : [기초-종합] 짝수 합 구하기문제 설명정수 한 개를 입력받아 1 부터 그 수까지 짝수의 합을 구해보자. 입력정수 한 개가 입력된다.(0 ~ 100) 출력1부터 입력된 수까지 짝수의 합을 출력한다. 입력 예시5 출력 예시6 내 풀이12345678910num = int(input());i = 1;sum = 0;for i in range(i, num+1) : if i % 2 == 0: sum += i;print(sum); 모범 답안12345678910a=input()n=int(a)s=0for i in range(1, n+1) : if(i%2==0) : s+=iprint(s)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1077번)","slug":"codeup-48","date":"2019-07-12T06:23:32.000Z","updated":"2019-07-21T06:39:54.114Z","comments":true,"path":"2019/07/12/codeup-48/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/12/codeup-48/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1077 : [기초-반복실행구조] 정수 한 개 입력받아 그 수까지 출력하기문제 설명정수 한 개를 입력받아 0부터 그 수까지 순서대로 출력해보자.(0 ~ 100) 입력정수 한 개가 입력된다.(0 ~ 100) 출력0부터 그 수까지 줄을 바꿔 한 줄씩 출력한다. 입력 예시4 출력 예시01234 내 풀이12345678num = int(input());i = 0;for i in range(i, num+1) : print(i);# for i in range(시작값, 끝값+1):# 반복문 모범 답안123456a=input()n=int(a)for i in range(n+1): print(i)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1076번)","slug":"codeup-47","date":"2019-07-11T13:22:51.000Z","updated":"2019-07-21T06:22:23.848Z","comments":true,"path":"2019/07/11/codeup-47/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/11/codeup-47/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1076 : [기초-반복실행구조] 문자 한 개 입력받아 알파벳 출력하기문제 설명영문자 한 개가 입력되었을 때 그 문자까지의 알파벳을 순서대로 출력해보자.(a ~ z) 입력영문자 한 개가 입력된다.(a ~ z) 출력a부터 입력한 문자까지 순서대로 공백을 두고 출력된다. 입력 예시f 출력 예시a b c d e f 내 풀이12345678x = input();# 아스키 코드: 97 ~ 122num = ord(x);start = 97;while start &lt;= num: print(chr(start), end=' '); start += 1; 아스키 코드로 변경하면 숫자값이므로 조건문의 연산을 수행할 수 있게 된다. a의 아스키 코드값인 97부터 사용자가 입력한 값까지 출력하도록 한다. while문을 순회하면서 1번씩 출력하는데,공백을 두고 같은 줄에 출력하기 위해 end=’ ‘을 추가한다. 모범 답안12345678c=input()n=ord(c)i=ord('a')while i&lt;=n : print(chr(i), end=' ') i+=1","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1075번)","slug":"codeup-46","date":"2019-07-10T13:22:51.000Z","updated":"2019-07-10T14:17:49.015Z","comments":true,"path":"2019/07/10/codeup-46/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/10/codeup-46/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1075 : [기초-반복실행구조] 정수 한 개 입력받아 카운트다운 출력하기2문제 설명정수 한 개가 입력되었을 때 카운트다운을 출력해보자.(1 ~ 100) 입력정수 한 개가 입력된다.(1 ~ 100) 출력1만큼 씩 줄여 한 줄에 하나씩 1이 될 때까지 출력한다. 입력 예시5 출력 예시43210 내 풀이12345num = int(input());while num &gt; 0: num-= 1; print(num); 입력한 숫자를 바로 출력하지 않고, 1만큼 줄인 후 출력하기 시작해야 하므로 1num-=1; 이 화면에 출력하는 코드 1print(num); 보다 먼저(위에) 와야 한다. 모범 답안1234567a=input()n=int(a)while n&gt;0 : n-=1 print(n)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"}]},{"title":"CodeUp(코드업) 풀이 (1074번)","slug":"codeup-45","date":"2019-07-08T15:00:53.000Z","updated":"2019-07-10T14:18:45.681Z","comments":true,"path":"2019/07/09/codeup-45/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/09/codeup-45/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1074 : [기초-반복실행구조] 정수 한 개 입력받아 카운트다운 출력하기1문제 설명정수 한 개가 입력되었을 때 카운트다운을 출력해보자.(1 ~ 100) 입력정수 한 개가 입력된다.(1 ~ 100) 출력1만큼 씩 줄여 한 줄에 하나씩 1이 될 때까지 출력한다. 입력 예시5 출력 예시54321 내 풀이12345num = int(input());while num &gt; 0: print(num); num-= 1; 모범 답안1234567a=input()n=int(a)while n&gt;=1 : print(n) n=n-1","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"},{"name":"1074","slug":"1074","permalink":"https://JihyeHwang09.github.io/tags/1074/"}]},{"title":"CodeUp(코드업) 풀이 (1073번)","slug":"codeup-44","date":"2019-07-07T17:18:53.000Z","updated":"2019-07-07T17:43:01.303Z","comments":true,"path":"2019/07/08/codeup-44/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/08/codeup-44/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1073 : [기초-반복실행구조] 0 입력될 때까지 무한 출력하기2문제 설명정수가 순서대로 입력된다.(-2147483648 ~ 2147483647, 단 개수는 알 수 없다.) 0이 아니면 입력된 정수를 출력하고 0이 입력되면 출력을 중단해보자. 입력정수가 순서대로 입력된다.(-2147483648 ~ 2147483647, 단 개수는 알 수 없다.) 출력입력된 정수를 줄을 바꿔 하나씩 출력하는데, 0이 입력되면 0을 출력하고 종료한다. 입력 예시7 4 2 3 0 1 5 6 9 10 8 출력 예시74230 내 풀이123456789list = input().split();i = 0;num = int(list[i]);while num != 0: print(num); i+= 1; num = int(list[i]);print(0); 모범 답안123456789a=input().split()i=0x=int(a[i])while x!=0 : print(x) i=i+1 x=int(a[i])print(0)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"},{"name":"1073","slug":"1073","permalink":"https://JihyeHwang09.github.io/tags/1073/"}]},{"title":"CodeUp(코드업) 풀이 (1072번)","slug":"codeup-43","date":"2019-07-06T15:44:46.000Z","updated":"2019-07-06T16:03:01.177Z","comments":true,"path":"2019/07/07/codeup-43/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/07/codeup-43/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1072 : [기초-반복실행구조] 정수 입력받아 계속 출력하기문제 설명n개의 정수가 순서대로 입력된다.(-2147483648 ~ 2147483647, 단 n의 최대 개수는 알 수 없다.) n개의 입력된 정수를 순서대로 출력해보자. 입력첫 줄에 정수의 개수 n이 입력되고,두번째 줄에 n개의 정수가 공백을 두고 입력된다.(-2147483648 ~ 2147483647, 단 n의 최대 개수는 알 수 없다.) 출력n개의 정수가 한 개씩 줄을 바꿔 출력된다. 입력 예시51 2 3 4 5 출력 예시12345 내 풀이 while문을 이용한 풀이 1234567count = int(input());list = input().split();i = 0;while i &lt; count: print(list[i]); i+= 1; 모범 답안 for ~ in문을 이용한 풀이 1234n = int(input())a = input().split()for x in a: print(x)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"},{"name":"1072","slug":"1072","permalink":"https://JihyeHwang09.github.io/tags/1072/"}]},{"title":"CodeUp(코드업) 풀이 (1071번)","slug":"codeup-42","date":"2019-07-06T15:29:27.000Z","updated":"2019-07-07T17:26:28.166Z","comments":true,"path":"2019/07/07/codeup-42/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/07/codeup-42/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1071 : [기초-반복실행구조] 0 입력될 때까지 무한 출력하기1 해문제 설명정수가 순서대로 입력된다.(−2147483648 ~ 2147483647, 단 개수는 알 수 없다.) 0이 아니면 입력된 정수를 출력하고 0이 입력되면 출력을 중단해보자. 입력정수가 순서대로 입력된다.(−2147483648 ~ 2147483647, 단 개수는 알 수 없다.) 출력입력된 정수를 줄을 바꿔 하나씩 출력하는데, 0이 입력되면 0을 출력하고 종료한다. 입력 예시7 4 2 3 0 1 5 6 9 10 82 출력 예시74230 내 풀이123456list = input().split();for x in list: print(x); if int(x) == 0: break; 모범 답안123456a = input().split()for x in a: print(x) if int(x)==0: break","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"},{"name":"1071","slug":"1071","permalink":"https://JihyeHwang09.github.io/tags/1071/"}]},{"title":"CodeUp(코드업) 풀이 (1070번)","slug":"codeup-41","date":"2019-07-05T14:29:27.000Z","updated":"2019-07-06T15:15:07.739Z","comments":true,"path":"2019/07/05/codeup-41/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/05/codeup-41/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1070 : [기초-조건/선택실행구조] 달 입력 받아 계절 출력하기문제 설명월이 입력될 때 계절이 출력되도록 해보자. 예월 : 계절12, 1, 2 : winter3, 4, 5 : spring6, 7, 8 : summer9, 10, 11 : fall 입력월을 의미하는 한 개의 정수가 입력된다.(1 ~ 12), B, C, D 등의 문자가 입력된다.) 출력계절을 출력한다. 입력 예시12 출력 예시winter 내 풀이 사전(Dictionary)을 이용한 풀이 123456month = int(input());def season(mon): print(&#123;12: 'winter', 1: 'winter', 2: 'winter', 3: 'spring', 4: 'spring', 5: 'spring', 6: 'summer', 7: 'summer', 8: 'summer', 9: 'fall', 10: 'fall', 11: 'fall'&#125;.get(mon, -1));season(month); 모범 답안 if ~ elif문을 이용한 풀이 123456789101112a=input()x=int(a)if x==12 or x==1 or x==2 : print(\"winter\")elif x==3 or x==4 or x==5 : print(\"spring\")elif x==6 or x==7 or x==8 : print(\"summer\")elif x==9 or x==10 or x==11 : print(\"fall\")","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"파이썬","slug":"파이썬","permalink":"https://JihyeHwang09.github.io/tags/파이썬/"},{"name":"1070","slug":"1070","permalink":"https://JihyeHwang09.github.io/tags/1070/"}]},{"title":"CodeUp(코드업) 풀이 (1069번)","slug":"codeup-40","date":"2019-07-04T14:54:17.000Z","updated":"2019-07-06T14:47:10.309Z","comments":true,"path":"2019/07/04/codeup-40/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/04/codeup-40/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1069 : [기초-조건/선택실행구조] 평가 입력받아 다르게 출력하기문제 설명평가(A, B, C, D, …)를 문자로 입력 받아 내용을 다르게 출력해보자. 평가내용평가 : 내용D : slowly~C : run!B : good!!A : best!!!나머지문자들 : what? 입력영문자 한 개가 입력된다.(A, B, C, D 등의 문자가 입력된다.) 출력평가내용에 따라 다른 내용이 출력된다. 입력 예시A 출력 예시best!!! 내 풀이 사전(Dictionary)을 이용한 풀이 123456x= input();def switch(x): print(&#123;'A': 'best!!!', 'B': 'good!!', 'C': 'run!', 'D': 'slowly~'&#125;.get(x, 'what?'));switch(x); 파이썬에는 switch/case문이 없다. 사전(Dictionary)을 이용하여 switch 함수를 만들어 주었다. 모범 답안 if ~ elif문을 이용한 풀이 123456789101112a=input()if a==\"D\" : print(\"slowly~\")elif a==\"C\" : print(\"run!\")elif a==\"B\" : print(\"good!!\")elif a==\"A\" : print(\"best!!!\")else : print(\"what?\")","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1069","slug":"1069","permalink":"https://JihyeHwang09.github.io/tags/1069/"}]},{"title":"CodeUp(코드업) 풀이 (1068번)","slug":"codeup-39","date":"2019-07-03T12:52:14.000Z","updated":"2019-07-06T14:47:05.562Z","comments":true,"path":"2019/07/03/codeup-39/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/03/codeup-39/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1068 : [기초-조건/선택실행구조] 정수 한 개 입력받아 평가 출력하기문제 설명점수(정수)를 입력받아 평가를 출력해보자.(0 ~ 100) 평가기준점수범위 : 평가90 ~ 100 : A70 ~ 89 : B40 ~ 69 : C0 ~ 39 : D 로 평가되어야 한다. 입력정수 한 개가 입력된다.(0 ~ 100) 출력평가 기준에 따라, 평가가 문자로 출력된다. 입력 예시90 출력 예시A 내 풀이1234567891011121314151617a = input();num = int(a);def eval(num): if num &gt;= 0 and num &lt;= 100: if num &gt;= 90: print('A'); elif num &gt;= 70: # elif num &gt;= 70 and num &lt; 90: # 90 미만일 경우에만 이 if문을 타게 되므로 # num &lt; 90 조건을 넣지 않아도 된다. print('B'); elif num &gt;= 40: print('C'); else: print('D');eval(num); 모범 답안123456789101112a=input()x=int(a)if x&gt;=90 : print('A')elif x&gt;=70 : print('B')elif x&gt;=40 : print('C')else : print('D')","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1068","slug":"1068","permalink":"https://JihyeHwang09.github.io/tags/1068/"}]},{"title":"CodeUp(코드업) 풀이 (1067번)","slug":"codeup-38","date":"2019-07-02T12:52:14.000Z","updated":"2019-07-06T14:46:56.230Z","comments":true,"path":"2019/07/02/codeup-38/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/02/codeup-38/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1067 : [기초-조건/선택실행구조] 정수 한 개 입력받아 분석하기문제 설명정수 한 개가 입력되었을 때, minus(음)/plus(양)even(짝)/odd(홀)을 출력해보자. 입력정수 한 개가 입력된다.(-2147483648 ~ 2147483647, 단 0은 입력되지 않는다.) 출력입력된 정수에 대해첫 줄에 minus(음) 나 plus(양) 를 출력하고,두번째 줄에 odd(홀) 나 even(짝) 을 출력한다. 입력 예시-2147483648 출력 예시minuseven 내 풀이12345678910111213141516a = input();num = int(a);def minusPlus(num): if num &lt; 0: print(\"minus\"); elif num &gt; 0: print(\"plus\");def evenOdd(num): if num%2 == 0 : print(\"even\"); else : print(\"odd\");minusPlus(num);evenOdd(num); 양수와 음수를 판별해주는 함수 minusPlus와 짝수와 홀수를 판별해주는 함수 evenOdd를 각각 만든 뒤, 호출하여 화면에 해당 문자열을 출력하게 만들었다. 모범 답안12345678910111213a=input()x=int(a)if x&gt;0 : print(\"plus\")elif x&lt;0 : print(\"minus\")if x%2==0 : print(\"even\")else : print(\"odd\")","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1067","slug":"1067","permalink":"https://JihyeHwang09.github.io/tags/1067/"}]},{"title":"CodeUp(코드업) 풀이 (1066번)","slug":"codeup-37","date":"2019-07-01T14:46:21.000Z","updated":"2019-07-06T14:46:47.369Z","comments":true,"path":"2019/07/01/codeup-37/","link":"","permalink":"https://JihyeHwang09.github.io/2019/07/01/codeup-37/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1066 : [기초-조건/선택실행구조] 정수 세 개 입력받아 짝/홀 출력하기문제 설명세 정수 a, b, c가 입력되었을 때, 짝 even(짝)/odd(홀)을 출력해보자. 입력세 정수 a, b, c 가 공백을 두고 입력된다.(0 ~ 2147483647) 출력순서대로 even(짝)/odd(홀)을 줄을 바꿔 출력한다. 입력 예시1 2 8 출력 예시oddeveneven 내 풀이1234567891011121314a, b, c = input().split();x = int(a);y = int(b);z = int(c);def evenOdd(num): if num%2 == 0 : print(\"even\"); else : print(\"odd\");evenOdd(x);evenOdd(y);evenOdd(z); 홀수와 짝수를 판별하는 함수 evenOdd를 만들어서 출력해준다. 모범 답안123456789101112131415161718a,b,c=input().split()x=int(a)y=int(b)z=int(c)if x%2==0 : print(\"even\")else : print(\"odd\")if y%2==0 : print(\"even\")else : print(\"odd\")if z%2==0 : print(\"even\")else : print(\"odd\")","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1066","slug":"1066","permalink":"https://JihyeHwang09.github.io/tags/1066/"}]},{"title":"CodeUp(코드업) 풀이 (1063번)","slug":"codeup-36","date":"2019-06-30T03:47:32.000Z","updated":"2019-07-06T14:46:38.940Z","comments":true,"path":"2019/06/30/codeup-36/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/30/codeup-36/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1063 : [기초-삼항연산] 두 정수 입력받아 큰 수 출력하기문제 설명입력된 두 정수 a, b 중 큰 값을 출력하는 프로그램을 작성해보자.(단, 조건문을 사용하지 않고 3항 연산자 ? 를 사용한다.) 입력두 정수가 공백을 두고 입력된다.(-2147483648 ~ 2147483647) 출력큰 값이 10진수로 출력된다. 입력 예시123 456 출력 예시456 내 풀이1234567try: a, b = input().split(); x = int(a); y = int(b); print(x if x&gt;y else y);except Exception as e: print(e); 파이썬에서 삼항연산자는 if와 else를 사용해서 나타낸다. x가 y보다 클 때 x값을 출력하고 아니면 y를 출력한다는 의미이다. 모범 답안1234a,b=input().split()x=int(a)y=int(b)print(x if x&gt;y else y)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1063","slug":"1063","permalink":"https://JihyeHwang09.github.io/tags/1063/"}]},{"title":"CodeUp(코드업) 풀이 (1061번)","slug":"codeup-35","date":"2019-06-29T13:58:30.000Z","updated":"2019-07-06T14:46:30.233Z","comments":true,"path":"2019/06/29/codeup-35/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/29/codeup-35/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1061 : [기초-비트단위논리연산] 비트단위로 xor 하여 출력하기문제 설명입력 된 정수 두 개를 비트단위로 xor 연산한 후 그 결과를 정수로 출력해보자. 입력두 개의 정수가 공백을 두고 입력된다.(-2147483648 ~ 2147483647) 출력두 정수를 비트단위로 xor 계산을 수행한 결과가 10진수로 출력된다. 입력 예시3 5 출력 예시6 내 풀이1234567try: a, b = input().split(); x = int(a); y = int(b); print(x^y);except Exception as e: print(e); 모범 답안123456a,b=input().split()x=int(a)y=int(b)print(x^y)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1061","slug":"1061","permalink":"https://JihyeHwang09.github.io/tags/1061/"}]},{"title":"CodeUp(코드업) 풀이 (1060번)","slug":"codeup-34","date":"2019-06-27T15:18:54.000Z","updated":"2019-07-06T14:46:24.346Z","comments":true,"path":"2019/06/28/codeup-34/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/28/codeup-34/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1060 : [기초-비트단위논리연산] 비트단위로 and 하여 출력하기문제 설명입력 된 정수 두 개를 비트단위로 and 연산한 후 그 결과를 정수로 출력해보자. 입력두 개의 정수가 공백을 두고 입력된다.(-2147483648 ~ 2147483647) 출력두 정수를 비트단위로 and 계산을 수행한 결과가 10진수로 출력된다. 입력 예시3 5 출력 예시1 내 풀이1234567try: a, b = input().split(); x = int(a); y = int(b); print(x &amp; y);except Exception as e: print(e); 모범 답안1234a,b=input().split()x=int(a)y=int(b)print(x&amp;y)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1060","slug":"1060","permalink":"https://JihyeHwang09.github.io/tags/1060/"}]},{"title":"CodeUp(코드업) 풀이 (1059번)","slug":"codeup-33","date":"2019-06-27T14:22:40.000Z","updated":"2019-07-06T14:46:14.472Z","comments":true,"path":"2019/06/27/codeup-33/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/27/codeup-33/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1059 : [기초-비트단위논리연산] 비트단위로 바꿔 출력하기문제 설명입력 된 정수를 비트단위로 참/거짓을 바꾼 후 정수로 출력해보자. 입력정수 1개가 입력된다.(-2147483648 ~ +2147483647) 출력비트 단위로 1-&gt;0, 0-&gt;1로 바꾼후 그 값을 10진수로 출력한다. 입력 예시2 출력 예시-3 내 풀이12345try: num = int(input()); print(~(num));except Exception as e: print(e); 모범 답안123a=input()n=int(a)print(~n)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1059","slug":"1059","permalink":"https://JihyeHwang09.github.io/tags/1059/"}]},{"title":"CodeUp(코드업) 풀이 (1058번)","slug":"codeup-32","date":"2019-06-25T15:19:06.000Z","updated":"2019-07-06T14:46:09.567Z","comments":true,"path":"2019/06/26/codeup-32/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/26/codeup-32/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1058 : [기초-논리연산] 둘 다 거짓일 경우만 참 출력하기문제 설명두 가지의 참(1) 또는 거짓(0)이 입력될 때, 모두 거짓일 때에만 참이 계산되는 프로그램을 작성해보자. 입력1 또는 0의 값만 가지는 2개의 정수가 공백을 두고 입력된다. 출력둘 다 거짓일 경우에만 1을 출력하고 이외의 경우에는 0을 출력한다. 입력 예시0 1 출력 예시0 내 풀이12345678try: a, b = input().split(); x = int(a); y = int(b); print(int(not x and not y));except Exception as e: print(e); 모범 답안123456789a,b=input().split()x=int(a)y=int(b)b1=bool(x)b2=bool(y)z=int((not b1) and (not b2))print(z)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1058","slug":"1058","permalink":"https://JihyeHwang09.github.io/tags/1058/"}]},{"title":"CodeUp(코드업) 풀이 (1057번)","slug":"codeup-31","date":"2019-06-24T15:00:20.000Z","updated":"2019-07-06T14:46:00.677Z","comments":true,"path":"2019/06/25/codeup-31/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/25/codeup-31/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1057 : [기초-논리연산] 참/거짓이 서로 같을 때에만 참 출력하기문제 설명두 가지의 참(1) 또는 거짓(0)이 입력될 때, 참/거짓이 서로 같을 때에만 참이 계산되는 프로그램을 작성해보자. 입력1 또는 0의 값만 가지는 2개의 정수가 공백을 두고 입력된다. 출력참/거짓이 서로 같을 때에만 1을 출력하고 이외의 경우에는 0을 출력한다. 입력 예시0 0 출력 예시1 내 풀이12345678try: a, b = input().split(); x = int(a); y = int(b); print(int(not(x^y)));except Exception as e: print(e); 참/거짓이 서로 다를 때만 1을 출력하는 xor 연산과 반대이므로 (x^y)를 논리 상태를 반전시켜주는 not으로 감싸준다. 모범 답안12345678a,b=input().split()x=int(a)y=int(b)b1=bool(x)b2=bool(y)z=int(b1 == b2)print(z)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1057","slug":"1057","permalink":"https://JihyeHwang09.github.io/tags/1057/"}]},{"title":"CodeUp(코드업) 풀이 (1056번)","slug":"codeup-30","date":"2019-06-24T14:56:20.000Z","updated":"2019-07-06T14:45:55.657Z","comments":true,"path":"2019/06/24/codeup-30/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/24/codeup-30/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1056 : [기초-논리연산] 참/거짓이 서로 다를 때에만 참 출력하기문제 설명두 가지의 참(1) 또는 거짓(0)이 입력될 때, 참/거짓이 서로 다를 때에만 참이 계산되는 프로그램을 작성해보자. 이러한 논리 연산을 XOR(exclusive or, 배타적 논리합)연산이라고도 부른다. 집합의 의미로는 합집합에서 교집합을 뺀 것을 의미한다. 모두 같은 의미이다. 입력1 또는 0의 값만 가지는 2개의 정수가 공백을 두고 입력된다. 출력참/거짓이 서로 다를 때에만 1을 출력하고 이외의 경우에는 0을 출력한다. 입력 예시1 1 출력 예시0 내 풀이12345678try: a, b = input().split(); x = int(a); y = int(b); print(x^y);except Exception as e: print(e); 둘 중 하나만 참일 때 True를 출력하는 비트 연산자 ^를 사용해서 출력한다. 모범 답안12345678910a,b=input().split()x=int(a)y=int(b)b1=bool(x)b2=bool(y)z=int((b1==True and b2==False) or (b1==False and b2==True))print(z)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1056","slug":"1056","permalink":"https://JihyeHwang09.github.io/tags/1056/"}]},{"title":"CodeUp(코드업) 풀이 (1054번)","slug":"codeup-29","date":"2019-06-22T15:00:41.000Z","updated":"2020-03-03T14:04:24.540Z","comments":true,"path":"2019/06/23/codeup-29/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/23/codeup-29/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1054 : [기초-논리연산] 둘 다 참일 경우만 참 출력하기문제 설명두 가지의 참(1) 또는 거짓(0)이 입력될 때, 모두 참일 때에만 참이 계산되는 프로그램을 작성해보자. 입력1 또는 0의 값만 가지는 2개의 정수가 공백을 두고 입력된다. 출력둘 다 참(1)일 경우에만 1을 출력하고 이외의 경우에는 0을 출력한다. 입력 예시1 1 출력 예시1 내 풀이12345678910try: a, b = input().split(); a = int(a); b = int(b); if a == 1 and b == 1: print(1); else: print(0);except Exception as e: print(e); 모범 답안123456789a,b=input().split()x=int(a)y=int(b)b1=bool(x)b2=bool(y)z=int(b1 and b2)print(z)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1054","slug":"1054","permalink":"https://JihyeHwang09.github.io/tags/1054/"}]},{"title":"CodeUp(코드업) 풀이 (1053번)","slug":"codeup-28","date":"2019-06-21T15:00:41.000Z","updated":"2019-07-06T14:45:45.947Z","comments":true,"path":"2019/06/22/codeup-28/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/22/codeup-28/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. ###1053 : [기초-논리연산] 참 거짓 바꾸기 문제 설명1(true, 참) 또는 0(false, 거짓) 이 입력되었을 때 반대로 출력하는 프로그램을 작성해보자. 입력정수 1개가 입력된다.(단, 0 또는 1 만 입력된다.) 출력입력된 값이 0이면 1, 1이면 0을 출력한다. 입력 예시1 출력 예시0 내 풀이123456789try: num = int(input()); if num == 0 or num == 1: if num == 0: print(1); else: print(0);except Exception as e: print(e); 모범 답안1234567a=input()x=int(a)b=bool(x)x=int(not b)print(x) 1b=bool(x) 파이썬 내장 함수인 bool을 이용하면, 자료형의 참과 거짓을 식별할 수 있다. 1x=int(not b) not은 논리 NOT 연산으로서, 논리 상태를 반전시킨다.변수 b에 true가 담여있으면 false, fasle면 true로 반전된다.이를 int()를 이용해 정수로 변환하여 출력해주었다. bool 연산 예시12&gt;&gt;&gt; bool('apple')# True ‘apple’은 빈 문자열이 아니므로 bool 연산의 결과로 bool 자료형인 True를 반환한다. 12&gt;&gt;&gt; bool('')# False 빈 문자열은 bool 연산의 결과로 False를 반환한다. 1234&gt;&gt;&gt; bool(3)# True&gt;&gt;&gt; bool(0)# False 숫자 3은 0이 아니므로 bool 연산의 결과로 True를,숫자 0은 False를 반환한다. 참고 링크 [점프 투 파이썬- 불 자료형]: https://wikidocs.net/17","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1053","slug":"1053","permalink":"https://JihyeHwang09.github.io/tags/1053/"}]},{"title":"CodeUp(코드업) 풀이 (1052번)","slug":"codeup-27","date":"2019-06-21T02:46:41.000Z","updated":"2019-07-06T14:45:38.165Z","comments":true,"path":"2019/06/21/codeup-27/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/21/codeup-27/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1052 : [기초-비교연산] 두 정수 입력받아 비교하기4문제 설명두 정수(a, b)를 입력받아 a와 b가 서로 다르면 1, a와 b가 같으면 0 을 출력하는 프로그램을 작성해보자. 입력두 정수 a, b가 공백을 두고 입력된다.(-2147483648 ~ 2147483647) 출력a와 b가 다른 경우 1, 그렇지 않은 경우 0을 출력한다. 입력 예시0 1 출력 예시1 내 풀이12345678910try: a, b = input().split(); a = int(a); b = int(b); if a != b: print(1); else: print(0);except Exception as e: print(e); 모범 답안1234567a,b=input().split()x=int(a)y=int(b)z=int(a!=b)print(z)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1052","slug":"1052","permalink":"https://JihyeHwang09.github.io/tags/1052/"}]},{"title":"CodeUp(코드업) 풀이 (1051번)","slug":"codeup-26","date":"2019-06-20T02:46:41.000Z","updated":"2019-07-06T14:45:29.369Z","comments":true,"path":"2019/06/20/codeup-26/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/20/codeup-26/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1051 : [기초-비교연산] 두 정수 입력받아 비교하기3문제 설명두 정수(a, b)를 입력받아,b가 a보다 크거나 같으면 1, b가 a보다 작으면 0을 출력하는 프로그램을 작성해보자. 입력두 정수 a, b가 공백을 두고 입력된다. (-2147483648 ~ 2147483647) 출력b가 a보다 크거나 같은 경우 1, 그렇지 않은 경우 0을 출력한다. 입력 예시0 -1 출력 예시0 내 풀이12345678910try: a, b = input().split(); a = int(a); b = int(b); if b &gt; a or b == a: print(1); else: print(0);except Exception as e: print(e); 모범 답안1234567a,b=input().split()x=int(a)y=int(b)z=int(x&lt;=y)print(z)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1051","slug":"1051","permalink":"https://JihyeHwang09.github.io/tags/1051/"}]},{"title":"CodeUp(코드업) 풀이 (1050번)","slug":"codeup-25","date":"2019-06-19T11:52:18.000Z","updated":"2019-07-06T14:45:14.405Z","comments":true,"path":"2019/06/19/codeup-25/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/19/codeup-25/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1050 : [기초-비교연산] 두 정수 입력받아 비교하기2문제 설명두 정수(a, b)를 입력받아 a와 b가 같으면 1, a가 b와 같지 않으면 0을 출력하는 프로그램을 작성해보자. 입력두 정수 a, b가 공백을 두고 입력된다.(-2147483648 ~ 2147483647) 출력a와 b의 값이 같은 경우 1, 그렇지 않은 경우 0을 출력한다. 입력 예시0 0 출력 예시1 내 풀이12345678910try: a, b = input().split(); a = int(a); b = int(b); if a == b: print(1); else: print(0);except Exception as e: print(e); 조건문인 if ~ else를 사용하여 a == b일 경우 1을 출력하고,이 외의 경우에는 0을 출력하게 했다. 모범 답안1234567a,b=input().split()x=int(a)y=int(b)z=int(x==y)print(z) 모범 답안의 경우 조건문인 if ~ else를 사용하지 않고,비교연산자를 통해 x == y 계산을 수행한 후, 그 결과로 1(참) 또는 0(거짓)이 담기도록 했다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1050","slug":"1050","permalink":"https://JihyeHwang09.github.io/tags/1050/"}]},{"title":"CodeUp(코드업) 풀이 (1049번)","slug":"codeup-24","date":"2019-06-18T01:57:16.000Z","updated":"2019-07-06T14:45:04.620Z","comments":true,"path":"2019/06/18/codeup-24/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/18/codeup-24/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1049 : [기초-비교연산] 두 정수 입력받아 비교하기1문제 설명두 정수(a, b)를 입력받아 a가 b보다 크면 1, a가 b와 같거나 b가 a보다 크다면 0 을 출력하는 프로그램을 작성해보자. 입력두 정수 a, b가 공백을 두고 입력된다.(-2147483648 ~ 2147483647) 출력a가 b보다 큰 경우 1을, 그렇지 않은 경우 0을 출력한다. 입력 예시9 1 출력 예시1 내 풀이12345678910try: a, b = input().split(); a = int(a); b = int(b); if a &gt; b: print(1); elif a == b or b &gt; a: print(0);except Exception as e: print(e); if, elif문을 이용하여 경우에 따라 print할 출력값을 다르게 했다. 모범 답안1234567a,b=input().split()x=int(a)y=int(b)z=int(x&gt;y)print(z) 12z=int(x&gt;y)print(z) 모범 답안의 경우,변수 하나를 만들어서 x &gt; y일 경우 1, 그 외의 경우에는 0이 z에 담기도록 했다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1049","slug":"1049","permalink":"https://JihyeHwang09.github.io/tags/1049/"}]},{"title":"CodeUp(코드업) 풀이 (1048번)","slug":"codeup-23","date":"2019-06-17T13:00:28.000Z","updated":"2019-07-06T14:44:56.563Z","comments":true,"path":"2019/06/17/codeup-23/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/17/codeup-23/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1048 : [기초-비트시프트연산] 한 번에 2의 n승으로 출력하기문제 설명정수 두 개(a, b)를 입력받아(0 &lt;= a, b &lt;= 10) a를 2b 배를 출력하는 프로그램을 작성해보자. 입력정수 두 개가 공백을 두고 입력된다.(0 &lt;= a , b &lt;= 10) 출력a 를 2b 배 만큼 곱해 출력한다. 입력 예시1 3 출력 예시8 내 풀이12345678try: a, b = input().split(); a = int(a); b = int(b); if a &gt;= 0 and b &lt;= 10: print(a &lt;&lt; b);except Exception as e: print(e); 1 3이 입력되면, 1을 2^3하여(8배하여) 출력한다. 1에 2^3을 해주기 위해서 왼쪽 비트시프트(&lt;&lt;)를 이용하여 3만큼 움직여 준다. 모범 답안123456a,b=input().split()x=int(a)y=int(b)print(x&lt;&lt;y)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1048","slug":"1048","permalink":"https://JihyeHwang09.github.io/tags/1048/"}]},{"title":"CodeUp(코드업) 풀이 (1047번)","slug":"codeup-22","date":"2019-06-16T07:03:41.000Z","updated":"2019-07-06T14:44:49.518Z","comments":true,"path":"2019/06/16/codeup-22/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/16/codeup-22/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1047 : [기초-비트시프트연산] 정수 한 개 입력받아 2 곱해 출력하기문제 설명정수 한 개를 입력했을 때 2를 곱해 출력하는 프로그램을 작성해보자.(단, -1073741824 ~ 1073741823) 입력정수 한 개가 입력된다.(단, -1073741824 ~ 1073741823) 출력입력 받은 정수 * 2의 계산 결과가 출력된다. 입력 예시1024 출력 예시2048 내 풀이12345try: num = int(input()); print(num &lt;&lt; 1);except Exception as e: print(e); 정수*2 의 결과를 출력해도 되지만,비트시프트연산자 &lt;&lt;, &gt;&gt; 는 정수를 2배로 곱하거나 나누어 계산해준다. 왼쪽 비트시프트 (&lt;&lt;)가 될 때에는 오른쪽에 0 이 주어진 수 만큼 추가된다. 오른쪽 비트시프트(&gt;&gt;)가 될 때에는 왼쪽에 0(0 또는 양의 정수인 경우) 이나 1(음의 정수인 경우)이 주어진 수 만큼 추가된다. 범위(32비트)를 넘어가 이동되는 비트는 삭제된다. 예시12345a = 10;print(a &lt;&lt; 1); #20 이 출력print(a &gt;&gt; 1); #5 가 출력print(a &lt;&lt; 2); #40 이 출력print(a &gt;&gt; 2); #2 가 출력 모범 답안123a=input()n=int(a)print(n&lt;&lt;1)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1047","slug":"1047","permalink":"https://JihyeHwang09.github.io/tags/1047/"}]},{"title":"CodeUp(코드업) 풀이 (1046번)","slug":"codeup-21","date":"2019-06-14T16:52:15.000Z","updated":"2019-07-06T14:44:43.435Z","comments":true,"path":"2019/06/15/codeup-21/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/15/codeup-21/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1046 : [기초-산술연산] 정수 세 개 입력받아 합과 평균 출력하기문제 설명정수 세 개를 입력받아 합과 평균을 출력하는 프로그램을 작성해보자.(단, -2147483648 ~ 2147483647) 입력정수 세 개가 공백을 두고 입력된다.(단, -2147483648 ~ 2147483647) 출력입력 받은 정수 세 개의 합과 평균을 줄을 바꿔 출력한다. 평균은 소수점 이하 둘째 자리에서 반올림하여 첫째 자리까지 출력한다. 입력 예시1 2 3 출력 예시62.0 내 풀이12345678910try: a, b, c = input().split(); a = int(a); b = int(b); c = int(c); sum = a + b + c; print(sum); print('&#123;0:0.1f&#125;'.format(sum/3));except Exception as e: print(e); 모범 답안1234567a,b,c=input().split()x=int(a)y=int(b)z=int(c)print(x+y+z)print('%.1f' % ((x+y+z)/3))","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1046","slug":"1046","permalink":"https://JihyeHwang09.github.io/tags/1046/"}]},{"title":"CodeUp(코드업) 풀이 (1045번)","slug":"codeup-20","date":"2019-06-13T15:04:52.000Z","updated":"2019-07-06T14:44:36.375Z","comments":true,"path":"2019/06/14/codeup-20/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/14/codeup-20/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1045 : [기초-산술연산] 정수 두 개 입력받아 자동 계산하기문제 설명정수 두 개(a, b)가 공백을 두고 입력된다. (단, a, b의 범위는 0 ~ 2147483647이고, b는 0이 아니다.) 입력정수 두 개(a, b)가 공백을 두고 입력된다.(단, a, b의 범위는 -2147483648 ~ 2147483647이고, b는 0이 아니다.) 출력첫 줄에 합둘째 줄에 차(a-b)셋째 줄에 곱,넷째 줄에 a를 b로 나눈 몫,다섯째 줄에 a를 b로 나눈 나머지,여섯째 줄에 a를 b로 나눈값(실수, 소수점 셋째 자리에서 반올림해 둘째 자리까지 출력)을 출력한다. 입력 예시1 3 출력 예시0 내 풀이123456789101112131415161718try: a,b = input().split(); x = int(a); y = int(b); # 첫 줄에 합 print(x + y); # 둘째 줄에 차(a-b) print(x - y); # 셋째 줄에 곱, print(x * y); # 넷째 줄에 a를 b로 나눈 몫, print(x // y); # 다섯째 줄에 a를 b로 나눈 나머지, print(x % y); # 여섯째 줄에 a를 b로 나눈값(실수, 소수점 셋째 자리에서 반올림해 둘째 자리까지 출력) print('&#123;0:0.2f&#125;'.format(float(x / y)));except Exception as e: print(e); 모범 답안123456789a,b=input().split()x=int(a)y=int(b)print(x+y)print(x-y)print(x*y)print(x//y)print(x%y)print('%.2f' % (x/y))","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1045","slug":"1045","permalink":"https://JihyeHwang09.github.io/tags/1045/"}]},{"title":"CodeUp(코드업) 풀이 (1042번)","slug":"codeup-19","date":"2019-06-13T14:53:38.000Z","updated":"2019-07-06T14:44:30.950Z","comments":true,"path":"2019/06/13/codeup-19/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/13/codeup-19/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1042 : [기초-산술연산] 정수 두 개 입력받아 나눈 몫 출력하기문제 설명정수 두 개(a, b) 를 입력받아 a를 b로 나눈 몫을 출력하는 프로그램을 작성해보자.(단, 입력되는 두 개의 정수 a, b의 범위는 -2147483648 ~ 2147483647이고, b는 0이 아니다.) 입력정수 두 개(a, b)가 공백을 두고 입력된다.(단, a, b의 범위는 -2147483648 ~ 2147483647이고, b는 0이 아니다.) 출력a를 b로 나누었을 때의 몫을 정수형태로 출력한다. 예를 들어 5÷2=2.5 인경우, 2를 출력한다. 입력 예시1 3 출력 예시0 내 풀이123456try: a,b = input().split(); answer = int(a) // int(b); print(answer);except Exception as e: print(e); 모범 답안1234a,b=input().split()x=int(a)y=int(b)print(x//y)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1042","slug":"1042","permalink":"https://JihyeHwang09.github.io/tags/1042/"}]},{"title":"CodeUp(코드업) 풀이 (1041번)","slug":"codeup-18","date":"2019-06-11T15:01:59.000Z","updated":"2019-07-06T14:44:25.128Z","comments":true,"path":"2019/06/12/codeup-18/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/12/codeup-18/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1041 : [기초-산술연산] 문자 한 개 입력받아 다음 문자 출력하기문제 설명영문자 한 개를 입력받아, 그 다음 문자를 출력하는 프로그램을 작성해보자. 영문자 ‘A’의 다음 문자는 ‘B’이고, 문자 ‘0’의 다음 문자는 ‘1’이다. 입력영문자 한 개가 입력된다. 출력입력된 문자의 아스키코드 값 바로 다음 코드 값에 해당하는 문자를 출력한다. 입력 예시a 출력 예시b 내 풀이12345678try: # 문자 -&gt; 아스키코드 변환 ch = input(); num = ord(ch); # 아스키코드 -&gt; 문자로 변환 print(chr(num+1));except Exception as e: print(e); 문자 -&gt; 아스키코드 변환하기 위해 ord()함수를 사용하였다. 아스키코드는 기본적으로 10진수 0부터 127까지 사용한다. 따라서, 입력된 문자의 아스키코드 값 바로 다음 코드 값에 해당하는 문자를 출력하기 위해서는 +1로 값을 증가시킨 후, 이 값을 문자로 변환해준다. 모범 답안1234a=input()n=ord(a)c=chr(n+1)print(c)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1041","slug":"1041","permalink":"https://JihyeHwang09.github.io/tags/1041/"}]},{"title":"CodeUp(코드업) 풀이 (1040번)","slug":"codeup-17","date":"2019-06-11T15:00:59.000Z","updated":"2019-07-06T14:44:14.639Z","comments":true,"path":"2019/06/12/codeup-17/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/12/codeup-17/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1040 : [기초-산술연산] 정수 한 개 입력받아 부호 바꿔 출력하기문제 설명입력된 정수의 부호를 바꿔 출력하는 프로그램을 작성해보자.(단, -2147483647 ~ 2147483647 범위의 정수가 입력된다.) 입력정수 한 개가 입력된다. 출력입력 받은 정수의 부호를 바꿔 출력한다. 입력 예시-1 출력 예시1 내 풀이12345try: num = int(input()); print(-num);except Exception as e: prin 양수 -&gt; 음수, 음수 -&gt; 양수로 변환하기 위해서 출력할 때,변수에 단항연산자 -를 붙여서 부호를 바꾸어 주었다. 모범 답안123a=input()n=int(a)print(-n)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1040","slug":"1040","permalink":"https://JihyeHwang09.github.io/tags/1040/"}]},{"title":"CodeUp(코드업) 풀이 (1037번)","slug":"codeup-16","date":"2019-06-10T15:00:59.000Z","updated":"2019-07-06T14:44:04.699Z","comments":true,"path":"2019/06/11/codeup-16/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/11/codeup-16/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1037 : [기초-출력변환] 정수 한 개 입력받아 아스키 문자로 출력하기문제 설명10진 정수 한 개를 입력받아 아스키문자로 출력하는 프로그램을 작성해보자.(단, 0 ~ 255 범위의 정수만 입력된다.) 입력10진수 1개(0 ~ 255 범위) 출력입력된 10진수에 해당되는 아스키 문자 1개 입력 예시65 출력 예시A 내 풀이12345try: num = int(input()); print(chr(num));except Exception as e: print(e); 아스키 코드 번호 -&gt; 문자열로 변환하려면,chr()함수를 사용한다. 모범 답안1234a=input()n=int(a)c=chr(n)print(c) 참고링크 [파이썬(Python) 아스키코드 문자 변환방법!!]: https://sinwho.tistory.com/entry/%ED%8C%8C%EC%9D%B4%EC%8D%ACPython-%EC%95%84%EC%8A%A4%ED%82%A4%EC%BD%94%EB%93%9C-%EB%AC%B8%EC%9E%90-%EB%B3%80%ED%99%98%EB%B0%A9%EB%B2%95","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1037","slug":"1037","permalink":"https://JihyeHwang09.github.io/tags/1037/"}]},{"title":"CodeUp(코드업) 풀이 (1036번)","slug":"codeup-15","date":"2019-06-10T13:40:59.000Z","updated":"2019-07-06T14:43:55.399Z","comments":true,"path":"2019/06/10/codeup-15/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/10/codeup-15/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1036 : [기초-출력변환] 영문자 한 개 입력받아 10진수로 출력하기문제 설명영문자 한 개를 입력받아 아스키코드 10진수값으로 출력하는 프로그램을 작성해보자. 입력영문자 한 개가 입력된다. 출력입력 받은 문자에 해당되는 아스키코드값을 10진수로 출력한다. 입력 예시A 출력 예시65 내 풀이12345try: str = input(); print(ord(str));except Exception as e: print(e); 문자열을 아스키 코드 번호로 변환하려면, ord()함수를 사용한다. 모범 답안123a=input()n=ord(a)print(n) 참고링크 [Python/파이썬 문자를 아스키 코드 번호로 변환, ASCII Code 를 문자(Char)로 변환]: http://mwultong.blogspot.com/2007/01/python-ascii-code-char.html","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1036","slug":"1036","permalink":"https://JihyeHwang09.github.io/tags/1036/"}]},{"title":"CodeUp(코드업) 풀이 (1031번)","slug":"codeup-14","date":"2019-06-09T13:43:08.000Z","updated":"2019-07-06T14:43:43.979Z","comments":true,"path":"2019/06/09/codeup-14/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/09/codeup-14/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1031 : [기초-출력변환] 10진수 한 개 입력받아 8진수로 출력하기문제 설명10진수를 입력받아 8진수로 출력하는 프로그램을 작성해보자. 입력10진수가 1개 입력된다.(단, 입력되는 정수는 int 범위이다.) 출력입력 받은 10진수를 8진수로 바뀌어 출력한다. 입력 예시10 출력 예시12 내 풀이1 oct 함수를 이용하는 방법 123456try: num = int(input()); answer = oct(num); print(answer[2:]);except Exception as e: print(e); 파이썬에서 기본 입력은 10진수이다. 10진수 -&gt; 8진수 변환을 위해파이썬의 내장 함수인 oct 함수를 사용하였다. 형식: oct(10진수 정수) -&gt; 8진수 8진수로 변환할 경우, 0o가 앞에 붙기 때문에 입출력 예시처럼 10을 입력했을 경우 12로 변환되지 않고, 0o12로 변환된다. 1print(answer[2:]); 파이썬 문자열의 슬라이싱을 이용하여,8진수 문자열의 접두어인 0o를 제외하고 2번째 인덱스부터 출력한다. 내 풀이2 format 함수를 이용하는 방법 12345try: num = int(input()); print(format(num, 'o'));except Exception as e: print(e); format() 내장함수를 이용하면, 다른 진수의 문자열로 바꿀 경우,접두어를 제외할 수 있다. 모범 답안 포매팅 문자열을 사용하는 방법 123a=input()n=int(a)print('%o' % n) # '%포매팅 문자열' %변수 %o는 8진수를 나타내는 포매팅 문자열이다.모범답안의 경우, 포매팅 문자열인 %o를 이용하여 정수를 8진수로 출력해주었다. 참고링크 [[Python] 2진수, 8진수, 10진수, 16진수 변환]: https://doriri.tistory.com/30 [파이썬 10진수, 8진수, 16진수, 2진수 입력]: https://withcoding.com/70 [[파이썬] 2진수, 8진수, 16진수 다루기]: http://www.daleseo.com/python-int-bases/","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1031","slug":"1031","permalink":"https://JihyeHwang09.github.io/tags/1031/"}]},{"title":"CodeUp(코드업) 풀이 (1030번)","slug":"codeup-13","date":"2019-06-08T07:17:17.000Z","updated":"2019-06-08T07:38:08.720Z","comments":true,"path":"2019/06/08/codeup-13/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/08/codeup-13/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1030 : [기초-데이터형] 정수 한 개 입력받아 그대로 출력하기3문제 설명정수 한 개를 입력받아 그대로 출력해보자.(단, 입력되는 정수의 범위는 –9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 이다.) 입력정수 한 개가 입력된다.(단, 입력되는 정수의 범위는 –9223372036854775808 ~ 9223372036854775807 이다.) 출력입력된 정수가 그대로 출력된다. 입력 예시-2147483649 출력 예시-2147483649 내 풀이12345try: a = input(); print(int(a));except Exception as e: print(e); python2의 경우 int의 표현 범위가 32비트 -&gt; -2147483648 ~ 2147483647이어서 이 범위를 벗어날 경우는 long형을 사용하여 나타냈다. python3에서는 long형이 사라지고, 대신 int형이 64비트 이상의 정수 데이터도 나타낼 수 있도록 크기가 유연해졌다. 단, long형이 메모리의 한도 내에서 무한대인 것에 비해, int형은 무한대는 아니다. 모범 답안123a=input()n=int(a)print(n) 참고링크 [[python]정수 실수 자료형]: https://umbum.tistory.com/165","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"}]},{"title":"CodeUp(코드업) 풀이 (1029번)","slug":"codeup-12","date":"2019-06-07T13:39:53.000Z","updated":"2019-07-06T14:43:14.414Z","comments":true,"path":"2019/06/07/codeup-12/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/07/codeup-12/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1029 : [기초-데이터형] 실수 한 개 입력받아 그대로 출력하기2문제 설명실수 한 개를 입력받아 그대로 출력해보자.(단, 입력되는 실수의 범위는 +- 1.710^-308 ~ 1.710^308 이다.) 입력소수점 이하 자리수가 11개 이하인 실수 한 개가 입력된다.(단, 입력되는 실수의 범위는 +- 1.710^-308 ~ 1.710^308 이다.) 출력입력된 실수를 소수점 이하 11번째 자리까지 출력한다. 입력 예시3.14159265359 출력 예시3.14159265359 format 함수를 이용한 풀이 내 풀이112345try: number = input(); print(format(float(number), '.11f'));except Exception as e: print(e); 내 풀이212345try: number = float(input()); print('&#123;0:0.11f&#125;'.format(number));except Exception as e: print(e); 모범 답안123a=input()print('%.11f' % float(a)) 소수점 아래 11자리까지 나타낼 것이므로 %f사이에 .11을 적어줍니다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1029","slug":"1029","permalink":"https://JihyeHwang09.github.io/tags/1029/"}]},{"title":"CodeUp(코드업) 풀이 (1027번)","slug":"codeup-11","date":"2019-06-06T12:07:28.000Z","updated":"2019-07-06T14:43:07.083Z","comments":true,"path":"2019/06/06/codeup-11/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/06/codeup-11/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1027 : [기초-입출력] 년월일 입력받아 형태 바꿔 출력하기문제 설명년월일을 출력하는 방법은 나라마다, 형식마다 조금씩 다르다. 날짜를 년월일(yyyy.mm.dd)의 형태로 입력받아, 일월년(dd-mm-yyyy)의 형태로 출력하는 프로그램을 작성해보자. (단, 한 자리 일/월은 0을 붙여 두 자리로, 년도는 0을 붙여 네 자리로 출력한다.) 입력년월일이 ‘.’(닷)으로 구분되어 입력된다. 출력년월일을 일월년으로 바꾸어 ‘-‘(대쉬, 마이너스)로 구분해 출력한다. 입력 예시2014.07.15 출력 예시15-07-2014 내 풀이 zfill 함수를 이용하는 방법 12345try: yyyy, mm, dd = input().split('.'); print(dd.zfill(2), mm.zfill(2), yyyy.zfill(4), sep='-');except Exception as e: print(e); 모범 답안12345y,m,d=input().split('.')print('%02d' % int(d), end='-')print('%02d' % int(m), end='-')print('%04d' % int(y)) 모범 답안의 경우, end 함수를 이용해 ‘-‘로 연, 월, 일을 연결해주었다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1027","slug":"1027","permalink":"https://JihyeHwang09.github.io/tags/1027/"}]},{"title":"CodeUp(코드업) 풀이 (1026번)","slug":"codeup-10","date":"2019-06-04T16:37:56.000Z","updated":"2019-07-06T14:43:01.561Z","comments":true,"path":"2019/06/05/codeup-10/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/05/codeup-10/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1026 : [기초-입출력] 시분초 입력받아 분 만 출력하기문제 설명시간을 시:분:초 형태로 입력 받아 분 만 출력하는 프로그램을 작성해보자. 입력시간이 [시:분:초]의 형태로 입력된다. 출력분 만 출력한다. (단, 10보다 작은 경우 불필요한 0은 출력하지 않는다.) 입력 예시17:23:57 출력 예시23 내 풀이12hour, minute, second = input().split(':');print(minute); 모범 답안123a,b,c=input().split(':')print(int(b)) 피드백 받은 코드123456input_str = \"23:03:12\"try:print(int(input_str.split(\":\")[1]))except Exception as e:print(e)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1026","slug":"1026","permalink":"https://JihyeHwang09.github.io/tags/1026/"}]},{"title":"CodeUp(코드업) 풀이 (1025번)","slug":"codeup-9","date":"2019-06-03T15:00:14.000Z","updated":"2019-07-06T14:42:56.389Z","comments":true,"path":"2019/06/04/codeup-9/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/04/codeup-9/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1025 : [기초-입출력] 정수 한 개 입력받아 나누어 출력하기문제 설명다섯 자리의 정수 한 개를 입력받아 각 자리별로 구분해 출력한다. 입력다섯자리로 이루어진 한 개의 정수를 입력받는다.(단, 10,000 &lt;= 입력받는 수 &lt;= 99,999 ) 출력각 자리의 수를 분리해한 줄에 하나씩 [ ]속에 넣어 출력한다. 입력 예시75254 출력 예시[70000][5000][200][50][4] 내 풀이1123456n = input();print(\"[%d]\" %(int(n[0]) * 10000));print(\"[%d]\" %(int(n[1]) * 1000));print(\"[%d]\" %(int(n[2]) * 100));print(\"[%d]\" %(int(n[3]) * 10));print(\"[%d]\" %(int(n[4]) * 1)); 내 풀이2 for문을 이용 123number = input();for i in range(len(number)): print(\"[%d]\" %(int(number[i]) * 10**(len(number)-(i+1)))); 모범 답안1234567n=input()print(\"[\"+str(int(n[0])*10000)+\"]\")print(\"[\"+str(int(n[1])*1000)+\"]\")print(\"[\"+str(int(n[2])*100)+\"]\")print(\"[\"+str(int(n[3])*10)+\"]\")print(\"[\"+str(int(n[4]))+\"]\")","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1025","slug":"1025","permalink":"https://JihyeHwang09.github.io/tags/1025/"}]},{"title":"CodeUp(코드업) 풀이 (1024번)","slug":"codeup-8","date":"2019-06-02T15:13:18.000Z","updated":"2019-07-06T14:42:50.667Z","comments":true,"path":"2019/06/03/codeup-8/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/03/codeup-8/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1024 : [기초-입출력] 단어 한 개 입력받아 나누어 출력하기문제 설명단어를 하나 입력받는다. 입력받은 단어(영어)의 각 문자를 한줄에 한 문자씩 분리해 출력한다. 입력단어(영어) 하나를 입력받는다.(단, 단어의 길이는 20글자 이하이다.) 출력단어(영어)를 문자 단위로 나누어한 줄에 한개씩 ‘ ’로 묶어서 출력한다. 입력 예시Boy 출력 예시&#39;B&#39;&#39;o&#39;&#39;y&#39; 내 풀이123strList = list(input());for i in strList: print(\"'%c'\" %i); 입력받은 단어(영어)를 한 개씩 쪼개기 위해 list에 넣어주었다.(배열과 비슷한 개념) 한 글자씩 출력하기 위해 리스트를 for문으로 돌면서 한 글자씩 출력해준다.포맷문자(format string)을 이용하여 strList에 각각 한 글자씩 들어있으므로한 글자씩 출력할 때는 %c %i로 나타내준다. 한 글자씩 출력하되 &#39;&#39;로 감싸줘야 하므로 &quot;&#39;&#39;%c&quot; %i로 나타내준다. &#39;&#39;나 &quot;&quot;를 출력하기 위해서는 &#39;&#39;안에 쓰고 &quot;&quot;로 감싸주거나(“‘’“) 반대로 &quot;&quot;를 안에 쓰고 &#39;&#39;로 감싸주면 된다.(‘“”‘) 모범 답안1234a=input()for c in a: print(\"'\"+c+\"'\") 모범답안의 경우, c를 &#39;&#39;로 감싸서 출력하기 위해서 +로 연결해주고 &quot;&quot;로 감싸주었다. 굳이 리스트에 넣지 않아도 문자열 자체를 하나씩 for문을 돌릴 수 있다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1024","slug":"1024","permalink":"https://JihyeHwang09.github.io/tags/1024/"}]},{"title":"CodeUp(코드업) 풀이 (1023번)","slug":"codeup-7","date":"2019-06-02T14:24:22.000Z","updated":"2019-07-06T14:42:42.922Z","comments":true,"path":"2019/06/02/codeup-7/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/02/codeup-7/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1023 : [기초-입출력] 실수 한 개 입력받아 부분별로 출력하기문제 설명실수 한 개를 입력받는다. 입력 받은 실수를 정수 부분과 실수 부분으로 나누어 따로 출력한다. 입력실수 한 개가 입력된다.(단, 입력 값은 절댓값이 정수부가 100,000을 넘지 않으며, 소수점 이하는 0으로 시작하지 않으며, 6자리이하이다.) 출력첫 번째 줄에 정수 부분을, 두 번째 줄에 실수 부분을 입력된 자릿수만큼 그대로 출력한다. 입력 예시1.414213 출력 예시1414213 내 풀이123a, b = input().split('.');print(a);print(b); 모범 답안1234a,b=input().split('.')print(int(a))print(int(b))","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1023","slug":"1023","permalink":"https://JihyeHwang09.github.io/tags/1023/"}]},{"title":"CodeUp(코드업) 풀이 (1021번)","slug":"codeup-6","date":"2019-06-01T14:15:35.000Z","updated":"2019-07-06T14:42:32.771Z","comments":true,"path":"2019/06/01/codeup-6/","link":"","permalink":"https://JihyeHwang09.github.io/2019/06/01/codeup-6/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1021 : [기초-입출력] 단어 한 개 입력받아 그대로 출력하기문제 설명하나의 단어를 입력받아 그대로 출력해보자. 입력한 단어가 입력된다.(단, 단어의 길이는 50글자 이하이다.) 출력입력받은 단어를 그대로 출력한다. 입력 예시Informatics 출력 예시Informatics 내 풀이1234str = input();result = len(str);if result &lt;= 50: print(str); 모범 답안12a=input()print(a)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1021","slug":"1021","permalink":"https://JihyeHwang09.github.io/tags/1021/"}]},{"title":"CodeUp(코드업) 풀이 (1020번)","slug":"codeup-5","date":"2019-05-31T09:36:02.000Z","updated":"2019-07-06T14:42:20.729Z","comments":true,"path":"2019/05/31/codeup-5/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/31/codeup-5/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1020 : [기초-입출력] 주민번호 입력받아 형태 바꿔 출력하기문제 설명주민등록번호는 다음과 같이 구성된다. XXXXXX-XXXXXXX 앞의 6자리는 생년월일(yymmdd)이고 뒤 7자리는 성별, 지역, 오류검출코드이다. 주민등록번호를 입력받아 형태를 바꿔 출력해보자. 입력주민등록번호 앞 6자리와 뒤 7자리가 “-“로 구분되어 입력된다. 출력“-“를 제외한 주민번호 13자리를 모두 붙여 출력한다. 입력 예시980907-1121112 출력 예시9809071121112 내 풀이123# 입력받은 문자열을 personal_id라는 변수에 담는다.personal_id = input();print(''.join(personal_id .split('-'))); personal_id .split(‘-‘): 변수에 담긴 주민번호값을 &#39;-&#39;를 기준으로 나눈다. ‘’.join(personal_id .split(‘-‘)): “-“를 없앤 주민번호값을 공백없이 붙이기 위하여 join을 사용하는데 구분자를 넣고 싶다면 .join앞에 넣어주면 된다. 구분자 문자열을 넣어 연결한 예시12345678fruit = ['apple', 'banana', 'orange'];# '-'로 연결한 예시print('-'.join(fruit));# apple-banana-orange# 공백' '으로 연결한 예시print(' '.join(fruit));# apple banana orange 모범 답안12a,b=input().split('-')print(a+b) 모범 답안의 경우, 입력받을 때부터 &#39;-&#39;를 기준으로변수 a, b에 각각 나누어 담았다. 더하기(+) 연산자를 이용하여 문자열을 이어붙였다. 입력할 때부터 구분자 문자열을 기준으로 변수 2개에 나누어 담아주는 모범 답안은 시간 복잡도면에서 효율적으로 보인다. 내가 작성한 코드는 사용자가 입력한 값을 통째로 받아서 그 이후에 split을 해줘서 코드 라인이 1줄 더 많지만, 변수를 1개 만들어 메모리를 더 적게 할당 받기 때문에 공간 복잡도면에서 효율적이라고 생각한다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1020","slug":"1020","permalink":"https://JihyeHwang09.github.io/tags/1020/"},{"name":"구분자","slug":"구분자","permalink":"https://JihyeHwang09.github.io/tags/구분자/"},{"name":"join","slug":"join","permalink":"https://JihyeHwang09.github.io/tags/join/"},{"name":"split","slug":"split","permalink":"https://JihyeHwang09.github.io/tags/split/"}]},{"title":"CodeUp(코드업) 풀이 (1019번)","slug":"codeup-4","date":"2019-05-30T09:36:02.000Z","updated":"2019-07-06T14:42:10.913Z","comments":true,"path":"2019/05/30/codeup-4/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/30/codeup-4/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1019 : [기초-입출력] 년월일 입력받아 형식에 맞게 출력하기문제 설명년, 월, 일을 입력받아 형식에 맞게 출력하는 프로그램을 작성해보자. 입력년, 월, 일이 “.(닷)”으로 구분되어 입력된다. 출력입력받은 년, 월, 일을 출력한다. 단, 자릿수는 yyyy.mm.dd형태로 출력한다.(입출력 예시 참고, %02d를 사용하면 2칸을 사용해 출력하는데, 1자리 수인 경우 앞에 0이 붙어 출력된다.) 내 풀이12yyyy, mm, dd = input().split('.');print(yyyy.zfill(4), mm.zfill(2), dd.zfill(2), sep='.'); zfill 함수 형식: print(문자열.zfill(길이)) zfill()을 이용하면, 지정한 길이만큼 채워지지 않을 경우,남는 앞부분을 0 채워준다. 만약에 길이가 문자열보다 적으면, 모든 문자열을 출력한다. 모범 답안12345a,b,c=input().split('.')print('%04d' % int(a), end='.')print('%02d' % int(b), end='.')print('%02d' % int(c)) end 인수 print문의 끝에 end = ‘문자열’을 추가할 경우,그 다음의 출력문이 오른쪽에 이어서 표시된다. 위의 모범 답안에서는 end=’.’이므로 콤마(.)로 다음의 프린트문이 연결되어 출력된다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1019","slug":"1019","permalink":"https://JihyeHwang09.github.io/tags/1019/"},{"name":"sep 인수","slug":"sep-인수","permalink":"https://JihyeHwang09.github.io/tags/sep-인수/"},{"name":"end 인수","slug":"end-인수","permalink":"https://JihyeHwang09.github.io/tags/end-인수/"}]},{"title":"CodeUp(코드업) 풀이 (1018번)","slug":"codeup-3","date":"2019-05-29T14:55:43.000Z","updated":"2019-07-06T14:42:00.191Z","comments":true,"path":"2019/05/29/codeup-3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/29/codeup-3/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1018 : [기초-입출력] 시간 입력받아 그대로 출력하기문제 설명시간이 특정 형식에 맞추어 입력될 때 그대로 출력하는 프로그램을 작성 해보자. 입력시(hour)와 분(minute)이 “:”(콜론)으로 구분되어 입력된다. 출력입력받은 시간을 “시:분”으로 출력한다. 내 풀이12hour, minute = input().split(':');print(hour + ':' + minute); 콤마(,)로 구분할 경우 문자, 숫자에 상관없이 공백이 삽입되어 띄어쓰기가 되어 출력된다. 더하기(+)로 구분하면, 문자끼리는 공백없이 이어져서 출력되고, 숫자는 덧셈 연산이 이루어진다. 문자와 숫자를 (+)로 이어붙이면, 타입이 달라서 오류가 난다. 모범 답안12h,m=input().split(':');print(int(h), int(m), sep=':'); sep 인자를 사용하여 띄어쓰기(공백)이 아니라 다른 문자열을 사이에 넣을 수 있다. 형식: 출력 부분에서 콤마(,)로 구분하고 sep=&quot;내용&quot; sep 인자 예시12print(1, 2, 3, sep = '+');# 1+2+3 참고 링크 [프린트문print() 옵션(문자열 형식)]: https://www.opentutorials.org/module/2980/17535 [출력 -print(), sep=’ ‘, end=’ ‘ [Python]]: https://it-coco.tistory.com/entry/%EC%B6%9C%EB%A0%A5-print-sep-end [파이썬 print 함수 사용법 정리 (파이썬 화면 출력)]: https://withcoding.com/64 [Python(파이썬) 표준 출력]: https://wikidocs.net/20403","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"1018","slug":"1018","permalink":"https://JihyeHwang09.github.io/tags/1018/"},{"name":"zfill 함수","slug":"zfill-함수","permalink":"https://JihyeHwang09.github.io/tags/zfill-함수/"}]},{"title":"CodeUp(코드업) 풀이 (1014 ~ 1017번)","slug":"codeup-2","date":"2019-05-28T14:32:31.000Z","updated":"2019-06-02T16:50:40.585Z","comments":true,"path":"2019/05/28/codeup-2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/28/codeup-2/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. 1014 : [기초-입출력] 문자 두 개 입력받아 순서 바꿔 출력하기내 풀이, 모범 답안12a, b = input().split();print(b, a); 1015 : [기초-입출력] 실수 한 개 입력받아 소수점 이하 둘째 자리까지 출력하기 문제 설명: 실수(float) 한 개를 입력받아 소수점 이하 3째 자리에서 반올림 하여2째 자리까지 출력하시오. 입력 예시: 1.59254 출력 예시: 1.59 내 풀이1 round 함수를 이용한 포맷팅 12answer = round(float(input()), 2);print(answer); cf 1) 소수점 반올림하는 방법 형식: round(실수, 소수점 아래 자리수) round 함수를 이용할 때, 두번째 인자를 비울 경우-&gt; 소수점 첫번째 자리에서 반올림한다. 123 # round 함수 두번째 인자를 비울 경우 round(8.3323425);# 9 cf 2) 소수점을 올림, 내림하는 방법 소수점 올림, 내림을 할 때, 파이썬에서 기본적으로 제공하는 함수가 아닌math 클래스를 import하여 ceil, floor, trunc 함수를 사용할 수 있다. 1234567import math # math 모듈을 import한다.# ceil: 올림math.ceil(-2.14) # -2.1을 올림하면 0에 더 가까워진 -2가 된다.# floor: 내림math.floor(-2.14) # -2# trunc: 내림math.trunc(-2.14) # -3 cf 3) 내림 함수 trunc 와 floor 차이점 floor를 이용하면 소수점 아래 숫자를 버리고 위쪽과 가까워진 -2가 된다. trunc를 이용하면, 무조건 아래를 향해서 내림하여 -3이 된다. trunc는 int와 같은 결과를 반환한다. 내 풀이 2 format 함수를 이용한 포맷팅 12number = float(input());print(\"&#123;0:0.2f&#125;\".format(number))); 형식: format(요소(item), 포맷 지정자(format-specifier)) 모범 답안(사이트에 제시된) 포맷 코드와 숫자 함께 사용하기 123f=float(input()) # 사용자에게 입력받은 값을 float를 이용해 실수로 변환 -&gt; 변수 f에 넣는다.print('%.2f' % f)# print (\"내용 %f\" %변수이름) 구글링을 해보니,이 포맷팅 방식은 python3 이전의 방식이라고 하니 참고하는 정도로 보면 좋을 것 같다. 문자열 포맷팅을 위해 %를 사용했다. &#39;%f&#39; %변수를 사용할 경우, 소수점 아래 6자리까지 그대로 표시된다. &#39;%0.숫자f&#39; %변수는 소수점 아래 자리수만큼 숫자를 적어주면, 그 자리수까지 표시된다. &#39;%0.f&#39; %변수형태로 사용할 경우, 소수점 없이 정수처럼 출력할 수 있다. 1017 : [기초-입출력] 정수 한 개 입력받아 세 번 출력하기 입력: 정수 한 개가 입력된다. 출력: 입력받은 정수를 공백으로 구분해 세 번 출력한다. 내 풀이12i = input();print(i, i, i); 모범 답안123n=input()n=int(n)print(n, n, n,); 파이썬에서는 변수 사이에 콤마(,)를 넣어서 공백으로 구분해 출력할 수 있다. 참고 링크 [[Python] 문자열 포맷팅 방법들]: https://brownbears.tistory.com/421 [문자열 포맷 코드]: https://wikidocs.net/13 [[Python]파이썬 자리수 조절]: https://dpdpwl.tistory.com/94","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"소수점","slug":"소수점","permalink":"https://JihyeHwang09.github.io/tags/소수점/"},{"name":"반올림","slug":"반올림","permalink":"https://JihyeHwang09.github.io/tags/반올림/"},{"name":"내림","slug":"내림","permalink":"https://JihyeHwang09.github.io/tags/내림/"},{"name":"올림","slug":"올림","permalink":"https://JihyeHwang09.github.io/tags/올림/"},{"name":"포맷팅","slug":"포맷팅","permalink":"https://JihyeHwang09.github.io/tags/포맷팅/"},{"name":"python formating","slug":"python-formating","permalink":"https://JihyeHwang09.github.io/tags/python-formating/"},{"name":"1014","slug":"1014","permalink":"https://JihyeHwang09.github.io/tags/1014/"},{"name":"1015","slug":"1015","permalink":"https://JihyeHwang09.github.io/tags/1015/"},{"name":"1017","slug":"1017","permalink":"https://JihyeHwang09.github.io/tags/1017/"}]},{"title":"CodeUp(코드업) 풀이 (1010 ~ 1013번)","slug":"codeup-1","date":"2019-05-26T22:13:06.000Z","updated":"2019-06-02T16:50:46.679Z","comments":true,"path":"2019/05/27/codeup-1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/27/codeup-1/","excerpt":"","text":"이 포스팅은 codeup.kr(코드업)의 문제를 Python3로 풀고 정리한 내용입니다. [기초-출력] 출력하기 01 ~ 07은 생략하였습니다. 1010 : [기초-입출력] 정수 한 개 입력받아 그대로 출력하기 내 풀이 12a = input();print(a); 모범 답안 123a=input()a=int(a)print(a) 파이썬은 입력받을 때, 자료형에 구애받지 않기 때문에int로 형변환을 따로 해주지 않았는데,모범 답안에서는 입력 받은 후에 int로 형변환을 하여 출력했다. 1011 : [기초-입출력] 문자 한 개 입력받아 그대로 출력하기 내 풀이 &amp; 모범 답안 12a = input()print(a); 1012 : [기초-입출력] 실수 한 개 입력받아 그대로 출력하기 내 풀이 12a = input();print(a); 모범 답안 123a=input()a=float(a) # float(숫자): 실수형으로 출력print(\"%f\" % a) # print (\"내용 %f\" %변수이름) 1013 : [기초-입출력] 정수 두 개 입력받아 그대로 출력하기 내 풀이 12a, b = input().split();print(a, b); 모범 답안 1234a,b = input().split()n = int(a)m = int(b)print(a, b) 1a, b = input().split(); input으로 한 번에 값을 여러 개 입력 받으려면,input으로 입력받은 값들을 split을 이용해서 공백을 기준으로 나눠준 뒤,각 변수에 대입해준다.각 변수는 콤마(,)로 구분해준다. 입력 받은 두 개의 값이 정수라는 것을 보장하기 위해 모범 답안에서는입력받은 값을 넣은 a, b를 각각 int()를 이용해서 정수로 변환시켜주고 있다. 참고 링크 [[파이썬1] %.1f 숫자 ,%문자 ,Input() / print()]]: (https://systemtrade.tistory.com/325 [8.3 한 번에 값 두 개 입력받기]: https://dojang.io/mod/page/view.php?id=1220","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Python","slug":"back-end/python","permalink":"https://JihyeHwang09.github.io/categories/back-end/python/"}],"tags":[{"name":"codeup 해설","slug":"codeup-해설","permalink":"https://JihyeHwang09.github.io/tags/codeup-해설/"},{"name":"코드업","slug":"코드업","permalink":"https://JihyeHwang09.github.io/tags/코드업/"},{"name":"python","slug":"python","permalink":"https://JihyeHwang09.github.io/tags/python/"},{"name":"100제","slug":"100제","permalink":"https://JihyeHwang09.github.io/tags/100제/"},{"name":"여러 개 입력 받기","slug":"여러-개-입력-받기","permalink":"https://JihyeHwang09.github.io/tags/여러-개-입력-받기/"},{"name":"1010","slug":"1010","permalink":"https://JihyeHwang09.github.io/tags/1010/"},{"name":"1011","slug":"1011","permalink":"https://JihyeHwang09.github.io/tags/1011/"},{"name":"1012","slug":"1012","permalink":"https://JihyeHwang09.github.io/tags/1012/"},{"name":"1013","slug":"1013","permalink":"https://JihyeHwang09.github.io/tags/1013/"}]},{"title":"02. 클린 코드 - 2. 의미있는 이름(7)","slug":"book-clean-code-9","date":"2019-05-26T07:57:57.273Z","updated":"2019-05-26T13:56:45.750Z","comments":true,"path":"2019/05/26/book-clean-code-9/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/26/book-clean-code-9/","excerpt":"","text":"클린 코드 - 애자일 소프트웨어 장인 정신(로버트 C.마틴 지음 | 박재호.이해영 옮김)를 읽고 정리한 내용입니다.개인적으로 공부한 내용을 정리하려는 목적임을 알려드립니다. 7) 자신의 기억력을 자랑하지 마라 문자 하나만 사용하는 변수 이름은 문제가 있다. 루프에서 반복 횟수를 세는 변수 i, j, k는 괜찮다. l은 절대 안된다!(1과 구분하기 어려우므로) 단, 루프 범위가 아주 작고 다른 이름과 충돌하지 않을 때만 괜찮다. 그 외에 대부분 적절하지 못하다. 똑똑한 프로그래머와 전문가 프로그래머 사이에서 나타내는 차이점 하나는,전문가 프로그래머는 명료함이 최고라는 사실을 이해한다.자신의 능력을 좋은 방향으로 사용해 남들이 이해하는 코드를 내놓는다. 8) 클래스 이름 클래스 이름과 객체 이름은 명사나 명사구가 적합하다.동사는 사용하지 않는다! ex)좋은 예: customer, WikiPage, Account, AddressParser피하는 단어: Manager, Processor, Data, Info 9) 메서드 이름 메서드 이름은 동사나 동사구가 적합하다. ex)좋은 예: postPayment, deletePage, save접근자(Accessor), 변경자(Mutator), 조건자(Predicate)는javabean 표준에 따라 값 앞에 get, set, is를 붙인다. 1234string name = employee.getName();customer.setName(\"mike\");if (paycheck.isPosted())// ... 메서드는 인수를 설명하는 이름을 사용한다. 아래 코드의 메서드명이 인수를 설명하고 있기 때문에위 코드보다 아래 코드보다 더 좋다. 1Complex fulcrumPoint = new Complex(23.0); 1Complex fulcrumPoint = Complex.FromRealNumber(23.0); 10) 기발한 이름은 피하라. 재미난 이름보다 명료한 이름을 선택하라. 특정 문화에서만 사용하는 농담은 피하는 편이 좋다.의도를 분명하고 솔직하게 표현하라.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Book","slug":"developer/book","permalink":"https://JihyeHwang09.github.io/categories/developer/book/"}],"tags":[{"name":"클린 코드","slug":"클린-코드","permalink":"https://JihyeHwang09.github.io/tags/클린-코드/"},{"name":"Clean Code","slug":"clean-code","permalink":"https://JihyeHwang09.github.io/tags/clean-code/"},{"name":"의미있는 이름","slug":"의미있는-이름","permalink":"https://JihyeHwang09.github.io/tags/의미있는-이름/"}]},{"title":"02. 클린 코드 - 2. 의미있는 이름(6)","slug":"book-clean-code-8","date":"2019-05-25T13:21:41.000Z","updated":"2019-05-25T16:14:57.727Z","comments":true,"path":"2019/05/25/book-clean-code-8/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/25/book-clean-code-8/","excerpt":"","text":"손관절 부상으로 인해 손글씨로 정리한 내용으로 올립니다:) 클린 코드 - 애자일 소프트웨어 장인 정신(로버트 C.마틴 지음 | 박재호.이해영 옮김)를 읽고 정리한 내용입니다.개인적으로 공부한 내용을 정리하려는 목적임을 알려드립니다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Book","slug":"developer/book","permalink":"https://JihyeHwang09.github.io/categories/developer/book/"}],"tags":[{"name":"클린 코드","slug":"클린-코드","permalink":"https://JihyeHwang09.github.io/tags/클린-코드/"},{"name":"Clean Code","slug":"clean-code","permalink":"https://JihyeHwang09.github.io/tags/clean-code/"},{"name":"의미있는 이름","slug":"의미있는-이름","permalink":"https://JihyeHwang09.github.io/tags/의미있는-이름/"}]},{"title":"02. 클린 코드 - 2. 의미있는 이름(5)","slug":"book-clean-code-7","date":"2019-05-24T13:21:41.000Z","updated":"2019-05-24T13:22:50.242Z","comments":true,"path":"2019/05/24/book-clean-code-7/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/24/book-clean-code-7/","excerpt":"","text":"손관절 부상으로 인해 손글씨로 정리한 내용으로 올립니다:) 클린 코드 - 애자일 소프트웨어 장인 정신(로버트 C.마틴 지음 | 박재호.이해영 옮김)를 읽고 정리한 내용입니다.개인적으로 공부한 내용을 정리하려는 목적임을 알려드립니다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Book","slug":"developer/book","permalink":"https://JihyeHwang09.github.io/categories/developer/book/"}],"tags":[{"name":"클린 코드","slug":"클린-코드","permalink":"https://JihyeHwang09.github.io/tags/클린-코드/"},{"name":"Clean Code","slug":"clean-code","permalink":"https://JihyeHwang09.github.io/tags/clean-code/"},{"name":"의미있는 이름","slug":"의미있는-이름","permalink":"https://JihyeHwang09.github.io/tags/의미있는-이름/"}]},{"title":"02. 클린 코드 - 2. 의미있는 이름(4)","slug":"book-clean-code-6","date":"2019-05-22T15:11:26.000Z","updated":"2019-05-22T15:15:48.403Z","comments":true,"path":"2019/05/23/book-clean-code-6/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/23/book-clean-code-6/","excerpt":"","text":"손관절 부상으로 인해 손글씨로 정리한 내용으로 올립니다:) 클린 코드 - 애자일 소프트웨어 장인 정신(로버트 C.마틴 지음 | 박재호.이해영 옮김)를 읽고 정리한 내용입니다.개인적으로 공부한 내용을 정리하려는 목적임을 알려드립니다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Book","slug":"developer/book","permalink":"https://JihyeHwang09.github.io/categories/developer/book/"}],"tags":[{"name":"클린 코드","slug":"클린-코드","permalink":"https://JihyeHwang09.github.io/tags/클린-코드/"},{"name":"Clean Code","slug":"clean-code","permalink":"https://JihyeHwang09.github.io/tags/clean-code/"},{"name":"의미있는 이름","slug":"의미있는-이름","permalink":"https://JihyeHwang09.github.io/tags/의미있는-이름/"}]},{"title":"02. 클린 코드 - 2. 의미있는 이름(3)","slug":"book-clean-code-5","date":"2019-05-22T14:41:54.000Z","updated":"2019-05-22T14:47:16.187Z","comments":true,"path":"2019/05/22/book-clean-code-5/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/22/book-clean-code-5/","excerpt":"","text":"손관절 부상으로 인해 손글씨로 정리한 내용으로 올립니다:) 클린 코드 - 애자일 소프트웨어 장인 정신(로버트 C.마틴 지음 | 박재호.이해영 옮김)를 읽고 정리한 내용입니다.개인적으로 공부한 내용을 정리하려는 목적임을 알려드립니다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Book","slug":"developer/book","permalink":"https://JihyeHwang09.github.io/categories/developer/book/"}],"tags":[{"name":"클린 코드","slug":"클린-코드","permalink":"https://JihyeHwang09.github.io/tags/클린-코드/"},{"name":"Clean Code","slug":"clean-code","permalink":"https://JihyeHwang09.github.io/tags/clean-code/"},{"name":"의미있는 이름","slug":"의미있는-이름","permalink":"https://JihyeHwang09.github.io/tags/의미있는-이름/"}]},{"title":"02. 클린 코드 - 2. 의미있는 이름(2)","slug":"book-clean-code-4","date":"2019-05-21T05:16:08.000Z","updated":"2019-05-21T16:46:53.411Z","comments":true,"path":"2019/05/21/book-clean-code-4/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/21/book-clean-code-4/","excerpt":"","text":"손관절 부상으로 인해 손글씨로 정리한 내용으로 올립니다:) 클린 코드 - 애자일 소프트웨어 장인 정신(로버트 C.마틴 지음 | 박재호.이해영 옮김)를 읽고 정리한 내용입니다.개인적으로 공부한 내용을 정리하려는 목적임을 알려드립니다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Book","slug":"developer/book","permalink":"https://JihyeHwang09.github.io/categories/developer/book/"}],"tags":[{"name":"클린 코드","slug":"클린-코드","permalink":"https://JihyeHwang09.github.io/tags/클린-코드/"},{"name":"Clean Code","slug":"clean-code","permalink":"https://JihyeHwang09.github.io/tags/clean-code/"},{"name":"의미있는 이름","slug":"의미있는-이름","permalink":"https://JihyeHwang09.github.io/tags/의미있는-이름/"}]},{"title":"02. 클린 코드 - 2. 의미있는 이름(1)","slug":"book-clean-code-3","date":"2019-05-20T05:16:08.000Z","updated":"2019-05-21T16:46:58.999Z","comments":true,"path":"2019/05/20/book-clean-code-3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/20/book-clean-code-3/","excerpt":"","text":"손관절 부상으로 인해 손글씨로 정리한 내용으로 올립니다:) 클린 코드 - 애자일 소프트웨어 장인 정신(로버트 C.마틴 지음 | 박재호.이해영 옮김)를 읽고 정리한 내용입니다.개인적으로 공부한 내용을 정리하려는 목적임을 알려드립니다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Book","slug":"developer/book","permalink":"https://JihyeHwang09.github.io/categories/developer/book/"}],"tags":[{"name":"클린 코드","slug":"클린-코드","permalink":"https://JihyeHwang09.github.io/tags/클린-코드/"},{"name":"Clean Code","slug":"clean-code","permalink":"https://JihyeHwang09.github.io/tags/clean-code/"},{"name":"의미있는 이름","slug":"의미있는-이름","permalink":"https://JihyeHwang09.github.io/tags/의미있는-이름/"}]},{"title":"기타 다이어그램(컴포넌트. 배포, 패키지 다이어그램)","slug":"se-15","date":"2019-05-18T15:00:51.000Z","updated":"2019-05-18T07:39:49.545Z","comments":true,"path":"2019/05/19/se-15/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/19/se-15/","excerpt":"","text":"15강. 기타 다이어그램(컴포넌트. 배포, 패키지 다이어그램) 기타 다이어그램(컴포넌트. 배포, 패키지 다이어그램)에 대해 알아보자. 주요 용어 컴포넌트: 기능을 구현하여 인터페이스를 제공하는 소프트웨어 부품으로물리적 바이너리 파일이다. 제공 인터페이스: 어떤 컴포넌트의 제공 인터페이스는그 컴포넌트가 구현하여 서비스로 제공하는 인터페이스이다. 요구 인터페이스: 어떤 컴포넌트의 요구 인터페이스는그 컴포넌트가 기능을 수행하기 위해 필요한 (다른 컴포넌트가 제공하는) 인터페이스이다. 패키지: 관련성이 있는 UML 요소들을 하나의 그룹으로 만들기 위한컨테이너를 말한다. 배포 다이어그램: 실행 상황에서 노드들의 구성을 보여주고소프트웨어 요소들이 실제로 어떤 하드웨어에 배치되어 실행되는지를 보여준다. 정리하기 컴포넌트는 재사용될 수 있는 캡슐화된 소프트웨어 부품이다. 컴포넌트는 jar 파일이나 dll 파일과 같은 물리적 바이너리 파일이다. 컴포넌트는 제공 인터페이스와 요구 인터페이스를 가진다. 배포 다이어그램은 하드웨어 구성과 소프트웨어 요소의 배치에 관한시스템의 물리적 뷰를 보여준다. 배포 다이어그램에서 노드는 대개 하드웨어이나 구성 요소의 실행 환경을 제공하는 소프트웨어도 노드로 표현된다. 소프트웨어 구성 요소(artifact)는 노드 상에 존재하는 물리적 소프트웨어 요소로실행 파일, 라이브러리, 소스, 문서 파일 등을 말한다. 패키지는 요소를 그룹화하기 위한 것이며 패키지 간에는의존 관계가 존재할 수 있다. 참고 자료 UML을 활용한 시스템 분석 설계, 최은만, 2010, 생능출판사 UML을 활용한 객체지향 분석 설계, 그래디 부치 등, 에이콘출판사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"컴포넌트 다이어그램","slug":"컴포넌트-다이어그램","permalink":"https://JihyeHwang09.github.io/tags/컴포넌트-다이어그램/"},{"name":"배포 다이어그램","slug":"배포-다이어그램","permalink":"https://JihyeHwang09.github.io/tags/배포-다이어그램/"},{"name":"패키지 다이어그램","slug":"패키지-다이어그램","permalink":"https://JihyeHwang09.github.io/tags/패키지-다이어그램/"}]},{"title":"상태 머신 다이어그램","slug":"se-14","date":"2019-05-17T15:03:00.000Z","updated":"2019-05-18T07:21:12.160Z","comments":true,"path":"2019/05/18/se-14/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/18/se-14/","excerpt":"","text":"14강. 상태 머신 다이어그램 상태 머신 다이어그램에 대해 알아보자. 주요 용어 상태: 특정 시점에서 객체나 시스템의 상황을 의미하는 것으로 객체의 상태는 주어진 시점에서 객체의 속성 값들로 표현된다. 상태 전이: 한 상태에서 다른 상태로 상태가 변경되는 것으로,트리거에 의해 또는 이전 상태의 내부 행위가 종료되면 발생할 수 있다. 트리거: 상태 전이를 일으키는 이벤트를 트리거 또는 트리거링 이벤트라고 한다. 상태 머신 다이어그램: 객체, 서브시스템 또는 전체 시스템의 상태와상태 전이를 표현하여 행위를 모델링하는 UML 다이어그램이다. 정리하기 객체의 상태는 특정 시점에서 객체가 가지는 속성들의 값으로 표현된다. 상태 머신 다이어그램을 사용하여 단일 객체의 상태 변화를 모델링할 수 있다. 상태 전이 화살표와 함께 ‘트리거[조건] / 효과’를 명세할 수 있다. 트리거는 상태 전이를 야기하는 이벤트이며,조건이 단축될 때만 전이가 일어난다. 선택 노드는 조건에 따른 여러 진이를 명료하게 표현하기 위한 것이다. 트리거는 시그널 수신 노드로, 전이 효과는 시그널 송신 노드로 표현할 수 있다. 복합 상태는 하나의 상태를 세분화하여 복수 개의 상태로 표현한 것이다. 참고 자료 UML을 활용한 시스템 분석 설계, 최은만, 2010, 생능출판사 UML을 활용한 객체지향 분석 설계, 그래디 부치 등, 에이콘출판사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"상태 머신 다이어그램","slug":"상태-머신-다이어그램","permalink":"https://JihyeHwang09.github.io/tags/상태-머신-다이어그램/"}]},{"title":"클래스 다이어그램과 객체 다이어그램","slug":"se-13","date":"2019-05-17T14:25:29.000Z","updated":"2019-05-17T14:50:18.084Z","comments":true,"path":"2019/05/17/se-13/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/17/se-13/","excerpt":"","text":"13강. 클래스 다이어그램과 객체 다이어그램 상호작용 다이어그램에 대해 알아보자. 주요 용어 클래스: 동종의 객체를 추상화하여 표현한 틀로서객체가 가질 수 있는 속성과 행위로 구성된다. 객체: 특정 클래스의 실제화된 인스턴스이다. 상속 관계: 부모 클래스와 자식 클래스 간의 관계이다.자식 클래스는 부모 클래스가 가지는 공통 속성과 행위를 상속받는다. 의존 관계: 클래스 간의 단순 사용 관계로 가장 약한 형태의 결합이다. 클래스 다이어그램: 개별 클래스의 명세와 클래스 간의 관계를 표현하는UML 다이어그램이다. 정리하기 클래스는 객체의 설계도이며, 객체는 클래스의 인스턴스이다. 클래스는 상태를 나타내는 속성과 동작을 표현하는 메소드로 구성된다. 클래스 간의 관계로 의존, 연관, 집합체 연관, 구성 집합체 연관, 일반화가 있다. 클래스 다이어그램을 사용하여 클래스를 명세하고클래스 간의 관계를 보여줄 수 있다. 객체 다이어그램은 객체의 상태와 링크를 이용하여실행 중의 시스템 상황을 보여준다. 참고 자료 UML을 활용한 시스템 분석 설계, 최은만, 2010, 생능출판사 UML을 활용한 객체지향 분석 설계, 그래디 부치 등, 에이콘출판사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"상호작용 다이어그램","slug":"상호작용-다이어그램","permalink":"https://JihyeHwang09.github.io/tags/상호작용-다이어그램/"}]},{"title":"상호작용 다이어그램","slug":"se-12","date":"2019-05-16T12:39:50.000Z","updated":"2019-05-16T12:50:38.417Z","comments":true,"path":"2019/05/16/se-12/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/16/se-12/","excerpt":"","text":"12강. 상호작용 다이어그램 상호작용 다이어그램에 대해 알아보자. 주요 용어 상호작용 다이어그램: 시스템 구성 요소들 사이의 상호작용을 표현하는 다이어그램을 의미한다. 시퀀스 다이어그램: 유스케이스가 실행될 때 필요한 구성 요소들 사이의상호작용과 상호작용 순서를 표현하는 다이어그램이다. 통신 다이어그램: 시퀀스 다이어그램과 의미적으로 동일하나상호작용에 참여하는 요소들 사이의 관계를 명확히 표현하는 다이어그램이다. 동기 메시지: 메시지 송신자가 동기 메시지를 전송한 후리턴 메시지의 수신을 기다려야 한다. 비동기 메시지: 메시지 송신자가 비동기 메시지를 전송한 후즉시 다른 작업을 계속할 수 있다. 정리하기 시퀀스 다이어그램과 통신 다이어그램은 대표적 상호작용 다이어그램이다. 시퀀스 다이어그램은 메시지의 흐름과 순서에 초점을 두어 상호작용을 표현한다. 통신 다이어그램은 메시지를 주고받는 객체들 간의 관계-&gt; 즉, 상호작용이 있는 객체들의 연결과 구성을 보여준다. 메시지의 종류로는 동기, 비동기, 리턴, 생성 및 삭제 메시지가 있다. 시퀀스 다이어그램에서 참여 요소는 생명선의 아래를 향해 가면서메시지를 주고 받는다. 통신 다이어그램은 참여 요소, 통신 링크와 메시지로 구성된다. 참고 자료 UML을 활용한 시스템 분석 설계, 최은만, 2010, 생능출판사 UML을 활용한 객체지향 분석 설계, 그래디 부치 등, 에이콘출판사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"상호작용 다이어그램","slug":"상호작용-다이어그램","permalink":"https://JihyeHwang09.github.io/tags/상호작용-다이어그램/"}]},{"title":"액티비티 다이어그램","slug":"se-11","date":"2019-05-14T15:00:04.000Z","updated":"2019-05-15T14:00:58.675Z","comments":true,"path":"2019/05/15/se-11/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/15/se-11/","excerpt":"","text":"11강. 액티비티 다이어그램 액티비티 다이어그램에 대해 알아보자. 주요 용어 액티비티: 일련의 액션들로 구성된 상위 개념의 작업 프로세스 액션: 액티비티의 구성단위로 분해될 수 없는 단일 작업을 말한다.오퍼레이션의 호출, 시그널의 전송, 객체의 생성이나 소멸 및 단순 계산 등을 의미한다. 시그널: 외부와의 상호작용을 의미한다.외부의 사람, 시스템, 또는 프로세스로 보내는 메시지나그들로부터 받는 메시지를 표현한다. 객체: 액션들 사이에서 전달되는 데이터이다. 액티비티 다이어그램: 액션(또는 액티비티), 제어 흐름, 데이터 객체 등으로구성되는 UML 다이어그램으로 동적 행위 또는 작업 과정을 표현한다. 정리하기 액티비티 다이어그램은 작업 수행에 필요한 일련의 액션들과그들의 제어 흐름을 표현하는 다이어그램이다. 액티비티는 일련의 액션들과 제어 흐름 및 여러 요소들을 포함하는 것으로액션의 상위 개념이다. 액션은 액티비티 수행을 위한 단일 작업을 의미하며더 이상 분해할 수 없는 작업 단위이다. 제어 흐름은 앞선 액션이 완료된 후 다음 액션이 시작되는 것이며,객체 흐름은 앞선 액션의 출력이 다음 액션의 입력으로 사용된다는 의미이다. 포크로부터 둘 이상의 작업 흐름이 진행될 수 있으며 이것들은 동시에 수행된다. 동시 수행되었던 둘 이상의 작업들은 동기화를 위해 조인으로 합쳐진다. 확장 영역은 배열과 같은 것에 포함된 모든 요소들에 대해서,반복적으로 각각 처리하는 액션들을 하나의 영역으로 묶은 것이다. 액션의 행위 주체를 구분하기 위해 파티션(또는 스윔레인)을 사용한다. 참고 자료 새로 쓴 소프트웨어 공학, 최은만, 2014, 정익사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"액티비티 다이어그램","slug":"액티비티-다이어그램","permalink":"https://JihyeHwang09.github.io/tags/액티비티-다이어그램/"}]},{"title":"유스케이스 다이어그램 및 명세","slug":"se-10","date":"2019-05-14T08:37:34.000Z","updated":"2019-05-14T08:52:12.858Z","comments":true,"path":"2019/05/14/se-10/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/14/se-10/","excerpt":"","text":"10강. 유스케이스 다이어그램 및 명세 유스케이스 다이어그램 및 명세에 대해 알아보자. 주요 용어 유스케이스: 사용자 입장에서 시스템의 동작을 기술한 시나리오.시스템의 유사 기능을 나타내는 모든 구체적 시나리오들을 일반적이고 구조적으로 표현함 유스케이스 다이어그램: UML 다이어그램 중 하나로 시스템 외부의 액터와 시스템이 제공하는 기능인 유스케이스를 추상화하여 상호작용을 표현함 그림 요구사항: 문제 해결이나 목적 달성을 위해 사용자가 필요로 하는조건이나 능력으로 시스템이 제공해야 하는 것 요구사항 분석: 자연어로 작성된 요구사항이 정확하고 완전하며일관성이 있는지 검토하여 수정하는 작업 유스케이스 분석: 자연어로 작성된 요구사항을 유스케이스를 사용하여구조화한 후 이것을 보다 정형화하고 구체화하는 작업 정리하기 유스케이스는 완성될 목표 시스템의 사용 시나리오이며 기능 요구사항에 해당한다. 유스케이스는 사용자의 관점에서 기술해야 하고,어떻게(How)보다는 무엇(What)에 초점을 맞추어야 한다. 액터는 구현 대상은 아니며, 시스템과 상호작용하는 사람이나외부의 시스템을 의미한다. 액터는 유스케이스를 시작시키거나 정보를 제공할 수도 있으며또 결과를 제공 받을 수 있다. 유스케이스 간의 주요 관계에는 include, extend, generalize 등이 있다. 시스템 경계를 이용하여 분석 대상을 외부 요소와 구별 지을 수 있다. 유스케이스 명세는 각 유스케이스 별로 구체적인 시나리오를 담고 있는 문서이다. 참고 자료 새로 쓴 소프트웨어 공학, 최은만, 2014, 정익사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"유스케이스 다이어그램","slug":"유스케이스-다이어그램","permalink":"https://JihyeHwang09.github.io/tags/유스케이스-다이어그램/"}]},{"title":"객체지향 분석과 설계","slug":"se-9","date":"2019-05-12T15:00:30.000Z","updated":"2019-05-12T13:02:38.120Z","comments":true,"path":"2019/05/13/se-9/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/13/se-9/","excerpt":"","text":"9강. 객체지향 분석과 설계 객체지향 분석과 설계에 대해 알아보자. 주요 용어 OOA / OOD: 객체지향 분석과 설계로 상호작용하는 객체들로 시스템을 모델링하는 방법이다.분석 과정에서는 문제 도메인을 분석하여다루어야 하는 정보들에 관한 개념 모델을 작성하는 것에주안점을 둔다. 유스케이스: 사용자와 시스템 간의 일련의 상호 작용또는 사용자 입장의 사용 시나리오로서 시스템이 제공하는 기능적 요구사항을 의미한다. 객체 설계: 시스템 설계 후에 클래스를 설계하는 작업이다.클래스에 대한 자료구조를 하고 각 오퍼레이션에 대한 알고리즘과 인터페이스가 정의된다. 엔터티 / 경계 / 제어 객체:엔터티 객체는 시스템이 유지해야 하는 정보를 표현하고,경계 객체는 시스템의 인터페이스를 의미하며,제어 객체는 유스케이스를 실현하는 객체이다. UP와 RUP: UP은 유스케이스 기반이며 아키텍처 중심적인반복적이고 점증적 개발을 위한 프로세스 프레임워크이며,RUP는 UP를 상세히 다듬은 버전으로, 프로세스를 HTML로 문서화하여 사용화한 제품이다. 정리하기 객체지향 분석과 설계 과정에서 UML을 사용하여 모델을 작성한다. 유스케이스는 해당 기능의 여러 구체적 시나리오들을 일반화하여 명세한 것이다. 객체지향 분석의 동적 모델은 시퀀스 다이어그램과 상태 머신 다이어그램으로 표현된다. 유스케이스 간의 관계로는 확장, 포함, 상속 관계가 있다. 시스템 설계 과정에서 프로젝트의 설계 목표와 시스템 아키텍처를 정한다. 객체 설계 단계에서 문제 도메인의 객체를 솔루션 객체로 변환된다. UP는 유스케이스 기반의 아키텍처 중심적 프로세스로 위험 관리를 중요시 한다. 참고 자료 새로 쓴 소프트웨어 공학, 최은만, 2014, 정익사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"객체지향 분석과 설계","slug":"객체지향-분석과-설계","permalink":"https://JihyeHwang09.github.io/tags/객체지향-분석과-설계/"}]},{"title":"소프트웨어 유지보수","slug":"se-8","date":"2019-05-12T12:27:27.000Z","updated":"2019-05-12T12:38:19.447Z","comments":true,"path":"2019/05/12/se-8/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/12/se-8/","excerpt":"","text":"8강. 소프트웨어 유지보수 소프트웨어 유지보수에 대해 알아보자. 주요 용어 소프트웨어 유지보수: 고객에게 인도되어 사용 중에 있는 소프트웨어를 환경 적응, 오류 수정, 성능 향상, 유지보수성 향상 등을 위하여 계속하여 수정, 보완하는 일 재공학: 레가시 시스템의 이해성을 높이고 유지보수성, 재사용성 등을 개선하기 위해 소프트웨어를 변경하는 작업 역공학: 소프트웨어 요소를 분석하여 높은 추상 수준의 표현을 유도하는 작업 코드 스멜: 소스 코드에 존재하고 있는 문제를 일으킬 수 있는 나쁜 부분 소프트웨어 형상관리: 소프트웨어 요소들의 관련성을 파악하고 그것들의 버전들을 일관성 있게 관리함으로써 소프트웨어 시스템의 진화를 통제하는 일 정리하기 소프트웨어 유지보수 유형은 수정, 적응, 완전, 예방 유지보수로 구분된다. 소프트웨어 재공학은 아키텍처의 변화 없이 소프트웨어의 이해성과 유지보수성을 높이도록 시스템을 수정하는 것이다. 재구조화란 같은 추상 수준에서 코드나 문서의 형태를 바꾸는 작업이다. 역공학은 프로그램이나 사용자 매뉴얼로부터 초기 단계 생성물인 기능 명세나 설계 문서 등을 생성하는 과정을 의미한다. 코드 스멜은 설계나 코딩 작업이 잘못되었다는 징후이며 리팩토링이 필요한 이유이다. 소프트웨어 형상 관리는 소프트웨어에 가해지는 변경을 제어하고 관리하는 일이다. 사이클로매틱 수와 소프트웨어 사이언스는 소스 코드의 복잡도를 측정하는 척도이다. 참고 자료 새로 쓴 소프트웨어 공학, 최은만, 2014, 정익사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"소프트웨어 유지보수","slug":"소프트웨어-유지보수","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-유지보수/"}]},{"title":"소프트웨어 설계","slug":"se-7","date":"2019-05-11T07:00:23.000Z","updated":"2019-05-11T13:47:16.306Z","comments":true,"path":"2019/05/11/se-7/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/11/se-7/","excerpt":"","text":"7강. 소프트웨어 설계 소프트웨어 설계에 대해 알아보자. 주요 용어 소프트웨어 아키텍처: 소프트웨어 구조를 말하며 시스템을 구성하는 요소들과 그들간의 관계를 의미한다. 아키텍처 스타일: 유사한 애플리케이션들에 적용되는 공통적인 아키텍처 패턴으로 같은 부류의 시스템을 설계할 때 초안으로 사용될 수 있는 아키텍처 구조적 설계: 데디터 흐름을 분석하여 시스템을 기능적으로 분해하는 전통적 설계 방법 결합도와 응집력: 결합도는 두 모듈 간의 상호 의존성 정도를 의미하며, 응집력은 한 모듈이 가지는 기능적 집중성에 관한 상대적 척도 정리하기 아키텍처 모델은 시스템 구성 요소들과 이들 간의 관계를 표현한다. 소프트웨어 아키텍처는 비기능적 요구사항과 큰 관련을 가진다. 저장소 모델은 공유된 데이터베이스에 기초한 데이터 중심 아키텍처이다. 클라이언트 - 서버 아키텍처는 분산 시스템에 적용되는 아키텍처이다. 계층형 아키텍처는 추상화 원리를 적용한 구조이다. 구조적 설계는 변환 분석과 트랜잭션 분석에 의해 데이터 흐름도로부터 구조도를 유도한다. 높은 응집력을 가지고 다른 모듈과 느슨하게 결합되는 모듈을 설계해야 한다. 참고 자료 새로 쓴 소프트웨어 공학, 최은만, 2014, 정익사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"소프트웨어 설계","slug":"소프트웨어-설계","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-설계/"}]},{"title":"사용자 요구 분석","slug":"se-6","date":"2019-05-10T07:00:23.000Z","updated":"2019-05-10T07:16:44.151Z","comments":true,"path":"2019/05/10/se-6/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/10/se-6/","excerpt":"","text":"6강. 사용자 요구 분석 사용자 요구 분석에 대해 알아보자. 주요 용어 FURPS+: HP에서 정의한 요구사항 분류 모델로 F는 기능적 요구사항을 의미하며나머지는 비기능적 요구사항인 사용성, 신뢰성, 성능, 지원성 및 제약조건을 의미한다. 요구 공학: 시스템의 목표와 기능 및 제약사항을 결정하는 과정으로시스템 요구사항을 만들고 유지하기 위한 반복적 프로세스를 말한다. JAD: 애플리케이션 설계와 개발 과정에 고객과 사용자를 참여시키는 방법.고객과 개발자 간의 협력과 합의를 위해 워크숍을 진행한다. 객체지향 분석: 객체를 식별하고 객체 간의 관계를 바탕으로 요구사항을 분석하는 방법.클래스 다이어그램, 상태 다이어그램, 시퀀스 다이어그램 등으로분석 과정의 결과물을 표현한다. 시스템 모델: 시스템 명세를 문서화할 때,다양한 관점에서 시스템의 모습을 표현하기 위해 사용되는 모델 정리하기 요구 공학은 시스템 요구사항 문서를 만들고 유지하기 위한 프로세스이다. JAD는 애플리케이션의 설계와 개발 과정에 고객과 사용자를 참여시키는 방법이다. 요구사항 검토 과정에서 요구사항의 완전성, 일관성, 명확성 등을 검증한다. 요구사항 관리는 요구사항의 변화를 이해하고 통제하는 프로세스이다. 유스케이스는 사전 조건, 사후 조건 및 예외 사항을 포함하여시스템의 동작에 관한 시나리오들을 기술한 문서이다. 객체지향 분석은 시스템을 기능 모델, 분석 객체 모델, 동적 모델로 표현한다. 구조적 분석의 데이터 흐름도는 정보의 흐름과 정보의 변환을 표현하며데이터 사전과 함께 시스템의 기능 측면을 모델링한다. 참고 자료 새로 쓴 소프트웨어 공학, 최은만, 2014, 정익사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"사용자 요구 분석","slug":"사용자-요구-분석","permalink":"https://JihyeHwang09.github.io/tags/사용자-요구-분석/"}]},{"title":"소프트웨어 테스트","slug":"se-5","date":"2019-05-08T15:00:04.000Z","updated":"2019-05-08T15:41:05.228Z","comments":true,"path":"2019/05/09/se-5/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/09/se-5/","excerpt":"","text":"5강. 소프트웨어 테스트 소프트웨어 테스트에 대해 알아보자. 주요 용어 결함 테스트 / 검증 테스트:결함 테스트는 소규모 코드에서 결함을 찾고자 하는 것이며검증 테스트는 고객이 원하는 것인지를 보이기 위한 고수준 테스트 화이트박스 테스트: 프로그램의 논리 구조에 바탕을 두고 테스트하는 것으로구조 테스트라고도 한다. 테스트케이스 선정기준: 화이트박스 테스트 방식에서 테스트케이스들이 얼마나 적정한지를 판단하는 기준으로문장, 분기, 조건 검증 기준 등이 있다. 블랙박스 테스트: 명세서에 기초하여 입력 데이터를 선정한 후 출력 결과를 조사하여프로그램의 기능을 테스트하는 것으로 기능 테스트라고도 한다. 회귀 테스트: 프로그램의 수정으로 생길 수 있는 새로운 오류의 발생여부를 밝히기 위한 테스트 정리하기 소프트웨어 테스트는 단계별로 단위 테스트, 통합 테스트, 시스템 테스트로 구분된다. 통합 테스트는 개별 모듈들을 통합하여 테스트하면서 시스템을 구축해 나가는 기술이다. 화이트박스 테스트에서는 프로그램의 구조에 기초하여 테스트케이스를 개발한다. 화이트박스 테스트에서 테스트케이스 선정 기준으로는문장 검증 기준, 분기 검증 기준, 조건 검증 기준, 경로 검증 기준 등이 있다. 블랙박스 테스트에서는 동치 분할, 경계 값 분석, 원인-결과 그래프 방법 등을 사용하여테스트 데이터를 개발한다. 성능 테스트는 평균 응답 시간이나 처리율 등의 서능 요인들을 파악하기 위한 테스트이다. 시스템으로 통합된 후 성능, 신뢰성, 안전성, 사용성 등의 비기능적 요구사항을 테스트한다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"소프트웨어 테스트","slug":"소프트웨어-테스트","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-테스트/"}]},{"title":"소프트웨어 품질","slug":"se-4","date":"2019-05-07T15:00:04.000Z","updated":"2019-05-10T07:13:27.485Z","comments":true,"path":"2019/05/08/se-4/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/08/se-4/","excerpt":"","text":"4강. 소프트웨어 품질 소프트웨어 품질에 대해 알아보자. 주요 용어 ISO / IEC9126: 소프트웨어 제품의 품질 특성들과 메트릭을 정의한 표준 CMMI: 조직의 개발 프로세스 능력과 성숙도를 평가하기 위한 모델 SQA(소프트웨어 품질 보증): 소프트웨어 개발 과정에서 품질 수준을보증하기 위해 수행하는 품질 관리 활동 V&amp;V(확인과 검증): 전체 생명 주기에 걸쳐 소프트웨어가 명세에 맞게작성되었는지 확인하고 고객의 요구를 충족하는지 검증하는 활동 소프트웨어 신뢰도: 주어진 환경에서 의도된 기능을 고장 없이 수행할 수 있는 소프트웨어 능력 정리하기 소프트웨어 제품의 외부 품질 특성은 사용자 관점의 품질 특성이며,내부 품질 특성은 개발자 관점의 특성이다. ISO / IEC9126은 사용자 관점에서 제품의 품질 특성을 여섯 개로 분류하며각각은 다시 여러 부분 특성들로 구성된다. CMMI는 조직의 개발 프로세스 역량과 성숙도를 평가하는 모델로프로세스 개선을 위한 프레임워크를 제공한다. 소프트웨어 품질 보증은 사용자가 원하는 품질 수준을 보증하기 위해수행하는 품질 관리 활동을 말한다.ㅌ 확인과 검증(V&amp;V)을 위해 정적인 검토 방법과동적인 소프트웨어 테스트가 보완적으로 사용된다. 인스펙션은 설계 문서나 코드를 요구사항이나 표준과 비교 검사하여오류를 찾아내는 조직화되고 형식을 갖춘 검토 방법이다. 참고 자료 새로 쓴 소프트웨어 공학, 최은만, 2014, 정익사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"소프트웨어 품질","slug":"소프트웨어-품질","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-품질/"}]},{"title":"프로젝트 관리","slug":"se-3","date":"2019-05-07T12:28:04.000Z","updated":"2019-05-10T07:13:31.699Z","comments":true,"path":"2019/05/07/se-3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/07/se-3/","excerpt":"","text":"3강. 프로젝트 관리 프로젝트 관리에 대해 알아보자. 주요 용어 인원 - 월(PM): 작업 양의 단위로,1PM은 보통 수준의 1인이 1개월간 수행해야 하는 작업 양 WBS- 프로젝트 수행을 위한 개발 업무를 세분화하여 계층구조로 표현한 것 CPM- 작업들의 순서를 정하고 임계경로에 기초하여 프로젝트의 일정을 계획하기 위한 방법 COCOMO- 프로그램의 규모를 가지고 프로젝트 비용을 산정하는 방법 위험 관리 - 발생 가능한 위험 요인들을 예측하고 영향력을 분석하여대책을 계획하고 감독하는 것 정리하기 프로젝트 관리자는 프로젝트를 계획하고 계획된 시간과 예산에 맞춰개발이 진행되는지 감독해야 한다. 이정표는 개별 활동의 종료 시점또는 주요 단게의 종료 시점에서 얻어지는 중간산출물로 프로젝트 관리를 위해 필요하다. WBS는 개발 단계나 개발 업무를 분할하여 계층적으로 표현한다. CPM을 사용하여 개발 일정을 수립하고 간트 차트로 도표화 한다. 기능 점수 방법은 소프트웨어가 제공하는 기능을 계량화한 소프트웨어 규모의 척도이다. 중급 COCOMO는 프로그램의 규모 외에 비용 승수를 고려하여 노력과 비용을 추정한다. 상세 COCOMO는 개발 단계와 서브시스템 별로 구분하여 노력을 추정한다. 발생 가능한 위험 요인들을 예측하고 영향력을 분석하여 대책을 계획하고 감독하는 것을위험 관리라고 한다. 참고 자료 새로 쓴 소프트웨어 공학, 최은만, 2014, 정익사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"프로젝트 관리","slug":"프로젝트-관리","permalink":"https://JihyeHwang09.github.io/tags/프로젝트-관리/"}]},{"title":"마크다운(markdown) 문서에 체크박스 추가하기","slug":"TIL-2019-05-06","date":"2019-05-05T15:00:01.000Z","updated":"2019-05-06T14:45:17.288Z","comments":true,"path":"2019/05/06/TIL-2019-05-06/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/06/TIL-2019-05-06/","excerpt":"","text":"To-do List를 마크다운(markdown) 문서로 작성할 때,사용하기 좋은 체크박스(check-box) 넣는 방법에 대해 알아보자. 빈 체크박스를 만들고 싶다면, - [ ]를 넣으면 된다. 처음에 - [] 이렇게 작성했더니 []가 화면에 뜨고 체크박스로 보여지지 않았다. 주의할 점은 빈 체크박스를 만들 때는 [] 사이를 한 칸 띄워줘야 한다는 것이다. - [X]를 넣으면 완료된 체크박스를 넣을 수 있다. 이때, 소문자 x이든 대문자 X이든 둘 다 사용가능하다. 정리하기 빈 체크박스 만들기 1) [] 사이를 띄어쓰지 않고 체크박스를 만들려고 한 경우(잘못된 예시) [] learn the GraphQL 2) [ ] 사이를 한 칸 띄워 체크박스 만들기 learn the GraphQL 완료된 체크박스 만들기 1) 소문자 x로 체크박스 만들기 Setting the Server 대문자 X로 체크박스 만들기 Setting the Server","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://JihyeHwang09.github.io/tags/markdown/"},{"name":"check-box","slug":"check-box","permalink":"https://JihyeHwang09.github.io/tags/check-box/"}]},{"title":"yarn init error- \"Can't answer a question unless a user TTY\"","slug":"TIL-2019-05-05","date":"2019-05-04T15:00:01.000Z","updated":"2019-05-12T15:23:48.242Z","comments":true,"path":"2019/05/05/TIL-2019-05-05/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/05/TIL-2019-05-05/","excerpt":"","text":"yarn init 명령어를 입력한 후 발생한 에러에 대해 알아보자. Git Bash에 yarn init을 입력했더니 위와 같이 Error가 뜬다. 해결 방법: Git Bash가 아닌 명령 프롬프트(CMD)에 yarn init을 입력하면에러 없이 yarn init을 실행할 수 있다. 참고 링크 [yarn] init이 안될 때 (yarn init error - Can’t answer a question a user TTY)","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"yarn init error","slug":"yarn-init-error","permalink":"https://JihyeHwang09.github.io/tags/yarn-init-error/"},{"name":"Can't answer a question unless a user TTY","slug":"can-t-answer-a-question-unless-a-user-tty","permalink":"https://JihyeHwang09.github.io/tags/can-t-answer-a-question-unless-a-user-tty/"}]},{"title":"소프트웨어 프로세스","slug":"se-2","date":"2019-05-04T10:37:56.000Z","updated":"2019-05-10T07:13:36.300Z","comments":true,"path":"2019/05/04/se-2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/04/se-2/","excerpt":"","text":"2강. 소프트웨어 프로세스 소프트웨어 프로세스에 대해 알아보자. 주요 용어 소프트웨어 프로세스 모델: 실제 소프트웨어 프로세스를 추상화하여 간략히 표현한 것 폭포수 모델: 전통적 소프트웨어 개발 프로세스 모델로 선형 순차 모델 알파 테스트: 완전히 개발된 시스템을 개발 현장에서 테스트하는 것으로 주문형 제품의 경우 개발자와 고객 사이에 인수에 대한 동의가 이루어질 때까지 수행한다. V 모델: 폭포수 모델의 확장된 형태로 분석이나 설계 등의 개발 단계마다 상응하는 테스트 단계가 존재하는 소프트웨어 프로세스 모델 애자일 방법: 변화를 수용하고 현업을 강조하며 제품의 빠른 인도를 강조한 반복적이고 점증적인 소프트웨어 개발 방법 정리하기 소프트웨어 프로세스는 소프트웨어 개발 또는 유지보수를 위해 수행되는 활동들의 절차이다. 프로세스 모델은 실제 프로세스의 추상화된 요약 표현으로 실제 프로세스의 골격이다. 폭포수 모델은 전통적 개발 모델로 기본적으로 각 단계에서 수행되는 활동들이 거슬러 반복됨 없이 한 방향으로 진행된다. 점증적 모델에서 소프트웨어는 요구사항의 중요도에 따라 여러 개의 모듈들로 분해되어 계획되고, 각각은 점증적으로 개발되어 인도된다. 애자일 개발 방법은 품질의 저하 없이 변화를 수용하고, 협업을 강조하며, 제품의 빠른 인도를 강조하는 반복적 방법이다. 익스트림 프로그래밍은 개발 주기의 잦은 반복과 짧은 배포 주기, 빠른 피드백, 이를 통한 지속적인 개선 등을 주장하는 방법이다. 테스트 선행 개발은 테스트 케이스를 먼저 작성한 다음, 이것을 통과하는 코드를 만드는 것이다. 참고 자료 새로 쓴 소프트웨어 공학, 최은만, 2014, 정익사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"},{"name":"소프트웨어 프로세스","slug":"소프트웨어-프로세스","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-프로세스/"}]},{"title":"운영체제 사례","slug":"os-15","date":"2019-05-03T13:44:45.000Z","updated":"2019-05-03T14:07:18.607Z","comments":true,"path":"2019/05/03/os-15/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/03/os-15/","excerpt":"","text":"15강. 운영체제 사례 운영체제 사례에 대해 알아보자. 주요 용어 임베디드 시스템: 미리 정해진 특정한 기능들을 수행하기 위해하드웨어와 소프트웨어가 결합된 특수 목적 컴퓨터 시스템 POSIX: 유닉스 시스템의 표준 인터페이스 Hard real-time system: 정해진 시간 내에 작업한 결과가절대적으로 출력되어야 하는 실시간 시스템 Soft real-time system: 정해진 시간 내에 작업의 결과가나오지 않더라도 심각한 시스템 에러로 보지 않는 실시간 시스템 정리하기 리눅스 커널은 일체형 구조이며, GNU GPL하에 커널 소스를 공개한다. 임베디드 시스템이란 미리 정해진 특정한 기능들을 수행하기 위해하드웨어와 소프트웨어가 결합된 특수 목적 컴퓨터 시스템이다. 실시간 운영체제는 정해진 시간 내에 필요한 결과를 얻을 수 있어야 한다. Windows 1.0은 퍼스털 컴퓨터에서 GUI 환경을 제공하기 위한 운영 환경 Windows 95부터 32비트 운영체제의 형태를 갖추었다. Windows 9x 계열은 가정용 PC를 위한 운영체제,Windows NT는 서버 및 사무용 데스크톱 운영체제로 활용된다. Windows NT는 멀티 쓰레드 마이크로 커널 기반 수정 마이크로 커널 운영체제이다. NT의 커널, 실행부 서브시스템, 커널 드라이버, 윈도우 관리자, 가상 메모리 관리자 등운영체제의 대부분의 기능을 포함한다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"운영체제 사례","slug":"운영체제-사례","permalink":"https://JihyeHwang09.github.io/tags/운영체제-사례/"}]},{"title":"운영체제 보안","slug":"os-14","date":"2019-05-02T02:54:38.000Z","updated":"2019-05-02T03:05:57.532Z","comments":true,"path":"2019/05/02/os-14/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/02/os-14/","excerpt":"","text":"14강. 운영체제 보안 운영체제 보안에 대해 알아보자. 주요 용어 보호영역: 한 프로세스가 접근할 수 있는 자원을 의미 변조: 인가받지 않는 제3자가 자원에 접근하여 내용을 변경하는 것 위조: 인가받지 않는 제3자가 위조물을 삽입하는 것 트랩도어: 고의로 만들어 놓은 시스템의 보안이 제거된 비밀 통로 비밀 채널: 중요한 정보나 자료를 얻어 내기 위한 정상적인 데이터 전송 메커니즘이 아닌 비밀 통로 암호화: 인가되지 않은 것들에게는 정보 접근을 제한하기 위해 정보를 변형시키는 과정 공개키: 공개키 암호화 방식에서 암호화에 사용되는 키를 말한다. 개인키: 공개키 암호화 방식에서 복호화에 사용되는 키를 말한다. 인증 및 식별: 사용자를 구분(식별)하고 확인(인증)하는 것 접근제어: 사용자 및 자원의 접근권한 수준을 관리 정리하기 운영체제 보안의 기본 목표는 기밀성, 무결성, 가용성의 세 가지이다. 정보 침해 위협 요소로는 흐름 차단, 가로채기, 변조, 위조 등이 있다. 임의적 접근제어는 개별 사용자가 자율적 판단에 따라 보유하고 있는자원의 접근 권한을 다른 사용자에게 부여하는 기법이다. 강제적 접근제어는 각각의 객체의 비밀등급,개별 사용자의 허가등급에 따라 제어가 이루어진다. 역할 기반 접근통제에서는 사용자는 역할의 멤버가 됨으로써 권한을 배정받는다. 비밀키 암호 알고리즘은 사용된 키를 일반에게 공개하지 않고,이 키를 아는 자만이 볼 수 있도록 하는 알고리즘이다. 공개키 암호화 방식에서는 암호화에 공개키를,복호화에 개인키를 사용한다. 참조 모니터는 주체와 객체의 접근권한을 정의한데이터베이스를 참조하여 보안 정책을 수행한다. 벨 - 라파듈라 모델은 상위 보안 수준에서 하위 보안 수준으로정보가 흐르는 것을 방지하는 것에 관심을 둔다. 비바 모델은 정보가 하위 보안 수준에서 상위 보안 수준으로흐르는 것을 방지하는 것에 관심을 둔다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"분산 운영체제","slug":"분산-운영체제","permalink":"https://JihyeHwang09.github.io/tags/분산-운영체제/"}]},{"title":"분산 운영체제","slug":"os-13","date":"2019-04-30T15:24:55.000Z","updated":"2019-05-01T14:08:39.729Z","comments":true,"path":"2019/05/01/os-13/","link":"","permalink":"https://JihyeHwang09.github.io/2019/05/01/os-13/","excerpt":"","text":"13강. 저장장치 및 파일 분산 운영체제에 대해 알아보자. 주요 용어 분산 파일 시스템: 클라이언트가 서버에 저장된 파일을 마치 로컬 파일인 것처럼처리할 수 있는 클라이언트 / 서버 기반 파일 시스템 분산 메모리: 분산 시스템에 연결된 컴퓨터들이 메모리를 공유할 수 있도록 하는 구조 원격 프로시저 호출: 한 컴퓨터에서 작동하고 있는 애플리케이션이다른 컴퓨터에 있는 프로시저를 호출할 수 있도록 클라이언트 / 서버 메커니즘 스텁(stub) 루틴: 원격 프로시저 호출에서 파라미터 전달을 담당하는 루틴 정리하기 분산 시스템은 네트워크를 통해 서로 약하게 결합된 프로세서들의 집합으로,프로세서들은 각자의 메모리와 클럭을 사용한다. 분산 시스템의 목적은 자원 공유, 연산속도 향상, 통신의 용이성이다. 분산 운영체제는 사용자가 로컬 자원을 사용하는 것과동일한 방식으로 원격 자원을 사용할 수 있도록 한다. 분산 파일 시스템은 클라이언트가 서버에 저장된 파일을마치 로컬 파일인 것처럼 처리할 수 있도록 한다. 분산 메모리는 분산 시스템에 연결된 컴퓨터들이 메모리를 공유할 수 있도록 하는 구조이다. 원격 메모리는 논리적 메모리를 정의하고 공유하도록 하는메모리 API를 통해 분산 메모리를 구현한다. 분산 공유 메모리는 로컬 컴퓨터의 페이징 시스템을 확장하여 분산 메모리를 구현한다. 원격 프로시저 호출(RPC)를 통해 한 컴퓨터에서 작동하는 애플리케이션이다른 컴퓨터에 있는 프로시저를 호출할 수 있다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"분산 운영체제","slug":"분산-운영체제","permalink":"https://JihyeHwang09.github.io/tags/분산-운영체제/"}]},{"title":"저장장치 및 파일","slug":"os-12","date":"2019-04-30T03:24:05.000Z","updated":"2019-04-30T03:31:02.755Z","comments":true,"path":"2019/04/30/os-12/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/30/os-12/","excerpt":"","text":"12강. 저장장치 및 파일 저장장치 및 파일에 대해 알아보자. 주요 용어 순차접근: 순차적으로 기록 및 판독을 하는 경우 직접접근: 위치를 지정하여 데이터를 직접 읽거나 쓸 수 있는 경우 FCFS: 먼저 도착한 요구가 먼저 서비스를 받음 SSTF: 마지막으로 서비스 받은 요구에 가장 인접한 요구를 먼저 서비스 SCAN: 현재의 진행 방향에 있는 모든 요구를 서비스하고 진행 방향의 마지막 실린더까지 진행한 후 방향을 바꾸어 동일하게 서비스 LOOK: 진행 방향에서 앞을 보고 서비스 요구가 없을 경우 더 이상 마지막 트랙까지 이동하지 않도록 함 SLTF: 디스크 암이 특정 실린더에 도착하면 가장 짧은 회전지연을 갖는 요구를 우선적으로 서비스 순차파일: 레코드가 물리적 순서에 따라 저장되어 있는 파일 인덱스된 순차 파일: 레코드가 각 레코드의 키를 기준으로 한 논리적 순서대로 비열되어 있는 파일 직접 파일: 레코드의 물리적 주소를 통해 직접 액세스되는 파일 정리하기 저장장치는 순차접근 저장장치와 직접접근 저장장치로 나뉜다. 직접접근 저장장치인 자기 디스크의 접근시간은 탐구시간, 회전지연시간, 전송시간으로 구성된다. 디스크 스케줄링은 디스크 접근 요구를 효율적으로 처리하는 작업으로, 탐구시간을 최소화하는 것이 중요하다. SSTF는 마지막으로 서비스 받은 요구에 가장 인접한 요구를 먼저 서비스하는 방법이다. SCAN은 현재의 진행 방향에 있는 모든 요구를 서비스하고 진행 방향의 마지막 실린더까지 진행한 후 방향을 바꾸어 동일하게 서비스하는 방법이다. N-Step SCAN은 새로이 도착하는 요구들은 다음번 되돌아올 때 서비스를 받도록 하는 방법이다. C-SCAN은 정해진 한 방향으로의 진행이 완료되면 디스크의 반대편 끝으로 점프한 후 다시 같은 방향으로 진행하며 서비스하는 방법이다. LOOK과 C-LOOK은 진행 방향에서 앞을 보고 서비스 요구가 없을 경우 더 이상 마지막 트랙까지 이동하지 않도록 하는 방법이다. SLTF는 회전시간 최적화를 위한 알고리즘으로, 일단 디스크 암이 특정 실린더에 도착하면 가장 짧은 회전지연을 갖는 요구를 우선적으로 서비스하는 방법이다. 파일 관리자는 파일의 생성, 수정, 삭제 연산, 파일의 공유 및 접근제어, 백업, 정보 보호 등의 기능을 수행한다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"저장장치 및 파일","slug":"저장장치-및-파일","permalink":"https://JihyeHwang09.github.io/tags/저장장치-및-파일/"}]},{"title":"장치 관리","slug":"os-11","date":"2019-04-29T03:24:05.000Z","updated":"2019-04-30T03:29:39.601Z","comments":true,"path":"2019/04/29/os-11/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/29/os-11/","excerpt":"","text":"11강. 장치 관리 장치 관리에 대해 알아보자. 주요 용어 전용장치: 한 번에 단지 하나의 프로세스에만 할당되는 장치 공용장치: 여러 프로세스에 할당될 수 있는 장치 가상장치: 디스크 등 공유가 가능한 장치를 이용하여 전용장치를 공용장치처럼 보이게 한다. 장치제어기: 장치를 직접적으로 다루는 전자장치 폴링: CPU가 입출력장치의 상태를 지속적으로 확인하여 CPU가 원하는 상태가 될 때까지 기다리는 방법 인터럽트: 어떤 장치가 다른 장치의 작업을 잠시 중단시키고 자신의 상태를 알리는 기능 DMA: CPU를 통하지 않고 직접 메모리에 접근하여 데이터를 전송하는 방법 사이클 스틸링: CPU와 DMA 제어기가 동시에 메모리를 액세스하려는 경우 DMA 제어기에 우선권을 주는 것 버퍼링: CPU의 데이터 처리 속도와 데이터 전송 속도의 차이로 인한 문제를 메모리의 일부를 일시적 데이터 저장 장소로 사용하는 버퍼를 이용하여 해결하는 방법 스풀링: 입출력의 속도를 높이기 위하여 입출력 프로세스와 저속 입출력장치 사이의 데이터 전송을 자기 디스크와 같은 고속 장치를 통하도록 하는 방법 정리하기 운영체제에서 장치 관리자는 시스템의 모든 주변기기를 관리하며 입출력의 균형을 유지한다. 장치는 일반적으로 전용장치, 공유장치, 그리고 가상장치의 세 가지 범주로 구분된다. 입출력이 발생하는 경우 이를 처리하는 방법으로 프로그램 방법, 인터럽트 방법, DMA 방법이 있다. 프로그램 방법은 CPU가 입출력장치의 상태를 지속적으로 확인하여 CPU가 원하는 상태가 될 때까지 기다리는 폴링을 이용하는 방법이다. 인터럽트 방법은 어떤 장치가 다른 장치의 작업을 잠시 중단시키고 자신의 상태를 알리는 인터럽트를 이용하는 방법이다. DMA는 DMA 제어기를 이용하여 CPU를 통하지 않고 직접 주기억장치에 접근하여 데이터를 전송하는 방법이다. 장치와는 독립적으로 입출력을 관리하는 방법으로 버퍼링과 스풀링이 있다. 버퍼링은 CPU의 데이터 처리 속도와 데이터 전송 속도의 차이로 인한 문제를 메모리의 일부를 일시적 데이터 저장 장소로 사용하는 버퍼를 이용하여 해결한다. 버퍼링에는 단일 버퍼링, 이중 버퍼링, 순환 버퍼링이 있다. 스풀링은 입출력의 속도를 높이기 위하여 입출력 프로세스와 저속 입출력장치 사이의 데이터 전송을 자기 디스크와 같은 고속 장치를 통하도록 하는 방법이다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"장치 관리","slug":"장치-관리","permalink":"https://JihyeHwang09.github.io/tags/장치-관리/"}]},{"title":"가상 메모리(2)","slug":"os-10","date":"2019-04-28T14:59:26.000Z","updated":"2019-04-28T15:06:40.888Z","comments":true,"path":"2019/04/28/os-10/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/28/os-10/","excerpt":"","text":"10강. 가상 메모리(2) 지난 시간에 이어 가상 메모리에 대해 알아보자. 주요 용어 Belady의 이상현상(anomaly): 프로세스에 더 많은 수의 페이지 프레임을 할당할 경우오히려 페이지 부재가 더 많이 생길 수 있는 현상 국부성: 프로세스는 기억장치 내의 정보를 균일하게 액세스하는 것이 아니라어느 한순간에 특정 부분을 집중적으로 참조하는 특성 워킹세트: 어떠한 시점을 기준으로 정해진 크기의 과거 시간 구간 동안 참조된 페이지의 집합 쓰래싱(thrashing): 페이지 부재가 비정상적으로 많이 발생하여 프로그램의 처리보다페이지 교체에 너무 많은 시간을 소비함으로써 시스템의 처리량이 급격히 저하되는 현상 정리하기 페이지 교체기법은 메모리가 완전히 사용되고 있을 때 새로 적재되어야 할 페이지를 위하여어느 페이지가 교체되어야 하는지에 관계된다. 페이지 교체기법으로는 FIFO, LRU, LFU, NUR, 2차 기회, 클럭, 워킹세트, PFF 등이 있다. 최적의 페이지 교체기법은 앞으로 가장 오랫동안 사용되지 않을 페이지를 선택하는 방법이다. 프로세스는 기억장치 내의 정보를 균일하게 액세스하는 것이 아니라,어느 한 순간에는 특정 부분을 집중적으로 참조하는 국부성을 보인다. 워킹세트는 어떠한 시점을 기준으로 정해진 크기의과거 시간 구간 동안 참조된 페이지의 집합이다. 워킹세트 알고리즘은 프로개름의 효율적 실행을 위해워킹세트가 메모리 내에 유지되도록 한다. PFF 알고리즘의 기본 아이디어는 페이지 부재 비율이 높으면페이지 프레임을 더 배정하고, 낮으면 회수하는 것이다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"가상 메모리","slug":"가상-메모리","permalink":"https://JihyeHwang09.github.io/tags/가상-메모리/"}]},{"title":"가상 메모리","slug":"os-9","date":"2019-04-28T04:32:33.000Z","updated":"2019-04-28T05:00:53.688Z","comments":true,"path":"2019/04/28/os-9/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/28/os-9/","excerpt":"","text":"9강. 가상 메모리 가상 메모리에 대해 알아보자. 주요 용어 가상주소: 가상 메모리에서 실행 프로세스가 참조하는 주소 페이징 기법: 가상 메모리를 고정된 크기의 블록인 페이지 단위로 나누어 관리하는 기법 세그먼테이션 기법: 가상 메모리를 논리적 의미에 부합하는 다양한 크기의 세그먼트 단위로 나누어 관리하는 기법 동적 주소 변환: 프로세스가 실행되는 동안 가상주소를 실주소로 바꾸는 절차 정리하기 가상 메모리는 메모리 크기보다 더 큰 기억공간을 사용하는 프로세스를 실행할 수 있다. 프로세스에서 사용되는 가상주소는 동적 주소 변환을 통해 메모리의 실주소로 변환된다. 연속적인 가상주소가 실주소 공간에서도 연속적인 필요는 없다. 페이징 기법은 페이지라는 고정 크기 블록 단위로 기억장치를 관리한다. 세그먼테이션 기법은 모듈화에 따른 논리적 의미에 부합하는 다양한 크기의 세그먼트 단위로 기억장치를 관리한다. 요구 페이지 호출기법은 페이지가 필요한 시점에 메모리에 적재한다. 예상 페이지 호출기법은 앞으로 사용될 것으로 예상되는 페이지를 미리 메모리에 적재한다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"가상 메모리","slug":"가상-메모리","permalink":"https://JihyeHwang09.github.io/tags/가상-메모리/"}]},{"title":"메모리 관리","slug":"os-8","date":"2019-04-27T04:31:46.000Z","updated":"2019-04-28T04:58:49.060Z","comments":true,"path":"2019/04/27/os-8/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/27/os-8/","excerpt":"","text":"8강. 메모리 관리 메모리 관리에 대해 알아보자. 주요 용어 기억장치 계층구조: 적절한 비용으로 높은 성능을 낼 수 있도록 소량의 고속/고가 기억장치와 대량의 저속/저가 기억장치를 계층적으로 구성 연속 메모리 할당: 한 프로세스가 하나의 연속된 하나의 연속된 블록으로 메모리에 할당 다중 프로그래밍: 여러 프로세스가 메모리에 동시에 적재되는 것 단편화(fragentation): 프로세스의 크기가 메모리 분할 영역과 맞지 않아 메모리 공간이 사용되지 못하고 낭비되는 것 통합: 인접된 공백을 더 큰 하나의 공백으로 만듦 집약: 메모리 내의 모든 공백을 하나로 모음 정리하기 프로세스가 실행되기 위해서는 수행될 명령이 메모리상에 존재해야 한다. 컴퓨터 시스템의 기억장치는 적은 비용으로 높은 성능을 제공하기 위해 계층적으로 구성된다. 단일 프로그래밍 환경에서는 연속 메모리 할당기법은 관리기법이 단순하지만, 컴퓨터 자원을 효율적으로 사용하는 데 문제가 있다. 다중 프로그래밍을 통해 CPU와 주변장치의 이용률을 높일 수 있다. 고정 분할 방식은 정해진 크기의 분할 영역으로 메모리를 활용하는 방식으로 각 분할 영역에서 내부 단편화가 발생할 수 있다. 동적 분할 방식은 각각의 작업에 필요한 만큼의 메모리를 할당함으로써 내부 단편화를 제거하지만 외부 단편화가 발생할 수 있다. 외부 단편화는 통합과 집약기법으로 해결 가능하다. 메모리 배치기법은 프로세스를 메모리의 어디에 배치할 것인가 하는 결정과 관련되어 있으며, 최초 적합, 후속 적합, 최적 적합, 최악 적합 기법이 있다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"메모리 관리","slug":"메모리-관리","permalink":"https://JihyeHwang09.github.io/tags/메모리-관리/"}]},{"title":"교착상태(2)","slug":"os-7","date":"2019-04-25T15:00:58.000Z","updated":"2019-04-26T05:36:52.713Z","comments":true,"path":"2019/04/26/os-7/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/26/os-7/","excerpt":"","text":"7강. 교착상태(2) 지난 시간에 이어서 교착상태에 대해 알아보자. 주요 용어 안전 순서열: 가용자원, 또는 이전 프로세스에 할당된 자원을 이용하여 필요한 작업을 마칠 수 있는 프로세스의 순차적 순서열 은행원 알고리즘: 교착상태 회피를 위한 자원 할당 알고리즘으로,프로세스가 요구한 자원을 할당해 줄 경우 안전 순서열이 존재하는지를 검사하여 요구 수용 여부를 결정 정리하기 교착상태를 처리하는 방법은 교착상태를 방지하는 방법, 교착상태를 회피하는 방법,교착상태를 탐지하여 이를 복구하는 방법 등이 있다. 교착상태 회피 방법은 프로세스의 자원 사용에 대한 사전 정보를 활용하여교착상태가 발생할 수 있는 불안전상태가 되는 것을 피한다. 은행원 알고리즘은 프로세스가 요구한 자원을 할당해 줄 경우안전 순서열이 존재하는지를 검사하여 요구 수용 여부를 결정한다. 변형된 자원할당 그래프에서 선언간선을 할당간선으로 바꾸어도 사이클이 발생하지 않는 아전상태일 경우자원 요청을 수용한다. 교착상태 탐지 및 복구 방법은 교착상태가 발생하였는가를 탐지한 후,희생자를 선택하여 프로세스를 중지시키거나 자원을 선점한다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"교착상태","slug":"교착상태","permalink":"https://JihyeHwang09.github.io/tags/교착상태/"}]},{"title":"교착상태(1)","slug":"os-6","date":"2019-04-24T15:00:58.000Z","updated":"2019-04-25T12:39:49.492Z","comments":true,"path":"2019/04/25/os-6/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/25/os-6/","excerpt":"","text":"6강. 교착상태(1) 교착상태에 대해 알아보자. 주요 용어 교착상태: 2개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에결과적으로 아무것도 완료되지 못하는 상태 점유 대기: 프로세스가 이미 다른 자원을 할당받아 배타적으로 점유하고 있는 상황에서다른 프로세스가 점유하고 있는 자원이 해제되기를 기다리는 것 원형 대기: 프로세스의 자원 점유 및 점유된 자원의 요구 관계가 환형을 이루며 대기하는 것 정리하기 교착상태(deadlock)는 2개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에결과적으로 아무것도 완료되지 못하는 상태이다. 교착상태의 **필요조건**은 상호배제, 점유 대기, 비선점, 환형 대기 조건이며,이 조건들이 모두 만족될 경우 교착상태가 발생할 수 있다. 교착상태를 **처리**하는 방법은 교착상태를 방지하는 방법, 교착 상태를 회피하는 방법,교착상태를 탐지하여 이를 복구하는 방법 등이 있다. 교착상태를 **방지**하는 방법은 교착상태의 네 가지 필요조건 중 어느 하나라도 발생할 수 없도록 막는 방법이다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"교착상태","slug":"교착상태","permalink":"https://JihyeHwang09.github.io/tags/교착상태/"}]},{"title":"병행 프로세스(2)","slug":"os-5","date":"2019-04-23T15:00:58.000Z","updated":"2019-04-24T12:57:33.414Z","comments":true,"path":"2019/04/24/os-5/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/24/os-5/","excerpt":"","text":"5강. 병행 프로세스(2) 지난 시간에 이어서 병행 프로세스에 대해 알아보자. 주요 용어 생산자/소비자 문제: 유한 크기의 버퍼를 이용하여 데이터를 공급하는 처리와데이터를 사용하는 처리 과정을 병행 프로세스로 구현하는 다중처리 동기화 문제의 예 판독기/기록기 문제: 공유 메모리 영역에서 데이터를 읽어 데이터를 읽어 사용하는 판독기 프로세스들과 데이터를 기록하는 기록기 프로세스들 사이의 동기화 및 상호배제 문제 메시지 시스템: 메시지 교환 방식으로 프로세스 사이의 통신을 처리하는 시스템 정리하기 생산자/소비자 문제는 상호배제와 동기화가 필요한 문제로 세마포어를 이용하여 구현할 수 있다. 판독기/기록기 문제에서 판독기는 동시에 공유 데이터 객체에 접근할 수 있으나,기록기는 배타적 접근이 필요하다. 프로세스 사이의 통신은 공유기억장치나 메시지 교환방식을 이용하여 구현한다. 메시지 전달은 수신자나 송신자의 이름을 명시하여 직접 통신을 하거나,우편함을 통한 간접 통신을 통해 이루어진다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"병행 프로세스","slug":"병행-프로세스","permalink":"https://JihyeHwang09.github.io/tags/병행-프로세스/"}]},{"title":"병행 프로세스(1)","slug":"os-4","date":"2019-04-22T15:02:58.000Z","updated":"2019-04-22T15:06:35.288Z","comments":true,"path":"2019/04/23/os-4/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/23/os-4/","excerpt":"","text":"4강. 병행 프로세스(1) 병행 프로세스에 대해 알아보자. 주요 용어 병행성(concurrency): 여러 개의 프로세스 또는 쓰레드가 동시에 실행되는 시스템의 특성 Fork/Join: 병행성을 식별하는 최초의 언어 표기법 프로세스의 동기화: 2개 이상의 프로세스에 대한 처리 순서를 결정하는 것 임계영역: 2개 이상의 프로세스가 동시에 액세스하면 안 되는 공유 자원을 액세스하는 코드 영역 상호배제: 2개 이상의 프로세스가 동시에 임계영역에 진입하지 못하게 하는 것 세마포어: 상호 배제나 동기화 문제 등을 해결하기 위해 특수한 원자연산에 의해서만 접근되는 정수형 공용 변수 정리하기 병행 시스템은 여러 개의 프로세스가 동시에 실행되며, 이들이 상호작용함에 따라 공유자원 점유, 동기화, 통신 등의 문제가 발생함 동기화는 2개 이상의 프로세스에 대한 처리 순서를 결정하는 것을 의미 2개 이상의 프로세스가 동시에 액세스하면 안 되는 공유 자원을 액세스하는 코드 영역을 임계영역이라고 한다. 2개 이상의 프로세스가 동시에 임계영역에 진입하지 못하도록 하는 것을 상호배제라고 한다. P와 V라는 원자연산에 의해서만 접근되는 정수형 공용변수인 세마포어를 이용하여 상호배제 및 동기화를 구현할 수 있다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"병행 프로세스","slug":"병행-프로세스","permalink":"https://JihyeHwang09.github.io/tags/병행-프로세스/"}]},{"title":"스케줄링 알고리즘","slug":"os-3","date":"2019-04-22T11:02:58.000Z","updated":"2019-04-22T11:23:10.499Z","comments":true,"path":"2019/04/22/os-3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/22/os-3/","excerpt":"","text":"3강. 스케줄링 알고리즘 스케줄링 알고리즘에 대해 알아보자. 주요 용어 평균 대기시간: 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합의 평균값 평균 반환시간: 각 프로세스가 생성된 시점부터 수행이 완료된 시점까지의 소요시간의 평균값 FCFS: First-Come First-Served. 먼저 도착한 것을 먼저 처리 SJF: Shortest Job First. 수행 시간이 가장 짧은 것을 먼저 처리 SRT: Shortest Remaining Time. 남은 수행 시간이 가장 짧은 것을 먼저 처리 RR: Round Robin. 정해진 시간 간격만큼씩 순서대로 돌려 가며 처리 HRN: Highest Response Ratio Next. 응답비율이 가장 큰 것을 먼저 처리 정리하기 FCFS 스케줄링은준비 큐에 도착한 순서에 따라 디스패치하는비선점 방식의 스케줄링 알고리즘 SJF 스케줄링은 준비 큐에서 기다리는 프로세스 중수행 시간이 가장 짧다고 예상되는 것을 먼저 디스패치하는 비선점 알고리즘 SRT 스케줄링은 실행이 끝날 때까지남은 시간 추정치가 가장 짧은 프로세스를 먼저 디스패치하는 선점 방식의 알고리즘 RR 스케줄링은 정해진 시간 간격만큼씩 순서대로 돌려 가며디스패치하는 선점 방식의 알고리즘 HRN 스케줄링은 대기시간과 서비스 받을 시간을 함께 고려한우선순위에 따라 스케줄링하는 비선점 방식의 알고리즘 다단계 피드백 큐 스케줄링은 입출력 위주의 프로세스(대화식 작업)가CPU 스케줄링에 우선권을 갖도록하는 선점 방식의 알고리즘 다단계 피드백 큐 스케줄링은 각 단계의 큐마다 주어진 시간 할당량을 모두 소비하고,선점된 프로세스는 큰 단계 큐로 가고, 그렇지 않은 프로세스는 점차 작은 단계로 갈 수 있게 하는 적응적 방식의 변형도 있다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"스케줄링 알고리즘","slug":"스케줄링-알고리즘","permalink":"https://JihyeHwang09.github.io/tags/스케줄링-알고리즘/"}]},{"title":"프로세스 개요","slug":"os-2","date":"2019-04-21T10:52:03.000Z","updated":"2019-04-22T11:22:31.286Z","comments":true,"path":"2019/04/21/os-2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/21/os-2/","excerpt":"","text":"2강. 프로세스 개요 프로세스 개요에 대해 알아보자. 주요 용어 프로세스: 실행 중인 프로그램, CPU, 메모리, 입출력장치, 파일 등실행에 필요한 자원을 할당받아 동작한다. 프로세스 제어 블록(PCB): 프로세스 상태, 프로세스 번호, 프로그램 카운터, 레지스터 등프로세스를 관리하기 위한 정보를 포함하는 자료구조 스케줄러: 각 프로세스들이 CPU, 메모리, 입출력장치, 파일 등과 같은 자원을 공유할 때,시스템 내에서 프로세스의 실행 순서나 일정을 조정해주는 관리자 독립적 프로세스: 시스템에서 실행 중인 다른 프로세스의 영향을 받지도 않고 주지도 않는 프로세스 유기적 프로세스: 시스템에서 실행 중인 다른 프로세스의 영향을 주고받으며 동작하는 프로세스 쓰레드: 프로세스 내에서의 다중처리를 위하여 제안된 개념으로실행 단위를 프로세스에서 한 단계 낮추어 규정한 것으로 제어의 흐름을 의미 한다. 디스패칭의 단위로 경량 프로세스라고도 함 디스패처: 준비상태에 있는 프로세스를 실행상태로 전이시키는 작업을 수행하는 운영체제 내의 모듈 선점 스케줄링 정책: 진행 중인 작업에 인터럽트를 걸고 다른 작업에 CPU를 할당하는 스케줄링 전략 비선점 스케줄링 정책: 일단 프로세스가 CPU를 할당받아 실행이 시작되면,프로세스 자체가 I/O 인터럽트를 걸거나 프로세스를 종료할 때까지 실행상태에 있게 하는 스케줄링 전략 문맥 교환: CPU가 현재 실행하고 있는 프로세스의 문맥(상태)을 프로세스 제어 블록(PCB)에 저장하고, 다음 프로세스의 PCB로부터 문맥을 복원하는 작업 정리하기 프로세스는 생성, 준비, 실행, 대기, 종료의 다섯 상태 중 하나로 존재하며,CPU의 스케줄링, I/O 대기 등에 따라 준비, 실행, 대기 등으로 상태가 변화되며 동작한다. 프로세스 제어 블록(PCB)은 프로세스를 명시해 주는 다양한 내용을 포함하고 있다. 쓰레드란 하나의 프로그램 내에서 제어의 단일 순차적 흐름으로 정의되며,하나의 쓰레그 내에서는 하나의 실행점만이 존재하며, 각 쓰레드는 수행에 필요한 최소한의 정보만으로 구성된다. 하나의 프로세스 내에는 하나 이상의 쓰레드가 있을 수 있어 쓰레드를 생성하여프로세스 내에서 다중처리를 할 수 있다. 프로세스의 스케줄링을 위해 상위단계, 하위단계 및 중간단계 스케줄러가 사용된다. 스케줄링 기법 중 어떤 프로세스도 CPU를 빼앗길 수 없는 경우를 비선점이라 하며,그렇지 않은 경우를 선점이라고 한다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"},{"name":"프로세스","slug":"프로세스","permalink":"https://JihyeHwang09.github.io/tags/프로세스/"}]},{"title":"운영체제 개요","slug":"os-1","date":"2019-04-20T00:22:09.000Z","updated":"2019-04-22T11:21:55.008Z","comments":true,"path":"2019/04/20/os-1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/20/os-1/","excerpt":"","text":"1강. 운영체제 개요 운영체제 개요에 대해 알아보자. 주요 용어 운영체제: 컴퓨터 시스템의 자원을 관리하고컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 시스템 소프트웨어 시스템 호출: 응용 프로그램이 운영체제에게 서비스를 요청하는 메커니즘 커널: 응용 프로그램과 하드웨어 수준의 처리 사이의 가교 역할을 하는 운영체제의 핵심 요소 일괄처리 운영체제: 처리할 작업을 모아서 순차적으로 수행하는 시스템 대화형 운영체제: 사용자의 입력에 즉시 응답하여 처리 결과를 출력하는 시스템 실시간 운영체제: 실시간 제약조건, 즉 엄격한 시간제한 내에 응답하는 것을 보장할 수 있는 시스템 멀티프로그래밍: 한 프로세스가 입출력 등의 이벤트를 기다리는 동안다른 프로세스가 CPU에서 실행될 수 있도록 하는 방식 정리하기 운영체제는 컴퓨터 시스템의 자원을 관리하고컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 시스템 소프트웨어이다. 응용 프로그램은 하드웨어 자원을 직접 액세스할 수 없으며,시스템 호출이라는 절차를 통해 필요한 서비스를 운영체제에게 요청해야 한다. 커널은 응용 프로그램과 하드웨어 수준의 처리 사이의 가교 역할을 하는 운영체제의 핵심 요소로,대표적인 두 가지로 일체형 커널과 마이크로 커널이 있음 운영체제의 주요 구성 요소에는 프로세스 관리자, 메모리 관리자, 장치 관리자, 파일 관리자가 있다. 운영체제의 유형은 크게 일괄처리 운영체제, 대화형 운영체제, 실시간 운영체제, 그리고 하이브리드 운영체제로 분류된다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"운영체제","slug":"컴퓨터-과학/운영체제","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/운영체제/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"운영체제","slug":"운영체제","permalink":"https://JihyeHwang09.github.io/tags/운영체제/"}]},{"title":"02. 클린 코드 - 1. 깨끗한 코드(2)","slug":"book-clean-code-2","date":"2019-04-19T05:16:08.000Z","updated":"2019-04-20T05:55:42.222Z","comments":true,"path":"2019/04/19/book-clean-code-2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/19/book-clean-code-2/","excerpt":"","text":"클린 코드 - 애자일 소프트웨어 장인 정신(로버트 C.마틴 지음 | 박재호.이해영 옮김)를 읽고 정리한 내용입니다.개인적으로 공부한 내용을 정리하려는 목적임을 알려드립니다. 깨끗한 코드란?비야네 스트롭스트룹(C++ 창시자이자 The C++ Programming Language 저자) 효율이 단순히 속도만을 뜻하지 않는다. CPU 자원을 낭비하는 코드도 우아하지 못하다. 나쁜 코드는 나쁜 코드를 유혹한다! 흔히 나쁜 코드를 고치면서 오히려 더 나쁜 코드를 만든다는 뜻이다. 철저한 오류 처리 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드 깨끗한 코드란 한 가지를 잘 한다. 나쁜 코드는 너무 많은 일을 하려 애쓰다가 의도가 뒤섞이고 목적이 흐려진다. 깨끗한 코드는 한 가지에 집중 한다. 그래디 부치(Object Oriented Analysis and Design with Application 저자) 깨끗한 코드는 단순하고 직접적이다.잘 쓴 문장처럼 읽힌다.결코 설계자의 의도를 숨기지 않는다.오히려 명쾌한 추상화와 단순한 제어문으로 가득하다. 코드는 추측이 아니라 사실에 기반해야 한다. 반드시 필요한 내용만 담아야 한다. 코드를 읽는 사람에게 프로그래머가 단호하다는 인상을 줘야 한다. ‘큰’ 데이브 토마스(OTI 창립자이자 이클립스 전략의 대부) 깨끗한 코드란 다른 사람이 고치기 쉽다. 실제로 일기 쉬운 코드와 고치기 쉬운 코드는 엄연히 다르다! 깨끗한 코드를 테스트 케이스와 연관 짓는다. 테스트 케이스가 없는 코드는 깨끗한 코드가 아니다. 아무리 코드가 우아해도, 가독성이 높아도, 테스트 케이스가 없으면 깨끗하지 않다. 큰 코드보다 작은 코드에 가치를 둔다. 작을수록 좋다. 사람이 읽기 좋은 코드를 작성하라. 마이클 페더스(Working Effectively with Legacy Code 저자) 깨끗한 코드는 주의 깊게 작성한 코드 누군가 시간을 들여 깔끔하고 단정하게 정리한 코드 세세한 사항까지 꼼꼼하게 신경 쓴 코드 주의를 기울인 코드 론 제프리스(Extreme Programming Installed,Extreme Programming Adventrue in C# 저자) 중복 줄이기 표현력 높이기 초반부터 간단한 추상화 고려하기 내게는 이 세 가지가 깨끗한 코드를 만드는 비결이다. 워드 커닝햄(워키 창시자, 익스트림 프로그래밍 공동 창시자,디자인 패턴을 뒤에서 움직이는 전문가, 스몰토크와 객체지향의 정신적 지도자,코드를 사랑하는 프로그래머들의 대부) 깨끗한 코드는 읽으면서 놀랄 일이 없어야 한다. 언어를 단순하게 보이도록 만드는 책임은 우리에게 있다. 프로그램을 단순하게 보이도록 만드는 열쇠는 언어가 아니다. 언어를 단순하게 보이도록 만드는 열쇠는 프로그래머다! 우리들 생각 깨끗한 변수 이름, 깨끗한 함수, 깨끗한 클래스를 만드는 방법을 소개한다. 오브젝트 진영이 생각하는 깨끗한 코드를 설명한다. 동의하든 동의하지 않든 우리 시각을 이해하고 존중하려 애써주면 좋겠다. 우리는 저자다 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다. 비율이 이렇게 높으므로 읽기 쉬운 코드가 매우 중요하다. 기존 코드를 읽어야 새 코드를 짜므로 읽기 쉽게 만들면 사실은 짜기도 쉬워진다. 그러므로 급하다면, 서둘러 끝내려면, 쉽게 짜려면, 읽기 쉽게 만들면 된다. 보이스카우트 규칙 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라. 잘 짠 코드가 전부는 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다. 우리는 적극적으로 코드의 퇴보를 막아야 한다. 한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다. 코드 정리의 예시 변수 이름 하나를 개선 조금 긴 함수 하나를 분할 약간의 중복을 제거 복잡한 if문 하나를 정리 시간이 지날수록 코드가 좋아지는 프로젝트에서 개선한다고 상상해보자! 지속적인 개선이야말로 전문가 정신의 본질이다. 결론 이 책을 읽는다고 뛰어난 프로그래머가 된다는 보장은 없다. 코드감각을 확실히 얻는다는 보장도 없다. 단지 뛰어난 프로그래머가 생각하는 방식과 그들이 사용하는 기술과 기교와 도구를 소개할 뿐이다. 공연장으로 가다가 길을 잃은 연주회의 바이올리니스트에 대한 우스개 소리를 기억하는가? 그는 길거리에서 한 노인에게 카네기 홀로 가는 방법을 물었다. 노인은 연주자와 그가 든 바이올린을 보고 이렇게 말했다. “연습해, 연습!” 느낀점 이 책의 내용을 본격적으로 마주하기 전에 가질 마음가짐에 대해 정리할 수 있는 시간이었다. 프로그래밍 분야에서 유명한 명사들의 깨끗한 코드에 대한 견해를 접하면서그 본질이 무엇이며 왜 깨끗한 코드가 중요한지를 느낄 수 있었다. 이 책을 읽는다고 코드감각을 확실히 얻는다는 보장이 없다는 내용이 있어 공감이 되었다. 나는 프로그래밍과 인생, 이 두 가지에서 확실한 보장이라는 것은 애초에 존재하지 않는다고 생각한다. 이 책을 그저 소설책 읽듯이 읽기만 해서는 얻는 건 베스트 셀러인 클린 코드를 읽었다는 자기 만족 뿐일 것이다. 책에 나오는 여러 예제 코드, 특히 깨끗한 코드로 개선하기 전과 후를 비교하는 예제들을 내 손으로직접 타이핑하고 비교해보며 습관처럼 체득하고자 한다. 그저 연습만이 있을 뿐이다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Book","slug":"developer/book","permalink":"https://JihyeHwang09.github.io/categories/developer/book/"}],"tags":[{"name":"클린 코드","slug":"클린-코드","permalink":"https://JihyeHwang09.github.io/tags/클린-코드/"},{"name":"Clean Code","slug":"clean-code","permalink":"https://JihyeHwang09.github.io/tags/clean-code/"},{"name":"깨끗한 코드","slug":"깨끗한-코드","permalink":"https://JihyeHwang09.github.io/tags/깨끗한-코드/"}]},{"title":"소프트웨어 공학 개요","slug":"se-1","date":"2019-04-18T03:12:19.000Z","updated":"2019-05-10T07:13:40.597Z","comments":true,"path":"2019/04/18/se-1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/18/se-1/","excerpt":"","text":"1강. 소프트웨어 공학 개요 소프트웨어 공학의 개요에 대해 알아보자. 주요 용어 소프트웨어: 포괄적 의미에서 프로그램과 데이터 및 관련 문서들의 묶음 소프트웨어 공학: 소프트웨어 생산과 관련된 모든 부분에 공학적 원리와 방법을 적용시키려는 연구 분야 또는 전문 작업 분야 소프트웨어 개발 방법론: 소프트웨어 개발을 위한 구조적 방법을 말하는 것으로 따라야할 행위들 ex) 결과의 표기법 및 규칙 등을 포함 소프트웨어 개발 프로세스: 소프트웨어 개발이나 유지보수 목적으로 수행되는 일련의 활동 연습 문제Q. 포괄적 의미에서 소프트웨어의 정의 프로그램과 데이터 및 설계 문서나 매뉴얼 등의 관련 문서 12해설: 포괄적 의미의 소프트웨어는 소스 코드와 데이터 외에도실행 파일, 설계 문서, 설치 파일, 시스템 매뉴얼과 사용자 매뉴얼 등을 포함하는 개념이다. Q. 소프트웨어 공학의 목표에 해당되지 않는 것은? 품질 좋은 소프트웨어 소프트웨어의 경제적 생산3. 자원을 최대한 사용 계획된 일정에 맞게 소프트웨어를 생산 12정답: 3)해설: 자원은 보통 제한적으로 제공되므로 효율적으로 이용해야 한다. Q. 소프트웨어 개발 프로세스(what)와 개발 방법(how)을 결합한 개념은? 기술(technique)2. 소프트웨어 개발 방법론(methodology) 소프트웨어 생명 주기(life cycle) 소프트웨어 공학 원리(principle) 123정답: 2)해설: 소프트웨어 생명 주기는 탄생에서 폐기까지의 변화 과정을 의미하는 개념기술은 방법에 비해 기계적이며 &apos;제한적인 적용&apos;을 내포하는 용어이다. Q. 다음이 설명하는 좋은 소프트웨어의 기준은? 소프트웨어가 탑재되어 실행될 하드웨어나 운영체제가 달라져도,소프트웨어가 쉽게 수정될 수 있어서 계속 동작할 수 있다. 소프트웨어의 검사성2. 소프트웨어의 이식성 소프트웨어의 유지보수성 소프트웨어의 정확성 1234정답: 2)해설: 소프트웨어의 이식성이란 소프트웨어의 환경이 바뀌어도쉽게 수정되어 동작하는 능력을 의미한다.이때, 환경은 하드웨어, 운영체제 및 상호작용하는 다른 시스템을 말한다. 정리하기 소프트웨어는 무형의 인공물로 다른 공학 제품에 비해 변경이 용이하다. 소프트웨어 위기 현상은 소프트웨어 공학 기술의 후진성에 기인한다. 소프트웨어 공학의 정의는 소프트웨어의 개발, 운영, 유지보수에 체계적이고 숙달되고 정량화된 접근 방법을 적용하는 것이다. 소프트웨어 공학 환경은 최하위 층부터 소프트웨어 공학 원리, 방법과 기술, 방법론, 그리고 도구로 구성된다. 소프트웨어 개발 방법론이랑 문제 해결을 위해 여러 방법들과 기술들이 정해진 프로세스 안에서 함께 묶인 것이다. 좋은 소프트웨어인가를 판단하는 기준으로는 신뢰도, 정확성, 성능, 사용성, 상호운용성, 유지보수성, 이식성, 검증성, 추적성 등이 있다. 참고 자료 새로 쓴 소프트웨어 공학, 최은만, 2014, 정익사","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"컴퓨터-과학/소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/소프트웨어-공학/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"소프트웨어 공학","slug":"소프트웨어-공학","permalink":"https://JihyeHwang09.github.io/tags/소프트웨어-공학/"}]},{"title":"매개변수와 전달인자 특성을 적용하여 코드 줄이기","slug":"js-2019-04-17","date":"2019-04-17T13:39:06.000Z","updated":"2019-04-17T14:06:11.503Z","comments":true,"path":"2019/04/17/js-2019-04-17/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/17/js-2019-04-17/","excerpt":"","text":"매개변수(Parameter)와 전달인자(Argument)의 특성을 이해한 후,불필요한 코드를 줄일 수 있었다. 예시를 보고 비교해보자. 12345678910111213const arr =['봄','꽃', '만개하다'];console.log(arr.length); // 3count(arr.length);// 수정 전function count(arr.length) &#123; const length = arr.length; if (length === 1) &#123; // ... &#125; else if (length &gt; 1) &#123; //... &#125;&#125; 위의 코드에서는 count함수 안에서 length라는 변수를 새로 만들어서 매개변수로 받은 arr.length를 대입했다. 1const length = arr.length; 매개변수의 특성을 이해하고 있다면 이 코드는 필요하지 않다. 함수 호출시 넘어온 전달 인자(Argument)값은 매개변수에 복사되어 대입된다는 특성이 있다. 따라서, count 함수 안에서 인자로 전달받은 값을 length라는 이름으로 사용하고 싶다면, 매개변수의 이름을 length로 적어주면 코드를 줄일 수 있다. 불필요한 코드를 줄인 예시는 아래와 같다. 12345678// 수정 후function count(length) &#123; if (length === 1) &#123; // ... &#125; else if (length &gt; 1) &#123; //... &#125;&#125;","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"매개변수","slug":"매개변수","permalink":"https://JihyeHwang09.github.io/tags/매개변수/"},{"name":"Parameter","slug":"parameter","permalink":"https://JihyeHwang09.github.io/tags/parameter/"},{"name":"전달인자","slug":"전달인자","permalink":"https://JihyeHwang09.github.io/tags/전달인자/"},{"name":"Argument","slug":"argument","permalink":"https://JihyeHwang09.github.io/tags/argument/"}]},{"title":"01. 클린 코드 - 1. 깨끗한 코드(1)","slug":"book-clean-code-1","date":"2019-04-16T10:59:03.000Z","updated":"2019-04-20T05:51:06.889Z","comments":true,"path":"2019/04/16/book-clean-code-1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/16/book-clean-code-1/","excerpt":"","text":"클린 코드 - 애자일 소프트웨어 장인 정신(로버트 C.마틴 지음 | 박재호.이해영 옮김)를 읽고 정리한 내용입니다.개인적으로 공부한 내용을 정리하려는 목적임을 알려드립니다. 코드가 존재하리라 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세하게 표현하기란 불가능하다. 기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업, 바로 이것이 프로그래밍이며 이렇게 명시한 결과가 코드이다. 코드는 요구사항을 표현하는 언어이다. 요구사항에 더욱 가까운 언어를 만들 수 있고, 요구사항에서 정형 구조를 뽑아내는 도구를 만들 수도 있다. 어느 순간에는 정밀한 표현이 필요하다. 그 필요성을 없앨 방법이 없으므로 코드도 항상 존재하리라. 나쁜 코드잘 나가던 회사의 일화 80년대 후반 킬러 앱 하나를 구현한 회사가 있었는데, 커다란 인기를 끌었다. 제품 출시 주기가 늘어지면서 버그가 다음 버전에도 그대로 남아있었다. 회사는 얼마 못가 망했다. 잘 나가던 회사가 망한 이유 출시에 바빠 코드를 막 짰다. 기능을 추가할수록 코드가 엉망이 되었고, 결국은 감당이 불가능한 수준에 이르렀다. 회사가 망한 원인은 바로 나쁜 코드 탓이었다. 어째서 나쁜 코드를 짜는가? 급해서? 서두르느라? 아마 그랬을 것이다. 많이들 겪어본 상황이다. 많은 프로그래머들이 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이 있다. 또한 대충 짠 프로그램이 돌아간다는 사실에 안도감을 느끼며 그래도 안 돌아가는 프로그램보다 돌아가는 쓰레기가 좋다고 느낀 경험이 있다. 다시 돌아와 나중에 정리하겠다고 다짐들을 하지만 나중은 결코 오지 않는다. 나쁜 코드로 치르는 대가 나쁜 코드가 쌓일수록 팀 생산성은 떨어진다. 원대한 재설계의 꿈 시간을 들여 깨끗한 코드를 만드는 노력이 비용을 절감하는 방법일 뿐만 아니라 전문가로서 살아남는 길이다. 태도 일정에 쫓기더라도 대다수 관리자는 좋은 코드를 원한다. 좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다. 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다. 원초적 난제 모든 프로그래머가 기한을 맞추려면 나쁜 코드를 양산할 수 밖에 없다고 느낀다. 오히려, 나쁜 코드를 양산하면 기한을 맞추지 못한다. 오히려 엉망진창인 상태로 인해 속도가 곧바로 늦어지고, 결국 기한을 놓친다. 기한을 맞추는 유일한 방법은 언제나 코드를 최대한 깨끗하게 유지하는 습관이다. 깨끗한 코드라는 예술? 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 안다는 뜻은 아니다. 깨끗한 코드를 작성하려면 ‘청결&#39;이라는 힘겹게 습득한 감각을 활용해 자잘한 기법들을 적용하는절제와 규율이 필요하다. 열쇠는 &#39;코드 감각&#39;이다. 어떤 사람은 &#39;코드 감각&#39;을 타고난다. 어떤 사람은 투쟁해서 얻어야 한다. &#39;코드 감각&#39;이 있으면 좋은 코드와 나쁜 코드를 구분한다. 느낀점 나도 시간에 쫓긴다는 이유로 ‘이렇게 코드를 짜면 나중에 고생할텐데… 이렇게 짜면 안되는데..’하면서나 자신이 보기에도 마음에 들지 않는 코드를 작성한 경험이 있다. 특히 나쁜 코드를 우선은 마감기한에 맞춰 작동은 가능하게 한 후, 리팩토링 하겠다고 생각했던내 자신을 반성하게 된다. 나는 위에서 저자가 말한 ‘코드 감각’을 타고나지 않았다고 느낀다. 그 코드 감각은 노력해서 얻을 수 있다고 생각한다.이러한 생각은 내가 더욱 꾸준하게 프로그래밍을 공부할 수 있는 원동력이 된다. 처음부터 클린한 코드를 짜기 위한 방법을 배우고 익혀서 체득하고자 한다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"Book","slug":"developer/book","permalink":"https://JihyeHwang09.github.io/categories/developer/book/"}],"tags":[{"name":"클린 코드","slug":"클린-코드","permalink":"https://JihyeHwang09.github.io/tags/클린-코드/"},{"name":"Clean Code","slug":"clean-code","permalink":"https://JihyeHwang09.github.io/tags/clean-code/"},{"name":"깨끗한 코드","slug":"깨끗한-코드","permalink":"https://JihyeHwang09.github.io/tags/깨끗한-코드/"}]},{"title":"덧셈 연산과 문자열 변환","slug":"js-2019-04-15","date":"2019-04-15T13:56:32.000Z","updated":"2019-04-17T14:00:41.164Z","comments":true,"path":"2019/04/15/js-2019-04-15/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/15/js-2019-04-15/","excerpt":"","text":"덧셈 연산과 문자열 변환 과정에서 무의식적으로 코딩하다가 일어난 이슈와 그 해결 방법에 대해 정리하고자 한다. Number 타입의 값들을 이어 붙여서 문자열로 변환하고자 했다. 123const yyyy = 2019;const mm = 04;const dd = 15; yyyy, mm, dd 각 변수에는 Number 타입의 값이 각각 들어있다. 이 값들을 문자열인 &#39;20190415&#39;로 변환하고자 한다. 처음 작성한 코드는 아래와 같다. 123let today = \"\";today = String(yyyy + mm + dd);console.log(today); //'2038' 먼저 각 변수에 담긴 숫자들의 덧셈 연산이 이루어진 후, String을 통해 문자열로 변환이 이루어진다. 따라서 의도와는 달리 &#39;2038&#39;이라는 결과가 나온다. 해당 이슈는 크게 2가지 방법으로 해결할 수 있다. 대처 방안1. 각각을 문자열로 바꾼 후, 덧셈 연산(+)을 통해 이어 붙여준다.12today = String(yyyy) + String(mm) + String(dd);console.log(today); //'20190415' 2. 덧셈 연산(+) 사이에 빈 문자열(‘’)을 추가하여 숫자를 문자열로 변환해 준다.12today = yyyy + \"\" + mm + \"\" + dd;console.log(today); //'20190415' 중요한 포인트는 문자열 변환과 덧셈 연산의 순서이다.덧셈 연산 후, 문자열로 변환하는 것이 아니라문자열 변환 후, 덧셈 연산이 일어나야 위의 목적에 원하는 결과를 얻을 수 있다.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"덧셈 연산","slug":"덧셈-연산","permalink":"https://JihyeHwang09.github.io/tags/덧셈-연산/"},{"name":"문자열","slug":"문자열","permalink":"https://JihyeHwang09.github.io/tags/문자열/"}]},{"title":"2019-04-14_TIL","slug":"TIL-2019-04-14","date":"2019-04-14T14:59:07.000Z","updated":"2019-05-12T15:23:31.530Z","comments":true,"path":"2019/04/14/TIL-2019-04-14/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/14/TIL-2019-04-14/","excerpt":"","text":"2019년 4월 14일 (일)자바스크립트의 형변환 중에 묘하게 작동하는 부분을 알게 되다. 자바스크립트의 형변환을 공부하면서 parseInt와 만났을때묘하게 작동하는 부분을 알게 되어 공유하고자 한다. ab는 문자열이고 12는 숫자인데 이 둘을 이어붙인 문자열을 변수 strNum에 담았다. 문자열인 &quot;ab12&quot;를 parseInt로 정수로 변환한 결과를 console.log로 화면에 출력해보면 어떤 값이 나올까? 123const strNum = \"ab12\";console.log(parseInt(strNum)); // NaNconsole.log(typeof strNum); // string ab12라는 숫자값이 없기 때문에 NaN이 출력 된다. 타입은 그대로 string이다. 이번에는 숫자 12를 앞에, 문자열 ab를 뒤에 이어붙인 문자열을 변수 numStr에 담았다. 타입은 string인 “12ab”를 parseInt로 정수로 변환한 결과를 출력해보면,위의 예제처럼 이번에도 NaN이 나올까? 123const numStr = \"12ab\";console.log(parseInt(numStr)); // 12console.log(typeof strNum); // string 엇? 예상과 다르게 정수 12가 출력된다. 타입은 string이 나온다. 자바스크립트에서 형변환을 할때는 이렇게 우리의 의도와는 다르게작동하는 경우가 있기 때문에 주의를 기울일 필요가 있다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"개발자로서 일하는 것도 사람 사이의 일, 커뮤니케이션의 중요성","slug":"TIL-2019-04-13","date":"2019-04-13T14:57:35.000Z","updated":"2019-07-24T12:12:29.479Z","comments":true,"path":"2019/04/13/TIL-2019-04-13/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/13/TIL-2019-04-13/","excerpt":"","text":"2019년 4월 13일 (토)개발자로서 일하는 것도 사람 사이의 일, 커뮤니케이션의 중요성 오늘은 세미나에 가서 여러 세션을 들었다. 많은 강연들이 있었지만 특히 협업을 하면서 어떤 방식으로커뮤니케이션을 하는 것이 긍정적인 효과를 낼 수 있는지를 예시를 들어알려주시는 부분이 인상적이었다. 강연 기회가 있다면 주저하지 말고 도전하자. 패스트캠퍼스를 함께 수료한 친구들과 함께한 세미나에서 발표를 한 적이 있는데,그때 굉장히 긴장했던 기억이 있다. 한 강연자분이 강연을 하면 할수록 긴장은 서서히 줄어들기 때문에 기회가 될 때마다강연자로 무대에 서는 것이 좋다고 얘기했다. 아직은 병아리 개발자라 강연자로 서는 건 아직은 이르다고 생각했었는데,거침없이 도전해 보고자 한다. 점점 더 많은 강연에 강연자로 선다면 점차 긴장은 줄일 수 있을 것이다.발표자로서 사람들과 눈을 마주치고 웃으며 소통할 수 있는 날이 올 수 있기를 꿈꾼다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"블로그를 시작한 계기","slug":"TIL-2019-04-12","date":"2019-04-12T14:52:04.000Z","updated":"2019-05-12T15:28:30.511Z","comments":true,"path":"2019/04/12/TIL-2019-04-12/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/12/TIL-2019-04-12/","excerpt":"","text":"블로그를 시작한 계기 난 엄청나게 뛰어난 개발자가 아니다. 내가 개발을 하는 이유는 딱 하나다. 재미있으니까. 재미를 느끼는 개발을 일로 삼아 개발자가 되었다. 배우는 속도가 빠르지 않고 어떤 기술을 공부한다고 해서 바로 습득하는 것에 어려움을 느낀다. 이를 극복하는 방법으로 기술 블로그를 선택했다. 내가 그날 공부한 내용과 이슈들을 정리하고 이 내용을함께 공유까지 할 수 있다는 점이 매력적으로 느껴졌다. 기술 블로그 글을 짤막하게나마 매일 쓴다는 건나 자신이 나태해지는 걸 방지한다는 측면에서 이점이 많다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"리눅스(Linux) 디렉토리 삭제하기","slug":"linux-2019-04-11","date":"2019-04-11T14:58:57.000Z","updated":"2019-08-19T12:06:56.088Z","comments":true,"path":"2019/04/11/linux-2019-04-11/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/11/linux-2019-04-11/","excerpt":"","text":"리눅스(Linux) 디렉토리 삭제하는 방법에 대해 알아보자. 1. rm. -r 해당 폴더안에 있는 모든 파일들까지 같이 삭제하고,자기자신 폴더까지 삭제하는 옵션 2. rmdir. rmdir 디렉토리만 삭제하는 명령 주의할 점: 디렉토리 안에 파일이 존재하는 경우,디렉토리가 삭제되지 않는다! 참고링크 [리눅스 디렉토리 삭제]: https://dream-cy.tistory.com/41 [리눅스에서-파일을-삭제하는-방법]: https://webisfree.com/2018-01-19/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-%ED%8C%8C%EC%9D%BC%EC%9D%84-%EC%82%AD%EC%A0%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Linux","slug":"back-end/linux","permalink":"https://JihyeHwang09.github.io/categories/back-end/linux/"}],"tags":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/tags/back-end/"},{"name":"Linux","slug":"linux","permalink":"https://JihyeHwang09.github.io/tags/linux/"},{"name":"rm. -r","slug":"rm-r","permalink":"https://JihyeHwang09.github.io/tags/rm-r/"},{"name":"rmdir. rmdir","slug":"rmdir-rmdir","permalink":"https://JihyeHwang09.github.io/tags/rmdir-rmdir/"}]},{"title":"리눅스 명령어","slug":"linux-2019-04-10","date":"2019-04-10T14:56:10.000Z","updated":"2019-04-11T15:21:56.265Z","comments":true,"path":"2019/04/10/linux-2019-04-10/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/10/linux-2019-04-10/","excerpt":"","text":"리눅스 cp, cat, sudo 명령어에 대해 알아보자. 1. cp 어떤 파일의 사본을 새로운 이름으로 만들고 싶을 때 사용하는 명령어 1cp [옵션] [원본] [사본] 2. cat1cat [옵션] [파일명] 파일의 내용을 화면에 출력하는 명령어 3. sudo 루트 사용자만이 애플리케이션의 설치, 삭제, 변경에 필요한 권한을 가지고 있다. 일반 사용자가 애플리케이션을 설치하기 위해서는 sudo 명령어로 루트 권한을 임시로 부여한다. 패스워드를 반드시 입력해야 한다. 참고 링크 [리눅스 초보자가 익혀야 할 12가지 명령 ]: http://www.ciokorea.com/news/29239 [리눅스 cp 명령어와 mv 명령어에 대해 알아보자.]: (https://corej21.tistory.com/42)","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Linux","slug":"back-end/linux","permalink":"https://JihyeHwang09.github.io/categories/back-end/linux/"}],"tags":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/tags/back-end/"},{"name":"Linux","slug":"linux","permalink":"https://JihyeHwang09.github.io/tags/linux/"},{"name":"cp","slug":"cp","permalink":"https://JihyeHwang09.github.io/tags/cp/"},{"name":"cat","slug":"cat","permalink":"https://JihyeHwang09.github.io/tags/cat/"},{"name":"sudo","slug":"sudo","permalink":"https://JihyeHwang09.github.io/tags/sudo/"}]},{"title":"logging 라이브러리 - winston","slug":"node-library-winston","date":"2019-04-09T14:09:56.000Z","updated":"2019-04-11T15:21:56.259Z","comments":true,"path":"2019/04/09/node-library-winston/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/09/node-library-winston/","excerpt":"","text":"Node.js logging 라이브러리 중 하나인 winston을 접하고 적용하면서 만난 issue를 정리해보자. winston.Logger는 생성자가 아니라는 타입 에러가 발생했다. winston의 버전이 3.0.0 이상인 경우 winston.Logger를 사용할 수 없다. 위 코드에서 new(winston.Logger)를 winston.createLogger로 바꿔준다. 이슈를 해결한 코드는 아래와 같다. 123let logger = winston.createLogger(&#123; // ...&#125;); 참고 링크 [winston]: https://www.npmjs.com/package/winston","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"Node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"참조 (Reference)","slug":"js-reference","date":"2019-04-07T15:14:40.000Z","updated":"2019-04-11T15:22:16.248Z","comments":true,"path":"2019/04/08/js-reference/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/08/js-reference/","excerpt":"","text":"참조 (Reference) JavaScript에는 모두 일곱 가지의 타입이 존재한다. 원시 타입(primitive type) Boolean Null Undefined Number String Symbol 참조 타입(reference type) Object 참조란? 여기에서 참조(reference)란, 객체가 컴퓨터 메모리 상에서 어디에 저장되었는지를 가리키는 값이다. JavaScript에서는 우리가 참조를 직접 읽거나 조작할 수 없다. 하지만, 언어를 제대로 이해하기 위해서 참조가 무엇인지 알아야 할 필요는 있다. 우리가 객체라고 생각하고 다루어왔던 값은 실제로는 객체에 대한 참조이다. 1const obj = &#123;&#125;; // 변수 `obj`에는 객체에 대한 참조가 저장되었다. 객체의 속성에 접근하면, JavaScript 엔진은 참조를 통해 메모리에 저장되어 있는 객체에 접근해서 해당 객체의 속성을 읽는다. 이런 동작을 가지고 역참조(dereference)라고 한다. 12const obj = &#123; prop: 1 &#125;;obj.prop; // `obj`를 통해 역참조된 객체의 속성을 읽어왔다. 함수 호출 함수 호출 시에는 인수가 복사되어 매개변수에 대입된다. 만약 함수 호출 시에 객체를 인수로 넘긴다면, 이 때 역시 실제로 복사되는 것은 객체 자체가 아니라 참조이다. 그래서, 우리는 이 참조를 이용해 원본 객체의 내용을 변경할 수 있다. 원본이나, 복사된 참조나 같은 객체를 가리키기 때문이다. 123456789const obj = &#123;&#125;;function addProp(o) &#123; o.prop = 1;&#125;// 변수 `obj`에 저장되어 있는 참조가 매개변수 `o`에 복사됩니다.addProp(obj);console.log(obj.prop); // 1 객체의 같음 (Equality) 우리는 이제까지 === 연산자를 이용해서 두 값이 같은지를 판별해 왔다. 그런데 객체에 대해서는 비교 연산 역시 오묘하게 동작한다. 내용이 같은 두 객체를 === 연산자를 통해 비교해도, 결과값은 false로 나온다. 12&#123;prop: 1&#125; === &#123;prop: 1&#125;; // false[1, 2, 3] === [1, 2, 3]; // false 위의 등호 연산자 역시, 객체의 내용을 비교하는 것이 아니라 객체의 참조를 비교한다. 우리가 생성자나 리터럴을 이용해 객체를 생성하면, 객체는 매번 새로 생성되어 각각 메모리의 다른 위치에 저장된다. 그래서, 내용이 똑같아 보이는 두 객체일지라도 그에 대한 참조는 서로 다른 것이다. 당연하게도, 두 참조가 정말로 같은 객체를 가리키고 있다면 등호 연산자는 true를 반환한다. 123const obj1 = &#123;&#125;;const obj2 = obj1;obj1 === obj2; // true 프로그램을 작성하다가 객체에 대한 비교를 하는 코드를 짜고 있는 자신을 발견하게 되면,지금 객체의 내용을 비교하려고 하는 것인지, 또는 객체의 참조를 비교하려고 하는 것인지를 꼭 생각해보자. 객체의 내용을 통해 비교하고 싶다면, 깊은 비교 기능을 지원하는 라이브러리를 이용하거나,정확히 어떤 내용을 비교하고 싶은지를 가지고 함수 혹은 메소드를 작성한 후 그것을 이용하자.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"전역 변수(Global Variable)와 전역 객체(Global Object)","slug":"js-global-variable-object","date":"2019-04-06T15:10:43.000Z","updated":"2019-04-11T15:22:16.233Z","comments":true,"path":"2019/04/07/js-global-variable-object/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/07/js-global-variable-object/","excerpt":"","text":"전역 변수 (Global Variable) 전역 스코프는 스코프 체인의 가장 바깥쪽에 있는 스코프 12345678let foo = \"outer\"; // 이 `foo`는 전역 스코프에서 선언됨&#123; let foo = \"inner\"; // 이 `foo`는 블록 스코프에서 선언됨 console.log(foo); // inner&#125;console.log(foo); // outer ‘outer’ 문자열을 값으로 갖는 변수 foo와 같이 전역 스코프에서 선언된 변수를 전역 변수(global variable)라고 한다. 주의할 점: 변수를 명시적으로 전역 스코프에서 선언하지 않더라도,한 번도 선언되지 않은 이름으로 안쪽 스코프에서 let, const, var를 붙여주지 않고 변수를 선언하면 전역 스코프에 변수가 만들어진다. 123456function func() &#123; variable = 1; // // `variable`이라는 변수가 선언된 적 없으므로, 전역 변수가 된다.&#125;func();console.log(variable); // 1 전역 변수는 코드의 어떤 부분에서든 아무런 제한 없이 접근하고 조작할 수 있다. 이런 특징이 편하고 좋아보이지만, 어려움을 겪을 수 있다. 어떤 프로그래밍 언어를 사용하건, 전역 변수에 의존해서 프로그래밍을 하는 것은 굉장히 금기시된다.전역 변수를 남용하다 보면 다음과 같은 어려움을 겪게 된다. 전역 변수에는 아무런 제한 없이 접근할 수 있으므로, 프로그램의 크기가 커짐에 따라 변수의 값이 어디서 어떻게 변경될지 예측하기 힘들다. 전역 변수를 통해 프로그램의 너무 많은 부분이 결합(coupling)된다. 예를 들어, A.js 파일을 고쳤는데 아무런 상관도 없어 보이던 B.js 파일의 코드가 오동작하게 될 수도 있다. 코드가 전혀 다른 곳에 위치한 부분에 의존하게 되므로, 전역 변수를 사용한 코드는 이해하기 어렵다. 이처럼 전역 변수를 잘못 사용하면 코드를 읽고, 쓰고, 변경하기 어려워진다. 변수를 선언할 때는 그 변수를 필요로 하는 작은 스코프 안에서만 접근할 수 있도록 하세요. 불가피하게 코드의 여러 부분에서 특정한 값을 공유하고 그 값을 변경해야 할 일이 생긴다면, 전역 변수 대신에 다른 기법을 활용하세요. 공유되는 값에 접근할 수 있는 코드의 범위를 최소한으로 줄이고, 그 값은 약속된 방식으로만 변경을 할 수 있도록 제약을 두어야 한다. 전역 객체 (Global Object) JavaScript 구동 환경은 모두 전역 객체(Global Object)라는 특별한 객체를 갖고 있다. 전역 변수가 선언되면, 이 변수는 또한 전역 객체의 속성이 되어 전역 객체를 통해서도 접근할 수 있게 된다. 12let foo = 1;window.foo; // 1 전역 객체의 이름은 JavaScript 구동 환경마다 다르다. 구동 환경 전역 객체 이름 웹 브라우저 window 웹 워커 self Node.js global 전역 객체에는 구동 환경에서 유용하게 쓸 수 있는 속성과 함수가 미리 적재되어 있다. ex1) 브라우저 환경에서는 서버와의 통신을 위한 fetch 함수가 미리 적재되어 있다. ex2) Node.js 환경에서는 모듈을 불러와 사용할 수 있도록 해 주는 require 함수가 미리 적재되어 있다.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"33 JavaScript Concepts - typeof","slug":"33-js-typeof","date":"2019-04-06T14:22:09.000Z","updated":"2019-04-11T15:22:16.084Z","comments":true,"path":"2019/04/06/33-js-typeof/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/06/33-js-typeof/","excerpt":"","text":"이 문서는 33 Concepts Every JavaScript Developer Should Know 주제로 노마드 코더(Nomad Coders)님이 강의한 내용을 정리하였습니다. typeof1234console.log(typeof \"11212\"); // stringconsole.log(typeof true); // booleanconsole.log(typeof function() &#123;&#125;); // function 거의 모든 primitive에서 다 작동한다. Number, boolean, string, undefined… type이 궁금하면 이렇게 typeof 뒤에 넣어서 작성해보면 된다. 1234console.log(typeof 1); // numberconsole.log(typeof false); // booleanconsole.log(typeof \"\"); // stringconsole.log(typeof undefined); // undefined 소괄호()로 감싸준 후 typeof를 붙여도 된다. 12345console.log(typeof undefined); // undefinedconsole.log(typeof undefined); // undefinedconsole.log(typeof true); // booleanconsole.log(typeof true); // boolean 버그가 하나 있다. 자바스크립트에는 WTF 모먼트가 있다. 1console.log(typeof null); // object 자바스크립트를 만든 개발자들(브랜든, 더글라스)이 이 버그에 대한 논의를 한 적이 있다. Object 대신에 Null -&gt; null로 고쳐야 한다는 논의가 있었다. 하지만 거절되었다. 그 이유는 이걸 고치면 다른 여러 프로그램들이 영향을 받을 수 있기 때문이다. 그래서 이 버그가 그대로 있는 것이다. (WTF 버그의 일종이다.) 비슷한 WTF버그들을 보자. 123console.log(typeof null); // objectconsole.log(typeof []); // objectconsole.log(typeof &#123;&#125;); // object typeof를 사용하면 Array인지 object인지 체크하고 싶을 때 구분이 되지 않는다. -&gt; 이 때는 typeof 대신에 instanceof를 사용하면 된다. instanceof는 primitive(string, boolean, number 등)에서는 작동하지 않는다는 점을 유의해야 한다. 123console.log([] instanceof Array); // trueconsole.log(&#123;&#125; instanceof Array); // falseconsole.log(&#123;&#125; instanceof Object); // true instanceof는 primitive에서는 작동하지 않는다. 12console.log(\"\" instanceof String); // falseconsole.log(true instanceof Boolean); // false primitive에서는 typeof를 사용한다. 12345678910console.log(typeof 1);// numberconsole.log(typeof \"1\");// stringconsole.log(typeof true);// booleanconsole.log(typeof undefined);// undefinedconsole.log(typeof function() &#123;&#125;);// function array의 경우에는instanceof를 사용한다. 123const he = [];he instanceof Array; 정리 primitive(number, string, boolean, undefined, function)은 typeof를 사용한다.배열(Array)은 instanceof Array를 사용하고,객체(Object)는 instanceof Object를 사용한다. 주의할 점 Typeof null은 object이다! 참고 링크 노마드 코더 nomad coders-(ep 05.) 자바스크립트 개발자라면 알아야하는 핵심 컨셉 33개 | #5. typeof","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"33-js-concepts","slug":"front-end/33-js-concepts","permalink":"https://JihyeHwang09.github.io/categories/front-end/33-js-concepts/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"33-js-concepts","slug":"33-js-concepts","permalink":"https://JihyeHwang09.github.io/tags/33-js-concepts/"}]},{"title":"33 JavaScript Concepts - type coercion(강제 형 변환)","slug":"33-js-type-coercion","date":"2019-04-05T11:46:42.000Z","updated":"2019-04-11T15:22:16.083Z","comments":true,"path":"2019/04/05/33-js-type-coercion/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/05/33-js-type-coercion/","excerpt":"","text":"이 문서는 33 Concepts Every JavaScript Developer Should Know 주제로 노마드 코더(Nomad Coders)님이 강의한 내용을 정리하였습니다. type coercion(강제 형 변환)123456789101112131415161718console.log(4 + \"hello\"); // 4helloconsole.log(4 + 4 + \"hello\"); // 8helloconsole.log(\"\" == true); // falseconsole.log(1 == true); // trueconsole.log(66 + true); // 67console.log(66 + true); // 67console.log(66 + 1); // 67console.log(66 + false); // 66console.log(66 + 0); // 66// true -&gt; 1, false -&gt; 0이 된다.console.log(55 - true); // 54// console.log(55 - 1); // 54console.log(55 - false); // 0// console.log(55 - 0); // 0 항상 더하기(+)가 모든 걸 숫자로 바꾸는 것은 아니다. 만약 여기 string이 있으면 이렇게 ‘66false’이 된다. 하나의 string 으로 인식한다. 1console.log(66 + \"false\"); // 66false 오직 덧셈 연산에서만 이렇게 덩어리가 된다. -&gt; loaded operator라고 한다. 자바스크립트는 왼쪽에서 오른쪽으로 연산이 일어난다. 1234console.log(10 + 66 + \"false\"); // 76false// 1) 숫자 10과 66의 덧셈 연산이 이루어져서 76이 된다.// 2) 그 다음 false와의 덧셈 연산(76+\"false\")이 이루어지는데, \"false\"가 string이므로// 결과는 \"76string\"이 된다. 뺄셈 연산에서는 string이 있으면 string을 number로 강제 형변환 한다. 123console.log(25 - \"1\"); // 24// 뺄셈 연산이 있으므로 string인 \"1\"이 숫자1로 강제로 형변환 된다. 곱셈 연산도 뺄셈 연산과 마찬가지로 string이 있으면 number로 강제 형변환 한다. 12console.log(25 * \"2\"); // 50console.log(25 * \"string\"); // NaN 123456789console.log(\"\" == true); // false// 텅빈 문자열은 거짓// 텅빈 문자열은 제로 바이트이다.// 이걸 0으로 변환 시킨다.console.log(0 == true); // false// 0은 거짓이다.console.log(NaN == true); // falseconsole.log(undefined == true); // falseconsole.log(null == true); // false ==보다는 ===를 주로 사용한다. ===를 사용하면 type coercion이 일어나지 않는다. 1234console.log(\"1\" == 1); // true// '=='를 사용해서 \"1\"이 숫자 1로 강제 형변환되었기 때문에 '참'이 된다.console.log(\"1\" === 1); // false// \"===\"를 사용했기 때문에 Type coercion 1234567891011console.log(\"true\" == true); // falseconsole.log(\"1\" == 1); // true// string \"true\"는 거짓인데, 왜 string \"1\"는 참일까?// \"==\"이 boolean을 만나면 숫자로 변환한다.console.log(\"true\" == 1);// -&gt; true가 1이 된다. 또한 앞에서 string을 숫자로 변환하려고 한다.console.log(parseInt(\"true\")); // NaN// 보다시피, \"true\"는 숫자가 되지 않는다.console.log(NaN == 1);// -&gt; 뒷단의 true는 1이 되고, 앞단의 \"true\"는 숫자가 안되니까 NaN이 된다.// NaN == 1을 시도한 것이므로 이는 당연히 거짓이 된다. ==가 boolean을 만나면, 모든 게 숫자로 변환되고 이상하고 복잡해진다. -&gt; 때문에 ==을 쓰지 않고 ===을 사용한다. 이렇게 ===를 이용하면 강제 형변환을 피할 수 있다. 12345const hello = \"\";if (hello) &#123; console.log(\"hello\");&#125; 위의 코드는 hello에 빈 문자열&quot;&quot;이 들어있을 때는 if문의 조건이 false가 되어 실행되지 않게 된다. 아래와 같이 변경해줘야(===나 !==로 비교)안전하다는 걸 알 수 있다. 123if (typeof hello !== undefined) &#123; console.log(\"hello\");&#125; 참고 링크 “다니엘의 it 도서관” - 형변환과 강제(type casting &amp; coercion) 노마드 코더 nomad coders- (ep 04.) 자바스크립트 개발자라면 알아야하는 핵심 컨셉 33개 | #4. type coercion 미남이의 이러쿵저러쿵 - JavaScript의 이런 점이 뒤통수를 때리더라.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"33-js-concepts","slug":"front-end/33-js-concepts","permalink":"https://JihyeHwang09.github.io/categories/front-end/33-js-concepts/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"33-js-concepts","slug":"33-js-concepts","permalink":"https://JihyeHwang09.github.io/tags/33-js-concepts/"}]},{"title":"const, let, var의 개념 비교","slug":"js-const-let-var","date":"2019-04-04T13:43:56.000Z","updated":"2019-04-11T15:22:16.224Z","comments":true,"path":"2019/04/04/js-const-let-var/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/04/js-const-let-var/","excerpt":"","text":"ES2015에서 let, const를 도입하게 된 배경 대부분의 문제는 전역 변수로 인해 발생한다. 전역 변수는 간단한 애플리케이션의 경우,사용이 편리하다는 장점이 있지만 불가피한 상황을 제외하고 사용을 억제해야 한다. 전역 변수는 유효 범위(scope)가 넓어서 어디에서 어떻게 사용될 것인지 파악하기 힘들며,비순수 함수(Impure function)에 의해 의도하지 않게 변경될 수도 있어서 복잡성을 증가시키는 원인이 된다.따라서 변수의 스코프는 좁을수록 좋다. ES6는 이러한 var 키워드의 단점을 보완하기 위해 let과 const 키워드를 도입하였다. let, const 변수와 블록 스코프 ES2015에서 도입된 let, const에는 이전의 변수와는 다른 몇 가지 특징이 있다. 먼저, let과 const는 같은 이름을 갖는 변수의 재선언을 허용하지 않는다.1234567let foo = 1;let foo = 2; // unknown: Duplicate declaration \"foo\"const foo = 3; // unknown: Duplicate declaration \"foo\"function func(param) &#123; let param = 1; // unknown: Duplicate declaration \"param\"&#125; 변수가 선언되기 전에 참조하려고 하면 에러가 난다. 12console.log(foo); // ReferenceError: foo is not definedlet foo = 1; ES2015 이전에는 변수를 위와 같이 사용해도 에러가 나지 않았다.오히려 위와 같은 방식이 하나의 프로그래밍 기법으로 활용되기도 했다. 하지만, 가독성을 해치고 유지보수를 어렵게 만든다는 이유 때문에ES2015에 들어와서 제약이 강화된 let과 const가 도입된 것이다. let과 const가 바로 블록 스코프(block scope)를 갖는다는 것1234if (true) &#123; let i = 0;&#125;console.log(i); // i is not defined if문, for문, while문, function, try/catch문 등의 구문을 사용하면 블록이 형성되어,그 안에서 let 또는 const를 통해 선언된 변수는 외부에서 접근할 수 없다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수이다. 1234567891011121314for (let i = 0; i &lt; 10; i++) &#123; console.log(i); // 0 // 1 // 2 // 3 // 4 // 5 // 6 // 7 // 8 // 9&#125;console.log(i); // ReferenceError: i is not defined 특별한 기능이 없는 블록을 만들 수 있다.객체와 유사하게 중괄호로 코드의 일부분을 둘러싸면 된다. 1234&#123; let i = 0;&#125;console.log(i); // ReferenceError: i is not defined var 변수와 함수 스코프 ES2015에서 let, const가 도입되기 전까지는, 모든 변수는 var 키워드를 통해 선언되었다. var는 let과 유사하게, 값을 다시 대입할 수 있는 변수이다. var는 함수의 매개변수와 유사하게, 함수 스코프를 갖는다. 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다. 12345function func() &#123; var foo = 1;&#125;func();console.log(foo); // ReferenceError: foo is not defined var를 통해 선언된 변수는 let, const로 선언된 변수와는 다른 특징을 갖는다. 먼저, var를 통한 변수 선언은 재선언을 허용한다. 123var foo = 1;var foo = 1;// 아무런 에러도 발생하지 않는다. var로 선언된 변수는 내부적으로 함수 혹은 파일의 맨 위로 끌어올려지는호이스팅(hosting) 현상이 일어난다. 스코프 안에만 있다면 변수가 선언되기 전에도 해당 변수에 접근할 수 있다. 변수의 선언만 위로 끌어올려질 뿐 값을 대입하는 과정은 코드의 순서에 맞게 이루어진다. 따라서, 대입이 일어나기 전에 변수의 값을 읽으면 undefined가 불러와지게 된다. 123456789console.log(foo); // undefinedvar foo = 1;function func() &#123; console.log(bar); // undefined var bar = 1;&#125;func(); 마지막으로, var 변수는 함수 스코프를 갖는다.즉, 함수가 아닌 블록에서 정의된 var 변수는 해당 블록 바깥에서도 유효할 수 있다. 12345678function func() &#123; for (var i = 0; i &lt; 10; i++) &#123; //... &#125; console.log(i); // 10&#125;func(); cf) 참고 var를 let으로 변경했을 경우: 블록 스코프이기 때문에 for문 밖에서는 i를 찾을 수 없다. 12345678function func() &#123; for (let i = 0; i &lt; 10; i++) &#123; //... &#125; console.log(i); // ReferenceError: i is not defined&#125;func(); 함수가 아닌 블록에서 정의된 var 변수는해당 블록 바깥에서도 유효할 수 있다는 특징에 주의하지 않을 경우,중첩된 for 루프와 같이 블록이 중첩된 코드에서 의도치 않은 동작을 할 수 있다. 12345678910for (var i = 0; i &lt; 3; i++) &#123; console.log(\"outer\"); // outer for (var i = 0; i &lt; 3; i++) &#123; console.log(\"inner\"); // inner // inner // inner &#125;&#125; 위아래 두 i 변수는 같은 함수 스코프에서 정의된 같은 변수이다. 바깥쪽 루프를 한 번 도는 동안, 안쪽 루프를 도느라 이미 i의 값이 3이 되어버렸다. cf) 참고 var를 let으로 변경했을 경우 12345678910111213141516171819for (let i = 0; i &lt; 3; i++) &#123; console.log(\"outer\"); for (let i = 0; i &lt; 3; i++) &#123; console.log(\"inner\"); &#125;&#125;// outer// inner// inner// inner// outer// inner// inner// inner// outer// inner// inner// inner const let var 스코프 블록 스코프 블록 스코프 함수 스코프 재대입 X O O 재선언 X X O 호이스팅 X X O 사용 권장 1순위 2순위 3순위 참고링크 [값 더 알아보기]: https://helloworldjavascript.net/pages/220-value-in-depth.html","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"33 JavaScript Concepts -  Call Stack(호출 스택)","slug":"33-js-concepts-call-stack","date":"2019-04-03T13:05:47.000Z","updated":"2019-04-11T15:22:16.076Z","comments":true,"path":"2019/04/03/33-js-concepts-call-stack/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/03/33-js-concepts-call-stack/","excerpt":"","text":"이 문서는 33 Concepts Every JavaScript Developer Should Know 주제로 노마드 코더(Nomad Coders)님이 강의한 내용을 정리하였습니다. Call Stack(호출 스택) Call Stack은 자바스크립트가 함수 실행을 핸들하는 방법 중 하나이다. 자바스크립트가 실행해야하는 함수를 보면, 스택(Stack) 위에 올릴 것이다. 스택(Stack)은 쌓아 올리는 것이다. (ex) 책을 쌓아올리거나 카드 스택을 만들거나 등등) 자바스크립트는 함수를 그 스택 위에 올리고, 함수를 다 실행하면 제거한다. 스택을 다 처리하면 실행할 게 없으므로 끝나는 것이다. 예시를 위해 자바스크립트가 실행해야 하는 함수 리스트를 만들어 보자. 1234567891011121314151617function three() &#123; console.log(\"i love js\");&#125;function two() &#123; three();&#125;function one() &#123; two();&#125;function zero() &#123; one();&#125;zero();// 스택에 올라가는 순서: zero -&gt; one -&gt; two -&gt; three// 스택에서 제거되는 순서: three -&gt; two -&gt; one -&gt; zero 여기에 에러가 생기면 어떻게 될까?123456789101112131415161718function three() &#123; console.log(\"i love js\");&#125;function two() &#123; three();&#125;function one() &#123; two();&#125;function zero() &#123; one(); throw Error(\"omg i am an error\");&#125;zero();// i love js// Error: omg i am an erro 만약 콜스택 상단에 에러가 있다면 어떻게 될까?1234567891011121314151617181920212223// 만약 콜스택 상단에 에러가 있다면 어떻게 될까?function three() &#123; console.log(\"i love js\"); throw Error(\"omg i am an error\");&#125;function two() &#123; three();&#125;function one() &#123; two();&#125;function zero() &#123; one();&#125;zero();// i love js// Error: omg i am an error// at three:41:9// at two:44:3// at one:47:3// at zero:50:3// // 스택에 올라가는 순서: zero -&gt; one -&gt; two -&gt; three(에러 발생) 정리 리스트가 존재한다. 이를호출 스택(Call Stack)이라고 한다. 함수는 리스트에 추가된다. 함수는 실행이 완료되면 가장 최근에 추가된 것부터 차례로 리스트에서 제거된다. 자바스크립트의 to do list(할일 목록)인 셈이다. 참고 링크 노마드 코더 nomad coders- (EP 01.) 자바스크립트 개발자라면 알아야하는 핵심 컨셉 33개 | #1. Call Stack 33 Concepts Every JavaScript Developer Should Know","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"33-js-concepts","slug":"front-end/33-js-concepts","permalink":"https://JihyeHwang09.github.io/categories/front-end/33-js-concepts/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"33-js-concepts","slug":"33-js-concepts","permalink":"https://JihyeHwang09.github.io/tags/33-js-concepts/"}]},{"title":"스코프(Scope)","slug":"js-scope","date":"2019-04-02T14:32:53.000Z","updated":"2019-04-11T15:22:16.255Z","comments":true,"path":"2019/04/02/js-scope/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/02/js-scope/","excerpt":"","text":"스코프(Scope)123456function add(x, y) &#123; // 변수 `x`와 `y`가 정의됨 return x + y;&#125;add(2, 3);console.log(x); // 에러! 매개변수와 같이 함수 안에서 정의된 변수는 함수 바깥에서는 접근할 수 X 함수 안에서만 사용할 수 있다. 특정 변수가 유효한 코드 상의 유효 범위를 가지고 스코프(scope)라고 한다. 위 예제에서의 x와 y는 함수 add의 내부 코드 안에서만 접근할 수 있다. 즉, 매개변수는 함수 스코프를 갖는다. 스코프 연쇄 (Scope Chain)123456const five = 5;function add5(x) &#123; return x + five; // 바깥 스코프의 `five` 변수에 접근&#125;add5(3); //8 add5함수의 return구문에서 함수 바깥에 있는 변수 five의 값을 가져와 사용했다. 이는 심지어 함수가 여러 겹 중첩(nested)되어 있더라도 가능하다. 12345678const five = 5;function add5(x) &#123; function add(y) &#123; return x + y; &#125; return add(five);&#125;add5(3); // 8 코드의 실행 흐름이 식별자에 도달하면, 먼저 그 식별자와 같은 이름을 갖는 변수를 현재 스코프에서 찾아본다. 변수가 존재하면 그것을 그대로 사용 만약, 현재 스코프에서 변수를 찾지 못할 경우 -&gt; 바로 바깥쪽 스코프에서 변수를 찾아봄 있으면 사용하고 없으면 바깥쪽 스코프로 올라가서 다시 찾아보는, 이 과정이 되풀이됨 이런 과정을 스코프 연쇄(scope chain)라 한다. 가장 바깥쪽 스코프를 만날 때까지 반복 가장 바깥쪽 스코프까지 찾아봤는데도 같은 이름의 변수를 찾지 못하면, 그제서야 에러가 발생 가장 바깥에 있는 스코프를 최상위 스코프(top-level scope) 또는 전역 스코프(global scope)라고 부른다.위 코드에서 five가 정의된 스코프가 바로 전역 스코프이다. 변수 가리기 (Variable Shadowing) 단일 스코프에서 같은 이름을 갖는 서로 다른 변수는 존재할 수 X 하지만 스코프 연쇄가 일어나면 가능해진다. 아래의 코드에서는 x라는 이름을 갖는 변수가 세 번 정의되었다. 12345678910111213const x = 3;function add5(x) &#123; //`x`라는 변수가 다시 정의됨 function add(x, y) &#123; // `x`라는 변수가 다시 정의됨 return x + y; &#125; return add(x, 5);&#125;add5(x);// 8 바깥쪽 스코프에 존재하는 변수와 같은 이름을 같는 변수를 안쪽 스코프에서 재정의할 수 있다. 안쪽 스코프에서는 바깥쪽 스코프에 있는 이름이 무시된다. 이런 현상을 변수 가리기(variable shadowing)라고 한다. 어휘적 스코핑 (Lexical Scoping) 스코프는 함수 호출의 형태에 의해서가 아니라,코드가 작성된 구조에 의해서 결정되는 것이다. 1234567891011function add5(x) &#123; const five = 5; return add(x);&#125;add5(3);function add(x) &#123; return five + x;&#125;// five is not defined add라는 함수가 add5라는 함수 안에서 호출되었다고 해서,add 함수 내부에서 add5 함수의 스코프 안에 있는 변수에 접근할 수 있는 것은 아니다. 코프는 코드가 작성된 구조에 의해 결정되는 성질이다.위 코드를 동작시키려면, 아래와 같이 작성해야 한다. 스코프의 종류 이 챕터에서는 함수 스코프를 중점적으로 다루었는데, 사실 스코프의 종류가 더 있다.특히, let과 const로 선언된 변수는 함수 스코프가 아니라 조금 다른 종류의 스코프를 가진다. 참고링크 [값 더 알아보기]: https://helloworldjavascript.net/pages/220-value-in-depth.html","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"함수의 구성 요소- 매개변수(parameter)와 인수(argument), 반환값(return value)","slug":"js-parameter-argument","date":"2019-04-01T14:24:04.000Z","updated":"2019-04-11T15:22:16.256Z","comments":true,"path":"2019/04/01/js-parameter-argument/","link":"","permalink":"https://JihyeHwang09.github.io/2019/04/01/js-parameter-argument/","excerpt":"","text":"함수의 구성 요소실행 순서 주의할 점: 함수를 정의하는 것만으로는 함수 내부에 있는 코드가 실행되지 않는다. 함수 내부의 코드를 실행하려면, 반드시 함수를 호출해주어야 한다. 매개변수(parameter)와 인수(argument) 매개변수는 변수의 일종이다. 함수 호출 시마다 인수가 매개변수에 대입된다. 주의할 점: 매개변수는 바깥에서 선언된 변수와는 관계없는 독립적인 변수이다. 123456789function say(x) &#123; x = \"I will get over it soon\"; return x;&#125;const y = \"Can I get over it?\";const result = say(y);console.log(result);//I will get over it soon ex) 함수 호출 시 인수가 들어갈 자리에 변수를 써주고,함수 내부에서 매개변수에 새로운 값을 대입한다고 하더라도 인수로 써준 변수의 값이 변경되지 않는다. 매개변수는 let으로 선언한 변수와 비슷하게 동작하지만 미묘하게 다른 점이 있다. 반환값 return 구문은 함수의 반환값을 결정한다. return 키워드 바로 다음에 오는 값이 함수 호출의 결과값으로 반환되며,반환되는 즉시 함수 실행이 끝난다. return 뒤에 아무 값도 써주지 않거나 아예 return 구문을 쓰지 않을 경우,함수는 undefined를 반환한다. 참고 링크","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트에서 변수를 관리하는 방법","slug":"js-how-to-manage-variables","date":"2019-03-31T05:58:18.000Z","updated":"2019-04-11T15:22:16.256Z","comments":true,"path":"2019/03/31/js-how-to-manage-variables/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/31/js-how-to-manage-variables/","excerpt":"","text":"자바스크립트에서 변수 관리법- 1. 함수 단위 변수를 관리하는 방법에 대해 알아보자.JavaScript에서 변수를 관리하는 방법은 크게 세 가지로 정리할 수 있다. 함수 단위로 변수를 관리하기 실행 시의 변수 검색은 렉시컬 영역을 기준으로 하기 실행 시의 변수 검색은 변수 스코프 체인을 이용하기 변수를 관리하는 방법을 알아보기에 앞서, 먼저 변수의 종류에는 무엇이 있는지 알아보자. 변수의 종류 변수의 종류로는 크게 전역 변수,지역 변수가 있다. 전역 변수: 어디서나 접근할 수 있는 변수를 말한다. 지역 변수: 선언된 영역에서만 접근 가능한 변수이다. 자바스크립트 스코프(JavaScript Scope)의 개념 자바스크립트에서의 스코프(Scope)는 변수가 유효성을 갖는 영역. 즉, 변수가 유효한 범위를 말한다. 해당 영역을 벗어난 변수는 참조할 수 없다는 특징이 있다. 중요한 것은 자바스크립트는 다른 언어와는 달리 중괄호가 아닌 변수를 함수 단위로 관리한다는 점이다. 1. 함수 단위로 변수를 관리하기자바스크립트에서는 변수를 함수 단위로 관리한다는 것을 예제를 통해 살펴보자. 예제112345678function mood() &#123; if (true) &#123; let now = \"excited\"; &#125; now = \"awesome\"; return now;&#125;mood(); // awesome 자바스크립트에서는 같은 함수의 내부에 있다면,위의 예제처럼 함수 안에 정의된 블록의 종류에 상관없이(if문, for문 등)정의한 변수에도 접근할 수 있다. 따라서 now = “awesome”;는 변수 now가 정의된 if문을 벗어났지만,같은 함수인 mood 내부에 있으므로 변수 now에 “awesone”이라는 문자열을 대입할 수 있는 것이다. 예제212345678let now = \"tired\";function mood() &#123; let now = \"excited\"; now = \"awesome\"; return now;&#125;mood(); // now의 값을 바꾸기 위해 시도console.log(now); // tired 함수 mood를 실행해도 now를 콘솔에 찍어보면, tired가 찍힌다. 위의 코드에서 let now = “tired”;처럼 어떠한 함수에도 포함되어 있는 않은 변수는 전역 변수 스코프에 정의된다. 같은 변수 now라도 함수 mood 바깥에 있는 now는 전역변수이고,mood 함수 안에 있는 now는 지역 변수이다. 따라서, 콘솔로 now를 찍을 때는 이미 함수 mood안에 정의되어 있는 now의 유효 범위를 벗어났기 때문에전역 변수인 now의 값인 tired가 찍히는 것이다. 참고 링크 [자바스크립트(javascript) 변수 스코프]:https://jusungpark.tistory.com/32 [Javascript - 변수관리 특징 및 스코프체인에 대하여]: https://trustyoo86.github.io/javascript/2017/11/18/javascript-variables-scope-chain.html","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"즉시 실행 함수(Immediately-invoked function expression)","slug":"js-immediately-invoked-function-expression","date":"2019-03-30T04:17:01.000Z","updated":"2019-04-11T15:22:16.232Z","comments":true,"path":"2019/03/30/js-immediately-invoked-function-expression/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/30/js-immediately-invoked-function-expression/","excerpt":"","text":"즉시 실행 함수(Immediately-invoked function expression)라는 키워드를 접하게 되어 정리해보고자 한다.즉시 실행 함수란 무엇이며 어떤 경우에 사용하고 즉시 실행 함수를 이용하는 방법에 대해 알아보자. 즉시 실행 함수(Immediately-invoked function expression)란? 일반적인 함수는 선언과 호출을 각각 따로 하는데,즉시 실행 함수는 함수를 정의함과 동시에 즉시 실행할 수 있다. 따로 호출하는 코드를 작성할 필요가 없다. 즉시 실행 함수의 종류는 기명 즉시 실행 함수(함수의 이름이 있는 즉시 실행 함수)와 익명 즉시 실행 함수(함수의 이름이 없는 즉시 실행 함수)가 있다. 즉시 실행 함수를 사용하는 이유1. 초기화 즉시 실행 함수는 최초로 한 번만 실행하는 초기화 코드에 많이 사용된다. 변수를 전역으로 선언하지 않기 위해서이다. 그 결과, 전역에 변수를 따로 추가하지 않아도 되므로 코드의 충돌 없이 구현할 수 있다. 즉시 실행 함수의 경우 같은 함수를 다시 호출할 수 없다.-&gt; 주로 플러그인이나 라이브러리 등을 만들 때 많이 사용된다. 2. 특정 스코프를 만들 때 사용 익명 함수로써 레퍼런스 없이 즉각적으로 실행되기 때문에특정 스코프를 만들 때 유용하게 사용할 수 있다. 즉시 실행 함수를 만드는 방법 즉시 실행 함수의 기본 형태는 아래와 같다. 즉시 실행 함수의 기본적인 형태123(function() &#123; // statements&#125;)(); 즉시 실행 함수 예시1234(function(food) &#123; console.log(\"I want some \" + food);&#125;)(\"cake\");// I want some cake 즉시 실행 함수로 만들기 위해서는 기명 함수이든 익명 함수이든 상관은 없다. 함수 리터럴을 소괄호()로 둘러싸준다. 일반적인 함수를 작성한다. function(food) {...} 이 함수를 소괄호로 감싸주어 (function(food) {...}) 의 형태로 만들어 준다. 함수가 바로 실행될 수 있게 하기 위해 소괄호()한 쌍을 바로 뒤에 붙여준다.(function(food) {...})(); 방금 추가한 ()안에 즉시 실행 함수의 인자로 넘길 값을 추가한다.(function(food) { ... })(&quot;cake&quot;); 위의 예제에서는 (&#39;cake&#39;)를 즉시 실행 함수의 인자로 넘겨서 호출하였다. 이때, &#39;cake&#39;는 food 매개변수로 넘겨지게 되는 것이다. 참고 링크 [ECMAScript 6 - Functions, 함수 2편]: http://0ctopus13prime.blogspot.com/2017/01/ecmascript-6-functions-2.html [자바스크립트 강좌 009 즉시 실행 함수 사용(Javascript Function)]: https://codingcoding.tistory.com/749","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"개발자의 Notion 활용하기","slug":"TIL-2019-03-29","date":"2019-03-29T05:32:19.000Z","updated":"2019-05-12T15:31:36.200Z","comments":true,"path":"2019/03/29/TIL-2019-03-29/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/29/TIL-2019-03-29/","excerpt":"","text":"개발자의 Notion 활용하기 나는 개발자로 일하면서 만난 이슈들과 여러가지 시도한 방법들 그리고 해결한 방법을개인적으로 Notion에 보드를 따로 만들어서 관리하고 있다. markdown 문서로 하나 하나 일일이 만드는 것보다 좋은 점을 느껴서Notion을 활용하는 이유를 적고자 한다. 개발 일정에 Notion을 활용하는 이유 보드에 블럭 단위로 관리하고 그 안에 코드와 함께 내가 작성한 기획 문서나 순서도 등을넣을 수 있어서 좋다고 느낀다. Notion에 작성한 파일을 마크다운 문서로 다운 받을 수 있다.(단, 다운 받을 때는 depth가 있어서 바로 마크다운 문서 1개의 파일이 아닌 압축 파일로 다운 받아진다.) 파일의 depth가 무제한이다. 마크다운 문서의 형태로 포스팅을 하면서 depth가 깊지 않아 불편함을 많이 느꼈다.(ex) 현재 블로그 카테고리의 depth는개발자- til 두 단계까지만 가능하다.) Notion은 무료 회원일 경우 블럭을 1,000개까지 무료 생성할 수 있고,유료 회원의 경우 블럭 안에 블럭 그 안에 블럭..을 끝없이 만들 수 있다. Notion을 개발에 활용하는 방법(개인적인 활용법) 나의 경우에는 개발 관련 보드를 따로 만들었다.(ex) Tasks &amp; Issues보드를 생성한다.) 보드의 구성은 To-do, doing, done, issues, today, nextup으로 구성하였다. To-do, doing, done 탭은 이번 개발 마지노선 기간까지 완료할 일을 적고 활용하는 구간이다. issues에는 개발을 하면서 어려운 점이 있거나 이슈가 발생했을 때,에러 메시지, 시도한 방안, 해결 방법, 참고 링크 등을 정리해둔다. today는 오늘 개발할 일정을 정리해두는 탭이다.To-do, doing 탭에 있는 기능들 중 오늘 구현할 내용들을 드로그 앤 드롭으로today 탭에 넣는다. nextup은 이번 기능 개발 마지노선 이후에 추가로 구현할 기능이나 추후 개발할 내용에 대해 정리해두는 탭이다.(ex) 이번 개발 마지노선까지는 날씨 정보에 대해 [시/도] 단위까지 구현하는 게 목표라면,nextup에는 [구/군], [읍/면/동] 단위까지 구현하는 일정을 적어둔다.) 큰 개발 일정을 적어두고, 블럭 단위로 큰 개발 목표 구현을 위해세세하게 구현해야 할 기능들을 블럭 단위로 만든다. 그 후, 개발에 대한 결과물을 내야 하는 마지노선 일자를 적어둔 후,To-do 탭 안에 기능 단위로 나뉘어진 블록 안에 그 기능을 구현하기 위해 할 일을 To-do list의 형태로 적어둔다.(개발하면서 추가, 수정, 삭제될 수 있다.)(분명 예상보다 이슈 등을 만나면 일정에 차질에 생길 수 있으므로 버퍼 1~2일을 미리 계산해둔다.) To-do탭 안에 있는 To-do list의 일들을 체크박스에 하나씩 체크 표시하면서 개발을 진행한다.(이렇게 개발을 진행할 경우, 중간에 수정사항이 생기거나 추가 기능이 생겨도 빠짐없이 구현할 수 있다.특히 일정이 타이트할 경우에도 To-do list를 보고 차근차근 하나씩 클리어하면 되므로 멘붕에 빠지는 걸 방지할 수 있었다.) To-do에서 doing을 거쳐 블록 안에 작성된 To-list 체크박스 항목들을 다 완료하면, done탭으로 옮긴다.(만약 done탭으로 옮겨진 기능에 에러가 생기면 다시 to-do탭으로 옮기고, 블럭 안에 to-do list를 추가한다. ) 개발 이슈에 대한 정리 사람은 똑같은 실수를 반복하기 마련이다. 그건 개발자도 예외가 아니다. 해당 이슈를 해결한 경험이 있더라도 사람의 기억력에는 한계가 있기 때문에 정리해두어서 꺼내 쓸 수 있어야 한다는 생각이 들었다. 습관적으로 틀리는 부분을 반복하기 때문에 겪었던 이슈를 적어두고 이에 대해 시도한 방안들, 해결한 방안들을 정리해둔다. 나만의 이슈 해결 라이브러리라고 볼 수 있다. 이슈를 만날 경우, 해당 발생 이슈를 블럭 하나를 생성해서 제목에 적는다. 내용에는 참고한 링크를 넣고, 시도한 방안, 해결 방법과 함께 해당 부분의 코드를 적는다. 코드를 넣을 때는 이슈가 발생한 코드와 이슈를 해결한 코드 2가지를 함께 넣는다.(추후 비교해서 확인하기 위해) 시도한 방안과 해결 방법을 나누어서 적는 이유는 내가 한 이슈에 대해서 어떤 시도를 했으며 이 시도가작용하지 않는 이유, 결론을 찾는 절차를 정리하기 위함이다. 아래 그림은 내가 작성한 Notion에 이슈를 정리한 예시이다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"정신 없는 일주일 그래도 포스팅을 하는 이유","slug":"TIL-2019-03-28","date":"2019-03-28T05:32:19.000Z","updated":"2019-07-24T12:11:23.995Z","comments":true,"path":"2019/03/28/TIL-2019-03-28/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/28/TIL-2019-03-28/","excerpt":"","text":"2019년 3월 28일 (목)정신 없는 일주일 그래도 포스팅을 하는 이유 우왕좌왕 정신 없는 1주일이었다. 특히 이번주는 어떻게 시간이 갔는지 기억이 안 날 정도로 바쁘게 흘러갔다. 너무 피곤하고 퇴근 후 집에 와서 노트북을 켜기까지가 힘들었다. 체력이 고갈되면 사람은 아무것도 하고 싶지 않고 다 놓고 싶어지기 마련이다. 방전 직전인 상태를 극복하고 포스팅을 하는 방법은 무엇일까? 내가 생각한 극복 방법은 집에 도착하자마자 옷도 갈아입지 않고 책상에 앉아서 포스팅을 올리는 방법이다. 이 방법을 이용해 피곤하지만 매일 포스팅을 할 수 있어서 현재 상황에서 효과적인 방법이라고 느꼈다. 개발을 하면서 만나는 에러와 함께 개발자로서의 삶에서 겪는 어려움이나 이슈들을새벽에 단 한 줄이라도 정리했다. 이를 통해 내가 개발자로서어떻게 하루하루를 살아가고 있는지를 보고 기억할 수 있다고 생각한다. 회사에서 야근을 하면서 매일 포스팅을 하는 것에 어려움을 많이 느끼고 있다.이러한 환경 속에서 몸이 힘들다는 이유로 포스팅을 남기지 않았다면 어땠을까?아마 그저 시간들을 흘려보냈을 거라고 생각한다.몸과 마음이 지칠 때일수록 내가 왜 포스팅을 하는지를 다시 떠올려 본다.나는 그저 개발자로서 살아가는 하루하루를 기록하고 이 기록들이 누군가에게,단 한 명에게라도 긍정적인 영향을 줄 수 있다면 정말 행복할 것 같다.더욱 이럴 때일수록 힘을 내서 포스팅을 할 필요를 느낀다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"객체의 속성 열거하기","slug":"js-object","date":"2019-03-27T14:14:16.000Z","updated":"2019-04-11T15:22:16.233Z","comments":true,"path":"2019/03/27/js-object/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/27/js-object/","excerpt":"","text":"객체의 속성 열거하기 객체의 속성을 열거할 때 사용할 수 있는 방법들을 정리해보자. Object.keys: 객체 자신의 속성 중 열거 가능한(enumerable) 속성의 이름을 배열로 반환 Object.values: 객체 자신의 속성 중 열거 가능한(enumerable) 속성의 속성 값을 배열로 반환 Object.entries: 객체 자신의 속성 중 열거 가능한(enumerable) 속성의 이름과 값을 배열로 반환 Object.getOwnPropertyNames: 객체 자신의 모든 속성의 이름을 배열로 반환합니다. 열거 불가능한 속성도 포함 for...in 구문: 객체 자신의 속성 및 상속받은 속성 중 열거 가능한(enumerable) 속성의 이름을 배열로 반환 경우에 따라 사용할 방법 대개의 경우 Object.keys를 사용하면 되지만, 상속받은 속성까지 열거하고 싶을 때는 for...in을 사용 열거 불가능한 속성도 열거하고 싶을 때는 Object.getOwnPropertyNames를 사용 12345678910111213141516const seasonObj = &#123; friend: \"Mike\", think: \"It's good weather! Let's hangout together!\"&#125;;Object.keys(seasonObj);// [ 'friend', 'think' ]Object.values(seasonObj);// [ 'Mike', 'It's good weather! Let's hangout together!' ]Object.values(seasonObj).join(\",\");// 'Mike,It's good weather! Let's hangout together!'Object.entries(seasonObj);// [ [ 'friend', 'Mike' ],// [ 'think', 'It's good weather! Let's hangout together!' ] ] 참고 링크 [객체의 속성 열거하기]: https://helloworldjavascript.net/pages/240-object-in-depth.html","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"2019-03-26_TIL","slug":"TIL-2019-03-26","date":"2019-03-25T16:39:47.000Z","updated":"2019-04-16T13:04:41.700Z","comments":true,"path":"2019/03/26/TIL-2019-03-26/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/26/TIL-2019-03-26/","excerpt":"","text":"2019년 3월 26일 (화)node를 하다가 react를 하려니까 마음만큼 속도가 나지 않는다.우선은 지금부터 최대한 내가 할 수 있는 부분부터 구현해보자.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"사실 시간이 없다는 건 핑계다.","slug":"TIL-2019-03-25","date":"2019-03-24T16:39:47.000Z","updated":"2019-07-24T12:12:06.489Z","comments":true,"path":"2019/03/25/TIL-2019-03-25/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/25/TIL-2019-03-25/","excerpt":"","text":"2019년 3월 25일 (월)사실 시간이 없다는 건 핑계다. 퇴근 후에 집에 오면 늘 밤 12시 혹은 새벽이었다. 돌이켜 생각해보니 나도 모르게 시간이 없다는 말을 많이 했던 것 같다. 시간이 없다는 건 사실 핑계다. 분명히 누수되는 시간은 있다. 평소 나는 아침 시간을 활용하려고 노력했다. 그래서 5시 ~ 5시 30분쯤에 일어나곤 했다. 계속 야근을 하다보니 내 생활 루틴이 깨졌고 늦게 일어나기 시작했다. 내가 집중적으로 공부할 수 있는 시간을 흘려 보내고 있었다. 하고 싶은 것들을 하기 위한 시간을 따로 내는 건 현재 상황에서 불가능에 가깝다.지금 하고 있는 node, react, javascript, css와 Computer Science 공부,사이드 프로젝트, 영어 공부 등등. 아침 시간 활용 암기카드 어플에 공부할 내용을 정리해두고 자동 재생 한다.출근 준비를 하면서, 틈날 때마다 본다. 출근 길에 서있어야 해서 무언가 책을 펼치거나 할 수 없으므로영화 인턴 mp3 파일을 반복해서 듣는다. 2) 잠을 줄이지는 X! 잠을 줄이면 집중하는 시간의 밀도가 떨어진다.수명을 줄이는 것과 같다. 더 줄일 수는 없다.-&gt; 대처 방법: 꾸준히 적어도 5시간은 수면 시간을 확보한다. 꾸준한 운동 평일에 퇴근하고 새벽까지 여는 헬스장에 잠깐이라도 들러서 30분이라도 운동을 하면스트레스가 풀리고 몸이 가벼워지는 느낌을 받았다. 장기적인 관점에서 건강한 개발을 위해 운동은 꼭 시간을 내어서 할 필요가 있다. 지금 당장은 시간이 들지만 운동을 했을 때 긍정적인 효과로 목, 허리 건강과 체력을 얻을 수 있다. -&gt; 대처 방법: 평일에는 퇴근길에 주2회 화, 금 헬스장에 들러 (계단 오르기 머신 || 등 운동)을 한다.집에 들렀다가 나오면 집에서 나올 수 없다. 퇴근 길에 바로 헬스장으로 가자.주말은 하루 1시간 30분 가량 운동에 시간을 할애한다.몸이 피곤할 경우 가기 귀찮아질 수 있으므로미리 운동복과 물병 등을 챙겨서 머리 맡에 놓아두고 눈 뜨면 바로 나간다는 원칙을 세워둔다.헬스장에 가는 게 어렵지, 가면 열심히 하는 나를 발견할 수 있다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"8시간의 삽질 그리고 얻은 건..","slug":"TIL-2019-03-24","date":"2019-03-24T14:34:52.000Z","updated":"2019-07-24T12:11:50.284Z","comments":true,"path":"2019/03/24/TIL-2019-03-24/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/24/TIL-2019-03-24/","excerpt":"","text":"2019년 3월 24일 (일)8시간의 삽질 그리고 얻은 건.. 오늘 create-react-app으로 React 프로젝트를 만들고 npm start로 띄우려는데 에러를 만났다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950here might be a problem with the project dependency tree.It is likely not a bug in Create React App, but something you need to fix locally.The react-scripts package provided by Create React App requires a dependency: \"babel-eslint\": \"9.0.0\"Don't try to install it manually: your package manager does it automatically.However, a different version of babel-eslint was detected higher up in the tree: c:\\Users\\username\\node_modules\\babel-eslint (version: 10.0.1)Manually installing incompatible versions is known to cause hard-to-debug issues.If prefer to ignore this check, add SKIP_PREFLIGHT_CHECK=true to an .env file in your project.That will permanently disable this message but you might encounter other issues.To fix the dependency tree, try following the steps below in the exact order: 1. Delete package-lock.json (not package.json!) and/or yarn.lock in your project folder. 2. Delete node_modules in your project folder. 3. Remove \"babel-eslint\" from dependencies and/or devDependencies in the package.json file in your project folder. 4. Run npm install or yarn, depending on the package manager you use.In most cases, this should be enough to fix the problem.If this has not helped, there are a few other things you can try: 5. If you used npm, install yarn (http://yarnpkg.com/) and repeat the above steps with it instead. This may help because npm has known issues with package hoisting which may get resolved in future versions. 6. Check if c:\\Users\\useranme\\node_modules\\babel-eslint is outside your project directory. For example, you might have accidentally installed something in your home folder. 7. Try running npm ls babel-eslint in your project folder. This will tell you which other package (apart from the expected react-scripts) installed babel-eslint.If nothing else helps, add SKIP_PREFLIGHT_CHECK=true to an .env file in your project.That would permanently disable this preflight check in case you want to proceed anyway.P.S. We know this message is long but please read the steps above :-) We hope you find them helpful!npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! class101@0.1.0 start: `react-scripts start`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the class101@0.1.0 start script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in: 읽어보니 babel-eslint 버전이 맞지 않는 것 같아서 친절하게 번호까지 매겨져 있는 설명을 따라차근차근 시도해 보았지만 변화한 건 없었다. 구글에 위의 에러 내용을 검색하여 stackoverflow나 다른 블로그들에 나온 해법들을 적용해보았으나 해결되지 않았다. 오후 2시부터 오후 10시 10분 가량까지 약 8시간 동안 이 에러 하나 고쳐보겠다고 구글링을 열심히 했는데, 결국완전히 해결하지는 못했다. 강제로 파일을 날려버리고 새로 설치하는 것도 시도해봤는데 어디가 꼬인 건지 아직 찾지 못했다.위의 에러 내용에 나온 If prefer to ignore this check, add SKIP_PREFLIGHT_CHECK=true to an .env file in your project. That will permanently disable this message but you might encounter other issues.를 참고해서React project 폴더의 .env파일에 SKIP_PREFLIGHT_CHECK=true를 넣어서 오류를 무시하고 우선은 띄우기로 했다.그 후에 npm start를 했더니 화면이 띄워진다. 문제를 해결한 것이 아니기에 속시원하지는 않다. 8시간 동안의 삽질이었다. 그리고 그 결과로 완전히 해결책을 얻은 것도 아니다. 임시 방편을 사용해서 우선은 프로젝트를 할 수 있는 정도. 이 8시간 동안의 삽질을 하면서 그 과정에서 ‘내가 개발자로서 살아가는 인생에서 삽질은 계속 되겠구나..’라는 생각이 들었다. 이 오랜 삽질이 언제 끝날지도 모르고 그 삽질의 결과로 유의미한 결과를 얻을 수 있을지 불확실하다. 이 불확실함에도 포기하지 않고 해결 방안을 찾아보고 계속해서 적용해보는 자세.그걸 얻었으면 그것으로도 오늘 하루의 삽질이 내 개발자로서의 삶에 굉장히 의미있는 순간이라고 생각한다. 오늘 만난 이 에러는 더 검색해 보고 해결 방안을 찾아보도록 해야겠다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"2019-03-23_TIL","slug":"TIL-2019-03-23","date":"2019-03-23T13:24:03.000Z","updated":"2019-04-16T13:04:41.695Z","comments":true,"path":"2019/03/23/TIL-2019-03-23/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/23/TIL-2019-03-23/","excerpt":"","text":"2019년 3월 23일 (토) 나는 블로그에 글을 쓰면서 내 블로그에 방문해서 글을 본 분들이주위 지인들 외에는 없을 거라 생각했는데, 오늘 놀라운 경험을 했다. 블로그 글 중에 3월20일자 TIL에 어설프게 알고 있어서 틀린 내용을 올렸었다.javascript의 배열 메소드 중에 pop()과 shift()는 배열의 요소를 삭제한 후 삭제한 요소를 반환한다.내가 쓴 글에서는 push(), uhshift()와 함께 배열의 길이를 리턴한다고 잘못 쓴 부분이 있었다.오늘 이 글에서 틀린 부분을 말씀해주신 분이 계셔서 수정할 수 있었다.누군가가 내가 쓴 글을 보고 그에 대한 피드백을 준다는 게 신기하고 감사한 일이다.덕분에 내가 어떤 부분을 어설프게 알고 있었는지를 알 수 있었고 좋은 자극이 되었다. 이 글을 통해 정말 감사하다는 말씀 다시 한 번 드리고 싶다. 테스트 주도 개발과 테스트라는 용어에 대한 차이를 알게 되었다.나도 모르게 두 단어를 혼동하고 있었다.테스트 주도 개발은 테스트를 먼저 만들고 테스트를 통과하기 위해 코드를 짜는 것을 말한다.내가 생각한 개발에 적용하고 싶은 테스트 방법은 단위 테스트에 가깝다고 볼 수 있다는 것을 알게 되었다. 깨달은 점 완벽한 지식이란 없는 것 같다.내가 맞게 알고 있는 것인지 끊임없이 생각해보고 검색하고 정리하자.어설프게 알고 있다면 빠르게 수정하고 이를 활용해서 익혀두자.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"배열의 특정한 위치에서 요소를 추가 또는 삭제하기","slug":"js-array.splice","date":"2019-03-22T12:23:13.000Z","updated":"2019-04-11T15:22:16.198Z","comments":true,"path":"2019/03/22/js-array.splice/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/22/js-array.splice/","excerpt":"","text":"배열의 특정한 위치에서 요소를 추가 또는 삭제하기 Array.splice는 배열의 중간에서 요소를 삭제하거나 추가할 수 있다. 오늘은 배열 중간에 원하는 값을 추가하기 위해 Array.splice를 사용하였다. Array.splice의 추가/삭제에 대해 정리해보자. Array.splice(시작 인덱스의 위치, 삭제할 요소의 개수(추가할 때는 0을 넣음), elements); 의 형식으로 사용한다. 1. 배열의 특정한 위치에서 요소를 삭제하기12345let arr = [a, b, c, d, e];arr.splice(3, 1);// dconsole.log(arr);// [a, b, c, e]; 배열에서 splice를 이용해서 삭제를 하기 위해서는 세 번째 인자는 주지 않는다. -&gt; Array.splice(시작 인덱스의 위치, 삭제할 요소의 개수); 인덱스는 0부터 시작한다. 3번째 요소인 d가 삭제된 상태가 된다. splice를 사용하면, 삭제된 요소가 return된다. splice는 원본 배열을 변경하기 때문에 arr.aplice를 실행한 후에는배열 arr에는 d가 삭제되어 있다. 2. 배열의 특정한 위치에서 추가하기123456let scheArr = [\"오늘\", \"오후\", \"2시\", \"알려줄게.\"];scheArr.splice(3, 0, \"일정\");console.log(scheArr);// [ '오늘', '오후', '2시', '일정', '알려줄게.' ]scheArr.join(\" \");//'오늘 오후 2시 일정 알려줄게.' splice를 이용하여 배열의 특정한 위치에 요소를 추가할 때는Array.splice(시작 인덱스의 위치, 0, elements); 의 형식으로 사용한다. 배열에서 요소를 삭제할 때와 다른 점은 2번째 인자 값을 꼭 0으로 주어야 한다는 것이다.0 이외에 다른 인덱스값을 넣을 경우에는 해당 인덱스에 있는 요소의 개수만큼 값이 세번째 인자로 준elements값으로교체되니 주의하자.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"2019-03-21_TIL","slug":"TIL-2019-03-21","date":"2019-03-20T23:59:11.000Z","updated":"2019-04-16T13:04:41.692Z","comments":true,"path":"2019/03/21/TIL-2019-03-21/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/21/TIL-2019-03-21/","excerpt":"","text":"2019년 3월 21일 (목) 예외 처리를 할 때는 다양한 방법들이 있지만,코드 라인 수를 줄이면서도 정확하게 내가 원하는 value와 type을 얻는 것이 중요하다는 걸 느꼈다. 공부할 것 예외 처리 케이스를 나누는 방법에 대해 생각해보기 예외 처리를 효과적으로 할 수 있는 도구들에 대해 알아보기","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"2019-03-20_TIL","slug":"TIL-2019-03-20","date":"2019-03-20T00:15:18.000Z","updated":"2019-04-29T00:01:57.464Z","comments":true,"path":"2019/03/20/TIL-2019-03-20/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/20/TIL-2019-03-20/","excerpt":"","text":"2019년 3월 20일 (수) 오늘 output으로 새 배열을 return하는 메소드와 배열의 길이를 return하는 메소드들을 이용했다.output으로 새 배열을 return하는 메소드에는 join(), map(), filter() 등이 있고,배열의 길이를 return하는 메소드로는 push() / unshift()등이 있다.(cf) pop()는 배열에서 삭제한 요소를, push()는 배열에 추가한 요소를 반환한다.) 이 과정에서 느낀 건 메소드의 기본적인 기능을 아는 것을 넘어서리턴값으로 무엇이 나오는지를 정확히 인지하고 있는 것 또한 중요하다는 것을 느꼈다.각 메소드의 리턴값의 포맷을 알고 있다면, 불필요한 코드를 줄일 수 있다. 공부할 것 자바스크립트에서 객체의 깊은 복사와 얕은 복사 - 구현 방법, 차이점 알아보기 각 메소드에 대한 input, output 타입 등 정리하기","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"2019-03-19_TIL","slug":"TIL-2019-03-19","date":"2019-03-18T15:22:25.000Z","updated":"2019-04-16T13:04:41.703Z","comments":true,"path":"2019/03/19/TIL-2019-03-19/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/19/TIL-2019-03-19/","excerpt":"","text":"2019년 3월 19일 (화) 개발을 하면서 막상 작동하는 코드를 구현하는 시간보다는이 코드가 내가 원하는 대로 잘 작동하는지몇 가지 케이스를 나눠서 시험하는 것, 디버깅하는 것에 시간을 더 쏟는다. 테스트 주도 개발 방법을 도입할 필요성을 절실히 느꼈으며 그로 인해 테스트 프레임 워크에 관심이 생겼다. 공부할 것 TDD(Test-driven Development) 테스트 주도 개발 방법 공부하기 Jest, Mocha 등의 자바스크립트 테스트 프레임 워크 공부해서 개발에 적용하기","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"2019-03-18_TIL","slug":"TIL-2019-03-18","date":"2019-03-18T14:07:20.000Z","updated":"2019-04-16T13:04:41.687Z","comments":true,"path":"2019/03/18/TIL-2019-03-18/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/18/TIL-2019-03-18/","excerpt":"","text":"2019년 3월 18일 (월) async/await를 어설프게 알고 있다가 구현하면서 어려움을 겪었다. node에서 콜백 지옥이 어떤 것인지 경험해 보았다. 코드 최적화를 고민해 보는 좋은 경험이었다. 1flow를 완성했다고 생각하면 생각지 못한 곳에서 에러가 나곤 했다.코드를 짤 때는 그 타입을 생각하고 값이 오지 않았을 때 등의 방어 코드를 잘 작성하는 게 중요하다는 걸 느꼈다. 공부할 것 async/await의 구동 원리 정리 하기 콜백 지옥을 극복하는 여러 시도들 정리하기","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"2019-03-17_TIL","slug":"TIL-2019-03-17","date":"2019-03-17T00:57:28.000Z","updated":"2019-04-16T13:04:41.687Z","comments":true,"path":"2019/03/17/TIL-2019-03-17/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/17/TIL-2019-03-17/","excerpt":"","text":"2019년 3월 17일 (일) 2개월 간 1일 1포스팅을 해가던 기록이 깨졌다. 어제 3월16일 밤 11시59분에 hexo g -d를 입력하고빌드, 배포되는 과정에서 00시가 넘어간 것으로 보인다. 사람은 언제든 실패할 수 있다.중요한 건 실패를 대하는 태도이다. 좌절을 겪는 건 사실이지만이 실패로 내 자신이 더 단단해질 것이라 생각한다.그저 지금까지 하던대로 다시 시작하면 되는 것이다. 대처법 당일 밤 12시 이전에 포스팅을 하는 것보다는00시가 지난 후 그 당일의 포스팅을 하자.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"2019-03-16_TIL","slug":"TIL-2019-03-16","date":"2019-03-16T14:55:14.000Z","updated":"2019-04-16T13:04:41.687Z","comments":true,"path":"2019/03/16/TIL-2019-03-16/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/16/TIL-2019-03-16/","excerpt":"","text":"2019년 3월 16일 (토) 하고 싶은 것도 많고 이를 위해서는 운동할 시간도 공부할 시간도 필요하다.시간은 한정되어 있고 그 한정된 시간을 사용하기 위해서는무엇이 중요하고 우선되어야 하는지를 구분할 필요가 있다.우선 순위를 세워서 선택과 집중을 할 시기이다. 생각해 볼 것 현재와 미래의 나를 생각해 볼 때 중요한 우선순위를 세워 보자.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"2019-03-15_TIL","slug":"TIL-2019-03-15","date":"2019-03-15T13:57:36.000Z","updated":"2019-04-16T13:04:41.687Z","comments":true,"path":"2019/03/15/TIL-2019-03-15/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/15/TIL-2019-03-15/","excerpt":"","text":"2019년 3월 15일 (금) 디버깅 방식의 중요성을 느꼈다. 코드를 짜는 시간보다 디버깅 시간이 훨씬 오래 걸리고 있다. 대안책이 필요하다. async를 하면 await를 어디에 붙일지를 생각하자.그리고 빼먹지 말자. JavaScript find 메소드, 하나의 함수에서 2개 이상의 값을 return 하는 여러가지 방법에 대해 내용 정리하자.","categories":[],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"2019-03-14_TIL","slug":"TIL_2019-03-14","date":"2019-03-13T15:31:00.000Z","updated":"2019-04-16T13:04:41.703Z","comments":true,"path":"2019/03/14/TIL_2019-03-14/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/14/TIL_2019-03-14/","excerpt":"","text":"2019년 3월 14일 (목) 개발하기 전의 기획과는 다르게 개발 방향이 흘러갈 수도 있다.물론 기획 단계에서는 알지 못했던 구현 불가능한 요소가 있을 수도 있다.하지만 큰 flow는 염두에 두고 방향성을 가지고 개발을 하는 게 좋을 것 같다.소프트웨어 구조 설계 하는 법을 공부하고 싶다. return의 유효 범위, findIndexOf, forEach 내용 정리하자.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"2019-03-13_TIL","slug":"TIL-2019-03-13","date":"2019-03-13T14:58:04.000Z","updated":"2019-04-16T13:04:41.686Z","comments":true,"path":"2019/03/13/TIL-2019-03-13/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/13/TIL-2019-03-13/","excerpt":"","text":"2019년 3월 13일 (수) Node.js와 JavaScript로 개발하면서 타입 에러를 자주 만났다.TypeScript를 공부해서 적용해 보고 싶다는 생각이 들었다. 서버를 전문적으로 배우고 싶다. 우선은 Node.js로 시작해서 noSQL인 mongoDB를 공부할 생각이다. openAPI는 내가 원하는 자료 형태가 존재하지 않을 때도 있고, 원하는 정보를가져올 수 있다고 해도 요청을 여러 번 해서 속도가 현저히 느려질 수 있다.최적화하는 방법은 뭘까 고민해보자. 생각해 볼 것 어느 선까지를 MVP로 볼 것인가? 내가 되고자 하는 개발자로서의 방향성","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"JavaScript에서 return과 break의 차이","slug":"js-return-and-break","date":"2019-03-11T15:34:35.000Z","updated":"2019-04-11T15:22:16.288Z","comments":true,"path":"2019/03/12/js-return-and-break/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/12/js-return-and-break/","excerpt":"","text":"JavaScript에서 return과 break의 차이 JavaScript로 코드를 짜면서 for문과 switch문을 작성할 일이 있었다.return과 break가 비슷한 역할을 하면서도 미묘한 차이가 있다는 사실은 알지만,명확하게 무엇이 다른 지는 생각나지 않았다. 따라서, 간략하게 정리하고자 한다. 1. return return은 함수 실행을 종료하고, 함수를 빠져 나온다. 2. break break는 현재 루프 즉, switch나 for, while문 등을 종료하고 루프에서 빠져나온다. 3. return과 break의 차이 만약에 함수 안에 작성된 루프 안에서 break가 쓰였다면, break를 감싸고 있는 루프를 빠져나가고 함수 밖으로는 나가지 않는다.return은 함수 실행을 종료하고 함수를 호출한 곳으로 실행 흐름을 옮긴다. 예시1234567891011121314// 다음 함수는 i가 3일 때, break문을 만나서, while loop를 종료합니다.// 그 후에 while문을 빠져나와서 실행 흐름이 return i * x;로 가서// 3 * x 값을 반환합니다.function text(x) &#123; let i = 0; while (i &lt; 6) &#123; if (i == 3) &#123; break; &#125; i += 1; &#125; return i * x;&#125; 참고 링크mdn- return에 대한 내용mdn- break에 대한 내용","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"요청과 응답 이해하기2","slug":"node-request-and-response2","date":"2019-03-10T15:00:02.000Z","updated":"2019-04-11T15:21:56.271Z","comments":true,"path":"2019/03/11/node-request-and-response2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/11/node-request-and-response2/","excerpt":"","text":"조현영님의 Node.js 교과서의 내용을 공부하여 정리한 내용입니다. 요청과 응답 이해하기212345678910111213141516171819202122const http = require(\"http\");const fs = require(\"fs\");http .createServer((req, res) =&gt; &#123; // 요청이 들어오면 먼저 fs 모듈로 HTML 파일을 읽는다. fs.readFile(\"./server2.html\", (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; // data 변수에 저장된 버퍼를 그대로 클라이언트에 보내주면 된다. // 이전 예제에서는 문자열을 보냈지만, 저렇게 버퍼를 보낼 수도 있다. res.end(data); &#125;); &#125;) .listen(8081, () =&gt; &#123; console.log(\"8081번 포트에서 서버 대기 중입니다!\"); &#125;);// 포트 번호를 8081번으로 바꿔주었다.// server1.js를 종료했다면 8080번 포트를 계속 사용해도 된다.// 하지만 종료하지 않았을 경우 server2.js가 같은 8080번 포트를 사용하면 에러가 발생하므로 8081번으로 바꾸었다.// 이렇게 포트만 다르게 해서 동시에 여러 노드 서버를 실행할 수도 있다. HTML 파일을 읽어와 클라이언트로 전송하는 데 성공했다. 하지만 현재 서버는 클라이언트가 누구인지 모른다. 그냥 요청이 올 때 모두에게 같은 응답을 보내고 있다. 다음 절에서는 서버가 클라이언트가 누구인지 기억해서 클라이언트별로 다르게 응답하는 방법을 알아보자.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"Node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"요청과 응답 이해하기1","slug":"node-request-and-response1","date":"2019-03-10T13:10:31.000Z","updated":"2019-04-11T15:21:56.278Z","comments":true,"path":"2019/03/10/node-request-and-response1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/10/node-request-and-response1/","excerpt":"","text":"조현영님의 Node.js 교과서의 내용을 공부하여 정리한 내용입니다. 요청과 응답 이해하기1서버는 클라이언트가 있기에 동작한다.클라이언트에서 서버로 요청(request)을 보내고,서버에서는 요청의 내용을 읽고 처리한 뒤 클라이언트에게 응답(response)을 보낸다. 따라서 서버에는 요청을 받는 부분과 응답을 보내는 부분이 있어야 한다.요청과 응답은 이벤트 방식이라고 생각하면 된다.클라이언트로부터 요청이 왔을 때 어떤 작업을 수행할지 이벤트 리스너를 미리 등록해두어야 한다. 이벤트 리스너를 가진 노드 서버를 만들어보자. 이벤트 리스너를 가진 노드 서버를 만들기12345678// createServer.jsconst http = require(\"http\");http.createServer((req, res) =&gt; &#123; // 여기에 어떻게 응답할지 적어준다. // req 객체는 요청에 관한 정보들을, // res 객체는 응답에 관한 정보들을 담고 있다.&#125;); http 서버가 있어야 웹 브라우저의 요청을 처리할 수 있으므로 http 모듈을 사용했다. http 모듈에는 createServer 메서드가 있다. 인자로 요청에 대한 콜백 함수를 넣을 수 있다. 요청이 들어올 때마다 매번 콜백 함수가 실행된다. 따라서 이 콜백 함수에 응답을 적어주면 된다. createServer의 콜백 부분을 보면 req와 res 매개변수가 있다. 매개변수 req와 res의 이름은 마음대로 바꿔도 된다. 아직은 코드를 실행해도 아무 일도 일어나지 않는다. 요청에 대한 응답도 넣어주지 않았고 서버와 연결하지도 않았기 때문이다. 아래 예제에서 응답을 보내는 부분과 서버 연결 부분을 추가해보자.123456789101112131415161718192021222324// server1-0.jsconst http = require(\"http\");http .createServer((req, res) =&gt; &#123; // res 객체에는 res.write와 res.end 메서드가 있다. // 우선 res.write의 첫 번째 인자는 클라이언트로 보낼 데이터이다. // 지금은 HTML 모양의 문자열을 보냈지만 버퍼를 보낼 수도 있다. // 또한, 여러 번 호출해서 데이터를 여러 개 보내도 된다. res.write(\"&lt;h1&gt;Hello Node!&lt;/h1&gt;\"); // res.end는 응답을 종료하는 메서드이다. // 만약 인자가 있다면 그 데이터도 클라이언트로 보내고 응답을 종료한다. // 따라서 위의 예제는 res.write에서 &lt;h1&gt;Hello Node!&lt;/h1&gt; 문자열을 한 번 // res.end에서 &lt;p&gt;Hello Server!&lt;/p&gt; 문자열을 한 번 클라이언트로 보낸 후 // 응답이 종료된 것이다. // 브라우저는 응답 내용을 받아서 렌더링한다. res.end(\"&lt;p&gt;Hello Server!&lt;/p&gt;\"); &#125;) .listen(8080, () =&gt; &#123; console.log(\"80번 포트에서 서버 대기 중입니다!\"); &#125;);server.on(\"error\", error =&gt; &#123; console.error(error);&#125;); createServer 메서드 뒤에 listen 메서드를 붙이고클라이언트에게 공개할 포트 번호와 포트 연결 완료 후 실행될 콜백 함수를 넣어준다. 이제 이 파일을 실행하면 서버는 8080 포트에서 요청이 오기를 대기한다. listen 메서드에 콜백 함수를 넣는 대신, 다음과 같이 서버에 listening 이벤트 리스너를 붙여도 된다. 추가로 error 이벤트 리스너도 붙여 보았다. 123// console$ node server18080번 포트에서 서버 대기 중입니다! 콘솔에 위와 같은 문장이 나왔다면, 이제 인터넷 브라우저를 열어http://localhost:8080 또는 http://127.0.0.1:8080에 접속하자. localhost와 포트란 localhost는 현재 컴퓨터의 내부 주소를 가리킨다. 외부에서는 접근할 수 없고 자신의 컴퓨터에서만 접근할 수 있다. 따라서 서버 개발 시 테스트용으로 많이 사용된다. localhost 대신 127.0.0.1을 주소로 사용해도 같습니다. 이러한 숫자 주소를 IP라고 부른다. 포트는 서버 내에서 프로세스를 구분하는 번호이다.서버는 HTTP 요청을 대기하는 것 외에도 다양한 작업을 한다.데이터베이스와도 통신해야 하고, FTP 요청을 처리하기도 한다. 따라서 서버는 프로세스에 포트를 다르게 할당하여 들어오는 요청을 구분한다. 유명한 포트 번호로는 21(FTP), 80(HTTP), 443(HTTPS), 3306(MYSQL)이 있다. 포트 번호는 IP 주소 뒤에 콜론(:)과 함께 붙여 사용한다. 현재 예제에서는 80번 포트를 사용해 클라이언트 요청을 대기하고 있다. 따라서 http://localhost:8080으로 접근해야 한다.하지만 http://gilbut.co.kr 같은 사이트들은 포트 번호를 따로 표시하지 않는다. 바로 80번 포트를 사용하기 때문이다. 80번 포트를 사용하면 주소에서 포트를 생략할 수 있다. http://gilbut.co.kr:80으로 요청해도 길벗 홈페이지에 접속된다. 이 책에서 80번 포트를 사용하지 않는 이유는 충돌을 방지하기 위해서이다. 보통 컴퓨터들은 80번 포트를 이미 다른 서비스가 사용하고 있을 확률이 크다. 보통 포트 하나에 서비스를 하나만 사용할 수 있으므로다른 서비스가 사용하고 있는 포트를 사용하려고 하면 에러가 발생한다. 따라서 예제를 실행할 때는 다른 포트 번호들을 사용하고,실제로 배포할 때는 80번 또는 443번 포트를 사용한다. 한 가지 더 알아둘 점이 있다. 리눅스와 macOS에서는 1024번 이하의 포트에 연결할 때 관리자 권한이 필요하다. 따라서 명령어 앞에 sudo를 붙여주어야 한다. 예를 들면 node server1 대신 sudo node server1을 입력해야 한다. 예제에서는 80번 포트를 사용하므로 sudo를 붙일 필요는 없습니다- 다른 서비스가 사용하고 있는 포트를 사용할 경우Error: listen EADDRINUSE :::포트 번호 같은 에러가 발생합니다. 이런 경우 그 서비스를 종료하거나, 노드의 포트를 다른 번호로 바꾸면 된다. 드디어 웹 서버가 만들어졌다! 페이지를 몇 개 더 만들어보자. 페이지는 주소로 구별해주자. 그 전에 HTML 파일을 만들어두는 것이 좋을 것 같다. res.write 메서드로 한 줄씩 HTML 코드를 적는 것은 너무 비효율적이다. 다행히 HTML 파일을 읽어서 전송하는 방법이 있다. 다음 예제를 통해 배워보자.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"Node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"원본 배열에 아무런 영향을 미치지 않는 메소드","slug":"js-array","date":"2019-03-09T14:50:34.000Z","updated":"2019-04-11T15:22:16.169Z","comments":true,"path":"2019/03/09/js-array/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/09/js-array/","excerpt":"","text":"배열로부터 새로운 값 생성원본 배열에 아무런 영향을 미치지 않는 메소드 JavaScript에서 원본 배열을 변경하는 것이 아닌,배열로부터 새로운 값을 생성하여 원본 배열에 아무런 영향을 미치지 않는 메소드를 알아보자. slice map concat reduce filter join 요소찾기 indexOf lastIndexOf 배열이 특정 조건을 만족하는지 판별하기 includes every some 참고링크: JAVASCRIPT로 만나는 세상","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"블로그 2개월 간의 회고","slug":"TIL-for-2-months-with-blog","date":"2019-03-07T15:09:47.000Z","updated":"2019-05-12T15:36:25.997Z","comments":true,"path":"2019/03/08/TIL-for-2-months-with-blog/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/08/TIL-for-2-months-with-blog/","excerpt":"","text":"블로그를 시작한 지 2개월이 지나는 시점에서 그동안 느낀 점을정리해보는 시간이 필요하다는 생각이 들었다. 1일 1 포스팅 2019년 1월 2일부터 하루도 빠짐없이 매일 포스팅을 작성하여 게시했다. 약 2개월가량 진행하면서 느낀 건 장단점이 있다는 것이다. 1. 포스팅의 질 저하 문제 포스팅의 전체적인 퀄리티가 떨어진다는 게 느껴졌다. 포스팅이라기보다는 TIL을 블로그 형식으로 게시했다는 표현이 더 어울릴지도 모르겠다. 지속할수록 1일 1 포스팅을 지키기 위한 포스팅을 하는 날이 늘어났다. 고민해 볼 부분 앞으로도 1일 1 포스팅을 할 것인가(대신 간결하고 명확하게)or 1일 1TIL을 하고 포스팅은 주 1회정도로 빈도수를 줄이고 퀄리티를 높일 것인가고민해 볼 필요를 느꼈다. 2. Hexo 블로그 Hexo로 블로그를 게재하면서 느낀 불편함이 있었다. 포스팅 수가 점점 늘어나다 보니 배포한 이후에도 실제로 반영되기까지 시간이 점점 늦춰졌다. 고민해 볼 부분 Go 언어로 된 Hugo 블로그로의 이전을 고려해 볼 필요가 있다.","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"TIL","slug":"developer/til","permalink":"https://JihyeHwang09.github.io/categories/developer/til/"}],"tags":[{"name":"TIL","slug":"til","permalink":"https://JihyeHwang09.github.io/tags/til/"}]},{"title":"AJAX","slug":"node-ajax","date":"2019-03-07T14:55:49.000Z","updated":"2019-04-11T15:21:56.253Z","comments":true,"path":"2019/03/07/node-ajax/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/07/node-ajax/","excerpt":"","text":"조현영님의 Node.js 교과서의 내용을 공부하여 정리한 내용입니다. 2.2.1 AJAX AJAX(Asynchronous Javascript And XML)는 비동기적 웹 서비스를 개발하기 위한 기법 이름에 XML이 들어가 있지만 꼭 XML을 사용해야 하는 것은 아니다. 요즘에는 JSON을 많이 사용한다. 쉽게 말해 페이지 이동 없이 서버에 요청을 보내고 응답을 받는 기술 요청과 응답은 4.1절에 설명되어 있다. 웹 사이트 중 페이지 전환 없이 새로운 데이터를 불러오는 사이트는 대부분 AJAX 기술을 사용하고 있다고 보면 된다. 보통 AJAX 요청은 jQuery나 axios 같은 라이브러리를 이용해서 보낸다. 하지만 이 책은 프런트엔드 라이브러리의 사용을 최소화하고 있으므로 -&gt; 자바스크립트가 기본으로 제공하는 방식으로 요청을 보낸다. 프런트엔드에는 ES2015+ 코드를 사용할 수 없는 경우(IE)가 있으므로 -&gt; ES5 문법을 사용함 기본 구조는 다음과 같다. 123456789101112131415var xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; // 요청에 대한 콜백 if (xhr.readyState === xhr.DONE) &#123; // 요청이 완료되면 if (xhr.status === 200 || xhr.status === 201) &#123; // 응답 코드가 200이나 201이면 console.log(xhr.responseText); // 서버에서 보내주는 값 &#125; else &#123; console.error(xhr.responseText); &#125; &#125;&#125;;xhr.open(\"GET\", \"https://www.zerocho.com/api/get\"); // 메서드와 주소 설정xhr.send(); // 요청 전송 먼저 XMLHttpRequest 생성자로 xhr 객체를 생성 xhr.open 메서드에 요청 메서드와 요청 주소를 넣고 xhr.send 메서드로 - 보내면 된다. xhr.onreadystatechange는 이벤트 리스너로 요청한 후 서버로부터 응답이 올 때 응답을 받을 수 있다. 응답 코드가 200번 대 숫자면 성공을 의미하므로 xhr.responseText에는 성공한 내용이 담겨 있을 것이고, 그렇지 않다면 에러 메시지가 담겨 있을 것이다. 현재 설정된 주소는 실제로 동작하는 주소이므로 콘솔에서 결과를 받을 수 있다. onreadystatechange 대신 onload와 onerror로 성공과 실패를 구별해도 된다. 1234567891011var xhr = new XMLHttpRequest();xhr.onload = function() &#123; if (xhr.status === 200 || xhr.status === 201) &#123; console.log(xhr.responseText); &#125;&#125;;xhr.onerror = function() &#123; console.error(xhr.responseText);&#125;;xhr.open(\"GET\", \"https://www.zerocho.com/api/get\"); // 메서드와 주소 설정xhr.send(); // 요청 전송 서버로 데이터를 같이 보내는 POST 요청의 경우 JSON 데이터를 보낸다. 1234567891011121314151617var xhr = new XMLHttpRequest();var data = &#123; name: \"zerocho\", birth: 1994&#125;;xhr.onreadystatechange = function() &#123; if (xhr.readyState === xhr.DONE) &#123; if (xhr.status === 200 || xhr.status === 201) &#123; console.log(xhr.responseText); &#125; else &#123; console.error(xhr.responseText); &#125; &#125;&#125;;xhr.open(\"POST\", \"https://www.zerocho.com/api/post/json\");xhr.setRequestHeader(\"Content-Type\", \"application/json\"); // 콘텐츠 타입을 json으로xhr.send(JSON.stringify(data)); // 데이터를 동봉해 전송 전체적인 구조는 비슷한데 xhr.send 메서드에 데이터를 넣어 보내는 것이 다르다. xhr.setRequestHeader 메서드로, 서버로 보내는 컨텐츠가 JSON 형식임을 알릴 수 있다. 현재 설정된 주소는 실제로 동작하는 주소라서 결과값을 받을 수 있다. POST 요청의 경우 에러가 발생하는데, 이 에러를 해결하는 방법은 10.7절에서 배울 예정","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"Node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"Morgan","slug":"node-morgan","date":"2019-03-05T15:02:00.000Z","updated":"2019-04-11T15:21:56.271Z","comments":true,"path":"2019/03/06/node-morgan/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/06/node-morgan/","excerpt":"","text":"조현영님의 Node.js 교과서의 내용을 공부하여 정리한 내용입니다. Morgan 현재 콘솔에 나오는 GET / 200 51.267 ms - 1539 같은 로그는 모두 morgan 미들웨어에서 나오는 것이다. 요청에 대한 정보를 콘솔에 기록해준다. morgan 미들웨어는 다음과 같이 사용한다. 12345// ...var logger = require(\"morgan\");// ...app.use(logger(\"dev\"));// ... 함수의 인자로 dev 대신 short, common, combined 등을 줄 수 있다. 인자에 따라 콘솔에 나오는 로그가 다르다. dev인 경우 GET / 200 51.267 ms – 1539의 의미는 순서대로 HTTP요청(GET)주소 - (/) HTTP상태코드(200) 응답속도(51.267ms) – 응답바이트(1539)이다. 보통 개발 시에는 short나 dev를 많이 쓰고, 배포 시에는 common이나 combined를 많이 사용한다. 인자를 바꿔서 로그가 어떻게 달라지는지 직접 확인해보자. 콘솔뿐만 아니라 파일이나 데이터베이스에 로그를 남길 수도 있다. 하지만 이러한 작업을 할 때는 winston 모듈을 더 많이 사용한다. winston 모듈은 15.1.6절에서 살펴보자.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"Node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"커스텀 미들웨어 만들기","slug":"node-custom-middleware","date":"2019-03-04T15:02:00.000Z","updated":"2019-04-11T15:21:56.253Z","comments":true,"path":"2019/03/05/node-custom-middleware/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/05/node-custom-middleware/","excerpt":"","text":"조현영님의 Node.js 교과서의 내용을 공부하여 정리한 내용입니다. 6.3.1 커스텀 미들웨어 만들기 직접 미들웨어를 만들어보면서 미들웨어의 원리를 이해보자. 요청이 들어올 때 콘솔에 메시지를 찍는 단순한 미들웨어이다. logger보다 위에 다음 코드를 적어준다. 1234567891011// app.js// ...app.set(\"views\", path.join(__dirname, \"views\"));app.set(\"view engine\", \"pug\");app.use(function(req, res, next) &#123; console.log(req.url, \"저도 미들웨어입니다\"); next();&#125;);app.use(logger(\"dev\"));// ... app.js 파일을 저장하고 서버를 실행한다. 1$ npm start http://localhost:3000에 접속하면, 콘솔에 다음과 같이 기록된다. 1234/ 저도 미들웨어입니다GET / 200 416.849 ms – 170/stylesheets/style.css 저도 미들웨어입니다GET /stylesheets/style.css 200 10.119 ms - 111 요청 두 개, 즉 GET /와 GET /stylesheets/style.css가 서버로 전달되었다. 각각의 요청이 모두 방금 만든 커스텀 미들웨어를 작동시켰다. 이렇게 서버가 받은 요청은 미들웨어를 타고 라우터까지 전달된다. 주의해야 할 점! 반드시 미들웨어 안에서 next()를 호출해야 다음 미들웨어로 넘어간다. logger나 express.json, express.urlencoded, cookieParser, express.static - 모두 내부적으로는 next()를 호출하므로 다음 미들웨어로 넘어갈 수 있다. next()는 미들웨어의 흐름을 제어하는 핵심적인 함수이다. next 함수의 다른 기능 인자의 종류로 기능이 구분된 인자를 아무것도 넣지 않으면 단순하게 다음 미들웨어로 넘어간다. next 함수의 인자로 route를 넣으면 특수한 기능을 한다. 이것은 라우터를 배울 때 함께 알아볼 예정 route 외의 다른 값을 넣으면 다른 미들웨어나 라우터를 건너 뛰고 바로 에러 핸들러로 이동 넣어준 값은 에러에 대한 내용으로 간주됨 에러 핸들링 미들웨어404 처리 미들웨어 익스프레스가 생성해주는 에러 핸들링 미들웨어를 보면 이해하기 쉽다. 가장 흔한 에러가 404 에러이다. 라우터에 등록되지 않은 주소로 요청이 들어올 때 발생 이 경우에는 404 NOT FOUND 상태 코드를 응답해주어야 한다. 1234// 404 처리 미들웨어app.use(function(req, res, next) &#123; next(createError(404));&#125;); 라우터 다음에 나오는 이 부분이 404 에러를 만들어내는 미들웨어 라우터에서 요청이 처리되지 않으면(일치하는 주소가 없다면) 요청은 라우터 다음에 위치한 이 미들웨어로 오게 된다. http-errors(createError) 패키지가 404 에러를 만들어내고, 이 에러를 next에 담아 에러 핸들러로 보내고 있다. 에러 핸들러 에러 핸들링 미들웨어는 아래와 같다. 12345678// 에러 핸들러app.use(function(err, req, res, next) &#123; res.locals.message = err.message; res.locals.error = req.app.get(\"env\") === \"development\" ? err : &#123;&#125;; res.status(err.status || 500); res.render(\"error\");&#125;); 이 미들웨어의 내용은 템플릿 엔진을 다룰 때 배울 예정 다른 미들웨어와 다르게 함수의 매개변수가 4개 req 전에 err라는 매개변수가 추가됨 next 함수에 넣어준 인자가 err 매개변수로 연결된다. 에러 핸들링 미들웨어는 일반적으로 미들웨어 중 제일 아래에 위치하여 위에 있는 미들웨어에서 발생하는 에러를 받아서 처리한다. app.use의 응용 방법 하나의 use에 미들웨어를 여러 개 장착할 수 있다. 순서대로 실행된다. 123456789101112131415app.use( \"/\", function(req, res, next) &#123; console.log(\"첫 번째 미들웨어\"); next(); &#125;, function(req, res, next) &#123; console.log(\"두 번째 미들웨어\"); next(); &#125;, function(req, res, next) &#123; console.log(\"세 번째 미들웨어\"); next(); &#125;); 이 성질을 활용하여 Express-generator가 생성한 코드도 다음과 같이 줄일 수 있다. 1234567app.use( logger(\"dev\"), express.json(), express.urlencoded(&#123; extended: false &#125;), cookieParser(), express.static(path.join(__dirname, \"public\"))); 가독성이 좋지 않아 이렇게는 잘 사용하지 않지만, 유효한 코드이다. next를 호출하지 않으면 다음 미들웨어로 넘어가지 않는다는 성질을 사용하여 다음과 같은 미들웨어도 만들 수 있다. 12345678910111213app.use( function(req, res, next) &#123; if (+new Date() % 2 === 0) &#123; return res.status(404).send(\"50% 실패\"); &#125; else &#123; next(); &#125; &#125;, function(req, res, next) &#123; console.log(\"50% 성공\"); next(); &#125;); 50% 확률(숫자를 2로 나눈 나머지가 항상 1이거나 0임을 이용)로 404 Not Found를 응답하거나 다음 미들웨어로 넘어가는 미들웨어 이 미들웨어 자체는 크게 의미가 없지만, 나중에 로그인한 사용자인지 확인할 때 위의 코드를 응용하게 된다. 다음 시간에는 Express에 사용되는 다른 미들웨어에 대해서도 알아보자.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"Node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"미들웨어(Middleware)","slug":"node-middleware","date":"2019-03-04T14:09:41.000Z","updated":"2019-04-11T15:21:56.265Z","comments":true,"path":"2019/03/04/node-middleware/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/04/node-middleware/","excerpt":"","text":"조현영님의 Node.js 교과서의 내용을 공부하여 정리한 내용입니다. 6.3 미들웨어 미들웨어는 익스프레스의 핵심요청과 응답의 중간(middle, 미들)에 위치하여 미들웨어라고 부른다. 뒤에 나오는 라우터와 에러 핸들러 또한 미들웨어의 일종이므로 미들웨어가 익스프레스의 전부라고 해도 과언이 아니다. 미들웨어는 요청과 응답을 조작하여 기능을 추가하기도 하고, 나쁜 요청을 걸러내기도 한다. app.use의 역할 미들웨어는 주로 app.use와 함께 사용된다. 먼저 app.use의 역할에 대해 알아보자. 12345678910111213141516171819202122232425...app.use(logger('dev'));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname,'public')));app.use('/', indexRouter);app.use('/users', usersRouter);// 404 처리 미들웨어app.use(function(req, res, next) &#123; next(createError(404));&#125;);// 에러 핸들러app.use(function(err, req, res, next) &#123; res.locals.message = err.message; res.locals.error = req.app.get('env') ==='development' ? err : &#123;&#125;; res.status(err.status || 500); res.render('error');&#125;);module.exports = app; app.js를 보면 수많은 use 메서드가 사용되고 있다는 걸 알 수 있다. app.use 메서드의 인자로 들어 있는 함수가 미들웨어 미들웨어는 use 메서드로 app에 장착한다. 제일 위의 logger(&#39;dev&#39;)부터 시작하여 미들웨어들을 순차적으로 거친 후라우터에서 클라이언트로 응답을 보낸다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"Node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"React 12일차","slug":"react12","date":"2019-03-02T15:00:45.000Z","updated":"2019-04-11T15:22:16.458Z","comments":true,"path":"2019/03/03/react12/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/03/react12/","excerpt":"","text":"BEM(Block, Element, Module)클래스 이름에 _나 -로 계층 구조를 나눈다.영역이름__ element이름 ModifiersModifier은 block 또는 element의 상태이다 어디에 밑줄, 오디에 하이픈 써야 하는지 알면 됨 React에서 BEM을 사용할 때는 컴포넌트가 블록이기 때문에 ex) PostListtitle, PostListlist, PostList__item classNames 사용법 - 코드, 주석보기 classNames를 사용하면, 디자인을 동적으로 바꿀 수 있다 컴포넌트 이름__요소 이름--상태 이름 BEM은 사람이 의도적으로 스코프를 만들어주는 것이다 사람이 직접 다 해야해서 오타날 확률도 높음. 최신 방법은 x SCSS(SCSS 공식 문서)[https://sass-lang.com/guide] 12345678&lt;!--$붙이면변수로사용--&gt;$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; Sass 문법은 거의 사용 x. SCSS를 사용 nesting 사용 다른 선택자 밑에 있는 자식을 스타일링하고 싶을 때 코드 작성량을 줄이고 싶을 때 같은 클래스 이름을 여러 번 사용하고 싶을 때 Sass에서 &amp;는 자기자신을 선택하고 싶을 때 사용 &amp;문법을 쓰면 부모에 대한 내용이 빠진다. &amp;쓰지 않으면, -&gt; 부모, 자식으로 컴파일링 됨 123456@import \"reset\";body &#123; font: 100% Helvetica, sans-serif; background-color: #efefef;&#125; Import @import하면 통신하느라 속도가 느려질 수 있음 여러 파일에 공유해야 하는 스타일을 common.scss에 저장해두고 index.scss에서 @import해서 사용 cf) scss에서는 // 주석 사용 가능(css에서는 // 주석 사용 x) Mixins공유하고 싶은 코드 뭉치를 묶어서 @mixin 사용 함수와 비슷 어떤 코드 뭉치를 재사용하고 싶을 때 -&gt; mixin 사용 매개변수를 받지 않을 때는 소괄호 () 생략 가능 cf) BEM은 클래스 이름으로 요소의 역할과 책임을 명확히 나타내고(클래스 이름을 더럽히지 말자.) 공유되어야 하는 스타일은 mixin으로 사용한다. 미디어 쿼리 나타낼 때 사용@include{}로 둘러싼 부분이 @content자리에 들어감.@content는 코드가 들어갈 빈칸 cf) 모바일 버전 먼저 만들기 Operators cf) calc() - 간단한 계산 지원. 특정 컴포넌트와 관련된 파일은 따로 만든다.(index.scss에 스타일 코드를 다 몰아넣는 게 x) ex) PostList.scss 1. scss로 BEM사용 컴포넌트 파일과 같은 이름의 scss파일을 만들기 공유되어야 하는 변수나 mixin은 common.scss에 몰아넣어두고 사용 Create React App 2.0에 추가된 속성 Adding a CSS Modules Stylesheet 가장 대중적으로 사용되는 방식 되도록 이 방법을 사용하는 것을 추천 손이 훨씬 편해짐 css 모듈을 사용할 때는 Camel Case로 코딩.(-을 사용하면, []표기법을 사용해야한다.)-&gt; Camel Case로 코딩하면, 점표기법 사용 가능 ‘styles’ 자리에는 ‘s’로 쓰면 편하다 유일하고 식별 가능한 클래스 이름을 자동으로 붙여줌 12345678910import React, &#123; Component &#125; from \"react\";import styles from \"./Button.module.css\"; // Import css modules stylesheet as stylesimport \"./another-stylesheet.css\"; // Import regular stylesheetclass Button extends Component &#123; render() &#123; // reference as a js object return &lt;button className=&#123;styles.error&#125;&gt;Error Button&lt;/button&gt;; &#125;&#125; styles는 객체. 이 styles 객체 안에 속성 이름과 속성값이 들어간다. 클래스 이름이 변환되서 사용자에게 전달됨 css파일이 변환되면서 객체가 생기고, 속성이름: 내가 쓴 클래스 이름, 속성값: 변환된 클래스 이름Error Button;className에 변환된 클래스 이름이 들어간다-&gt; 이름 충돌에 대힌 걱정을 할 필요 x cf) 식별자로 쓸 수 없는 속성의 경우, 대괄호 표기법 사용 (교재- 점 표기법, 대괄호 표기법 ) 페이지 컴포넌트 프레임 워크BootstrapSemantic UI React 컴포넌트가 미리 만들어져 있음 컴포넌트를 import해서 사용 storybook 통신하는 코드가 있으면, 부작용이 있는 컴포넌트임 부작용이 있는 컴포넌트는 테스트하기 어렵다 역할과 책임을 잘게 쪼개서 컴포넌트를 나누기(관례임) 화면을 그리는 컴포넌트, 외부 세계와 통신하는(부작용이 있는) 컴포넌트로 나누기(서로 다른 컴포넌트로 나누기) Presentational 컴포넌트(데이터가 아닌) UI 상태를 관리하기 위해 state를 갖는 경우가 있습니다.ex) 마우스의 좌표 Presentational 컴포넌트는 외부 코드에 의존하지 않게 하는 게 좋다 1234567React.createContext(&#123; username: 'fast', id: 0, login: () =&gt; &#123;&#125;, logout: () =&gt; &#123;&#125;&#125;)provider가 없을 때, &#123;&#125;안의 값이 default값으로 사용됨","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 11일차","slug":"react11","date":"2019-03-02T14:58:08.000Z","updated":"2019-04-11T15:22:16.384Z","comments":true,"path":"2019/03/02/react11/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/02/react11/","excerpt":"","text":"고차 컴포넌트 (Higher-Order Components) 컴포넌트를 받아서 컴포넌트를 반환하는 그저 함수일 뿐이다 컴포넌트x. 함수가 컴포넌트가 되려면, 컴포넌트가 아니라 엘리먼트를 반환해야 한다. 횡단 관심사(Cross-Cutting Concerns)를 위해 HOC 사용하기코드는 자세히 읽지 x 12345678const CommentListWithSubscription = withSubscription(CommentList, DataSource =&gt; DataSource.getComments());const BlogPostWithSubscription = withSubscription( BlogPost, (DataSource, props) =&gt; DataSource.getBlogPost(props.id)); 첫 번째 인수는 감싸지는 컴포넌트입니다. 두 번째 인수로 주어진 함수는 DataSource 와 props를 이용해 필요한 데이터를 받아옵니다.(데이터를 어떻게 가져올지) 클래스도 값이니까 매개변수로 넘겨줄 수 있다 원래 컴포넌트를 변경하지 마세요. 합성을 사용하세요. 클래스 컴포넌트에서 메소드 문법을 사용하면, 프르토 타입에 들어감 -&gt; But 이렇게 하지 말것. 다른 컴포넌트에도 영향을 끼침. 좋지 x 입력받은 컴포넌트를 직접 변경하지 x 관례: HOC와 무관한 prop은 감싸진 컴포넌트에 넘기세요.HOC는 컴포넌트에 기능을 추가합니다. 그러므로 컴포넌트의 사용법을 극단적으로 바꾸어서는 안 됩니다. 컴포넌트를 구현할 때가 아니라, 사용할 때 사용법은 prop이다 관례: 합성을 최대한 활용하세요. HOC는 여러 가지 인자를 받을 수 있다 HOC의 가장 일반적인 모양은 이렇게 생겼습니다. 12345678// React Redux's `connect`// redux와 react를 연결 -&gt; connect// connect(commentSelector, commentActions)는 redux와 react를 어떻게 연결할 지를 받음. 고차컴포넌트를 반환const ConnectedComment = connect( commentSelector, commentActions)(CommentList); 다시 말해서, connect는 HOC를 반환하는 고차 함수입니다! 고차 컴포넌트를 사용하는것이 Consumer보다 편한 방법 HOC를 사용할 경우, 컴포넌트 계층이 깊어지는 문제가 생김 익명 함수를 썼을 때, React 개발자 도구에 Unknown이 표시됨 관례: 원활한 디버깅을 위해 displayName도 감싸주세요.12345678910111213141516function withSubscription(WrappedComponent) &#123; class WithSubscription extends React.Component &#123; /* ... */ &#125; WithSubscription.displayName = `WithSubscription($&#123;getDisplayName( WrappedComponent )&#125;)`; return WithSubscription;&#125;function getDisplayName(WrappedComponent) &#123; // WrappedComponent.displayName가 있으면 그 이름을, // WrappedComponent.name가 있으면 그 이름을, // 다 없으면 익명으로 써라 return WrappedComponent.displayName || WrappedComponent.name || \"Component\";&#125; render 메소드 안에서 HOC를 사용하지 마세요. HOC는 한 번만 적용되게 만들어줘야 한다. render 매소드는 언제 어디서든 -&gt; 매번 새로운 컴포넌트를 그린다. 컴포넌트 새로운 타입이라서 상태를 매번 날려버린다는 문제가 있다. (React는 엘리먼트의 타입이나 key값이 바뀌면, 상태를 다 날려버리고 새로 그린다. ) export하는 쪽에서 HOC를 둘러주는 게 관례 Ref는 전달되지 않습니다. key와 ref는 prop으로 전달되지 x ref가 진짜 prop이 아니고, key와 마찬가지로 React에 의해 특별 취급되기 때문이다. 만약 HOC에서 반환하고자 하는 컴포넌트에 ref를 추가한다면, 그 ref는 안쪽 컴포넌트가 아니라 가장 바깥쪽의 컨테이너 컴포넌트에 대한 인스턴스를 가리키게 되는 문제가 발생한다. ref라는 이름으로는 전달이 불가능하므로, ref라는 이름이 아니라, innerRef라는 이름으로(ref가 아닌 다른 이름으로 넘겨주면 되는데, 보통 innerRef라는 이름으로 넘겨주는 게 관례이다.) ref객체를 받은 다음 innerRef라는 이름으로 다른 컴포넌트에 prop으로 넘겨주는 기법을 사용하는 게 관례!!","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 10일차","slug":"react10","date":"2019-03-01T12:58:01.000Z","updated":"2019-04-11T15:22:16.384Z","comments":true,"path":"2019/03/01/react10/","link":"","permalink":"https://JihyeHwang09.github.io/2019/03/01/react10/","excerpt":"","text":"합성 (composition) vs 상속 (inheritance)다른 컴포넌트를 담기게시판에 적용 헤더의 메뉴바에 하이라이트를 주는 등 페이지별로 달라야하는 부분이 있기 때문에App.js에 레이아웃을 두지 x -&gt; Layout.js를 따로 만들면 확장성이 좋음 헤더, 푸터 뭔가를 감싸는 컴포넌트 만들고 싶을 때 레이아웃 뿐만이 아니라 뭔가 빈칸이 있는 컴포넌트를 만들고 싶을 때 활용 Context ‘맥락’이라는 의미 언어 설정(ex) 한국어 버전이면, 앱 전역에서 공유되어야 하는 값) ex) UI 테마 등 Context API라는 기술이 멀리 사용되지는 않고 있음 Redux와 사용법은 다르지만, 목적은 비숫함 언제 Context를 사용해야 할까요?Context를 사용하면, 중간 계층에 위치하는 엘리먼트에 props를 넘겨주는 작업을 피할 수 있습니다: 123456789101112131415161718192021222324252627282930313233343536373839404142// Context를 사용하면 prop을 일일이 엮어주지 않고도// 컴포넌트 트리의 깊은 곳에 값을 넘겨줄 수 있습니다.// 테마에 대한 context를 만들어줍시다. (\"light\"를 기본값으로 합니다.)const ThemeContext = React.createContext(\"light\");class App extends React.Component &#123; render() &#123; // Provider를 사용해서 현재 테마를 트리 아래쪽으로 넘겨줍시다. // 어떤 컴포넌트든 이 값을 읽을 수 있습니다. 아주 깊은 곳에 위치해있더라도 말이죠. // 아래에서는, \"dark\"라는 값을 넘겨주었습니다. // 정보를 내려주고 싶은 부분을 Provider로 써준다. return ( &lt;ThemeContext.Provider value=\"dark\"&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;// 이제 더이상 중간 계층에 있는 컴포넌트에서// theme prop을 넘겨줄 필요가 없습니다.function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;function ThemedButton(props) &#123; // 테마 context를 읽어오려면 Consumer를 사용하세요. // React는 가장 가까운 Provider를 찾아서 그 값을 사용할 것입니다. // 이 예제에서, theme 값은 \"dark\"가 됩니다. return ( &lt;ThemeContext.Consumer&gt; &#123;/* 화살표 함수의 매개변수인 theme으로 들어온다.*/&#125; &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt; );&#125; Provider 하위 컴포넌트라면, 어디서든 Provider가 내려준 값 사용 가능 APIReact.createContext1const &#123; Provider, Consumer &#125; = React.createContext(defaultValue); context는 여러 개 사용할 수 있고, { Provider, Consumer } 쌍을 만듭니다 defaultValue 인수는 오직 상위에 같은 context로부터 생성된 Provider가 없을 경우에만 사용됩니다.(Consumer만 있고, Provider가 없을 때) Provider1&lt;Provider value=&#123;/* some value */&#125;&gt; 꼭 value 라는 이름 사용해야 함 Provider의 자손인 모든 Consumer는 Provider의 value prop이 바뀔 때마다 다시 렌더링됩니다.–&gt; Provider에서 다른 값을 내려주면 다시 렌더링o Provider에서 같은 값을 내려주면 다시 렌더링xxd) setState와 비슷 이는 shouldComponentUpdate의 영향을 받지 않으므로,조상 컴포넌트의 업데이트가 무시된 경우라 할지라도 Consumer는 업데이트될 수 있습니다. ex) pureComponent같은걸로 렌더링이 막혔더라도 렌더링이 잘 된다. Object.is 알고리즘을 통해 이전 값과 새 값을 비교함으로써 value prop이 바뀌었는지를 결정합니다. 예를 들어, 게시판에 적용한다면유저정보는 어디서든 접근가능해야 한다. app.js provider에 상태를 내려보낼 수 있다Provider를 가지고 있는 컴포넌트에 상태를 만들어준다. 중첩된 컴포넌트에서 context 갱신하기theme-toggler-button.js 객체는 값이니까 객체에 상태를 바꿔주는 함수를 넣어서 내려 보내준다. 함수의 매개변수에서 바로 분해대입 가능 setState는 비동기식으로 동작하므로 이전 상태를 함수로 넣어줘야 한다. 게시판에 context 적용로그인과 관련된 외부 세계와 연동하는 코드는 로그인 프로바이더에 넣음.로그인 프로바이더에 넣어두고, 사용자 정보의 캐시라고도 볼 수 있다.(사용자 정보 원본은 멀리 떨어져 있는 서버에 있고, 유저정보를 가까운 로그인 프로바이더에 넣어둠) 로그인폼은 가져와서 보여주는 역할 내가 작성한 글인 경우에만 수정 버튼 보여준다.내 ID 알아내려면, UserConsumer import logout(){}캐시를 사용하면, 원본과 달라질 수 있다는 문제가 발생할 수 있다. react가 logout함수를 호출 onClick={logout}or 함수가 실행되면 연쇄적으로 실행됨onClick={() =&gt; logout()}이렇게 써야 함. 이렇게 쓰면 동작x 잘못 쓴 거임!!onClick={() =&gt; logout} 페이지 전환페이지 상태, 페이지 전환 함수 댓글 추가, 게시물 제거는 직접 만들어보기 컴포넌트 구조 설계할 때 b가 a컴포넌트의 기능을 필요로 한다.즉, 의존성이 있는 컴포넌트인 b가 아래에 위치해야 한다. 라이프사이클 메소드에서 context에 접근하기12345678910111213141516171819202122// export default가 붙어있지 xclass Button extends React.Component &#123; componentDidMount() &#123; // ThemeContext value is this.props.theme &#125; componentDidUpdate(prevProps, prevState) &#123; // Previous ThemeContext value is prevProps.theme // New ThemeContext value is this.props.theme &#125; render() &#123; const &#123; theme, children &#125; = this.props; return &lt;button className=&#123;theme ? \"dark\" : \"light\"&#125;&gt;&#123;children&#125;&lt;/button&gt;; &#125;&#125;// 화살표 함수이지만, 함수형 컴포넌트임export default props =&gt; ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt;); Fragments짧은 구문&lt;&gt;&lt;/&gt; 는 key나 속성을 지원하지 않는다는 점을 제외하면다른 요소와 같은 방식으로 사용할 수 있습니다.&lt;&gt;&lt;/&gt; 는 Babel7 버전인 경우에 사용 가능 Key가 있는 FragmentPortals 루트 바깥에 모달이 그려지는 게 가능하다. Portals를 통한 이벤트 버블링리액트는 자체적인 이벤트 시스템을 가지고 있다. 상위 컴포넌트의 portal에서 이벤트 버블링을 캐치하면portal에 본질적으로 의존하지않는 보다 유연한 추상화 개발을 할 수 있습니다. portal을 쓰든 안 쓰든 사용방법은 같다. 구상, 추상을 잘 나눠야 한다. 컴포넌트 간에 서로 뭘 알고 뭘 알아야 하는지를 구분하는 게 중요하다.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 9일차","slug":"react9","date":"2019-02-28T14:33:59.000Z","updated":"2019-04-11T15:22:16.536Z","comments":true,"path":"2019/02/28/react9/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/28/react9/","excerpt":"","text":"제어되지 않는 컴포넌트제어되지 않는 컴포넌트는 진리의 원천(유일한 진리의 원천x)을 DOM에 두기 때문에,React를 사용한 코드와 사용하지 않은 코드를 통합하는 작업을 좀 더 쉽게 만들어줄 수 있습니다. 기본값 지정하기 value 속성을 이용하면, 제어되는 컴포넌트가 됨 defaultValue를 이용하면, 기본값을 주면서도 사용자가 편집 가능 (기본값도 지울 수 있음)제어되지 않는 컴포넌트 만드는 법 &lt;input type=&quot;checkbox&quot;&gt;와 &lt;input type=&quot;radio&quot;&gt; 엘리먼트는&#39;defaultChecked&#39; 어트리뷰트(제어되지 않는 컴포넌트이면서도 체크된 상태로 기본값 주고 싶을 때) &lt;select&gt;와 &lt;textarea&gt;는 ‘defaultValue’ 어트리뷰트를 지원합니다. The file input Tag cf) input type을 file로 주고, 속성을 multiple 주면 파일 여러 개 업로드 가능 입력받은 파일과 상호작용하기 위해서는 File API를 사용해야만 합니다.아래 예제는 submit 이벤트 핸들러 내에서 파일에 접근하기 위해 DOM node를 가리키는 ref를 생성하는 방법을 보여줍니다: 바로 아래 예제는 예전 ref 사용법임 cf) 비관적 업데이트 vs 낙관적 업데이트비관적 업데이트 - 사용자가 좀 기다려야함.낙관적 업데이트 - 서버와 통신에 실패했을 때 처리가 어려움 성능 최적화 리액트 개발 시 중요한 이슈 react는 setState가 일어난 컴포넌트의 모든 자식 컴포넌트를 다시 호출한다.–&gt; ( 모든 자식 컴포넌트의 render 메소드를 호출한다.)-&gt; 매번 새로 계산해야 한다.-&gt; 이 계산을 하는 게 느릴 수 있다.props와 state는 둘 다 객체임props와 state의 속성이 바뀌지 않았다면 render메소드를 다시 호출할 필요가 xrender함수는 순수함수(같은 입력 -&gt; 같은 출력) 불변성(PureComponent 실습 코드)key를 이용해서 상태를 초기화하는 예제 불변성을 유지할 수 있게하는 라이브러리immutable.jsimmutable.js 예시 코드 immer immer가 점점 뜨고 있음. 페이스북도 immer 사용을 권장 immer는 내장 객체와 내장 배열을 사용. -&gt; 이 라이브러리를 이용하면, 기존의 메소드를 사용하면서도 불변성을 유지할 수 있다. 비교조정 (Reconciliation) 피하기 shouldComponentUpdate 를 재정의하여 이러한 모든 것을 가속할 수 있습니다.이 함수의 기본 구현체는 ‘true’를 반환하고 React는 업데이트를 수행합니다. 123shouldComponentUpdate(nextProps, nextState) &#123; return true;&#125; 일부 상황에서 컴포넌트를 업데이트할 필요가 없는 경우shouldComponentUpdate 에서’false’ 를 반환하여이 컴포넌트 및 하위에서 호출하는 render()를 포함한 전체 렌더링 프로세스를 스킵할 수 있습니다. PureComponent에 shouldComponent가 내장되어 있는 것임 직접 shouldComponentUpdate를 세밀하게 만져도 된다. 비교조정 (Reconciliation) React는 선언적 API를 제공하기 때문에 갱신이 될 때에 정확히 무엇이 바뀌었는지를 걱정할 필요가 없습니다. 동기 다른 타입을 가진 두 엘리먼트는 다른 트리를 만들어 낼 것이다. ex) ‘div를 table로 고쳐줘라.’ 라고 하면, 엘리먼트의 타입을 바꾸라고 했으므로-&gt; 그 하위 트리는 비교를 수행하지 않고 싹 새로 그린다. 개발자가 제공한 key prop을 이용해,여러 번의 렌더링 속에서도 변경되지 말아야 할 자식 엘리먼트가 무엇인지를 알아낼 수 있을 것이다. -&gt; ‘엘리먼트 타입’이나 ‘key’가 바뀌면 -&gt; 더 이상 비교하지 않고, 새로 그린다. 비교를 할 때는 맨 위 엘리먼트부터 비교한다. 비교 알고리즘 (Diffing Algorithm) 두 트리를 비교할 때 React는 가장 먼저 두 루트 엘리먼트를 비교합니다. 이후의 동작은 루트 엘리먼트들의 타입에 따라 다릅니다. 다른 타입의 엘리먼트인 경우12345678910루트 엘리먼트들의 타입이 다르다면, React는 이전 트리를 버리고 트리를 완전히 새로 구축합니다.트리를 버릴 때, 이전 DOM 노드들은 모두 파괴됩니다.또한 컴포넌트 인스턴스의 componentWillUnmount() 라이프 사이클 훅이 실행됩니다.새 트리가 구축될 때, 새 DOM 노드들이 DOM 안에 삽입됩니다.그에 따라 컴포넌트 인스턴스의 componentWillMount() 훅이 실행되고,그 다음 componentDidMount() 훅이 실행됩니다.이전 트리에 연결되어 있던 **모든 state가 유실됩니다.**루트 엘리먼트 아래에 있는 모든 컴포넌트가 언마운트되고 그 state 또한 파괴됩니다. React의 상태는 화면에 그려질 때만 존재할 수 있다 같은 타입의 DOM 엘리먼트인 경우12같은 타입의 두 React DOM 엘리먼터를 비교할 때,React는 양쪽의 속성을 살펴본 뒤 같은 것들은 유지시키고 변경된 속성만을 갱신합니다. -&gt; DOM을 파괴하는 게 X두 요소를 비교하여 React는 DOM 노드에서 className만 수정되고있다는 사실을 알게됩니다. 1하나의 DOM 노드를 처리한 뒤에, React는 뒤이어 해당 노드의 자식들을 재귀적으로 처리합니다 -&gt; 하위 요소들에 대해서 똑같은 작업을 수행 같은 타입의 컴포넌트 엘리먼트인 경우 같은 타입의 컴포넌트 엘리먼트인 경우는 prop이 바뀔 뿐 state가 날아가지 않습니다. cf) componentWillReceiveProps()는 요즘은 사용하지 않습니다. 키12만약 자식이 키를 갖고 있다면,React는 그 키를 이용해 원래 트리의 자식과 새 트리의 자식 간이 일치하는 지를 결정할 수 있습니다. 같은 자료면 같은 키를 써야합니다. 같은 자료인데 키를 바꾸면 리액트는 다른 자료라고 인식합니다. 키가 바뀌면 상태가 다 날아갑니다. 내가 상태를 강제로 초기화하고 라이프사이클 훅을 싶을 때도 키를 사용할 수 있습니다. 엘리먼트 타입이나 상태가 바뀌면 상태가 다 날아간다는 걸 기억하세요!","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"익스프레스(Express)로 시간 절약","slug":"node-express-for-saving-time","date":"2019-02-26T15:03:46.000Z","updated":"2019-04-11T15:21:56.259Z","comments":true,"path":"2019/02/27/node-express-for-saving-time/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/27/node-express-for-saving-time/","excerpt":"","text":"익스프레스(Express)로 시간 절약 앞서 노드만을 사용해 단순한 웹 서버를 만드는 방법을 배웠다. 이 장에서는 익스프레스(Express)를 사용해 그 서버를 다시 만든다. 익스프레스의 기본에 대해 이해해 보자. 스캐폴딩(Scaffolding) 프로젝트는 대개 템플릿 코드가 일정량 필요하다. 프로젝트의 엉성한 뼈대(템플릿)를 만들어놓고,새 프로젝트를 시작할 때마다 이 템플릿을 복사하는 방법이 훨씬 간단하다. 루비 온 레일즈(Ruby on Rails)에서는 자동으로 스캐폴딩을 생성하는 프로그램을 만들어이 개념을 한 단계 진화시켰다. 익스프레스(Express)는 루비 온 레일즈(Ruby on Rails)의 아이디어를 받아들여, 프로젝트를 시작할 때 스캐폴딩을 생성하는 유틸리티를 제공한다. 메도라크 여행사 웹사이트 이 책 전체에서 사용하는 예제는 오리건 주를 찾아오는 사람을 대상을 서비스를 제공하는가상의 여행사 메도라크(들종다리)의 웹사이트이다. REST 서비스도 제공할 예정이다. 초기 단계 프로젝트에 사용할 새 디렉터리를 만든다. 이 디렉터리는 프로젝트의 루트 디렉터리이다. 이 책에서 ‘프로젝트 디렉터리’, ‘앱 디렉터리’, ‘프로젝트 루트’라고 말하면그건 이 디렉터리를 가리키는 것이다. Tip!프로젝트를 진행하다 보면 회의록이나 문서 같은 파일이 생기게 마련인데,이런 파일들과 웹 앱 파일을 분리해서 보관하자.-&gt; 서브디렉터리를 하나 만들어 프로젝트 루트로 지정하자.예를 들어, 메도라크 여행사 웹사이트 프로젝트와 관련된 파일을 ~/projects/meadowlark 안에 두되,프로젝트 루트(프로젝트 디렉터리)는 ~projects/meadowlark/site로 지정한다. npm은 프로젝트 의존성과 메타데이터를 package.json 파일에 보관해서 관리한다.이 파일을 만드는 가장 쉬운 방법은 npm init이다.이 명령을 내리면, 몇 가지 질문을 거쳐 package.json 파일을 생성한다.(진입점(entry point)을 묻는 질문에는 meadowlark.js 또는 프로젝트 이름을 쓰면 된다. ) Tip! package.json에 저장소 URL을 지정하지 않거나 README.md 파일을 작성하지 않으면npm을 실행할 때마다 경고가 나올 것임사실 package.json 파일에 들어있는 메타데이터는 프로젝트를 npm 저장소에 올리지 않는다면 필요 없는 것이지만,간단한 작업을 해서 경고를 없애는 것도 좋다. 익스프레스를 설치한다.1npm install --save express npm install을 실행하면, 지정한 패키지를 node_modules 디렉터리에 설치한다. –save 플래그를 지정하면 package.json 파일을 업데이트한다. node_modules 디렉터리는 언제든 npm에서 다시 생성할 수 있으니 저장소에 저장할 필요가 없다. 실수로 node_modules 디렉터리를 저장소에 추가하는 일이 없도록 다음과 같이 .gitignore 파일을 만들어 두자. 12// .gitignorenode_modules; meadowlark.js 파일을 만든다. 이 파일이 프로젝트의 진입점 이 책 전체에서 이 파일을 ‘앱 파일’이라고 부를 예정 1234567891011121314151617181920212223242526const express = require(\"express\");const app = express();app.set(\"port\", process.env.PORT || 3000);// 커스텀 404 페이지app.use(function(req, res) &#123; res.type(\"text/plain\"); res.status(404); res.send(\"404 - Not Found\");&#125;);// 커스텀 500 페이지app.use(function(err, req, res, next) &#123; console.error(err.statck); res.type(\"text/plain\"); res.status(500); res.send(\"500 - Server Error\");&#125;);app.listen(app.get(\"port\"), function() &#123; console.log( \"Express started on http://localhost:\" + app.get(\"port\") + \";press Ctrl-C to terminate.\" );&#125;); 기초적인 익스프레스 서버가 만들어졌다. 터미널에 아래의 명령어를 입력하여 meadowlark.js로 서버를 시작해보자.http://localhost3000에 접속할 수 있다. 1node meadowlark.js 아직 익스프레스에 아무런 라우트(Route)도 지정하지 않았으므로 페이지가 존재하지 않음을 나타내는 범용 404 페이지가 나타난다. NOTE애플리케이션 포트는 app.set(port, process.env.PORT || 3000)으로 지정했다.이렇게 하면, 서버를 시작하기 전에 환경 값을 설정해 포트를 오버라이드 할 수 있다.이 예제를 실행했을 때, 앱이 포트 3000에서 실행되지 않는다면,PORT 환경 변수가 설정됐는지 체크해보자. TIPHTTP 요청의 상태 코드와 리다이렉션 여부를 보여주는 브라우저 플러그인을 설치하길 권한다.이런 플러그인을 설치하면, 대개 간과할 수 있는리다이렉션 문제나 부정확한 상태 코드를 찾아내기 쉽다.크롬에서는 아이마(Ayima)의 Redirect Path가 좋다.브라우저 대부분에서 개발자 도구의 네트워크 섹션에서 상태 코드를 볼 수 있다. 홈페이지와 어바웃 페이지 라우트를 추가해보자. 다음과 같이 404 핸들러 앞에 새 라우트를 2개 추가한다. 123456789101112// app.get 메서드: 라우트를 추가하는 메서드// 이 메서드는 매개변수로 경로, 함수를 받는다.app.get(\"/\", function(req, res) &#123; res.type(\"text/plain\"); // 노드의 저수준 메서드 res.end 대신 익스프레스의 확장 메서드 res.send를 사용함 res.send(\"Meadowlark Travel\");&#125;);app.get(\"/about\", function(req, res) &#123; res.type(\"text/plain\"); res.send(\"About Meadowlark Travel\");&#125;); 이제 다시 아래의 명령어를 입력하여 서버를 다시 시작하면,홈페이지와 어바웃 페이지가 정상적으로 작동한다. 1node meadowlark.js app.VERB: 라우트를 추가하는 메서드 여기에서 VERB는 (소문자인) HTTP 동사(대개 ‘get’과 ‘post’)의 플레이스 홀더이다. 이 메서드는 매개변수로 경로와 함수를 받는다.경로 매개변수는 라우트를 정의한다. 기본적으로 대소문자를 구분하지 X 맨 뒤의 슬래시(/)는 무시한다. 매칭할 때는 쿼리스트링을 무시한 채 매칭한다.-&gt; About 페이지의 라우트는 /about, /About(대소문자를 구분하지 않기 때문에),/about/(맨 뒤의 슬래시 무시),/about?foo=bar(쿼리스트링 무시),/about/?foo=bar(맨 뒤의 슬래시 무시, 쿼리스트링 무시)등에 대해 모두 작동한다. 함수 배개변수는 라우트가 일치할 때 호출되는 함수이다.이 함수로 전달되는 매개변수는 요청/응답 객체이다.지금은 평문(plaintext)로 상태 코드 200을 반환한다.(익스프레스의 기본 상태 코드는 200이므로 명시하지 않아도 된다.) 노드의 저수준 메서드 res.end 대신 익스프레스의 확장 메서드 res.send를 사용함노드의 res.writeHead를 res.set과 res.status로 교체익스프레스는 Content-Type 헤더를 설정하는 편리한 메서드 res.type을 제공한다.물론 res.writeHead와 res.end를 써도 되지만 그럴 필요 X 커스덤 404와 500 페이지는 반드시 조금 다르게 처리해야 한다.app.get 대신 app.use를 썼다.app.use는 익스프레스에서 미들웨어(middleware)를 추가할 때 쓰는 메서드일단은 지금은 라우트와 일치하지 않는 모든 것을 처리하는 폴백(catch-all) 핸들러라고 생각하자.중요한 요점은 익스프레스에서는 라우트와 미들웨어를 추가하는 순서가 중요하다. 404핸들러를 라우트 앞에 두었다면, Home 페이지와 About 페이지는 동작하지 않고,404 에러가 일어났을 것이다.지금은 라우트 구조가 매우 단순하지만, 와일드 카드를 지원하므로 순서 문제가 생길 수 있다.ex) About 페이지에 /about/contact나 /about/directions 같은 서브페이지를 추가한다면 어떻게 될까?다음 코드는 원하는 대로 작동하지 않을 것이다. 123456789app.get(\"/about*\", function(req, res) &#123; // 콘텐츠를 전송하는 코드...&#125;);app.get(\"/about/contact\", function(req, res) &#123; // 콘텐츠를 전송하는 코드...&#125;);app.get(\"/about/directions\", function(req, res) &#123; // 콘텐츠를 전송하는 코드...&#125;); 위 예제에서는 첫 번째 핸들러 /about에서 와일드 카드를 썼으므로‘/about/contact’와 ‘/about/directions’ 핸들러는 절대 일치되는 일이 없다. 익스프레스는 콜백 함수가 받는 매개변수 숫자를 통해 404와 500 핸들러를 구별할 수 있다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"Node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"노드로 만드는 단순한 웹 서버","slug":"node-web-serever","date":"2019-02-26T14:48:22.000Z","updated":"2019-04-11T15:21:56.271Z","comments":true,"path":"2019/02/26/node-web-serever/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/26/node-web-serever/","excerpt":"","text":"노드로 만드는 단순한 웹 서버 지금 만드는 앱이 곧 서버이다.노드는 웹 서버를 만드는 작업을 아주 단순하게, 코드 몇 줄로도 가능하게 만들었다. Hello World 노드가 어떻게 동작하며, 프로그래머가 그 과정을 얼마나 컨트롤할 수 있는지 예제로 알아보자. 1234567891011121314151617// hello-world.jsconst http = require(\"http\");// http.createServer 메서드는 함수를 매개변수로 받는다.// 호출 시기: HTTP 요청이 있을 때마다 이 함수를 호출한다.http .createServer(function(req, res) &#123; // 단순히 콘텐츠 타입을 평범한 텍스트로 지정하고, // 문자열 'Hello world!'를 보낸다. // Content-Type: 응답 정보의 타입, 캐릭터셋(인코딩 정보) -&gt; 해석 -&gt; 표시 res.writeHead(200, &#123; \"Content-Type\": \"text/plain\" &#125;); res.end(\"Hello world!\"); &#125;) .listen(3000);console.log(\"Server started on localhost:3000; press Ctrl_C to terminate....\"); 이 서버는 HTML을 전송하지 않고 평범한 텍스트 메시지 ‘Hello World!’를 브라우저에 전송한다. 이벤트 기반 프로그래밍 이벤트 기반 프로그래밍에서는 프로그래머가 어떤 이벤트를 사용할 수 있는지,거기에 어떻게 응답해야 하는지 이해해야 한다.즉, 사용자가 뭔가를 클릭하면 프로그래머가 ‘클릭 이벤트’를 처리하는 식이다. 라우팅(Rounting) 라우팅이란 요청받은 콘텐츠를 클라이언트에 보내는 메커니즘이다. 웹 기반 클라이언트/서버 애플리케이션에서는 클라이언트가 원하는 콘텐츠를 URL에 표시,-&gt; 경로와 쿼리스트링에 표시한다. Hello World! 예제를 좀 더 확장하여홈페이지, 어바웃 페이지, 404(찾을 수 없음) 페이지만 들어 있는 정말 기본적인 웹사이트를 만들어보자. 아직은 이전 예제를 그대로 써서, HTML을 보내지 않고 평범한 텍스트를 보내자. 123456789101112131415161718192021222324252627282930const http = require(\"http\");http .createServer(function(req, res) &#123; // url에서 쿼리스트링과 옵션인 마지막 슬래시를 지우고 소문자로 바꿔서 정규화한다. let path = req.url.replace(/\\/?(?:\\?.*)?$/, \"\").toLowerCase(); switch (path) &#123; // (http://localhost:3000)으로 이동 case \"\": res.writeHead(200, &#123; \"Content-Type\": \"text/plain\" &#125;); // res.end()는 응답 프로세스를 종료한다. res.end(\"Homepage\"); // 쿼리스트링은 무시하므로 (http://localhost:3000/?foo=bar)를 치면, // 홈페이지로 이동한다. break; // (http://localhost:3000/about)으로 이동 case \"/about\": res.writeHead(200, &#123; \"Content-Type\": \"text/plain\" &#125;); res.end(\"About\"); break; default: // (http://localhost:3000/foo)같은 기타 URL은 404 페이지로 이동 res.writeHead(404, &#123; \"Content-Type\": \"text/plain\" &#125;); res.end(\"Not Found\"); break; &#125; &#125;) .listen(3000);console.log(\"Server started on localhost:3000; press Ctrl_C to terminate....\"); 정적 자원 전송 이제 진짜 HTML과 로고 이미지를 전송해보자. ex)주식 가격 표시기는 페이지를 새로 고칠 때마다 가격을 반영하여 바뀌지만,HTML이나 로고 이미지 같은 것들은 바뀌지 않는다. -&gt; 이를 &#39;정적 자원&#39;이라고 부른다. tip!개발 도중 혹은 작은 프로젝트를 진행할 때는 노드에서 정적 자원을 전송해도 별 문제가 없다.But, 큰 프로젝트를 진행할 때는 엔진X 같은 프록시 서버나 CDN을 사용한다. 노드는 파일을 열고 내용을 읽어서 콘텐츠를 브라우저에 전송하는 작업을 직접해야 한다. 프로젝트에 이 목적으로 사용할 public 디렉터리를 만들자. 그 디렉터리에 homte.html, about.html, 404.html을 만든다. 서브 디렉터리 img를 만든 다음 img/logo.jpg 이미지도 만든다. 12&lt;!-- home.html --&gt;&lt;h1&gt;home&lt;/h1&gt; 12&lt;!-- about.html --&gt;&lt;h1&gt;about&lt;/h1&gt; 1&lt;h1&gt;404 Not Found!!!&lt;/h1&gt; hello-world.js를 아래와 같이 수정한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// hello-world.jsconst http = require(\"http\");fs = require(\"fs\");// 보조함수인 serverStaticFile에서 필요한 작업을 대부분 수행한다.function serverStaticFile(res, path, contentType, responseCode) &#123; if (!responseCode) responseCode = 200; // fs.readFile: 파일을 읽는 비동기적 메서드 // 동기적 버전인 fs.readFileSync도 있지만, 생각을 비동기적으로 바꾸는 것을 추천 // fs.readFile을 호출해 파일 콘텐츠를 읽는다. // fs.readFile은 파일을 읽은 뒤 콜백 함수를 실행한다. // 파일이 존재하지 않거나 권한 문제 때문에 파일을 읽을 수 없다면, err 변수가 만들어지며, // 함수는 서버 에러를 나타내는 HTTP 상태 코드 500을 반환한다. fs.readFile(__dirname + path, function(err, data) &#123; if (err) &#123; res.writeHead(500, &#123; \"Content-Type\": \"text/plain\" &#125;); res.end(\"500, - Internal Error\"); // 파일을 성공적으로 읽으면, // 지정한 응답 코드, 콘텐츠 타입, 파일을 클라이언트에 보낸다. &#125; else &#123; res.writeHead(responseCode, &#123; \"Content-Type\": contentType &#125;); res.end(data); &#125; &#125;);&#125;http .createServer(function(req, res) &#123; // url에서 쿼리스트링과 옵션인 마지막 슬래시를 지욱 소문자로 바꿔서 정규화한다. let path = req.url.replace(/\\/?(?:\\?.*)?$/, \"\").toLowerCase(); switch (path) &#123; case \"\": serverStaticFile(res, \"/public/home.html\", \"text/html\"); // res.end()는 응답 프로세스를 종료한다. break; case \"/about\": serverStaticFile(res, \"/public/about.html\", \"text/html\"); break; case \"/img/logo.jpg\": serverStaticFile(res, \"/public/img/logo.jpg\", \"image/jpeg\"); break; default: serverStaticFile(res, \"/public/404.html\", \"text/html\", 404); break; &#125; &#125;) .listen(3000);console.log(\"Server started on localhost:3000; press Ctrl_C to terminate....\"); 이 예제의 라우팅은 매우 단순하다.http://localhost:3000/about으로 이동하면, public/about.html 파일이 전송된다.경로나 파일을 원하는 대로 바꿀 수 있다. ex) 요일마다 다른 About 페이지를 표시하고 싶다면, public/about_mon.html, public/about_tue.html 등을 만들고, 사용자가 localhost:3000/about으로 이동할 때 적절한 페이지를 전송하게끔 라우팅 프로그램을 만들 수 있다. Tip!__dirname은 실행 중인 스크립트가 들어있는 디렉터리로 해석된다.-&gt; 스크립트가 /home/sites/app.js에 들어 있다면,__dirname은 /home/sites로 해석된다.이 전역 변수를 사용하지 않으면, 앱을 다른 디렉터리에서 실행했을 때,분석하기 어려운 에러가 일어나곤 한다. 익스프레스(Express)로 출발 Express는 이미 존재하고, 시간을 소비해서 구현해야 할 기반 구조는 이미 만들어져 있다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"Node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"React 8일차","slug":"react8","date":"2019-02-24T16:21:02.000Z","updated":"2019-04-11T15:22:16.530Z","comments":true,"path":"2019/02/25/react8/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/25/react8/","excerpt":"","text":"JSX 더 알아보기 문법 설탕(syntatic sugar): 무언가를 문법적으로 쉽게 만든 것 .createElement()의 반환값은 객체다.가 중요 React 엘리먼트의 타입 지정하기&lt;div/&gt;&lt;Div/&gt;는 리액트에서 다르게 동작대문자로 시작하는 타입은 해당 JSX 태그가 React 컴포넌트임을 가리킨다. 그러니까, &lt;Foo /&gt;와 같은 JSX 표현을 사용하려면 Foo가 반드시 스코프 내에 존재해야 합니다. React가 스코프 안에 있어야합니다 JSX는 React.createElement를 호출하는 코드로 컴파일되기 때문에,React 라이브러리가 JSX 코드의 스코프 안에 항상 존재해야만 합니다. -&gt; 리액트 코드를 작성할 때 항상 import React from ‘react’;를 써줘야함 JSX 타입을 위한 점 표기법 사용하기사용자 정의 컴포넌트는 ‘대문자’로 시작해야합니다엘리먼트 타입이 소문자로 시작한다는 것은 그것이 or 와 같은 내장 컴포넌트라는 것을 뜻합니다.이 컴포넌트들은 결과적으로 ‘div’혹은 ‘span’와 같은 ‘문자열의 형태’로 React.createElement에 전달됩니다.-&gt; JSX에서 소문자 태그는 그 소문자 이름인 태그가 렌더링됨 와 같이’ 대문자’로 시작하는 타입은 React.createElement(Foo)와 같이 컴파일되며,따라서 여러분의 JavaScript 파일에 정의되어있거나 혹은 다른 파일에서 import 된 컴포넌트여야 합니다.대문자 -&gt; 대문자 실행 중에 타입 선택하기 대문자로 시작하는 변수는 JSX 타입이 될 수 있습니다. cf) 컴포넌트를 변수에 담고, 컴포넌트를 반환하기도 함컴포넌트를 받아서 컴포넌트를 반환하는 고차 컴포넌트도 있다. JSX 안애서 prop 사용하기 {}로 둘러싸면 값이 잘 넘어간다 문자열 리터럴Props의 기본값은 “True”속성 펼치기12345678910111213141516171819const Button = props =&gt; &#123; // other는 객체 // Button은 kind만 알면 되므로 const &#123; kind, ...other &#125; = props; const className = kind === \"primary\" ? \"PrimaryButton\" : \"SecondaryButton\"; //props안에 있는(kind빼고) other에 있는것들을 펼쳐서 버튼에 넣어줌. onClick이 버튼 태그에 등록됨 // button쓰듯이 사용자 정의 컴포넌트인 &lt;Button /&gt;을 사용하고 시ㅠ어서 return &lt;button className=&#123;className&#125; &#123;...other&#125; /&gt;;&#125;;const App = () =&gt; &#123; return ( &lt;div&gt; &lt;Button kind=\"primary\" onClick=&#123;() =&gt; console.log(\"clicked!\")&#125;&gt; Hello World! &lt;/Button&gt; &lt;/div&gt; );&#125;; JSX에서 자식 다루기문자열 리터럴여는 태그와 닫는 태그 사이에 문자열을 써넣을 수 있고, 이 때 props.children는 그냥 문자열이 됩니다.이런 식으로 많은 내장 HTML 엘리먼트를 사용할 수 있습니다: JSX를 자식으로 사용하기 여러 형태의 자식을 섞어서 쓸 수 있습니다. React 컴포넌트는 엘리먼트로 이루어진 배열 역시 반환할 수 있습니다. JavaScript 표현식을 자식으로 사용하기함수를 자식으로 사용하기 컴포넌트 안에 함수를 사용할 수 있다. 1234567891011121314151617// Calls the children callback numTimes to produce a repeated componentfunction Repeat(props) &#123; let items = []; for (let i = 0; i &lt; props.numTimes; i++) &#123; items.push(props.children(i)); &#125; return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;&#125;function ListOfTenThings() &#123; return ( &lt;Repeat numTimes=&#123;10&#125;&gt; &lt;!-- &#123;&#125;안에 함수를 넘겨서 화면을 그릴 수 있다 --&gt; &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125; &lt;/Repeat&gt; );&#125; 진리값, null, undefined는 무시됩니다. 이 성질은 React 엘리먼트를 조건부 렌더링하고 싶을 때 유용하게 사용할 수있습니다. 아래 JSX는 showHeader가 true일 때에만 를 렌더링합니다: 1234&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125; &lt;Content /&gt;&lt;/div&gt; &amp;&amp;연산자는 왼쪽이 truthy -&gt; 오른쪽 반환오른쪽이 falsy이면 -&gt; 왼쪽 반환 한 가지 주의해야 할 점은 0과 같은 몇몇 “falsy” 값들이 여전히 React에 의해 렌더링될 수 있다는 것입니다. 0이나 NaN은 리액트가 그린다. -&gt; 리액트 안에서 truthy, falsy 성질을 이용할 때는 주의! Proptypes를 이용한 타입 체크 타입스크립트가 뭔지는 알아야함 -&gt; 면접 질문 나올수도-&gt; 코드 실행하기 전 타입 관련 문제를 찾아낼 수 있는 기술.사용자가 점점 증가하는 추세 정적 타입 체크Ref와 DOM prop으로 넘기지 않는 2가지 - Ref와 key 부모에서 Ref와 key를 prop으로 넘겨줘도 리액트가 가로챔 어쩔수 없이 DOM객체를 직접 만져야 할 때가 있다ex) 외부 라이브러리를 가져다 쓸 때 가끔은 전형적인 데이터 흐름 밖에서 자식을 명령형으로 변경해야 할 필요가 있습니다. Ref 생성하기 Ref는 참조의 약자 123456789101112// DOM객체를 가리키는 화살표를 만들고 싶을 때// 1. Ref 객체를 만든다class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); &#125; render() &#123; // 2. Ref 객체를 넣어준다 return &lt;div ref=&#123;this.myRef&#125; /&gt;; &#125;&#125; Ref 사용하기 1번 연결시킨 뒤에는 .current속성을 이용해서 연결된 DOM노드를 가져올 수 있다 12// current속성을 이용해서 진짜 DOM객체를 가져온다const node = this.myRef.current; HTML 엘리먼트에 ref 어트리뷰트가 사용되면,ref의 current 속성은 DOM 엘리먼트 객체를 가리킵니다. 클래스 컴포넌트에 ref 어트리뷰트가 사용되면,ref의 current 속성은 해당 컴포넌트로부터 생성된 인스턴스를 가리킵니다. DOM 엘리먼트에 ref 사용하기 노트 필기 클래스 컴포넌트에 ref 사용하기12345678910111213141516class AutoFocusTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.textInput = React.createRef(); &#125; componentDidMount() &#123; // this.textInput.current는 클래스 인스턴스 // -&gt; this.textInput.current.focusTextInput(); &#125; render() &#123; return &lt;CustomTextInput ref=&#123;this.textInput&#125; /&gt;; &#125;&#125; -&gt; 클래스 인스턴스에 직접 접근할 수 있는 방법이 있고, 그 방법이 ref다. React에서 this가 가리키는게 무엇인지를 아는 게 중욧!!!! Ref와 함수형 컴포넌트 함수형 컴포넌트는 인스턴스를 가질 수 없기 때문에 ref 어트리뷰트 역시 사용할 수 없습니다 create-react-app-npx: npm을 다운받아서 바로 실행해줌npx명령을 실행하면 항상 패키지를 새로 다운 받는다 -&gt; 항상 최신 버전의 npm을 사용할 수 있다 npm start- 개발 서버 npm run build my-app├── README.md├── node_modules├── package.json├── .gitignore├── public│ ├── favicon.ico│ ├── index.html│ └── manifest.json└── src├── App.css├── App.js├── App.test.js├── index.css├── index.js├── logo.svg└── serviceWorker.js src - 변환 과정을 거쳐서 사용자에게. 압축이나 트랜스파일링 등 pulic - 변환 과정을 거치지 X Internet Explorer 9, 10, and 11는 지원 x(polyfills 사용해야함) 표준 명세에 적혀있다고 해서 실제 기능으로 사용할 수 있는 게 x Styles and AssetsAdding a Stylesheetbase64 010101로 되어있는 정보를 url에 넣고 싶다-&gt; url은 문자열만 담을 수 있으므로 base64 인코딩을 이용해서 변환 Adding Images, Fonts, and Files Create React App은 자동으로 깃 저장소로 만들어줌 -&gt; git init 안하고 바로 커밋 가능","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 7일차","slug":"react7","date":"2019-02-23T16:58:24.000Z","updated":"2019-04-11T15:22:16.529Z","comments":true,"path":"2019/02/24/react7/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/24/react7/","excerpt":"","text":"리스트와 키 React element가 들어있지 않은 배열로부터 React element가 들어있는 배열을 만들 수 있다.-&gt; 화면에 바로 그릴 수 있다. 기본적인 목록 컴포넌트 Warning: 에러는 아니지만, 코드에 문제가 있으니 확인해야 한다. map 메소드를 사용할 때는 key를 써줘야 한다. 키 키를 지정해주면 어떤 아이템이 바뀌었는지, 추가되었는지, 삭제 되었는지를 React에게 알려줄 수 있습니다. 어떤 자료가 있고, 그 자료의 식별자가 있다면 -&gt; 그 식별자를 key로 사용하는 게 좋다. 대부분의 경우 데이터의 ID를 키로 사용한다. eX1) 유저정보 userId나 userName(사이트에 가입하는 그 아이디)를 key로 사용한다. 최후의 수단으로 배열의 index를 key로 사용하는 방법을 사용한다. 항목 간 순서가 바뀔 수 있는 경우 키에 배열의 인덱스를 사용하지 않는 게 좋다. ex) todolist를 예로 들면, setState를 사용해서 변경해주면 순서가 뒤죽박죽이 될 수 있으므로key에 index를 사용하지 않는 게 좋다. (삭제, 위로, 아래로 등을 누르면 순서가 섞여버릴 수 있음) React에게 배열을 그려달라고 하려면, 거기에 key를 꼭 넣어줘야 한다.그 안에 있는 요소 각각에 key를 넣어야 한다. key를 사용하지 않으면, 여러 가지 문제가 발생할 수 있다. 주의할 점 key로 쓰는 값은 서로 다른 key를 붙여야 한다.(같은 key값을 가지면 안된다.) 3개의 li에 1, 1, 2를 붙이면 x! (cf) 주민등록번호가 같은 사람이 없음) 키로 컴포넌트 추출하기 키는 바로 바깥쪽의 배열에 대해서만 의미를 가집니다. map에서 바로 반환되는 element안에 key를 넣어줘야 한다.-&gt;map 메소드 안에 적어야 한다. mistakes에 적어주기 키는 형제 중에서 고유한 값이어야한다. key라는 이름은 아래쪽(자식 컴포넌트)에서 props로 받아서 사용할 수 없다. key와 ref는 React가 특별하게 취급하는 이름이기 때문에 자식 Component에서 prop으로 받아서 사용할 수 없다. mistakes에 적어주기 클래스는 인스턴스를 만들려고 사용하는 것이다. Game컴포넌트는 클래스이므로 React가 알아서new Game()해서 인스턴스를 생성해서 Game컴포넌트에 붙여놓는다.Game instance에 state라는 속성이 저장된다. Game컴포넌트에서 this.setState, this.props에서 쓰이는 this가 이 클래스의 인스턴스를 가리킨다. 실제로 클래스의 인스턴스가 생성되고, 개발자가 this를 쓰면,그 인스턴스를 만지는 것이다. 화면이 어떻게 표시되는지에 따라서, 그에 따른 state를 가질 수 있다. 화면에 표시되지 않는 Component의 state가 살아있을 수 없다. (메모리에서 사라짐.) new Game()해서 인스턴스가 생성되서 React의 기억에 촥~ 달라붙는다. Game이라는 노드가 사라지면, React의 기억에서그 노드에 달려있던 인스턴스의 state도 같이 날아간다.(메모리에서 사라진다.) 함수형 컴포넌트는 인스턴스를 만들어서 붙여놓을 수 때문에 상태를 가질 수 없는 것이다.ex)function Option(props) {}는 인스턴스를 만들 수 없다. 이 내용은 엄청나게 어려우므로 흘려들을 것: 함수형 컴포넌트도 상태를 기록할 수 있는 저장소가 있고,여기에 상태를 저장하는 방식으로 기능이 추가되고 있는 것 같다. -&gt; 아직 추가된 건 X 중요! Component가 그려져야 상태를 가질 수 있다. -&gt; ‘React의 기억’이 바뀌면, 상태가 날아갈 수 있다. React는 key값이 바뀌면, 상태가 다 날아간다. key가 배열안에서만 사용되는 게 X 상태 초기화를 위해 key를 바꿔주는 기법도 많이 사용된다. 폼 HTML 폼(form) 요소는 그 자체가 내부 상태를 가진다.ex) 체크박스 - 체크 여부를 알아서 기억함 input태그 - 자기가 알아서 기억하고, 지가 알아서 변경도 한다. select태그 text area form element에 각각의 상태 저장소가 있고, React Component에 상태 저장소가 있다.각각이 따로 상태를 가지고 있다는 걸 기억 -&gt; 각각 따로 상태를 가지고 있는 게 좋을 때도 있고, 좋지 않을 때도 있다. React에서는 form element가 상태를 가지지 못하도록 만드는 기능이 있다. 사용자가 입력한 상태를 읽어와서 사용자에게 feedback을 잘 할 수 있어야 한다. 사용자가 숫자를 입력해야 하는 field에 알파벳을 입력하고 있으면,경고를 주는 등의 feedback을 잘 할 수 있어야 한다. -&gt; 상태를 공유하기 위해 위쪽으로 상태를 끌어올리는 게 좋다. form이 내부에서 상태를 가지는 게 아니라, 위쪽으로 끌어올려서 제어할 수 있게 한다. 제어되는 컴포넌트 (Controlled Components)vs uncontrolled Componets 많이 사용되는 용어! 따로 정리해두기(TIL에) 서로 다른 2가지의 상태 저장소가 있고, 업데이트하는 방법도 다르다. 우리가 했던 todolist 예제에서는 상태 저장소가 2개가 있었던 것임 공유되는 상태를 끌어올리는 게 좋다. input에 그 자체의 상태를 없애버리고,사용자에게 피드백을 보여주는 컴포넌트에서는 input태그의 상태가 필요-&gt; 가장 가까운 공통 조상이 상태를 가지는 게 좋다. 상태를 전부 다 React에서 관리하게 할 수 있다. input 태그를 만들 때, value prop에 문자열을 넘겨주면,제어되는 컴포넌트가 되서 자체적인 상태를 가지지 않는 컴포넌트가 된다. 화면을 바꾼다. -&gt; input필드 안에 있는 내용을 바꾸려면, React에 있는 상태를 바꿔준다. input에 입력이 일어났을 때, 무언가 처리를 하고싶다면, onChange속성을 사용한다. input 이벤트와 change 이벤트의 차이점 찾아보기(DOM에서는 다름) React에서는 사용자의 입력이 일어날 때마다 뭔가를 해주고 싶다면-&gt; &lt;input&gt;, &lt;select&gt;, &lt;textarea&gt; 등에서 onChange속성을 사용하면, React가 알아서 잘 붙여준다. React에서는 value로 제어되는 컴포넌트로 만들어준 후, onChange로 e.target.value에는 지금 선택된 옵션의 value값이 들어있다. 제어되는 컴포넌트(Controlled Componentes)제어되는 컴포넌트? input,select, textarea가 화면을 그리는 기능만을 갖게 만들어주는 것이다.그 자체로는 상태가 변경되지도 않고 제어되지 않게 만드는 것이다. 제어되는 컴포넌트는 React의 상태를 바꿔야 화면이 바뀌게 되는 것이다. 제어되는 컴포넌트를 사용하는 이유 사용자의 입력을 아주 세밀하게 컨트롤 사용자가 입력할 때마다 바로바로 feedback을 주고 싶을 때 사용 만드는 방법: value상태, handleChange함수 하나를 만들어야 한다. 여러 input 제어하기 실제로는 form 전부를 제어되게 만드는 게 귀찮고 복잡한 과정임 전부 제어되는 컴포넌트가 되게 하면서도 편하게 코딩할 수 있게 만드는 라이브러리를 사용-&gt; formik 라이브러리를 사용 formik 라이브러리를 사용 제어되는 입력 필드의 Null 값 이 부분은 강사님이 그냥 넘어가심 제어되는 컴포넌트에 대한 대안책 제어되지 않는 컴포넌트를 잘 사용하려면 React의 세계로 DOM객체를 가져와야 한다. React에서 만지는 객체는 DOM객체가 아니다. 이 작업을 querySelector로 할 수가 없다. cf) ref라는 속성이 DOM객체를 가져올 때 사용하는 속성이다. State 끌어올리기 화씨, 섭씨 예제가 복잡해서 넘어가심 기억할 것!! 여러 자식들이 공유하는 상태가 필요할 때 자식 컴포넌트들끼리 통신해야 할 때 -&gt; 부모로 상태를 끌어올려서 관리하는 게 좋다. 합성(조합) (composition) vs 상속 (inheritance)다른 컴포넌트를 담기 ex) 쇼핑몰 프로젝트 헤더나 푸터는 어느 페이지에나 나타난다.- 종종 컴포넌트에 어떤 자식이 들어올 지 미리 알 수 없는 경우가 있습니다.이는 범용의 “박스” 역할을 하는 Sidebar 나 Dialog 같은 컴포넌트에서 많이 나타나는 패턴입니다. 이러한 경우, children이라는 특별한 prop을 통해 자식 요소를 출력에 그대로 전달하는 방법을 사용해보세요. children이라는 prop은 React가 특별히 관리하는 prop이다. 1234567function FancyBorder(props) &#123; return ( &lt;div className=&#123;\"FancyBorder FancyBorder-\" + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125; 12345678910function WelcomeDialog() &#123; return ( // FancyBorder에 chidren이라고 넘기지 않았지만, // 그 안에 있는 h1과 p가 children이 됨 &lt;FancyBorder color=\"blue\"&gt; &lt;h1 className=\"Dialog-title\"&gt;Welcome&lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt;Thank you for visiting our spacecraft!&lt;/p&gt; &lt;/FancyBorder&gt; );&#125; 기억할 것props.children이라는 특별한 prop이 있다.prop으로 element를 넘길 수 있다. -&gt; 부모로부터 받은 element를 화면에서 그려줄 수 있다. 컴포넌트를 만들고 싶은데, 빈칸을 만들고 싶을 때 ex) 레이아웃은 만들어 두고, 컨텐츠 영역만 갈아끼우고 싶을 때 사용 특수화 (Specialization) ex) 로그인 dialog, 경고 dialog 등특수한 경우인 컴포넌트를 만들어야 하는 경우 -&gt; React에서는 상속이 아닌 합성, 조합을 사용한다. cf) 상속에서 부모는 좀 더 일반적이고 포괄적인 경우, 자식은 특수한 경우.라서 보통은 상속을 이용하는데, React에서는 상속을 이용하지 X!.상속을 쓰지 말라고 React팀에서도 얘기하고 있음 할일 목록 실습 React에서는 컴포넌트 하나에 파일 하나를 만든다. 하나의 파일에 컴포넌트 여러 개 두는 경우 거의 없다. React코드는 항상 맨 윗줄에 이 코드가 있어야 한다.import React from ‘react’ className이라는 라이브러리를 사용하면 class 이름을 동적으로 생성할 수 있다.className 라이브러리(npm 페이지) 사용법: 이 class를 포함시킬 것인지 포함시키지 않을 것인지 true, false로 객체로 넘긴다.classNames(‘foo’, { bar: true }); // =&gt; ‘foo bar’ SandBox에서 npm추가하는 법 좌측 Add Dependendy에 키워드로 검색","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 6일차","slug":"react6","date":"2019-02-22T16:54:23.000Z","updated":"2019-04-11T15:22:16.458Z","comments":true,"path":"2019/02/23/react6/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/23/react6/","excerpt":"","text":"조건부 렌더링&amp;&amp; 논리 연산자를 사용해 if를 인라인으로 넣기 React는 문자열, 숫자는 잘 그려주는데, true, false, null 등은 화면에 안 그려준다. &amp;&amp;는 앞의 코드가 falsy이면 앞의 걸 반환하고, 앞의 코드가 true이면 뒤의 걸 반환한다. 12345678910111213141516171819202122function Mailbox(props) &#123; // unreadMessages.length는 안 읽는 메시지가 있으면 true, 안 읽은 메시지가 없으면 false가 됨 // &amp;&amp;는 앞의 코드가 falsy이면 앞의 걸 반환하고, 앞의 코드가 true이면 뒤의 걸 반환한다. // 앞의 코드가 falsy라서 false를 반환하면, React는 아무것도 화면에 그리지 않기 때문에 if - else의 느낌으로 사용할 수 있다. //if ~else를 React에서 사용할 수 있으나 복잡한 UI를 그리기에 불편해서 이렇게 &amp;&amp;를 이용함 const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; ( &lt;h2&gt;You have &#123;unreadMessages.length&#125; unread messages.&lt;/h2&gt; )&#125; &lt;/div&gt; );&#125;const messages = [\"React\", \"Re: React\", \"Re:Re: React\"];ReactDOM.render( &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;, document.getElementById(\"root\")); 조건부 연산자를 사용해 if-else 인라인으로 넣기123456789// if ~else 느낌으로 삼항 연산자를 쓸 수 있다.render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in. &lt;/div&gt; );&#125; 컴포넌트가 렌더링 되지 못하도록 방지123456789// 경고 메시지가 있으면 그려라.// 경고 메시지가 없으면, 아무것도 그리지 말고function WarningBanner(props) &#123; if (!props.warn) &#123; return null; &#125; return &lt;div className=\"warning\"&gt;Warning!&lt;/div&gt;;&#125;","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 5일차","slug":"react5","date":"2019-02-21T15:16:28.000Z","updated":"2019-04-11T15:22:16.458Z","comments":true,"path":"2019/02/22/react5/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/22/react5/","excerpt":"","text":"이벤트 제어하기 함수 안에서 함수를 정의할 수 있다. onClick={handleClick}의 {}안에 함수를 정의해도 되고, 밖에서 정의하고 안에 함수 이름을 써줘도 됨 123456789101112function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault(); console.log(\"The link was clicked.\"); &#125; return ( &lt;a href=\"#\" onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125; Event Pooling Note: If you want to access the event properties in an asynchronous way, you should call event.persist() on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code. 비동기식으로 이벤트 객체의 속성에 접근하기를 원한다면, 당신은 호출해야 한다.event.persist()라는 메소드를 호출해야 한다. 합성 이벤트를 pool에서 제거한다. await와 await 사이의 코드는 동기식으로 작동한다. React에서는 비동기 함수를 이벤트 리스너에 그냥 등록하는 건 위험하다. 이벤트 객체는 React에서 쓸 때 조심해야 한다. 비동기식으로 이벤트 객체의 속성에 접근하려면, event.persist() 메소드를 호출해야 한다. 미리 속성을 빼오면 괜찮다. 자세한 방법은 다음에 강사님이 알려주실 예정 React를 사용할 때, (일반적인 경우) 리스너를 추가하기 위해 DOM 요소가 생성된 후addEventListener 를 호출할 필요가 없습니다.대신 요소를 처음 렌더링할 때 리스너를 같이 넘겨주세요. React가 addEvnetListener를 호출해 주는 것이다. JSX 콜백에서 this 의 의미에 대해 주의해야합니다.자바스크립트에서 클래스 메서드는 기본적으로 바인딩 되지 않습니다.만약 this.handleClick 바인드를 잊은채로 onClick 에 전달하면,this 는 함수가 실제로 호출될 때 undefined 로 취급됩니다. 이건 React에서만 해당되는 동작이 아닙니다.자바스크립트의 함수의 동작 방식 자체가 이렇습니다.일반적으로 onClick={this.handleClick} 처럼 () 없이 메서드를 참조하면,그 메서드를 bind 해야합니다. 만약 bind 를 호출하는 게 귀찮은 경우,이 문제를 해결할 수 있는 두 가지 방법이 있습니다.만약 실험적 기능인 퍼블릭 클래스 필드 문법 을 사용하고 있다면,콜백을 올바르게 바인딩하기 위해 클래스 필드를 사용할 수 있습니다. this와 관련된 문제들이 있고, 여러 가지 해결 방법이 있는데,onClick이나 onSubmit, onMouseMouve 등에는 화살표 함수를 사용한다.this가 가리키는 게 잘 고정된다. 여러 가지 해결 방법은 각각의 성능 상의 장단점이 있다. 중요한 내용: React는 특별한 객체를 사용한다.-&gt; 주의해야 할 부분이 있다. 특히 이벤트 리스너를 사용할 때, this 때문에 문제가 많이 발생하므로 문제를 해결하기 위해서 화살표 함수를 사용하자.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 3일차","slug":"react3","date":"2019-02-20T15:21:09.000Z","updated":"2019-04-16T13:04:41.687Z","comments":true,"path":"2019/02/21/react3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/21/react3/","excerpt":"","text":"요소(element) 렌더링요소는 React 앱에서 가장 작은 단위의 재료입니다. 요소는 화면에 표시하고자 하는 내용을 서술합니다. React는 element를 받아서 화면에 그려주는 기능을 하는 라이브러리 브라우저 DOM 요소와 달리, React 요소는 순수한 객체이며 생성 비용이 저렴합니다. 생성 비용? ex) video태그, img태그 등은 비용이 많이 든다. (자바스크립트 실행 속도가 느려질 수 있다. 이 태그를 만들어내는 데 계산이 오래 걸리기 때문에, cpu 메모리가 많이 사용된다.) React DOM이라는 라이브러리가 개발자 대신에 알아서 DOM 요소 객체를 생성해서 appendChild 등을 해서 HTML문서에 넣어준다. DOM에서 요소 렌더링하기 React로 구축한 어플리케이션은 보통 하나의 루트 DOM 노드를 가진다. React 요소를 루트 DOM 노드에 렌더링하고 싶다면, ReactDOM.render() 에 둘 다 넘겨주면 됩니다. ReactDOM 라이브러리에 첫 번째 인수로 element를 넘겨주고, 두 번째 인수로 어디에 그려줄 것인지를 써준다. 우리는 2가지 라이브러리를 사용하는 것이다. React 라이브러리 ReactDOM 라이브러리 cf) 브라우저 DOM에 그리고 싶을 때 - ReactDOM라이브러리를 사용 모바일 앱에 그리고 싶을 때 - React Native를 사용(사용법은 많이 다름) 렌더링된 요소 업데이트React 요소는 변경 불가능 합니다. 한번 요소를 만들었다면, 그 자식이나 어트리뷰트를 변경할 수 없습니다. 중요!! 불변성(Immutability) 변경할 수 없다. 값을 변경하고 싶을 때는 값을 새로 만든다. React 요소는 사실 그냥 객체이기 때문에 변경 불가능하다는 의미는, 진짜 변경할 수 없다는 게 아니라 변경하고 싶으면, 처음부터 싹 새로 만든다는 의미이다. React는 화면을 조금이라도 바꾸고 싶으면, element를 처음부터 다 다시 그린다. 상태가 조금이라도 바뀌면, render메소드가 다 호출되고, React element가 맨 위에 있는 부모부터 가장 아래에 있는 자식까지 다~~~ 다시 그려지는 방식이다. Developer가 React element를 직접 변경할 일은 없다.요소는 영화의 단일 프레임에 비유할 수 있습니다. 즉, 요소는 특정 시점의 UI를 표현할 뿐입니다. 이제까지 배운 것만 가지고 UI를 갱신할 수 있는 유일한 방법은 새로운 요소를 만들어서 이 요소를 ReactDOM.render() 로 전달하는 것입니다. 보통 실무에서는 setState로 상태를 변경한다. 12345678910111213// 실무에서 활용되는 방법은 Xfunction tick() &#123; // toLocaleTimeString()는 사용자가 사용하는 시간으로 만들어주는 메소드 const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById(\"root\"));&#125;// tick이라는 함수가 1초에 한 번씩 실행됨setInterval(tick, 1000); 이 예제는 setInterval() 콜백을 이용해 매 초마다 ReactDOM.render() 를 호출하고 있습니다. Note: 실무에서, 대부분의 React 어플리케이션은 ReactDOM.render() 를 한 번만 호출합니다. 다음 섹션에서는 이러한 코드가 어떻게 상태를 갖는 컴포넌트 로 캡슐화 되는 지 배울 것입니다. 서로가 서로를 기반으로 만들어져 있기 때문에, 이 주제를 건너뛰지 않는 걸 권장합니다. React는 꼭 필요한 부분만 갱신합니다 상식으로 알고 있을 내용: DOM Tree에서 변경된 부분을 브라우저가 보라색으로 보여준다. 컴포넌트와 props 컴포넌트를 통해 UI를 독립적이고 재사용 가능한 부분으로 분리하고, 각 부분을 독립적으로 생각할 수 있습니다. 개념상 컴포넌트는 자바스크립트 함수와 비슷합니다. “props”이라 불리는 임의의 입력을 받아들이고, 화면에 무엇이 표시되어야 하는지를 서술하는 React 요소를 반환합니다. 컴포넌트 렌더링 함수는 긴 코드뭉치에 이름을 붙인 것임 그 함수의 이름만 기억해서 그 긴 코드를 실행시키는 것임 긴 엘리먼트를 생성하는 컴포넌트에 이름을 붙여서 사용할 수 잇는 것임 123// 컴포넌트 안에 많은 엘리먼트들이 들어있지만 모든 내용을 개발자가 기억하고 사용하는 게 X// 사용자 정의 컴포넌트의 이름을 그 기능을 잘 나타내주는 이름으로 붙여주어 사용한다.const element = &lt;Welcome name=\"Sara\" /&gt;; 컴포넌트 조립하기 제일 위에 있는 컴포넌트를 App이라고 부르는 게 관례이다. 컴포넌트 추출Props는 읽기전용입니다 props는 무슨 일이 있어도 수정하지 말 것 props는 부모로부터 데이터를 받으면 props에 들어있는 거고, props를 수정하지 않아야 한다. 123function sum(a, b) &#123; return a + b;&#125; 입력을 변경하지 않고, 동일한 입력에 대해 항상 동일한 결과를 반환하는 함수를 순수함수(pure function)라고 한다. 12345// 계좌에서 돈을 인출할 때// 이 함수는 입력을 변경하기 때문에 순수하지 않다.function withdraw(account, amount) &#123; account.total -= amount;&#125; render 메소드 안에서는 같은 입력이 들어왔을 때, 같은 출력이 나가게 만들어줘야 한다. ex) render 메소드 안에 Math.random()을 사용하지 X!! React에서 render 메소드가 호출되는 것을 개발자가 컨트롤할 수 없다. render 메소드 안에 Math.random()을 사용하면, 화면이 다시 그려질 때마다 출력이 계속 달라지기 때문에 화면이 예상치 못한 순간에 이상하게 나오는 버그가 발생할 수 있다.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"React 2일차","slug":"react2","date":"2019-02-20T14:49:25.000Z","updated":"2019-04-11T15:22:16.455Z","comments":true,"path":"2019/02/20/react2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/20/react2/","excerpt":"","text":"JSX 소개 JSX로 만든 엘리먼트는 변수에 담을 수 있고, 함수의 매개변수로도 사용할 수 있다. 왜 JSX인가?JSX에 표현식 포함하기 JSX 안에 자바스크립트 표현식 을 중괄호로 묶어서 포함시킬 수 있다. 예를 들어, 2 + 2, user.firstName, formatName(user) 를유효한 표현식으로 표현하면 아래와 같이 표현한다. 123456789101112function formatName(user) &#123; return user.firstName + \" \" + user.lastName;&#125;const user = &#123; firstName: \"Harper\", lastName: \"Perez\"&#125;;const element = &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;;ReactDOM.render(element, document.getElementById(\"root\")); 가독성을 좋게 하기 위해 JSX를 여러줄로 나눴습니다. 필수는 아니지만,이 작업을 수행할 때는 자동 세미콜론 삽입의 함정을 피하기 위해 괄호로 묶는 것이 좋다. JSX 또한 표현식이다 컴파일이 끝나면, JSX 표현식이 일반적인 자바스크립트 함수 호출이 되고,결과적으로 자바스크립트 객체로 평가된다. 이 말은 if 문이나 for 문 내에서 JSX를 사용할 수 있다. -&gt; 변수에 할당하거나 매개변수로 전달하거나 함수에서 반환할 수 있음을 의미한다. 123456function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125; JSX 어트리뷰트 정의 어트리뷰트에서 따옴표를 사용해서 문자열 리터럴을 정의할 수 있다. 1const element = &lt;div tabIndex=\"0\" /&gt;; 어트리뷰트에 중괄호를 사용하면, 자바스크립트 표현식을 포함시킬 수 있습니다. 1const element = &lt;img src=&#123;user.avtarUrl&#125; /&gt;; 어트리뷰트에 자바스크립트 표현식을 포함시킬 때 중괄호를 따옴표로 묶지 말아야 한다. 따옴표 (문자열 값인 경우) 또는 중괄호 (표현식인 경우) 중 하나를 사용해야 하며,하나의 어트리뷰트에 둘 다 사용할 수 있는 것이 아니다. 123이렇게 하면, user.avatarUrl에 들어있는 값이 넘어가는 게 아니라 문자열이 넘어감const element = &lt;img src=\"&#123;user.avatarUrl&#125;\"&gt;&lt;/img&gt;;const element = &lt;img src=\"user.avatarUrl\"&gt;&lt;/img&gt;; 경고:HTML에서 사용하던 어트리뷰트 이름을 JSX에서 그대로 사용할 수 없다.JSX는 HTML보다는 자바스크립트에 가깝기 때문에,React DOM은 HTML 어트리뷰트 이름 대신 camelCase 어트리뷰트 이름 컨벤션을 사용합니다. ex1) React에서는 tabIndex를 camelCase로 써준다.React 라이브러리를 통해 tabindex라고 변환되어 HTML에 들어가는 것이다. ex2) HTML에서는 label for를 React에서는 label htmlFor로 써야한다.예를 들어, JSX에서 class 는 className 이 되며, tabindex 는 tabIndex 가 됩니다. JSX 자식 정의 만약 태그가 비어있다면, XML 처럼 /&gt; 를 이용해 닫아주어야 한다. React에서는 HTML에서 여는 태그만 있는 태그들을 꼭 닫아주는 태그도 써줘야 한다.ex) img, link 1const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;; JSX 태그는 자식을 가질 수 있다. 123456const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;); JSX 인젝션 공격 예방 사용자가 입력한 내용을 JSX 내에 포함시켜도 안전하다. React에 XSS(cross-site-scripting)공격에 대한 보안 기능이 내장되어 있기 때문이다. 123const title = response.potentiallyMaliciousInput;// This is safe:const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;; 기본적으로, React DOM은 렌더링 되기 전에 JSX 내에 포함된 모든 값을 이스케이프 한다. 따라서 어플리케이션에 명시적으로 작성되지 않은 내용은 절대 삽입할 수 없습니다. 모든 것은 렌더링 되기 전에 문자열로 변환된다.이렇게 하면 XSS (cross-site-scripting) 공격을 막을 수 있다. JSX 객체 표현 사용자의 브라우저는 자바스크립트 코드만 해석할 수 있으므로JSX 코드를 자바스크립트 코드로 컴파일한 후 전달해야 한다. Babel은 JSX를 React.createElement() 호출로 컴파일한다. 아래 두 예제는 동일하다. 1const element = &lt;h1 className=\"greeting\"&gt;Hello, world!&lt;/h1&gt;; 12345const element = React.createElement( \"h1\", &#123; className: \"greeting\" &#125;, \"Hello, world!\"); React.createElement() 는 버그 없는 코드를 작성하는 데S도움을 주는 몇 가지 체크를 하긴 하지만,기본적으로는 아래와 같은 객체를 생성한다. 12345678910111213// Note: this structure is simplifiedconst element = &#123; type: \"h1\", props: &#123; className: \"greeting\", children: \"Hello, world\" &#125;&#125;;S- 이 객체를 \"React\"요소라고 부른다.- React요소는 화면에서 보고자 하는 내용에 대한 설명 내지 서술로 생각할 수 있다.- React는 이 객체를 읽어들이고 이를 사용하여 DOM을 만들어낸 뒤 최신 상태로 유지한다.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"Node.js 철학","slug":"node-js-design-pattern1","date":"2019-02-18T15:01:17.000Z","updated":"2019-04-11T15:21:56.259Z","comments":true,"path":"2019/02/19/node-js-design-pattern1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/19/node-js-design-pattern1/","excerpt":"","text":"1.1 Node.js 철학 본 포스팅은 도서 &lt;Node.js 디자인 패턴&gt;을 공부하며 정리한 내용입니다. 1.1.1 경량 코어 Node.js 코어 자체는 몇 가지 원칙에 근거한 기반을 가지고 있다. 코어를 최소의 기능 세트로 하고,나머지를 사용자의 몫(사용자 영역)으로 해서, 핵심 모듈의 바깥 영역 모듈들을 생태계에 맡기는 것이 이 원칙들 중에 하나이다. -&gt; 장점: 유지 보수 측면에서 편리할 뿐만 아니라전체 생태계의 발전에 긍정적인 문화적 영향을 가져올 수 있다. 1.1.2 경량 모듈 Node.js는 모듈 개념을 프로그램 코드를 구성하는 기본 수단으로 사용한다. 어플리케이션과 패키지라고 하는 재사용 가능한 라이버리를 만들기 위한 조립용 블록 Node.js에서 가장 널리 퍼친 원칙 중 하나 코드 크기 뿐만 아니라 범위적인 면세어도 작은 모듈을 설계하는 것 유닉스 철학에 뿌리를 두는 두 가지 계율 작은 것이 아름답다각 프로그램이 각기 한 가지 역할을 잘 하도록 만든다 작은 모듈이 가지는 장점 재사용성 이해하기 쉽고 사용하기 쉽다. 테스트 및 유지보수가 훨씬 간단하다. 브라우저와 완벽한 공유가 가능하다. 더 작고 집중된 모듈을 사용하면 작은 코드 조각이라도 모두가 공유하거나 재사용할 수 있다. DRY(Don’t Repeat Yourself, 같은 것을 반복하지 말라.)원칙에 대한 새로운 적용이다. 1.1.3 작은 외부 인터페이스 Node.js 모듈은 대개 최소한의 기능을 노출하는 특성이 있다.-&gt; 가장 큰 이점: API의 사용이 보다 명확해지고 잘못된 사용에 덜 노출된다.cf) 대부분의 경우 컴포넌트 사용자는기능을 확장하거나 부가적인 고급 기능의 활용이 필요 없는,매우 제한되고 집중된 기능에만 관심이 있다. Node.js에서 가장 일반적인 패턴 함수나 생성자와 같이 하나의 핵심 기능을 표현하는 동시에,더 많은 고급 기능이나 보조 기능은 노출된 함수나 생성자의 속성이 되도록 하는 것 이를 통해, 사용자는 중요한 내용과 부수적인 내용을 구분할 수 있다. Node.js 모듈의 또 다른 특성 확장 용도보다는 실제 사용하도록 만들어진다는 것이다. 얻는 효과 유스케이스를 줄인다. 구현을 단순화 유지 관리를 용이하게 한다. 가용성을 높인다. 1.1.4 간결함과 실용주의-KISS(Keep It Simple, Stupid)원칙 단순함이야말로 궁극의 정교함이다. 디자인은 구현과 인터페이스 모두에서 단순해야 한다.구현이 인터페이스보다 단순해야 하는 것이 더 중요하다. 단순함은 설계에서 가장 중요한 고려 사항이다. 단순한 설계 &gt; 완벽한 모든 기능을 가진 소프트웨어 이유? 구현하는데 소요되는 노력과 자원을 적게 사용하여 더 빨리 보급할 수 있다. 적응과 유지보수 및 이해가 쉽다. -&gt; 커뮤니티의 기여도를 높이고, 소프트웨어 자체가 성장하고 향상될 수 있도록 한다. 복잡하지 않고 실용적인 접근법(대부분의 경우)이 원칙적이고 완벽한 디자인보다 더 선호된다.","categories":[{"name":"Back-end","slug":"back-end","permalink":"https://JihyeHwang09.github.io/categories/back-end/"},{"name":"Node.js","slug":"back-end/node-js","permalink":"https://JihyeHwang09.github.io/categories/back-end/node-js/"}],"tags":[{"name":"Node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"문자열 심화 & 객체의 기본과 속성","slug":"js-zerocho4","date":"2019-02-18T13:27:34.000Z","updated":"2019-04-11T15:22:16.340Z","comments":true,"path":"2019/02/18/js-zerocho4/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/18/js-zerocho4/","excerpt":"","text":"본 포스팅은&lt;ZeroCho님의 인프런 - 웹 게임 개발 자바스크립트 &gt;강의를 들으면서 정리한 내용임을 알려드립니다. 문자열 심화 - index와 length123456\"함수야놀자\"[2];// \"야\"\"함수야놀자\"[0];//\"함\"\"함수야놀자\"[3];//\"놀\" 123함수야 놀자1 2 3 4 5 &lt;-- 사람0 1 2 3 4 &lt;-- 컴퓨터(자바스크립트) .length를 이용하면, 길이를 쉽게 구할 수 있다.아래의 예시를 보자. 123456let 단어 = \"함수야놀자\";// undefined단어[2];//\"야\"단어.length;//5 객체 객체는 함수, 배열, 그리고 함수도 배열도 아닌 객체로 구성된다. 함수function(){} 배열 함수도 배열도 아닌 객체 숫자 문자 불린(true, false) null undefined 1234ex)동물 사람 원숭이 사람은 동물, 원숭이는 동물이라고 할 수 있지만,사람을 원숭이라고 하거나 원숭이를 사람이라고 할 수 없다. -&gt; 함수는 객체이고, 배열은 객체라고 할 수 있으나객체를 배열이라고 하거나 배열을 객체라고 할 수 없다. 12345678910111213141516let 이름 = \"제로초\";let 키 = \"174\";let 몸무게 = \"68\";let 아이큐 = \"300\";let 통장잔고 = \"0\";이름;// \"제로초\"키;// \"174\"몸무게;// \"68\"아이큐;//\"300\"통장잔고;//\"0\" 123let 이름 = \"네로\";이름;// \"네로\" 이름에 “제로초”와 “네로”를 각각 저장하고 싶은데값이 “제로초”에서 “네로”로 바뀌었다. 만약 객체가 없다면,아래 예제와 같은 식으로 계속해서변수를 무제한으로 만들어야 하는 경우가 생긴다. 123let 이름2 = \"네로\";let 키2 = \"160\";let 몸무게2 = \"54\"; 객체는 값들을 그룹화할 때 쓰면 좋다. 1234567891011121314// 제로초라는 변수에 객체&#123;&#125;를 저장한다.let 제로초 = &#123;&#125;;let 제로초 = &#123; 이름: \"제로초\", 키: 174, 몸무게: 68&#125;;let 네로 = &#123;&#125;;let 네로 = &#123; 이름: \"네로\", 키: 160, 몸무게: 58&#125;; 123456789// 제로초를 호출하면,// 변수 제로초에 저장된 객체의 값을 가져온다.제로초;// &#123;이름: \"제로초\", 키: 174, 몸무게: 68&#125;//네로를 호출하면,// 변수 네로에 저장된 객체의 값을 가져온다.네로;// &#123;이름: \"네로\", 키: 160, 몸무게: 58&#125; 객체의 값 자리에는 모든 값 형태를 넣을 수 있다.함수도 넣을 수 있다. 함수가 들어있는 속성(프로퍼티)를 메서드라고 한다. 123456let 제로초 = &#123; 이름: \"제로초\", 먹다: function 먹다() &#123; console.log(\"냠냠\"); &#125;&#125;; 객체의 형태1234객체 = &#123;속성(프로퍼티): 값,속성(메서드): 함수,&#125;","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"문자열","slug":"문자열","permalink":"https://JihyeHwang09.github.io/tags/문자열/"},{"name":"객체","slug":"객체","permalink":"https://JihyeHwang09.github.io/tags/객체/"}]},{"title":"끝말잇기 구현","slug":"js-zerocho3","date":"2019-02-17T14:19:42.000Z","updated":"2019-04-11T15:22:16.328Z","comments":true,"path":"2019/02/17/js-zerocho3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/17/js-zerocho3/","excerpt":"","text":"본 포스팅은&lt;ZeroCho님의 인프런 - 웹 게임 개발 자바스크립트 &gt;강의를 들으면서 정리한 내용임을 알려드립니다. 끝말잇기 구현 코딩 자체보다는 순서도(알고리즘)가 더 중요하다. 순서도 논리적 사고를 하는 게 중요하다. 손이나 그림판으로 직접 그리면서 연습을 많이 해보자. while문으로 구현123456789101112131415161718// whilelet word = \"제로초초초\";// prompt는 대답을 받아주는 함수// 단어의 길이는 달라질 수 있다. (고정적이지 X)// 단어의 끝자리 인덱스는 항상 단어의 길이 -1이라는 규칙을 이용해서 구할 수 있다.// 전에 입력받은 단어의 마지막 번째 글자와 새로운 단어의 첫 글자가 같은지를 비교한다.while (true) &#123; let answer = prompt(word); if (word[word.length - 1] === answer[0]) &#123; // 맞았을 때 alert(\"딩동댕\"); // 첫 제시어를 저장하는 변수 word에 새로운 단어인 answer를 저장한다. word = answer; &#125; else &#123; // 틀렸을 때 alert(\"땡\"); &#125;&#125; alert, prompt와 console.log는 브라우저가 만들어준 함수이다. for문으로 구현-while문을 for문으로 바꿀 때는처음, 실행, 끝을 판단해야 한다. 12345// while문while (조건) &#123; 실행; 끝;&#125; 1234// for문for (처음; 조건; 끝) &#123; 실행;&#125; cf) while문의 조건을 true, false로바꿀 수 있는 것이 끝 부분이 된다. 123456789101112// 끝은 없으면 비워두면 된다.for (let word = \"제로초초초\"; true; ) &#123; let answer = prompt(word); if (word[word.length - 1] === answer[0]) &#123; // 맞았을 때 alert(\"딩동댕\"); word = answer; &#125; else &#123; // 틀렸을 때 alert(\"땡\"); &#125;&#125;","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"React 1일차","slug":"react1","date":"2019-02-15T16:08:36.000Z","updated":"2019-04-11T15:22:16.384Z","comments":true,"path":"2019/02/16/react1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/16/react1/","excerpt":"","text":"React공부 방법에 대한 tip 한글 번역판보다는 영문판이 최신 버전이므로영문판으로 공부하면 가장 최신 버전의 React를 접할 수 있다. 개요React가 무엇인가요? React는 선언적이고, 효율적이며, 유연한 JavaScript 라이브러리이다. 명령형 프로그래밍 ex) Dom API처럼 일일히 속성을 지정해서 값을 넣으라고 명령하는 것 코드를 실행하지 않고 결과를 알아보려면 어렵다. 선언적 프로그래밍 HTML은 이렇게 코드 짰으니까 네가 알아서 그려줘. 순서를 지정해줄 필요 X 코드가 생긴대로 결과물이 나온다는 특징이 있다. 코드가 결과물의 특징을 잘 반영하고 있다는 특징이 있다. -&gt; React는 선언적 프로그래밍이 가능하다. React는 효율적이다. React는 UI를 값으로 다룬다는 특징이 있다. React를 사용하면, “컴포넌트”라 불리는 여러 격리된 코드 조각을 조합해서, 복잡한 UI를 쉽게 만들 수 있다. React의 컴포넌트에는 두 가지 종류가 있다. 일단은 React.Component의 서브클래스부터 보자.: 컴포넌트는 클래스이다. 컴포넌트는 UI를 그려주는 render메소드는 가지고 있다. 1234567891011121314151617181920212223class ShoppingList extends React.Component &#123; //rendor()는 메소드 render() &#123; // UI를 나타내는 값을 만들어준 다음 return해준다. return ( // HTML코드처럼 생겼지만, HTML이 아니다. // 뷰를 만들어내는 특별한 표현식이다. // &lt;div&gt;으로 감싸져 있는 코드는 React div엘리먼트라고 부른다. // 각각의 요소들은 객체로 되어 있다. // 문서 사이에 어떤 컨텐츠를 표시하고 싶다. JSX 안에는 &#123;&#125;를 쓴 다음 그 안에 값을 넣어주면, 그 값이 화면에 그려지게 된다. &lt;div className=\"shopping-list\"&gt; &lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Instagram&lt;/li&gt; &lt;li&gt;WhatsApp&lt;/li&gt; &lt;li&gt;Oculus&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;// 사용 예제: &lt;ShoppingList name=\"Mark\" /&gt; XML과 비슷하게 생긴 위 태그의 사용법을 곧 살펴볼 것이다.우리는 화면을 어떻게 그릴지를 React에게 알려주기 위해 컴포넌트를 사용한다.데이터가 변경되면, React는 컴포넌트를 효율적으로 갱신한다.(즉, 다시 그린다.) 위에서 본 ShoppingList는 React 컴포넌트 클래스이다.컴포넌트는 props (“properties”의 줄임말)이라 불리는 매개변수를 받아서,render 메소드에서 뷰의 계층 구조를 반환한다.(화면을 어떻게 그릴 지에 대한 계층 구조를 반환한다.) cf) 어떻게 그릴 건지를 설명하는 값을 ‘뷰’라고 한다. render 메소드는 무엇을 그릴지에 대한 설명을 반환한다.그러면 React는 그것을 받아 화면에 그려준다.여기서 render가 반환하는 것은 React 엘리먼트로, ‘무엇을 그릴지’에 대한 정보를 담고있는 객체이다.대부분의 React 개발자들은 이러한 구조를 쉽게 표현할 수 있는 JSX라는 특별한 문법을 사용한다.(JavaScript Extended) 라는 JSX 코드는, 빌드 과정에서 React.createElement(‘div’)로 변환된다.위 예제는 사실 아래 코드와 같다: 123456return React.createElement( \"div\", &#123; className: \"shopping-list\" &#125;, React.createElement(\"h1\" /* ... h1 children ... */), React.createElement(\"ul\" /* ... ul children ... */)); 좀 더 알고싶으시다면, API reference에서 createElement()에 대한 자세한 설명을 읽어보자.하지만 이 튜토리얼에서는 이 함수를 직접 사용하지 않을 것이다. 대신, 우리는 JSX를 계속 사용해보자. JSX 안에서는 JavaScript를 자유롭게 활용할 수 있다.JSX 중괄호 안에는 어떤 JavaScript 표현식도 넣을 수 있다.그리고 React 엘리먼트는 JavaScript 객체로, 변수에 담거나 프로그램의 다른 부분으로 넘기는 것이 가능하다. 위 예제의 ShoppingList 컴포넌트는 브라우저에 내장된 DOM 컴포넌트(&lt;div /&gt;, &lt;li /&gt;)만 그려주고 있다.하지만 React 컴포넌트를 조합해서 그리는 것도 가능하다.예를 들어, 우리는 전체 쇼핑 목록을 그리기 위해 와 같이 쓸 수 있다.각각의 React 컴포넌트는 독립적이며 캡슐화되어 있다.이 성질은 우리가 단순한 컴포넌트로부터 복잡한 UI를 만드는 일을 가능하게 해준다. 컴포넌트를 태그 이름처럼 사용할 수 있다. React에서 컴포넌트를 사용하면 큰 HTML을 조각으로 나눠서 &lt;ProductList /&gt;로 사용하면 코드 수를 줄일 수 있다. 2교시 정보가 폭포수처럼 위에서 아래로 흐른다. 이벤트 리스너 다는 방법: onClick, onChange, onSubmit, onMouseMove 등에 함수를 넘겨줘야 한다. Square Component에 alert(this.props.value)를 사용하면, 현재 넘어온 칸에 있는 숫자가 뜬다. Board Component의 name=”Square”을 넣고,Square Component에 alert(this.props.name)를 사용하면, alert으로 “Square”라고 뜬다. JavaScript 클래스를 사용할 때,서브클래스의 생성자를 정의할 때는 반드시 super를 호출해주어야 한다. 생성자를 갖는 모든 React 컴포넌트 클래스는 그 생성자가 반드시 super(props)로 시작해야 한다. Constructor(생성자) 만들 때는 React Component를 생성할 때는 super(props)는 반드시 맨 위에 있어야 한다. super를 맨 윗줄에 안 써주면, 에러가 발생한다. super(props); 어떤 부모 생성자의 코드를 호출하는 것 this.props.value : 부모로부터 내려받은 값this.state.value: 내가 기억하고 있는 값 onClick={() =&gt; this.setState({value: ‘X’})}클릭했을 때, 기억하고 있는 값을 ‘X’를 바꿔준다.setState({})로 {}안의 상태를 바꿔준다. React의 가장 핵심적인 부분 React를 사용하면서, 반드시 setState라는 메소드를 통해서 상태를 변경해야 한다!-&gt; 그래야 상태가 변경될 때마다 화면이 갱신될 수 있다. this.setState의 기능 2가지- 상태 변경 - 화면 갱신 React에서는 상태를 바꾸면, 무조건 화면이 갱신된다. React에서 화면을 다시 그리는 방법이 setState밖에 없다.(상태를 변경해주면 자동으로 화면 갱신하게 만듦) render라는 메소드는 React 라이브러리가 알아서 호출해줌. (개발자가 render메소드를 호출할 일이 없음) setState할 때마다 React 라이브러리가 render메소드를 실행해서 화면이 바뀔 게 있는지 확인한다. 화면을 다시 그려야할 때마다 render메소드가 매번 호출된다. 12345678910111213141516class Square extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: null &#125;; &#125; render() &#123; return ( &lt;button className=\"square\" onClick=&#123;() =&gt; this.setState(&#123; value: \"X\" &#125;)&#125;&gt; &#123;this.state.value&#125; &lt;/button&gt; ); &#125;&#125; Square의 render 메소드 안에 있는 onClick 핸들러 안에서 this.setState를 호출하면,&lt;button&gt;이 클릭될 때마다 화면을 다시 그려야 한다는 사실을 React에게 알려줄 수 있다. 그 뒤, this.state.value는 ‘X’가 될 것이고, 이로 인해 게임판에 X가 표시된다.이제 사각형을 클릭해서, X가 표시되는지 확인해보자. 컴포넌트 안에서 setState를 호출하면, React는 해당 컴포넌트가 품고 있는 자식 컴포넌트까지 모두 새로 그려준다.-&gt; 부모 컴포넌트의 상태가 바뀌면, 자식 컴포넌트가 각각 가지고 render메소드가 다 호출된다. 게임 완성하기상태 끌어올리기 Square Component가 9개 있고, 각각이 상태를 가지고 있다. prop을 통해서 부모 컴포넌트에서 자식 컴포넌트로 상태를 보내는 건 쉽다. 자식 컴포넌트의 상태를 부모 컴포넌트로 끌어 올린다. 상태를 가장 가까운 공통 조상에 저장한다. -&gt; 상태 끌어올리기 여러 자식 컴포넌트에 저장되어 있는 데이터를 읽어와야 할 때,혹은 자식 컴포넌트끼리 통신을 해야 할 필요가 있을 때는부모 컴포넌트에서 상태를 공유하자.부모 컴포넌트에서는 prop을 통해 자식 컴포넌트에게 상태를 내려줄 수 있다.이 방법을 통해 부모 컴포넌트와 자식 컴포넌트가 따로 놀지 않게 만들 수 있다. 상태의 불일치 문제를 피하기 위해서 상태는 하나로 두는 게 좋다. 이제 사각형을 클릭했을 때의 처리를 해주어야 한다.Board 컴포넌트가 게임 상태를 저장하고 있으므로, Square 컴포넌트에서 Board 컴포넌트의 상태를 변경할 방법이 필요하다.컴포넌트의 상태에는 자기 자신만 접근할 수 있으므로,Square 컴포넌트에서 Board 컴포넌트의 상태를 직접 변경할 수 있는 방법은 없다. 이런 경우, 부모 컴포넌트인 Board에서 상태를 바꾸는 함수를 만들어 Square에 내려줌으로써 문제를 해결할 수 있다.이 함수를 Square가 클릭되는 순간 호출해주자.일단 Board 컴포넌트의 renderSquare 메소드를 고쳐보자. (참고: 아래 코드는 아직 동작하지 않습니다.) 부모 컴포넌트의 상태를 직접적으로 바꿀 수 있는 방법은 없다. But 부모 컴포넌트에서 상태를 바꿀 수 있는 함수를 자식 컴포넌트에게 내려준다면, -&gt; 부모 컴포넌트의 상태를 간접적으로 바꿀 수 있다. 부모 컴포넌트에서 각각의 값과 상태를 바꿀 수 있는 함수를 자식 컴포넌트에게 내려줘야 한다. renderSquare함수는 Board 컴포넌트 안에 있는 함수이다. props는 부모로부터 내려주는 함수 button도 컴포넌트. 내장 Dom 컴포넌트라고 부른다. Square, board 등은 사용자 정의 컴포넌트(Custom Component)라고 부른다. setState하면, render 메소드를 실행시킨다. -&gt; 그래서 화면이 다시 그려진다. cf) 제어되는 컴포넌트(Controlled Component): 자기 스스로의 상태를 갖고 있는 컴포넌트 제어되지 않는 컴포넌트: 자기 스스로의 상태를 갖고 있지 않은 컴포넌트 컴포넌트를 사용하는 방법 2가지 클래스로 사용하는 방법 함수로 사용하는 방법 클래스 컴포넌트: class가 부모로부터 내려 받은 값은 this.props에 저장된다. 함수형 컴포넌트: props라는 매개변수에 객체가 들어온다. props객체의 속성에 부모로부터 내려받은 값이 저장되어 있다. render 메소드를 쓰지 않는다. 턴 넘기기Declaring a Winner return만을 이용해서 함수를 종료시키는 기법이 많이 사용된다. 오늘 배운 내용 정리 하나의 컴포넌트로부터 수많은 엘리먼트가 만들어질 수 있다. 컴포넌트와 엘리먼트는 React 엘리먼트는 Dom 객체가 아니다. React 객체는 Dom 객체와 전혀 상관이 없다. ex) React 엘리먼트에 .textContent해서 값을 집어넣고 싶어서 아무 반응이 없다. props는 부모로부터 값을 내려받는 통로이다. 직접 자식 컴포넌트에서 부모 컴포넌트에게 값을 넘겨줄 수 없다. addEventListener를 쓸 필요가 없다. 컴포넌트는 상태를 가질 수 있고, 꼭 setStatus를 통해서만 바꿔야 한다는 약속이 있다. 상태를 처음 만들어줄 때는 생성자 안에서 만들어주는 게 원칙이다. 1234567class Square extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: null, &#125;; &#125; setStatus는 상태 변경, 화면 갱신이라는 2가지 효과가 있다. 부모 컴포넌트에서 상태를 공유하세요. 부모 컴포넌트에서는 prop을 통해 자식 컴포넌트에게 상태를 내려줄 수 있다.이 방법을 통해 부모 컴포넌트와 자식 컴포넌트가 따로 놀지 않게 만들 수 있다. 부모 컴포넌트는 상태를 바꾸는 함수를 만들어서 자식 컴포넌트에게 내려준다. 이 함수를 이용해서 자식 컴포넌트에서 부모 컴포넌트의 상태를 간접적으로 바꿔줄 수 있다.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"React","slug":"front-end/react","permalink":"https://JihyeHwang09.github.io/categories/front-end/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://JihyeHwang09.github.io/tags/react/"}]},{"title":"2019 상반기 공채 대비 코딩테스트 실전 모의고사 2회","slug":"programmers-second-mock-exam1","date":"2019-02-15T14:45:52.000Z","updated":"2019-02-15T15:03:19.447Z","comments":true,"path":"2019/02/15/programmers-second-mock-exam1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/15/programmers-second-mock-exam1/","excerpt":"","text":"2019 상반기 공채 대비 코딩테스트 실전 모의고사 2회 참고 사이트 빅오표기법 1. 배열 회전 배열의 회전이란 모든 원소를 오른쪽으로 한 칸씩 이동시키고,마지막 원소는 배열의 맨 앞에 넣는 것을 말합니다. 두 배열 arrA와 arrB가 매개변수로 주어질 때,arrA를 회전해 arrB로 만들 수 있으면 true를그렇지 않으면 false를 return 하는 solution 함수를 작성해주세요. 반복문을 사용할 수 있는지 물어보는 문제 아주 기초적인 문제이니 어렵지 않게 풀 수 있었을거에요. Python 코드1234567891011121314151617181920212223# def는 함수 정의# rotate는 함수 이름def rotate(arr): return arr[-1:] + arr[:-1]# python array modules# slice notation(:)# solution이라는 이름을 가진 함수를 정의def solution(arrA, arrB): arrA_len = len(arrA) arrB_len = len(arrB) # 길이가 다른 배열은 회전해도 같아질 수 없으므로, early return if(arrA_len!=arrB_len): return False # arrA를 한칸씩 회전하며, arrB와 같은지 확인 for _ in range(arrA_len): if arrA == arrB: return True arrA = rotate(arrA) return False Python 관련 내 해석12345678# def는 함수 정의# rotate는 함수 이름def rotate(arr): return arr[-1:] + arr[:-1]# python array modules# slice notation(:)# arr[-1:]배열의 끝부터 첫번째까지의 item# arr[-1:]배열의 처음부터 끝까지의 item 12def 함수이름(): # 1. 첫 행 본문 # 2. 함수를 호출했을 때 실행할 코드 블록 파이썬에서는끝에서부터 index를 매길때는 음수를 사용한다. 123456789ex) word = 'Python'word[-1]# last chracter# 출력값 'n'word[-6]# sixth-last character# 출력값 'P' Pytoh에서의 slicestep을 명시하지 않을 경우start:stop[:step] 여기서 [:step]은 써도 되고 안써도 된다. a[start:end] # start부터 end-1까지의 item a[start:] # start부터 리스트 끝까지 item a[:end] # 처음부터 end-1까지의 item a[:] # 리스트의 모든 item step을 명시하는 경우 a[start:end:step]# start부터 end-1까지 step만큼 인덱스 증가시키면서step을 지정할 때 :end에 유의하세요 end는 end부터 포함시키지 않겠다는 의미이지 end가 꼭 포함된다는 의미는 아닙니다. 또 start나 end가 음수가 음수인 경우에는 리스트의 끝에서부터 카운트하겠다는 의미입니다. a[-1] # 맨 뒤의 item a[-2:] # 맨 뒤에서부터 item2개 a[:-n] # 맨 뒤의 item n개 빼고 전부 예제를 보여드릴게요 123456789a = [10,11,12,13,14,15,16,17,18,19]print \"a =\", aprint \"a[0:1]:\", a[0:1]print \"a[0:1]:\", a[0:10]print \"a[0:1]:\", a[0:20]print \"a[0:1]:\", a[0:10:2]print \"a[0:1]:\", a[:-2]print \"a[0:1]:\", a[:-30] 의 결과는 12345678a = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]a[0:1]: [10]a[0:1]: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]a[0:1]: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]a[0:1]: [10, 12, 14, 16, 18]a[0:1]: [10, 11, 12, 13, 14, 15, 16, 17]a[0:1]: []입니다. 1234a[start:end] # start부터 end-1까지의 itema[start:] # start부터 리스트 끝까지 itema[:end] # 처음부터 end-1까지의 itema[:] # 리스트의 모든 item 즉, rotate라는 함수는 arr를 받아서 배열의 끝부터 맨앞까지 검사하는 함수이다. Python -&gt; JavaScript로 바꾸기참고 김승하 선생님 교재 JAVASCRIPT로 만나는 세상- 배열 MDN Array.prototype.slice() 123456789101112131415161718192021222324252627282930const rotate(arr) &#123; // 배열로부터 새로운 값 생성// * slice 메소드// 배열의 일부분에 해당하는 새로운 배열을 반환한다.// 원본 배열에 아무런 영향을 미치지 않는다.// 얕은 복사(shallow copy)를 하므로,// 배열 안에 배열 또는 객체가 들어있을 때는 주의해서 사용해야 한다.// 1. 인덱스 arr의 마지막 번째부터 arr의 맨 앞까지의 요소들을 가지고 새로운 배열을 생성한다.// 2. return arr.slice(-1, 0);&#125;// # solution이라는 이름을 가진 함수를 정의def solution(arrA, arrB): arrA_len = len(arrA) arrB_len = len(arrB) // # 길이가 다른 배열은 회전해도 같아질 수 없으므로, early return if(arrA_len!=arrB_len): return False // # arrA를 한칸씩 회전하며, arrB와 같은지 확인 for _ in range(arrA_len): if arrA == arrB: return True arrA = rotate(arrA) return False 12345678def rotate(arr):return arr[-1:] + arr[:-1]def solution(arrA, arrB):# len()은 리스트에 들어있는 원소 개수# -&gt; 즉, 리스트의 크기를 알려주는 함수arrA_len = len(arrA)arrB_len = len(arrB) 12345678910111213141516171819202122232425262728const rotate(arr)&#123;return arr.slice(-1, 0) +arr(0, -1);&#125;const solution(arrA, arrB)&#123;let arrA_len = arrA.length;let arrB_len = arrB.length;// 첫 번째 base case// 배열의 길이가 다르면, 회전해도 같아질 수 없으므로// return하고 함수를 종료한다.if (arrA_len !== arrB_len) &#123;return false;&#125;// 두 번째 base case// arrA를 한칸씩 회전하면서, arrB와 같은지를 확인한다. // for _ in range(arrA_len): // if arrA == arrB: // return True // arrA = rotate(arrA) // return False for (let i = 0; i &lt; arrA_len; i++)&#123; if (arrA == arrB)&#123; return true; &#125; arrA = rotate(arrA); &#125; return false;&#125;","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://JihyeHwang09.github.io/tags/알고리즘/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"https://JihyeHwang09.github.io/tags/프로그래머스/"},{"name":"코딩테스트","slug":"코딩테스트","permalink":"https://JihyeHwang09.github.io/tags/코딩테스트/"}]},{"title":"반복문(while, for)","slug":"js-zerocho2","date":"2019-02-14T10:30:22.000Z","updated":"2019-04-11T15:22:16.297Z","comments":true,"path":"2019/02/14/js-zerocho2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/14/js-zerocho2/","excerpt":"","text":"본 포스팅은&lt;ZeroCho님의 인프런 - 웹 게임 개발 자바스크립트 &gt;강의를 들으면서 정리한 내용임을 알려드립니다. 반복문while문먼저, while문의 형태를 보자. 12345처음;while (조건) &#123; 실행; 끝;&#125; 1234let 변수 = \"딸기\";while (\"딸기\" === 변수) &#123; console.log(\"딸기 좋아\");&#125; while문의 조건이 true이기 때문에무한반복 된다. 이렇게 무한 반복이 될 경우, 컴퓨터가 먹통이 된다. 그렇다면, 무한 반복이 되는 이 while문을어떻게 프로그래밍에서 사용할 수 있을까?아래의 예문을 보자. 12345let 변수 = 0;while (변수 &lt; 5) &#123; console.log(\"딸기 좋아\"); 조건 = 조건 + 10;&#125; 앞의 예문에서와 같이 while문을 사용하는 예제이다.변수는 변할 수 있는 값을 말하므로 이 변수 값을 바꿔서조건인 (변수 &lt; 5)를 false로 만들 수 있다.변수 값을 바꾸는 방법을 여러 가지가 있는데, 1조건 = 조건 + 10; 이 예제에서는 조건 = 조건 + 10;을 주어while문이 무한반복하지 않도록 만들었다. 반복문의 실행 순서에 대해 알아보자. 1234567let 조건 = 0; // 1while (조건 &lt; 5) &#123; //2 5 console.log(\"딸기 좋아\"); // 3 조건 = 조건 + 10; //4&#125;(\"과일 좋아\"); // 6 자바스크립트 코드의 흐름은 가장 윗 줄부터 차례대로 실행된다.반복문을 만나면, 반복문의 조건이 false가 될 때까지 반복한 후, 빠져나온다.그 후 아래에 있는 코드가 실행된다.반복문의 조건을 검사하여 false가 되는지 검사를 하고,반복문을 빠져나가는 것이다. 1234567let 조건 = 0; // 1while (조건 &lt; 5) &#123; //2 5 8 console.log(\"딸기 좋아\"); // 3 6 조건 = 조건 + 3; //4 7&#125;(\"과일 좋아\"); // 9 변수인 조건의 값이 0부터 시작해서,while문 안의 코드를 반복하다가조건의 값이 6이 되어 5보다 커지므로 그 때 반복문을 빠져나와반복문 바깥, 아래에 있는 “과일 좋아”라는 코드가 실행된다. 반복문을 조건문으로 바꿔보면, 그 실행 흐름을쉽게 이해할 수 있다.아래 예제를 보자. 12345678910111213141516171819let 조건 = 0; // 1if (조건 &lt; 5) &#123; // 2 console.log(\"딸기 좋아\"); // 3 조건 = 조건 + 3; //4 조건:3&#125;if (조건 &lt; 5) &#123; //5 console.log(\"딸기 좋아\"); // 6 조건 = 조건 + 3; // 7 조건: 6&#125;if (조건 &lt; 5) &#123; // 8 // 조건이 6이므로 false가 되어 반복문 빠져나옴 //8 console.log(\"딸기 좋아\"); 조건 = 조건 + 3;&#125;(\"과일 좋아\"); // 9 이렇게 조건문을 쭉 나열한 것을 줄여서 while문이 된 것이다. for문for문의 형태를 보자. 123for (처음; 조건; 끝) &#123; 실행;&#125; for문은 while문보다 코드가 짧다.그만큼 압축되어 들어있다는 것을 의미한다.while문을 for문으로, for문을 while문으로 바꿀 수 있다.while문과 for문을 비교해보자. 12345678// while문let 조건 = 0; // 1while (조건 &lt; 5) &#123; //2 5 8 console.log(\"딸기 좋아\"); // 3 6 조건 = 조건 + 3; // 4 7 조건:3&#125;(\"과일 좋아\"); // 9 12345// for문for (let 조건 = 0; 조건 &lt; 5; 조건 = 조건 + 3) &#123; console.log(\"딸기 좋아\");&#125;(\"과일 좋아\");","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 기초","slug":"js-zerocho1","date":"2019-02-13T09:48:34.000Z","updated":"2019-04-11T15:22:16.289Z","comments":true,"path":"2019/02/13/js-zerocho1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/13/js-zerocho1/","excerpt":"","text":"본 포스팅은&lt;ZeroCho님의 인프런 - 웹 게임 개발 자바스크립트 &gt;강의를 들으면서 정리한 내용임을 알려드립니다. &quot;REPL&quot;: READ EVALUATE PRINT LOOP 연산자 우선순위 대입연산자인 =이 제일 마지막에 실행된다. 소괄호()를 쓰면 연산자 우선순위를 바꿀 수 있다.(수학처럼) 함수1y = f(x) x**2 + x + 5 123function (x, z) &#123; return x + z + 5;&#125; ()부분이 입력값,return 부분이 출력값이라고 생각해도 된다. 123454 + 7 + 3 + 5; // 198 + 1 + 3 + 5; // 1710 + 3 + 3 + 5; // 2113 + 4 + 3 + 5; // 2512 + 4 + 3 + 5; // 24 바뀌는 부분만 첫째, 둘째로 넣고,나머지 공통되는 부분인 +3 + 5를 써넣는다. 123function 더하기(첫째, 둘째) &#123; return 첫째 + 둘째 + 3 + 5;&#125; 1234567891011console.log(\"안녕하세요\");console.log(\"제로초님\");console.log(\"반가워요\");console.log(\"안녕하세요\");console.log(\"김성수님\");console.log(\"반가워요\");console.log(\"안녕하세요\");console.log(\"진호인님\");console.log(\"반가워요\"); 이름 부분만 바뀌고 있다. 불필요하게 코드를 반복하고 있다. 반복되는 부분을 함수로 만들자. 12345function 인사(이름) &#123; console.log(\"안녕하세요\"); console.log(이름 + \"님\"); console.log(\"반가워요\");&#125; 이제 위 함수를 이용하여 처음에 총 9줄로 작성했던 코드를 3줄로 줄일 수 있다. 123456789101112인사(\"제로초\");// 안녕하세요// 제로초님// 반가워요인사(\"김성수\");// 안녕하세요// 김성수님// 반가워요인사(\"진호인\");// 안녕하세요// 진호인님// 반가워요 123함 수 야 놀 자1 2 3 4 5 &lt;-- 사람0 1 2 3 4 &lt;-- 컴퓨터(자바스크립트) 사람은 보통 1부터 세고,자바스크립트에서는 0부터 센다.cf) 파이썬같은 언어는 0이 아닌 1부터 센다. 123456\"함수야놀자\"[2];//야\"함수야놀자\"[0];//함\"함수야놀자\"[3];//놀 조건문if else문1234567if (true) &#123; (\"안녕\");&#125; else &#123; (\"잘가\");&#125;// 조건문에 true가 들어있으므로// 무조건 `안녕`이 나옴 12345678let 변수 = false;// 다른 코드// 다른 코드if (변수) &#123; (\"안녕\");&#125; else &#123; (\"잘가\");&#125; 시한 폭탄을 if ~ else문으로 짠다고 생각해보자. 12345678910111213let 변수 = \"펑\";변수 = \"암호\";if (변수 === \"펑\") &#123; (\"펑펑\");&#125; else &#123; (\"해제되었습니다.\");&#125;// 변수 값이 \"펑\"일 때는 \"펑펑\"이 나오지만,// 변수에 \"암호\"라는 값이 대입되었기 때문에// 실행흐름이 바뀌어서// \"해제되었습니다.\"가 나온다. else if문을 이용한 예시1234567891011let 변수 = \"사과\";if (변수 === \"사과\") &#123; (\"사과 좋아\");&#125; else if (변수 === \"오렌지\") &#123; (\"오렌지 좋아\");&#125; else if (변수 === \"딸기\") &#123; (\"딸기 좋아\");&#125; else &#123; (\"과일 싫어\");&#125; 자바스크립트는 코드가 위에서부터 한 줄씩 읽어 내려간다. if를 보는 순간, 우리 앞에는 4가지의 갈림길이 생긴 것이다. 이 4가지 조건 중에 하나가 실행된다. 이 4가지 조건들은 첫 번째 조건부터 차례대로 검사한다. if ~ else if ~ else문은코드에 갈림길을 제공한다고 생각하면 쉽다. 조건문에서 else if(){}와 else {}는 써도 되고 안 써도 된다. if만 써도 된다.(조건문을 쓰고자 한다면 if는 필수로 써야 함)cf) switch문도 참고","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"전송 오류 제어 방식","slug":"data-communication6","date":"2019-02-12T12:59:23.000Z","updated":"2019-02-12T13:14:39.065Z","comments":true,"path":"2019/02/12/data-communication6/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/12/data-communication6/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 전송 오류 제어 방식에 대해 알아봅시다.전송 오류 제어 방식전진(순방향) 오류 수정(FEC) 재전송 요구 없이 수신 측에서 스스로 오류 검출과수정을 하는 방식 역채널이 필요 없고, 연속적인 데이터 흐름이 가능함 데이터 비트 이외에 오류 검출 및 수정을 위한 비트(잉여 비트)들이 추가로 전송되어야 하기 때문에 전송 효율이 떨어짐 해밍 코드, 상승 코드 방식이 있음 후진(역방향) 오류 수정(BEC) 데이터 전송 과정에서 오류가 발생하면송신 측에 재전송을 요구하는 방식 패리티 검사, CRC, 블록 합 방식 등을 사용하여오류를 검출하고, 오류 제어는 자동 반복 요청(ARQ)에 의해이루어짐 순방향 에러 수정(Forward Error Correction) 방식에 사용되는 검사 방식에는 (해밍 코드), (상승 코드)가 있다. 송신 측에서 정보 비트에 오류 정정을 위한제어 비트를 추가하여 전송하면 수신 측에서 이 비트를 사용하여에러를 검출하고 수정하는 방식은 (전진(순방향) 오류 수정(FEC))이다. 전진에러수정(FEC) 코드는 역채널을 사용한다.(X) 1234[해설]3. 전진 오류 수정(FEC)은 데이터 전송 과정에서 발생한 오류를검출하여 오류를 재전송 오류 없이 스스로 수정하는 방식 입니다.즉 재전송 요구가 없기 때문에 역 채널이 필요 없습니다. 전진 오류 정정(FEC) 방식은 데이터 전송 과정에서 오류가발생하면 송신 측에 재전송을 요구하는 방식이다. (X) 12345[해설]4. 전진(순방향) 오류 정정(FEC) 방식은송신 측에 재전송을 요구하지 않습니다.송신 측에 재전송을 요구하는 방식은후진(역방향) 오류 수정 방식입니다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"전송 오류 제어 방식","slug":"전송-오류-제어-방식","permalink":"https://JihyeHwang09.github.io/tags/전송-오류-제어-방식/"}]},{"title":"HDLC의 프레임 및 데이터 전송 모드","slug":"data-communication5","date":"2019-02-11T13:50:04.000Z","updated":"2019-02-11T14:16:27.231Z","comments":true,"path":"2019/02/11/data-communication5/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/11/data-communication5/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 HDLC의 프레임 및 데이터 전송 모드에 대해 알아봅시다. 본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. HDLC의 프레임 종류정보(I) 프레임(Information Frame) 제어부가 &#39;0&#39;으로 시작하는 프레임 사용자 데이터를 전달하거나 피기백킹(Piggybacking) 기법을 통해데이터에 대한 확인 응답을 보낼 때 사용 감동(S) 프레임(Supervisor Frame) 제어부가 &#39;10&#39;으로 시작하는 프레임 오류 제어와 흐름 제어를 위해 사용 비번호(U) 프레임(Unnumbered Frame) 제어부가 &#39;11&#39;로 시작하는 프레임 링크의 동작 모드 설정과 관리, 오류 회복을 수행함 HDLC의 데이터 전송 모드: 데이터 전송 모드는 제어부에서 관리하는 U프레임에 의해 설정 표준(정규) 응답 모드(NRM) 반이중 통신을 하는 포인트 투 포인트 또는 멀티 포인트불균형 링크 구성에 사용 종국은 주국의 허가(Poll)이 있을 때에만 송신 비동기 응답 모드(ARM) 전이중 통신을 하는 포인트 투 포인트 불균형 링크 구성에 사용 종국은 주국의 허가(Poll) 없이도 송신이 가능하지만,링크 설정이나 오류 복구 등의 제어기능은 주국만 함 비동기 균형(평형) 모드(ABM) 전이중 통신을 하는 포인트 투 포인트 균형 링크에서 사용 혼합국끼리 허가 없이 언제나 전송할 수 있도록 설정 다음 전송 모드 중 HDLC에서 사용되지 않는 것은(b. 동기 응답 모드(SRM))이다. 1234a. 정규 응답 모드(NRM)b. 동기 응답 모드(SRM)c. 비동기 응답 모드(ARM)d. 비동기 평형 모드(ABM) 다음 설명에 알맞은 프레임을 고르시오. 1234a. 감독(Supervisor) 프레임b. 조정(Controll) 프레임c. 정보(Information) 프레임d. 비번호(Unnumbered) 프레임 1) 보기 중 HDLC에서 사용하는 프레임이 아닌 것은 `(b. 조정(Controll) 프레임)`이다. 2) 흐름 제어나 에러 제어를 위해 사용되는 프레임은 `(a. 감독(Supervisor) 프레임)`이다. 3) 사용자 데이터 전달을 위해 사용되는 프레임은 `(c. 정보(Information) 프레임)`이다. 4) 링크의 설정과 해제, 오류 회복을 위해 주로 사용되는 프레임은 `(d. 비번호(Unnumbered) 프레임)`이다. 5) 피기백킹(Piggybacking) 기법을 통해 데이터에 대한 확인 응답을 보낼 때 사용되는 프레임은 `(c. 정보(Information) 프레임)`이다. HDLC의 동작 모드 중 전이중 전송의 점대점 균형 링크 구성에 사용되는 것은 (비동기 균형(평형) 모드(ABM))이다. HDLC(High-level Data Link Control)의 세 가지 동작 모드 중 다음 설명에 해당하는 것은 (표준(정규) 응답 모드(NRM))이다. 123- 이 모드는 점대점이나 멀티포인트 불균형 링크 구성에 사용된다.- 주 스테이션이 링크 제어를 담당하며,부 스테이션은 주 스테이션으로부터 폴 메시지를 수신한 경우에만 데이터를 전송할 수 있다. (피기백킹(Piggybacking))은 수신측이 별도의 ACK를 보내지 않고 상대편으로 향하는 데이터 전문을 이용하여 응답하는 것이다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"HDLC","slug":"hdlc","permalink":"https://JihyeHwang09.github.io/tags/hdlc/"},{"name":"High-level Data LInk Control","slug":"high-level-data-link-control","permalink":"https://JihyeHwang09.github.io/tags/high-level-data-link-control/"},{"name":"데이터 전송 모드","slug":"데이터-전송-모드","permalink":"https://JihyeHwang09.github.io/tags/데이터-전송-모드/"}]},{"title":"전송 제어의 기본","slug":"data-communication4","date":"2019-02-10T00:28:40.000Z","updated":"2019-02-11T14:07:35.667Z","comments":true,"path":"2019/02/10/data-communication4/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/10/data-communication4/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 전송 제어의 기본과 HDLC(High-level Data Link Control)의 특징에 대해 알아봅시다. 본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. 전송 제어의 기본1. 전송 제어 데이터의 원활한 흐름을 위하여 입.출력 제어, 회선 제어, 동기 제어, 오류 제어, 흐름 제어 등을 수행하는 것 OSI 7 참조 모델의 데이터 링크 계층(2계층)에서 수행하는 기능이다. 2. 전송 제어 절차데이터 통신 회선의 접속 -&gt; 데이터 링크 설정(확립)-&gt; 정보 메시지 전송 -&gt; 데이터 링크 종결 -&gt; 데이터 통신 회선의 절단 다음은 전송 제어 절차를 순서 없이 나열한 것이다.알맞은 답을 고르시오.(1~2번) 12345a. 통신 회선 접속b. 정보 전송c. 데이터 링크 해제d. 데이터 링크 확립e. 통신 회선 절단 전송 제어 절차를 순서에 맞게 나열하시오.(a -&gt; d -&gt; b -&gt; c -&gt; e) 접속된 통신 회선 상에서 송신 측과 수신 측 간의 확실한 데이터 전송을 수행하기 위해논리적 경로를 구성하는 단계는 (d)이다. HDLC(High-level Data LInk Control)의 특징 비트(Bit) 위주의 프로토콜로, 각 프레임에 데이터의 흐름을 제어하고오류를 검출할 수 잇는 비트 열을 삽입하여 전송한다. 포인트 투 포인트 및 멀티 포인트, 루프 방식에서 모두 사용 가능하다. 단방향, 반이중, 전이중 통신을 모두 지원하며,동기식 전송 방식을 사용한다. 오류 제어를 위해 Go-Back-N과 선택적 재전송(Selective Repeat) ARQ를 사용한다. 흐름 제어를 위해 슬라이딩 윈도우 방식을 사용한다. 전송 제어상의 제한을 받지 않고 자유로이 비트 정보를 전송할 수 있는 것을 비트 투과성(투명성)이라고 한다. 비트 투과성(투명성)을 보장하기 위한 기능으로 비트 스터핑(Bit Stuffing)이 사용된다. 전송 효율과 신뢰성이 높다. HDLC 프레임 구조 HDLC 프레임 구조 - 이미지 출처 HDLC의 프레임 구조를 순서대로 나열하면,(주소부) -&gt; (제어부) -&gt; (정보부) -&gt; FCS -&gt; 플래그 순이 된다. 데이터 링크 프로토콜인 HDLC(High level Data Link Control)에서프레임의 동기를 제공하기 위해 사용되는 것으로항상 ‘01111110’의 형태를 보이는 구성 요소는 (플래그(Flag))이다. 데이터 링크 제어 프로토콜 중 전송 효율과 신뢰성이 높고정보 전송 단위가 프레임인 전송 제어 방식은 (HDLC)이다. 다음 중 HDLC 프로토콜의 특징이 아닌 것을 모두 고르시오.(c, e, f, g) 1234567a. 점대점 링크 및 멀티포인트 링크를 위한 프로토콜이다.b. 반이중 통신과 전이중 통신을 모두 지원한다.c. 비동기식 전송 방식을 사용한다.d. 슬라이딩 윈도우 방식에 의해 흐름 제어를 제공한다.e. 에러 제어를 위해 Stop-and-Wait 방식을 사용한다.f. 문자 지향형 전송 프로토콜이다.g. FCS 영역의 길이는 64비트이다. 123456[해설]c. HDLC 프로토콜은 동기식 전송 방식을 사용합니다.e. HDLC 프로토콜은 에러 제어를 위해 Go-Back-N ARQ와선택적 재전송 ARQ를 사용합니다.f. HDLC는 비트 지향형 전송 프로토콜 입니다.g. FCS 영역의 길이는 16 비트 또는 32비트 입니다. HDLC에서 비트 스터핑(Bit Stuffing)을 수행하는 목적은데이터의 투명성을 보장하기 위해서이다.(O) HDLC 프레임의 시작과 긑을 정의하는 것은 (플래그)이다. HDLC 프레임 형식 중 프레임의 종류를 식별하기 위해 사용되는 것은(제어부)이다. HDLC 프레임 구성에서 프레임 검사 시퀀스(FCS) 영역의 기능은(전송 오류 검출)이다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"data-communication","slug":"data-communication","permalink":"https://JihyeHwang09.github.io/tags/data-communication/"},{"name":"전송 제어의 기본","slug":"전송-제어의-기본","permalink":"https://JihyeHwang09.github.io/tags/전송-제어의-기본/"},{"name":"HDLC","slug":"hdlc","permalink":"https://JihyeHwang09.github.io/tags/hdlc/"},{"name":"High-level Data Link Control","slug":"high-level-data-link-control","permalink":"https://JihyeHwang09.github.io/tags/high-level-data-link-control/"}]},{"title":"통신 속도와 통신 용량","slug":"data-communication3","date":"2019-02-08T16:50:22.000Z","updated":"2019-02-09T03:59:16.709Z","comments":true,"path":"2019/02/09/data-communication3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/09/data-communication3/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 통신 속도와 통신 용량에 대해 알아봅시다. 본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. 통신 속도 / 통신 용량1. 통신 속도1) 변조 속도 1초 동안 몇 개의 변화가 있었는가를 나타내는 것(단위: Baud) 변조 속도(Baud) = 데이터 신호 속도(Bps)/ 변조 시간 상태 변화 수 2) 신호 속도 1초 동안 전송 가능한 비트의 수(단위: Bps(Bit/Sec)) 데이터 신호 속도(Bps) = 변조 속도(Baud) X 변조 시간 상태 변화의 수 3) 전송 속도 단위 시간에 전송되는 데이터의 양(문자, 블록, 비트, 단어 등) 4) 베어러 속도 데이터 신호에 동기 문자, 상태 신호 등을 합한 속도(Bps(Bit/Sec)) 변조 시 상태 변화 수 모노비트(Monobit) = 1Bit 디비트(Dibit) = 2Bit 트리비트(Tribit) = 3Bit 쿼드비트(Quadbit) = 4Bit 2. 통신 용량 단위 시간 동안 전송 회선이 최대로 전송할 수 있는 통신 정보량 샤논(Shannon)의 정의 1C = W * log₂(1 + S/N) C: 통신 용량, W: 대역폭(대역폭이 ‘Band Width’이므로 &#39;W&#39; 대신 &#39;B&#39;로도 사용), S: 신호 전력, N: 잡음 전력 전송로의 통신 용량을 늘리기 위한 방법 주파수 대역폭을 늘림 신호 세력을 높임 잡음 세력을 줄임 보(Baud) 속도가 2,400[Baud]이고 8위상 2진폭 변조를 수행하는 모뎀(MODEM)이라면데이터 전송 속도는 (9,600)bps이다. 1234567891011[해설]8위상이란 2진수 3비트로 표현 가능한 수로변조 시 상태 변화 수는 3Bit이고,2진폭이란 2진수 1비트로 표현 가능한 수로변조 시 상태 변화 수는 1Bit 입니다.-&gt; 변조 시 상태 변화 수는 모두 4Bit 입니다.-&gt; 신호 속도(bps) 계산 공식인`Bps = 변조 속도(Baud) X 변조 시 상태 변화 수&apos;에 대입하면,Bps = 2,400 X 4 = 9,600Bps 입니다. 4,800[Bps]의 8위상 편이 변조 방식 모뎀의 변조 속도는(1,600) 보[Baud]이다. 12345678[해설]8위상이란 2진수 3비트로 표현 가능한 수로변조 시 상태 변화 수는 3Bit이고,변조 속도(Baud) 계산 방법인&apos;Baud = 신호 속도(Bps) / 변조 시 상태 변화 수&apos;이므로Baud = 4,800 / 3 = 1,600Baud 입니다. 신호 속도, 변조 속도, 베어러 속도, 변환 속도 중통신 속도를 나타내는 단위가 아닌 것은 (변환 속도)이다. 123[해설]통신 속도를 나타내는 단위에는신호 속도, 변조 속도, 전송 속도 베어러 속도가 있습니다. 신호 대 잡음비가 63인 전송 채널의 대역폭이 8KHz라 하면통신 용량은 (48000)bps이다. 12345[해설]통신용량(C) = W * log₂(1 + S/N)이므로C = 8K * log₂(64)C = 8000 * 6C = 48000","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"data-communication","slug":"data-communication","permalink":"https://JihyeHwang09.github.io/tags/data-communication/"},{"name":"통신 속도","slug":"통신-속도","permalink":"https://JihyeHwang09.github.io/tags/통신-속도/"},{"name":"통신 용량","slug":"통신-용량","permalink":"https://JihyeHwang09.github.io/tags/통신-용량/"}]},{"title":"펄스 코드 변조(PCM)와 다중화기(Multiplexer)","slug":"data-communication2","date":"2019-02-08T06:39:50.000Z","updated":"2019-02-08T16:52:42.334Z","comments":true,"path":"2019/02/08/data-communication2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/08/data-communication2/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 펄스 코드 변조(PCM)와 다중화기(Multiplexer)에 대해 알아봅시다. 본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. 펄스 코드 변조(PCM) 화상, 음성, 동영상 비디오, 가상 현실 등과 같이연속적인 시간과 진폭을 가진 아날로그 데이터를디지털 신호로 변조하는 방식으로, CODEC을 이용한다. 펄스 코드 변조(PCM) 순서: 송신 측(표본화 -&gt; 양자화 -&gt; 부호화 -&gt; 수신 측(복호화 -&gt; 여과화) 아날로그-디지털 부호화 방식인 PCM(Pulse Code Modulaiton) 송신 측 과정을순서대로 바르게 나열하면(표본화(Sampling))-&gt; (양자화(Quantizing))-&gt; (부호화(Encoding))순이다. 음성 주파수 대역이 4KHz일 때, 디지털화하기에 가장 적당한 샘플 주파수는 (8)KHz이다. 123해설2. 샤논의 표본화 이론에 의해 적당한 표본화(샘플링) 횟수는 최고 주파수의 2배입니다.표본화 횟수 = 2 X 4KHz = 8KHz 아날로그 데이터(음성)를 디지털 신호로 전송하기에 적합한 변조 방법은(펄스코드변조방식(PCM))이다. PCM(Pulse Code Modulaiton)방식에서 PAM(Pulse Amplitude Modulation)신호를얻는 과정은 (표본화)이다. PCM 방식에서 표본화 과정을 거친 신호의 진폭을이산값으로 변화시키는 과정은 (양자화)이다. PCM 방식은 Frequency Modulation을 사용하여 변조한다.(X) 12해설6. PCM 방식은 Pulse Code Modulaiton을 사용하여 변조합니다. PAM 펄스의 아날로그 값과 양자화된 PCM 펄스의 디지털값의 차이를(양자화 잡음)이라고 한다. PCM 과정 중 양자화 과정에서 레벨 수가 128레벨인 경우(7) 비트로 부호화 된다. 123해설표본당 비트 수가 n인 경우 양자화 레벨은 2^n이므로,양자화 레벨이 128인 경우 표본당 비트 수는 7입니다. 다중화기(Multiplexer) 하나의 통신 회선에 여러 대의 단말기가 동시에 접속하여 사용할 수 있도록 하는 장치 cf) 다중화(Multiplexing): 하나의 통신 회선을 다수의 단말기가 공유할 수 있도록 하는 것으로,다중화를 위한 장치에는 다중화기, 집중화기, 공동 이용기가 있습니다. 다음과 같은 특징을 갖는 장비는 (다중화기(Multiplexer))이다. 123456- 여러 개의 채널들이 하나의 통신 회선을 통하여 결합된 신호의 형태로 전송되고, 수신 측에서 다시 이를 여러 개의 채널 신호로 분리하는 역할을 수행하는 장비- 여러 단말기가 같은 장소에 위치하는 경우, 하나의 통신 회선을 공유하도록 하여 전송로의 수를 감소시키기 위해 사용하는 장비 다중화(Multiplexing)을 함으로써 얻어지는 가장 좋은 점은전송 효율을 높일 수 있다는 것이다.(O) 효율적인 전송을 위해 넓은 대역폭(고속 전송 속도)을 가진하나의 전송 링크를 통해 여러 신호(데이터)를 동시에 실어 보내는기술은 (다중화)이다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"data-communication","slug":"data-communication","permalink":"https://JihyeHwang09.github.io/tags/data-communication/"},{"name":"펄스 코드 변조","slug":"펄스-코드-변조","permalink":"https://JihyeHwang09.github.io/tags/펄스-코드-변조/"},{"name":"PCM","slug":"pcm","permalink":"https://JihyeHwang09.github.io/tags/pcm/"},{"name":"다중화기","slug":"다중화기","permalink":"https://JihyeHwang09.github.io/tags/다중화기/"},{"name":"Multiplexer","slug":"multiplexer","permalink":"https://JihyeHwang09.github.io/tags/multiplexer/"}]},{"title":"전송 방식","slug":"data-communication1","date":"2019-02-07T14:06:21.000Z","updated":"2019-02-08T16:52:45.400Z","comments":true,"path":"2019/02/07/data-communication1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/07/data-communication1/","excerpt":"","text":"오늘은 데이터 통신에 자주 출제되는 전송 방식에 대해 알아봅시다. 본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. 전송 방식전송 방식에는동기식 전송과 비동기식 전송이 있다. 비동기식 전송 비동기식 전송에서 어떤 문자도 전송되지 않을 때 통신 회선은 예비(Reserve) 상태가 된다.(X) 123해설 1. 비동기식 전송에서 어떤 문자도 전송되지 않을 때 통신 회선은 휴지(Idle)상태가 됩니다. 비동기식 전송에서는 송.수신기의 클록 오차에 의한 오류 발생을 줄이기 위해짧은 비트열은 전송하지 않음으로써 타이밍 오류를 피한다.(X) 1234해설비동기 전송 방식은 짧은 비트열도 전송합니다.비동기 전송 방식은 타이밍 오류를 피하기 위해Start Bit와 Stop Bit를 사용하여 동기를 맞춥니다. 비동기 전송 방식에서 스타트(Start) 신호와 스톱(Stop) 신호는(Byte와 Byte) 사이를 구분하기 위하여 사용한다. 동기식 전송 다음 그림과 같은 전송 방식은 (동기식 전송 방식)이다.| SYN | SYN | STX | TEXT | ETX | 123456해설그림은 동기식 전송 방식 중에서 SYN 등의 동기 문자(전송 제어 문자)에 의해동기를 맞추는 문자 위주 동기 방식입니다.또한 아래 그림과 같이 동기 문자로 구성된 프레임 단위로 전송하는 비트(프레임)위주 동기 방식도그림과 함께 종종 출제되고 있으니 함께 알아두세요.| Control | error check | user data | control | address | sync | 다음 보기를 동기식 전송과 비동기식 전송으로 구분하시오. 비동기식 전송 123456a. 이진수 0 값을 갖고 1비트의 길이만큼 지속되는 시작(Start) 비트와이진수 1값을 갖고 1~2비트의 길이만큼 지속되는 정지(Stop)비트를 사용한다.b. 저속인 통신 시스템에 주로 사용한다.c. 비트 열이 전송되지 않을 때는 휴지 상태가 된다. 동기식 전송 12345678910111213d. 문자 또는 비트들의 데이터 블록을 송.수신한다.e. 전송 효율이 좋고 주로 원거리 전송에 사용하며 정보의 프레임 구성에 따라문자 동기 방식, 비트 동기 방식, 프레임 동기 방식으로나뉘는 전송 방식f. 동기 문자, 제어 정보, 데이터 블록을 구성되는 프레임이 사용된다.g. 수신기가 데이터 블록의 시작과 끝을 정확히 인식하기 위한프레임 레벨의 동기화가 요구된다.h. 전송할 데이터를 블록으로 구성하며,송신기와 수신기가 동일한 클록을 사용하여 데이터를 송수신한다. 전송 데이터와 제어 정보를 합친 것으로동기식 전송의 전송 단위를 (프레임)이라고 한다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"데이터 통신","slug":"정보처리기사/데이터-통신","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/데이터-통신/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"데이터 통신","slug":"데이터-통신","permalink":"https://JihyeHwang09.github.io/tags/데이터-통신/"},{"name":"data-communication","slug":"data-communication","permalink":"https://JihyeHwang09.github.io/tags/data-communication/"},{"name":"전송 방식","slug":"전송-방식","permalink":"https://JihyeHwang09.github.io/tags/전송-방식/"},{"name":"동기식 전송","slug":"동기식-전송","permalink":"https://JihyeHwang09.github.io/tags/동기식-전송/"},{"name":"비동기식 전송","slug":"비동기식-전송","permalink":"https://JihyeHwang09.github.io/tags/비동기식-전송/"}]},{"title":"정보처리기사 시험에 자주 출제되는 주제","slug":"engineer-information-processing","date":"2019-02-06T14:48:35.000Z","updated":"2019-02-08T16:52:44.573Z","comments":true,"path":"2019/02/06/engineer-information-processing/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/06/engineer-information-processing/","excerpt":"","text":"본 포스팅은 2019 시나공 정보처리기사 필기의 자료를 인용하였음을 알려드립니다. 1과목: 데이터베이스데이터베이스의 개념스키마(Schema)데이터 모델의 개념개체-관계 모델데이터베이스 설계관계형 데이터베이스의 구조관계형 데이터베이스의 제약 조건관계대수 및 관계해석정규화(Normalization)뷰(View)시스템 카탈로그트랜잭션의 개념병행제어스택(Stack)이진 트리의 운행법(Traversal)내부 정렬 2과목: 전자계산기 구조중앙처리장치명령어(Instruction)명령어 형식주소지정방식(Addressing Mode)마이크로 오퍼레이션(Micro Operation)메이저 스테이트(Major State)입.출력 제어방식인터럽트의 개념인터럽트 우선순위(Priority) 체제주기억장치연관기억장치, 복수 모듈 기억장치 3과목: 운영체제운영체제의 개념프로세스의 개요비선점 스케줄링교착 상태기억장치 관리의 개요페이지 교체 알고리즘가상기억장치 기타 관리사항디스크 스케줄링파일과 파일 시스템디렉토리 구조다중 처리기의 운영체제 구조와 프로세서 결합도분산 처리 시스템UNIX의 개요UNIX 파일 시스템과 명령어 4과목: 소프트웨어 공학소프트웨어와 시스템소프트웨어 생명 주기 모형1프로젝트 일정 계획소프트웨어 품질 보증구조적 분석 도구모듈과 모듈화검사 기법검사 전략유지보수객제지향 소프트웨어 공학객제지향 기법의 기본 원칙객제지향 기법의 생명 주기와 분석소프트웨어 재사용소프트웨어 재공학CASE 5과목: 데이터 통신전송 방식신호 변환 방식 - 디지털 변조(PCM)다중화(Multiplexing)통신 속도와 통신 용량전송 제어의 기본데이터 링크 제어 프로토콜- HDLC, SDLC오류 제어 방식오류 검출 방식데이터 교환 방식 - 축적 교환 방식경로 제어와 트래픽 제어OSI 참조 모델X.25TCP/IP","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"}]},{"title":"CSS 레이아웃 핵심속성 position","slug":"css-layout-position","date":"2019-02-04T13:19:24.000Z","updated":"2019-04-11T15:22:16.153Z","comments":true,"path":"2019/02/04/css-layout-position/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/04/css-layout-position/","excerpt":"","text":"position 속성position 속성 중에 relative, absolute가 거의 90%의 비율로 사용된다. position: relative; position: relative;는현재 이미지를 기준으로 변화를 주겠다는 의미이다. relative는 주위 환경에 영향을 끼치지 않으면서위치를 조정한다. position: absolute; 부모에 relatvie를 주지 않으면,전체창 기준으로 position: absolute;를 준 요소가 배치된다. 절대적인 기준점은 원래는 전체 창이다. 부모로 계속 올라가다가 relatvie를 만나면,그 relative를 기준으로absolute 준 요소가 배치된다. absolute 준 요소는 공간을 차지하지 못한다. 자기가 차지하고 있는 공간을 다 버리고 뜬다. 즉, 부모 요소에 상관없이 뜬다. float속성과 position속성을 이용하여 예제를 만들어 봅시다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;WOOD&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 클래스의 장점: 여러 개를 만들어놓고 재활용할 수 있다는 장점이 있다. --&gt; &lt;!-- wrapper의 역할은 동일하다. 가운데 정렬 --&gt; &lt;div class=\"header\"&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"container\"&gt; &lt;!-- float할 요소는 마크업에서 뒤따라오는 요소들과 섞이는 성질이 있기 때문에 오른쪽에 위치하고 있더라도 가장 상단에 마크업 해야 한다. --&gt; &lt;img class=\"container-bg\" src=\"./images/axe.png\" alt=\"\" /&gt; &lt;h1&gt;OAK &lt;span&gt;LABORATORY&lt;/span&gt;&lt;/h1&gt; &lt;p&gt; Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"contents\"&gt; &lt;div class=\"wrapper\"&gt; &lt;ul class=\"grid\"&gt; &lt;li&gt; &lt;!-- li에는 class를 달지 않아도 됨 li안에 li가 있는 게 아니므로 왠만하면 class를 붙이는 게 좋음. type selector는 불안정한 부분이 많음 --&gt; &lt;img src=\"./images/type-a.png\" alt=\"\" /&gt; &lt;div class=\"grid-title\"&gt; &lt;h2&gt;Tree House&lt;/h2&gt; &lt;a href=\"\"&gt;Play&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;!-- li에는 class를 달지 않아도 됨 li안에 li가 있는 게 아니므로 왠만하면 class를 붙이는 게 좋음. type selector는 불안정한 부분이 많음 --&gt; &lt;img src=\"./images/type-b.png\" alt=\"\" /&gt; &lt;div class=\"grid-title\"&gt; &lt;h2&gt;Furniture&lt;/h2&gt; &lt;a href=\"\"&gt;Play&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"./images/type-c.png\" alt=\"\" /&gt; &lt;div class=\"grid-title\"&gt; &lt;h2&gt;Wave Woods&lt;/h2&gt; &lt;a href=\"\"&gt;Play&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;div class=\"wrapper\"&gt;2015 © OAK LABORATORY&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/* CSS Reset */body,h1,h2,p,ul &#123; /* CSS 초기화를 위한 body */ /* 브라우저마다 기본 설정된 margin이 있으므로 0으로 초기화해야 함*/ /* margin 병합 현상을 해결하기 위해서 먼저 margin을 0으로 줘서 브라우저 내장 스타일인 margin에 조건에 맞는 margin이 0이라 존재하지 않아서 마치 적용되지 않은 것처럼 보이는 것임 */ margin: 0; padding: 0; /* p태그에는 padding이 없지만, 통상적으로 같이 묶어서 초기화하려고 묶어서 padding: 0을 줌. */&#125;li &#123; list-style-type: none;&#125;/* Common */.wrapper &#123; width: 960px; margin: 0 auto;&#125;/* Design */body &#123; /* 시각적인 디자인을 위한 body임. CSS Reset위한 body와 구분해야 협업할 때 좋다. */ /* 모든 페이지에 걸쳐진 배경색을 지정해준다. */ /* 모든 페이지에 걸쳐진 전경색(homeground color)을 지정해준다. */ background-color: #efefef; color: #999;&#125;.header &#123; background-image: url(images/header-bg.png); /* 배경색이 어둡기 때문에 전경색을 먼저 밝은 색으로 준다. */ color: orange; /* display: flow-root; */ /* 1. display: flow-root; header 안의 모든 margin이 밖으로 삐져나가지 않고, header안에 위치하도록 함. But 브라우저 호환성 때문에 추천 X */ overflow: hidden; /* container의 마진 병합 현상을 해결하기 위해서 부모인 header에 overflow: hidden;을 줘서 해결한다. (이 용도로 만들어진 overflow: hidden; 속성은 아니지만, 이렇게 사용한다. 야매나 트릭은 X) */ /* .header에 overflow: hidden;이 있기 때문에 float된 요소인 .container-bg의 높이를 읽을 수 있는 것이다. */&#125;.container &#123; /* wrapper는 2~3개 정도라 공통적인 스타일이므로 wrapper가 아니라 container에 스타일을 줘야 한다. */ /* border-left:;, border-right: ;로 나눠서 적어도 됨 */ border-width: 20px 20px 0 20px; border-style: 10px solid; padding: 50px; border-color: orange; overflow: hidden; /* 자식 요소인 .container-bg가 float된 요소라서 높이를 읽지 못하기 때문에 부모 요소인 container에 overlfow: hidden;을 줘서 자식 요소의 높이를 읽게 한다. */ position: relative;&#125;.container-bg &#123; /* margin-bottom: 20px; /* 주위 환경에 영향을 끼치지 않으면서도 이 도끼 사진을 아래쪽에 위치시키고 싶다. 이 도끼 사진을 이 container-bg가 차지하는 공간 안에서 아래쪽에 위치시키려면 -&gt; */ /* position: relative; */ /* 현재 이미지를 기준으로 변화를 주겠다. */ /* relative는 주위 환경에 영향을 끼치지 않으면서 위치를 조정한다. */ /* left: 0; right: 0; top: 100px; */ /* 도끼가 위로 가게 하고 싶다. */ /* top에 음수값 주면 됨 */ /* top: -100px; */ /* 도끼가 이미지가 잘린 이유? 부모 요소인 container에 overflow: hidden을 줬기 때문에 */ /* 부모에 relatvie를 주지 않으면, 전체창 기준으로 position: absolute;를 준 요소가 배치된다. */ /* 절대적인 기준점이 원래는 전체 창이다. */ /* 부모로 계속 올라가다가 relatvie를 만나면 그 relative를 기준으로 absolute준 요소가 배치된다. */ position: absolute; /* absolute 준 요소는 공간을 차지하지 못한다. */ right: -150px; bottom: 0; /* 자기가 차지하고 있는 공간을 다 버리고 뜬다. 부모 요소에 상관없이 뜬다. */ /* position 속성에서 relative, absolute가 거의 90% 사용된다. */&#125;.container h1 &#123; margin-bottom: 30px; letter-spacing: 10px; border-bottom: 5px solid; display: inline-block;&#125;.container h1 span &#123; /* h1은 기본 브라우저 내장 스타일이 bold이므로 굵기를 얇게 주고 싶은 span요소에 normal을 주면 됨 */ font-weight: normal;&#125;.container p &#123; line-height: 1.7; /* inline요소의 높이는 line-height로 조절한다. */ /* line-height는 숫자만 적어야 함.(단위 x) -&gt; 폰트 크기에 비례해서 늘어나고 줄어듬*/ margin-right: 300px;&#125;.contents &#123; background-color: #ddd; padding: 30px 0;&#125;.grid &#123; /* background-color: yellow; */ /* 자식 요소인.grid li의 높이를 읽기 위해서 overflow: hidden;을 한다. */ overflow: hidden;&#125;.grid li &#123; background-color: white; color: orange; float: left; width: 300px; margin-right: 30px; border-radius: 10px; /* 모서리를 둥글게 boder-radius를 줬을 때, 이미지가 너무 커서 border-radius가 안먹는 것처럼 보이는 것임*/ /* overflow: hidden;을 줘서 넘치는 부분을 숨기며 네 모서리 모두 둥글게 보인다. */ overflow: hidden;&#125;.grid li:last-child &#123; margin-right: 0;&#125;.grid li img &#123; display: block; /* 빔캠프 유튜브를 참고 */ border-bottom: 3px solid orange;&#125;.grid-title &#123; overflow: hidden;&#125;.grid-title h2 &#123; float: left; /* a태그의 이미지와 줄을 맞추기 위해서 padding을 주기 보다는 height를 고정값을 준 다음, line-height을 줘서 line중간에 텍스트가 오도록 한다. */ font-size: 14px; height: 50px; line-height: 50px; padding: 0 10px;&#125;.grid-title a &#123; float: right; background-image: url(./images/play.png); /* 크기가 작아서 배경이미지가 안나올 경우, 이미지 크기만큼 width, heigth값을 준다. */ width: 50px; height: 50px; /* 텍스트가 안보이게 하기 위해서 text-indent: -9999px;을 준다. */ text-indent: -9999px;&#125;.footer &#123; text-align: center; padding: 20px; letter-spacing: 10px; text-indent: 10px; font-size: 12px; color: #bbb; margin-bottom: 100px;&#125;","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"[object Object]","slug":"object-object","permalink":"https://JihyeHwang09.github.io/tags/object-object/"},{"name":"position","slug":"position","permalink":"https://JihyeHwang09.github.io/tags/position/"}]},{"title":"CSS 레이아웃 핵심속성 float","slug":"css-layout-float","date":"2019-02-03T14:11:20.000Z","updated":"2019-04-11T15:22:16.146Z","comments":true,"path":"2019/02/03/css-layout-float/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/03/css-layout-float/","excerpt":"","text":"1교시float로 가로배치 하기가로배치는 소박한 꿈이다.그러나 공식적으로 지원되는 게 없다.float도 가로 배치를 위한 속성이 아니다. 공식적인 방법이 아닌 방식으로 가로배치를 하려고 하기 때문에문제가 발생한다. 박스가 위로 떠있어야만이 그 박스 주위로 Dummy Text들이 그 주위로 흐른다.(같은 선상에 있지 않아야 한다.) float의 목적은 이미지와 텍스트가 어우러지게끔 하고 싶은 것이며,이미지는 공간을 차지 않도록 한다. 부모 요소가 아닌 body영역은 float된 요소의 높이 조차도 인식하고 있다.body를 root요소라고 한다. 123456789부모 &#123; display: flow-root; /* overflow: hidden과 관련되어 있음 */ /* 실무에서는 부모요소에 clearfix를 주는 방법을 많이 사용 */&#125;자식 &#123; float: left;&#125; 1번 예제 이제 float로 박스 2개를 양 옆으로 나누어 보자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;float로 양옆 나누기&lt;/title&gt; &lt;style&gt; body &#123; background-color: #ddd; color: dodgerblue; &#125; .wrapper &#123; width: 500px; background-color: white; border: 1px solid; margin: 50px auto; box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); padding: 10px; display: flow-root; /* body요소를 따라서 흐른다. */ &#125; .box &#123; font-family: \"arial\"; font-weight: bold; font-size: 50px; width: 100px; height: 100px; line-height: 100px; text-align: center; background-color: #c7e1fd; box-shadow: inset 0 0 1px; display: inline-block; float: left; &#125; .box.right &#123; float: right; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box\"&gt;1&lt;/div&gt; &lt;!-- .box의 디자인은 유지된 상태에서 float: right를 추가해야하므로 1) class에 box는 그대로 두고, right라는 클래스를 추가 -&gt; 2) float: right를 주기 --&gt; &lt;div class=\"box right\"&gt;2&lt;/div&gt; &lt;!-- &lt;div class=\"box\"&gt;3&lt;/div&gt; &lt;div class=\"box\"&gt;4&lt;/div&gt; &lt;div class=\"box\"&gt;5&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2교시2번 예제유지보수에 최적화하는 습관을 들여야 한다. sidebar에 margin-right: 20px를 주면 되지만,유지보수를 위해서는 float된 요소는 마크업 순서가 중요하다.float되는 요소는 마크업 순서가 contents보다 더 앞에 와야 한다.float는 상단에서 float가 이루어지고 그 후에 다른 요소가 그 주위로 흐르는 거니까float 요소는 마크업 순서가 먼저 와야 한다!!! float는 시각적인 위치랑 마크업 위치가 다르다!!! 이 특성 때문에 많이들 고생한다!! 이제 float로 사이드바를 만들어보자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;float로 사이드바 만들기&lt;/title&gt; &lt;style&gt; p &#123; margin: 0; &#125; body &#123; background-color: #ddd; color: dodgerblue; &#125; .wrapper &#123; width: 800px; margin: 50px auto; background-color: white; display: flow-root; &#125; .sidebar &#123; background-color: #c7e1fd; float: left; /* float가 적용되면, 왼쪽이든 오른쪽이든 컨텐츠가 붙어야하니까 contents 크기만큼 크기가 줄어버림 */ /* sidebar랑 contents는 시작점이 같음 sidebar랑 contents랑 겹치면 안되니까 contents가 오른쪽으로 밀린 것임 */ width: 100px; height: 300px; /* 보통, height는 사이즈르 주지 않는 게 좋다. */ &#125; .contents &#123; /* 1) 부모요소인 sidebar에 margin-right: 20px를 주면 된다. margin-left: 100px;(비추천!)2) 유지보수를 위해서는 자식 요소인 contents에 margin-left: 100px을 주면 된다. -&gt; 좋은 방법은 X (sidebar의 너비를 모르면 사용할 수 X)3) flow-root는 가장 최상위 요소처럼 보여지게 하라는 뜻float된 요소랑 float되지 않은 요소랑 독립되게 하려면, 자식 요소인 contents에display: flow-root;를 준다.*/ display: flow-root; /* 장점: sidebar의 너비가 줄거나 늘어나도, wrapper의 너비가 줄거나 늘어나도 수정할 게 X */ border: 5px solid mediumpurple; padding: 20px; &#125; .sidebar.right &#123; float: right; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"sidebar\"&gt;Sidebar&lt;/div&gt; &lt;div class=\"sidebar right\"&gt;Sidebar&lt;/div&gt; &lt;p class=\"contents\"&gt; Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate ele &lt;/p&gt; &lt;!-- &lt;div class=\"sidebar right\"&gt;Sidebar&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3번 예제자식이 float가 되면, 부모 기준에서 정리를 하지 않으면 안된다.부모 기준에서 정리를 하지 않으면, 뒤따라오던 content와 엉켜버린다. float로 이미지와 텍스트가 어우러지게 만들어보자! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;float로 이미지와 텍스트가 어우러지게!&lt;/title&gt; &lt;style&gt; p &#123; margin: 0; &#125; body &#123; background-color: #ddd; color: dodgerblue; &#125; .wrapper &#123; width: 600px; margin: 50px auto; padding: 50px; background-color: white; display: flow-root; &#125; .section &#123; background-color: #efefef; float: right; margin: 20px; margin-bottom: 20px; display: flow-root; /* 자식이 float가 되면, 부모 기준에서 정리를 하지 않으면 안된다. */ /* 부모 기준에서 정리를 하지 않으면, 뒤따라오던 content와 엉켜버린다. */ /* -&gt; 따라서, 부모 요소인 .section에 display: flow-root;를 준다. */ border: 10px solid; /* 색깔을 안주면, 전경색으로 자동으로 들어감 */ &#125; .section:last-child &#123; margin-bottom: 0px; /* 마지막 section아래에 margin 20px이 들어가면 맨 위와 대칭이 맞지 않으므로 가상 선택자를 써서 마지막 margin-bottom을 주지 않도록 만들기 */ &#125; .section p &#123; padding: 20px; display: flow-root; &#125; .section img &#123; float: left; &#125; .section.right &#123; text-align: right; &#125; .section.right img &#123; float: right; &#125; .section.mario &#123; color: dodgerblue; &#125; .section.luigi &#123; color: mediumorchid; &#125; .section.toad &#123; color: orange; &#125; /* 내가 작성한 코드 */ /* .section img &#123; float: left; &#125; .seciton p &#123; float: right; padding: 10px; &#125; .first &#123; border: 2px solid blue; &#125; .second &#123; border: 2px solid purple; &#125; .second img &#123; float: right; &#125; .second p &#123; float: left; display: flow-root; &#125; .third &#123; border: 2px solid yellow; &#125; */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"section mario\"&gt; &lt;img src=\"images/mario2.png\" /&gt; &lt;p&gt; &lt;strong&gt;Mario&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;div class=\"section luigi right\"&gt; &lt;img src=\"images/luigi2.png\" /&gt; &lt;p&gt; &lt;strong&gt;lugi&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;div class=\"section toad\"&gt; &lt;img src=\"images/toad2.png\" /&gt; &lt;p&gt; &lt;strong&gt;toad&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- border 색깔이 다름 --&gt;&lt;!-- lugi만 오른쪽으로 --&gt; 4번 예제display: flow-root;를 대체하는 방법 CSS를 공부한 사람들도 왜 display: flow-root;를 처음 보는 경우가 많은가? 생긴지 얼마 안 된 속성이며, 비교적 최근에 만들어진 속성이기 때문이다. 호환성이 좋지 않기 때문에 이 속성보다는 overflow: hidden;이나 clearfix를 이용하는 걸 추천한다. caniuse.com에서 flow-root 검색한 내용 쓸 수 없는 브라우저의 경우에는display: flow-root;의 대용품이 있다.overflow: hidden;이다.cf) margin 겹침 현상이 있을 때, 부모에게 overflow: hidden;을 사용함 위의 예제에서 display: flow-root;를 줬던 속성 자리에 overflow: hidden;을 주는 게 좋다. 이유: 이 두 가지가 성질이 똑같기 때문이다. Block Formating Context(BFC)라는 성질을overflow: hidden;과display: flow-root; 둘 다 가지고 있다. overflow: hidden; 넘쳐 흐르는 게 잘리는 속성 transition과 transform 속성은ie 크로스브라우징을 어느 정도 무시해야 한다는 생각이 있을 때 사용한다.(6-9버전)에서 사용할 수 없기 때문이다. 실무에서는 ie9버전을 맞춰야 하기 떄문에 float를 배우는 것이다. 이제 float 속성과 overflow: hidden;을 이용하여 그리드를 만들어 보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;float로 그리드 만들기&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"style.css\" /&gt; &lt;style&gt; p &#123; margin: 0; &#125; body &#123; background-color: #ddd; color: dodgerblue; &#125; .wrapper &#123; width: 640px; padding: 20px; background-color: white; border: 1px solid; margin: 50px auto; display: flow-root; &#125; .section &#123; background-color: #efefef; float: left; width: 200px; /*cf) width값을 %로 주는게 더 효율적임 */ margin-right: 20px; /* width값을 주지 않으면, 가로로 배치할 수 X */ &#125; .section:last-child &#123; margin-right: 0px; &#125; .section p &#123; padding: 20px; &#125; .section img &#123; transition: transform 1s; &#125; .section .cover &#123; overflow: hidden; &#125; .section:hover img &#123; transform: scale(1.2); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"section mario\"&gt; &lt;img src=\"images/mario2.png\" /&gt; &lt;p&gt; &lt;strong&gt;Mario&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;div class=\"section luigi right\"&gt; &lt;img src=\"images/luigi2.png\" /&gt; &lt;p&gt; &lt;strong&gt;Luigi&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;div class=\"section toad\"&gt; &lt;img src=\"images/toad2.png\" /&gt; &lt;p&gt; &lt;strong&gt;Toad&lt;/strong&gt; ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"float","slug":"float","permalink":"https://JihyeHwang09.github.io/tags/float/"},{"name":"[object Object]","slug":"object-object","permalink":"https://JihyeHwang09.github.io/tags/object-object/"}]},{"title":"자바스크립트 19일차","slug":"javascript19","date":"2019-02-01T17:12:59.000Z","updated":"2019-04-11T15:22:16.168Z","comments":true,"path":"2019/02/02/javascript19/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/02/javascript19/","excerpt":"","text":"모듈 역사 DOM Tree 라이브러리require.js 모듈 번들러Browserify CommonJS-require()함수를 이용해서 모듈을 이용 Node.js 모듈 UMD define()함수를 이용해서 모듈을 이용 많은 모듈 시스템이 있었다.기존의 자바스크립트 함수를 사용하는 모듈 시스템들이 사용되었다. 예전 모듈 시스템은 자바스크립트 함수를 사용했지만,지금의 모듈 시스템은 새롭게 추가된 문법을 사용한다. 1&lt;script type=\"module\" src=\"index.mjs\" /&gt; 위의 예시처럼 사용할 수는 있지만,ES2015모듈을 사용하지 않는 사용자가 있기 때문에 모듈 번들러를 통해 변환과정을 거친 뒤,브라우저에는 일반적인 JavaScript 파일로서 불러오는 방법이 널리 사용되고 있는 추세이다. 모듈이란? 특수한 방식(코드 변환 방식)을 이용해야 하는 방식을 모듈이라고 한다. import 혹은 export 구문을 사용할 수 있다. 별다른 처리를 해주지 않아도 엄격 모드(strict mode)로 동작한다. 모듈의 가장 바깥쪽에서 선언된 이름은 전역 스코프가 아니라 모듈 스코프에서 선언된다. 모듈 스코프 모듈 스코프에서 선언된 이름은 모듈 안에서만 사용할 수 있다. (전역 스코프가 아니라) 모듈 스코프에 선언된 이름은 (export 해주지 않는다면) 해당 모듈 내부에서만 접근할 수 있다. cf) 전역 변수는 편하긴 한데, 오염될 가능성이 높다. ex) 강남역 한복판의 사물함 -&gt; 따라서 여러 모듈의 가장 바깥쪽에서 같은 이름으로 변수, 함수, 클래스를 선언하더라도,서로 다른 스코프에서 선언되기 때문에 이름의 충돌이 생길 일이 없다. export &amp; importexport의 2가지 종류 named export default export 선언과 동시에 export 하기 실무에서 named export를 사용하고 싶을 때, 선언부 앞에 export를 붙여준다. 변수 이름을 수출하는 거지, 값을 수출하는 게 X default export 모듈마다 하나의 값을 지정해서 그 값을 export할 수 있다. 모듈을 대표하는 값이 이거다!라는 걸 지정해서그 값을 다른 모듈에서 편하게 불러와서 사용할 수 있다. import받는 쪽에서 중괄호로 감싸주지 않고 써준다. import할 때, export할 때의 변수 이름과 통일할 필요 X.import 받는 쪽에서 값에 내가 쓰고 싶은 이름을 붙여서 쓰면 된다.(이유: 값을 export하는 것이기 때문에) 클래스도 값이다. 익명 클래스도 만들 수 있다. 123export default class MyComponent &#123; render() &#123;&#125;&#125; 표현식이 와야하는 자리에 이름이 있는 클래스를 써도 되고, 익명 클래스를 써도 된다. class명 앞에 export 써도 되고, export default 써도 된다. 1234// `React`라는 이름의 default export와,// Component, Fragment라는 일반적인 export를 동시에 가져오기// 굳이 2줄로 나눠서 import할 필요 Ximport React, &#123; Component, Fragment &#125; from \"react\"; 12345// named export는 여러 개 있을 수 있다.// defualt export는 0개 or 하나 있을 수 있다. (여러 개 있을 수 X)export default class &#123;&#125;export const Component = \"...\";export const Fragment = \"...\"; 다른 이름으로 export &amp; import 하기 export 혹은 import 하는 이름의 뒤에 as를 붙여서,다른 이름이 대신 사용되게 할 수 있습니다. import하는 쪽에서 같은 이름의 변수들이 넘어올 경우,충돌을 막기 위해서 as를 사용해서 이름을 바꿔서 사용할 수 있다. 모듈 사용 시 주의할 점 주의할 점이 한 가지 있습니다.import 구문과 export 구문은 모듈 간 의존 관계를 나타내는 것일 뿐,코드를 실행시키라는 명령이 아니라는 것입니다. 같은 모듈을 여러 다른 모듈에서 불러와도, 모듈 내부의 코드는 단 한 번만 실행된다. import를 한다고 해서 그 당시에 코드가 반드시 실행된다는 보장이 없다. 여러 파일에서 그 모듈을 불러와서 실행한다고 해서 여러 번 실행되는게 아니라,딱 1번만 실행된다. import를 여러 번 했는데, 딱 한 번 실행되는 것이다. import명령을 한 줄 한 줄 실행하라는 의미가 아니다. cf1) 폴더를 import할 경우, 그 안에 있는 index.js를 import하는 것과 같다.import TodoList from ‘./TodoList’import TodoList from ‘./TodoList/index.js 위, 아래는 같게 작동함 cf) export * from … export, import를 같이 해주는 구문 …에 적혀있는 모든 모듈을 export해서 바로 import하겠다. export {name1, name2, …, nameN} from …; …이 모듈에서 이 nam e들을 export해서 바로 import하겠다.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 18일차","slug":"javascript18","date":"2019-01-31T15:01:40.000Z","updated":"2019-04-11T15:22:15.953Z","comments":true,"path":"2019/02/01/javascript18/","link":"","permalink":"https://JihyeHwang09.github.io/2019/02/01/javascript18/","excerpt":"","text":"예외 처리동기식 코드에서의 예외 처리 JavaScript 코드에서 발생할 수 있는 에러에는 다양한 것들이 있습니다.문법 에러와 같이 프로그래머의 실수로 인해 에러가 발생하는 경우도 있지만,네트워크 에러와 같이 코드와는 무관한 이유로 발생하는 에러도 있습니다. 코드 실행 중에 에러가 발생하면,코드의 실행이 중단되어 그 시점에 실행 중이었던 작업을 완료할 수 없게 됩니다. JavaScript는 이로부터 코드의 실행 흐름을 원상복구할 수 있는 기능을 제공하며,try...catch...finally 구문을 사용하면에러가 나더라도 코드의 실행을 지속할 수 있습니다. 1234567891011121314151617try &#123; console.log(\"에러가 나기 직전까지의 코드는 잘 실행됩니다.\"); // Array 생성자는 배열의 길이를 인수로 받는다. -1이 들어가서 에러가 남 // try문 안에서 에러가 나지 않으면, catch문 안에 있는 코드는 실행이 되지 X new Array(-1); // RangeError: Invalid array length console.log(\"에러가 난 이후의 코드는 실행되지 않습니다.\");&#125; catch (e) &#123; console.log(\"코드의 실행 흐름이 catch 블록으로 옮겨집니다.\"); alert(`다음과 같은 에러가 발생했습니다: $&#123;e.name&#125;: $&#123;e.message&#125;`);&#125;// try -catch문으로 에러를 잡지 않았다면, 아래 코드는 실행되지 X.// 에러가 잡혀야만 그 후의 코드가 실행됨console.log(\"에러가 잡혔다면, 다음에 나오는 코드도 문제없이 실행됩니다.\");// 에러가 나기 직전까지의 코드는 잘 실행됩니다.// 코드의 실행 흐름이 catch 블록으로 옮겨집니다.// 에러가 잡혔다면, 다음에 나오는 코드도 문제없이 실행됩니다. 에러가 났을 때 원상복구를 시도할 코드를 try 블록 내부에 작성하면,에러가 발생했을 때 코드의 실행 흐름이 try 블록에서 catch 블록으로 옮겨갑니다.이 때, catch 블록 안에서는에러에 대한 정보를 담고 있는 객체(위 코드의 e)를 사용할 수 있습니다. try 블록은 예외 처리를 위해서만 쓰이는 것은 아닙니다.try 블록 바로 뒤에 finally 블록이 오면,finally 블록에 있는 코드는 try 블록 안에서의 에러 발생 여부와 관계 없이무조건 실행됩니다.심지어 try 블록 내에서 return, break, continue 등으로 인해코드의 실행 흐름이 즉시 이동될 때에도 마찬가지로 무조건 실행됩니다. 1234567891011121314151617for (let i of [1, 2, 3, 4, 5]) &#123; try &#123; // i = 1 // i = 2 // i = 3 if (i === 3) &#123; // break를 만나면, 코드의 실행 흐름이 루프를 빠져나오게 되는데!! // for루프 안에 finally가 있으므로 -&gt; finally 안의 코드를 실행한 후에!! // 루프를 빠져나온다. break; &#125; // finally는 무조건 실행되어야 하므로 break를 만나서 루프를 빠져나가기 전에 `finally`를 실행한 후 빠져나간다. &#125; finally &#123; console.log(`현재 i의 값: $&#123;i&#125;`); &#125;&#125; finally 블록은catch 블록과도 같이 사용됩니다.이 때 코드의 실행 순서를 정리해 보면 다음과 같습니다. 에러가 안 났을 때: try - finally에러가 났을 때: try - 에러 발생 - catch - finally아래 코드를 통해 코드의 실행 순서를 시험해보세요. 123456789101112try &#123; console.log(\"try\"); new Array(-1); // RangeError: Invalid array length&#125; catch (e) &#123; console.log(\"catch\");&#125; finally &#123; console.log(\"finally\");&#125;// try// catch// finally 123456789try &#123; const length = prompt(\"배열의 길이를 입력하세요.\"); //prompt로 입력받은 값은 문자열이므로 parseInt로 정수를 써야 한다. const arr = new Array(parseInt(length));&#125; catch (e) &#123; alert(\"제대로 된 숫자를 입력하세요.\");&#125; finally &#123; console.log(\"finally\");&#125; 직접 에러 발생시키기 Error 생성자와 throw 구문을 사용해서 프로그래머가 직접 에러를 발생시킬 수 있습니다. 123456// 에러 생성자는 자바스크립트 자체에 내장되어 있는 생성자// new Error 에러 객체를 throw한다.const err = throw new Error(\"짝수가 아닙니다.\");// 에러 객체만 throw할 수 있다.// 아래 코드는 에러가 발생하지 Xthrow 1; 12345678910111213141516171819202122// 우리만의 Error 클래스를 만들고, 그 클래스를 이용해서 에러 처리를 할 수 있다.class MyError extends Error &#123; //...params는 나머지 매개변수 문법 // 나머지 매개변수들이 배열로 담긴다 constructor(value, ...params) &#123; super(...params); this.value = value; // name속성은 매개변수의 속성을 나타낸다. this.name = \"MyError\"; &#125;&#125;try &#123; const even = parseInt(prompt(\"짝수를 입력하세요\")); if (even % 2 !== 0) &#123; throw new MyError(even, \"짝수가 아닙니다.\"); &#125;&#125; catch (e) &#123; if (e instanceof MyError) &#123; console.log(e.value); &#125;&#125; 비동기식 코드에서의 예외 처리비동기 콜백 비동기식으로 작동하는 콜백의 내부에서 발생한 에러는,콜백 바깥에 있는 try 블록으로는 잡아낼 수 없습니다. 123456789101112function func1() &#123; try &#123; // setTimeout()은 작업큐에 이따가 실행해달라고 부탁하고 넘어가는 거므로 // setTimeout()바깥에 try문으로 감싸고 있더라도 // func1이 실행될 때는 setTimeout()이 실행되는 게 아니므로 에러가 잡히지 X setTimeout(() =&gt; &#123; throw new Error(\"에러!\"); &#125;); &#125; catch (e) &#123; console.error(e); &#125;&#125; JavaScript 엔진은 에러가 발생하는 순간 호출 스택을 되감는 과정을 거칩니다.이 과정 중에 try 블록을 만나야 코드의 실행 흐름을 원상복구시킬 수 있습니다.위 예제에서 setTimeout에 넘겨진 콜백에서 에러가 발생하면,호출 스택을 따라 올라가도 try 블록을 만나는 것이 아니므로,코드의 실행 흐름이 catch 블록으로 옮겨지지 않는 것입니다. 따라서, 위 예제의 try 블록을 비동기 콜백 내부에 작성해주어야 합니다. 123456789//// 콜백 바깥이 아니라 안에 작성해야 에러를 잡을 수 있다.setTimeout(() =&gt; &#123; try &#123; throw new Error(\"에러!\"); &#125; catch (e) &#123; console.error(e); &#125;&#125;); Promise Promise 객체는 세 가지 상태를 가질 수 있습니다. pending - Promise 객체에 결과값이 채워지지 않은 상태fulfilled - Promise 객체에 결과값이 채워진 상태(resolved라고도 함)rejected - Promise 객체에 결과값을 채우려고 시도하다가 에러가 난 상태 Promise 객체가 rejected 상태가 되면,이 Promise에 대해서는 then 메소드에 첫 번째 인수로 넘겨준 콜백이 실행되지 않고,두 번째 인수로 넘겨준 콜백이 대신 실행됩니다.그리고 이 콜백에는 에러 객체가 첫 번째 인수로 주어집니다. 12345678910111213141516171819const p = new Promise((resolve) =&gt; &#123; const even = parseInt(prompt(\"짝수를 입력하세요\")); if (even % 2 !== 0) &#123; throw new Error(\"짝수가 아닙니다.\"); &#125; else &#123; resolve(even); &#125;&#125;);p.then( (even) =&gt; &#123; return \"짝수입니다.\"; // 에러가 발생했을 때, 이 콜백이 실행된다 //then 메소드의 2번째 인수로 에러 콜백을 넘겨준다 &#125;, (e) =&gt; &#123; return e.message; &#125;).then(alert); 혹은, catch 메소드를 통해 에러 처리 콜백을 지정해줄 수도 있습니다. 1234567p.then((even) =&gt; &#123; return \"짝수입니다.\";&#125;) .catch((e) =&gt; &#123; return e.message; &#125;) .then(alert); 만약, then 메소드의 연쇄 안에서 에러가 발생하면,try...catch 구문과 유사하게 처음 만나는 에러 처리 콜백으로코드의 실행 흐름이 건너뛰는 결과를 낳게 됩니다. 1234567891011121314151617// undefined가 full filled 되어있는 Promise를 생성Promise.resolve() .then(() =&gt; &#123; // then 안에서 에러가 발생하면, 다음 then이 실행되는 게 X // catch콜백으로 실행 흐름이 건너뜀 // try -catch처럼 Promise에서는 then ~catch를 사용할 수 있음 // 우리가 이런 코드를 작성하지는 않더라도, 코드를 보고 해석할 수는 있어야 한다. // Promise에 finally 메소드는 지금은 없으나 곧 추가될 예정임 throw new Error(\"catch 메소드를 통해 예외 처리를 할 수 있습니다.\"); &#125;) .then(() =&gt; &#123; console.log(\"이 코드는 실행되지 않습니다.\"); &#125;) .catch((e) =&gt; &#123; return e.message; &#125;) .then(console.log); 비동기 함수앞에서 봤던 Promise 객체의 예외 처리 방식은,일반적인 동기식 예외 처리 방식과 다르게 콜백을 사용하고 있어서코드를 복잡하게 만드는 원인이 됩니다. 비동기 함수 내부에서는,rejected 상태가 된 Promise 객체를 동기식 예외 처리 방식과 동일하게try...catch...finally 구문으로 처리할 수 있습니다. 12345678910111213// 비동기 함수인 경우 -&gt; rejected 상태인 함수를 await하면 에러가 발생하고,// 그 에러는 try ~catch ~finally 구문으로 잡을 수 있다.async function func() &#123; try &#123; // 'https://nonexistent-domain.nowhere'이런 도메인이 없으므로 요청이 에러가 남 // 이에 대한 에러 처리를 try catch로 할 수 있음 const res = await fetch(\"https://nonexistent-domain.nowhere\"); &#125; catch (e) &#123; console.log(e.message); &#125;&#125;func(); // 출력 결과: Failed to fetch 단, Promise 객체에 대해 await 구문을 사용하지 않는 경우,에러가 발생해도 catch 블록으로 코드의 실행 흐름이 이동하지 않는다는 사실을 기억하세요. 비동기 함수인 경우-&gt; rejected 상태인 함수를 await구문을 사용하지 않으면,에러가 발생해도 catch 블록으로 코드의 실행 흐름이 이동하지 않는다는 걸 기억할 것! 123456789async function func() &#123; try &#123; fetch(\"https://nonexistent-domain.nowhere\"); &#125; catch (e) &#123; console.log(e.message); &#125;&#125;func(); // 아무것도 출력되지 않습니다.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 17일차","slug":"javascript17","date":"2019-01-31T14:50:15.000Z","updated":"2019-04-11T15:22:16.162Z","comments":true,"path":"2019/01/31/javascript17/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/31/javascript17/","excerpt":"","text":"업데이트 방식비관적 업데이트 vs 낙관적 업데이트1. 비관적(pessimistic) 업데이트1사용자 입력 -&gt; 수정 요청 -&gt; 성공 시 화면 갱신 사용자에게는 불편하지만, 개발자에게는 쉬움 2. 낙관적(optimistic) 업데이트1사용자 입력 -&gt; 바로 화면 먼저 갱신 -&gt; 수정 요청 ex) slack, trello 네트워크 요청은 항상 성공과 실패로 나뉜다는 걸 명심해야 한다.(ex) 지하철처럼 네트워크가 불안정한 곳에서 접속할 때) 사용자에게는 편하지만, 개발자에게는 어려움(실패했을 경우 원상복구하는 기술을 구현하는 게 어려움) 수정 요청 12성공 -&gt; 끝실패 -&gt; 원상복구 화면을 그릴 때는 비관적 업데이트 or 낙관적 업데이트로 그려줄 지를 정해야 함.(서버가 멀리 떨어져 있기 때문에 신경 써야함) 멀리 떨어져 있는 서버에 통신을 해야 하기 때문에 항상 실패할 가능성이 존재함 사용자가 원래 쓰던 경험을 존중하기 위해서는 주로 낙관적 업데이트를 사용 비용을 들여서 낙관적 업데이트를 해야 하는 필요성이 있으면, 낙관적 업데이트를 구현.아니면, 더 쉬운 비관적 업데이트로 구현 사용자가 무엇을 기대하는지를 고려하는 게 중요하다. 비동기 함수를 호출했을 때 반환되는 promise에는 비동기 함수 내부에서 반환한 값이 채워진다. 화면을 모두 다시 그리는 코드 VS 필요한 부분만 갱신하는 코드 화면을 모두 다시 그리는 코드 개발자에게는 좋지만, 기계에게는 좋지 않은 코드(속도도 느리고) 필요한 부분만 갱신하는 코드 개발자에게는 고통스러운 코드, 기계에게는 좋은 코드 -&gt; React는 개발자는 화면을 모두 다시 그리는 코드를 짜면서도기계에게는 필요한 부분만 갱신할 수 있게 알아서 바꿔주는 라이브러리이다.(DOM API를 직접 만져서 쓰는 게 아니라) 개발용 API서버, 운영용 API 서버를 따로 둔다. 테스트할 때는 개발용 API서버에 접속할 수 있고,운영할 때는 운영용 API 서버에 접속할 수 있어야 함. baseURL은 고정되어 있는 게 아니라, 그때그때마다 밖에서 변경할 수 있어야 함 Parcel에서 .env파일로 환경변수를 사용한다. ###Plural routes경로 사용법 게시물 목록 전체를 가져오고 싶을 때 1GET /posts 1번 게시물 가져오고 싶을 때 123GET /posts/1POST /postsPUT /posts/1 1번 게시물 수정하고 싶을 때 12PATCH /posts/1DELETE /posts/1 FilterFilter를 사용하는 이유 조건을 만족하는 특정 요소들을 가져오기 위해 사용 1Use . to access deep properties 게시물을 가져오는데, title은 json-server고 게시자가 typicode일 때 1GET /posts?title=json-server&amp;author=typicode id가 1이거나 id가 2인 경우의 게시물을 가져온다. 1GET /posts?id=1&amp;id=2 객체 안에 객체가 들어있는 경우 사용함. 1GET /comments?author.name=typicode PaginateUse _page and optionally _limit to paginate returned data. In the Link header you’ll get first, prev, next and last links. 한 페이지에 자료가 2개씩 나오는 페이지들 중의 1페이지 1GET/posts?\\_page=1&amp;\\_limit=2 한 페이지에 자료가 15개씩 나오는 페이지들 중의 2페이지 1GET/posts?\\_page=2&amp;\\_limit=15 _page=페이지 번호_limit= 한 페이지에 나올 게시물 수 12GET /posts?\\_page=7GET /posts?\\_page=7&amp;\\_limit=20 10 items are returned by default(기본적으로 한 페이지에 10개임) Sort123456Add \\_sort and \\_order (ascending order by default)GET /posts?\\_sort=views&amp;\\_order=ascGET /posts/1/comments?\\_sort=votes&amp;\\_order=ascFor multiple fields, use the following format:GET /posts?\\_sort=user,views&amp;\\_order=desc,asc 오름차순(Ascending) -&gt; asc 내림차순(Descending) -&gt; desc id 내림차순 정렬(최신글부터 보여주기 위해서) 1ex) https://fds-json-server-bbs.glitch.me/posts?_sort=id&amp;_order=desc id 내림차순 정렬(최신글부터 보여주기) + 한 페이지에 게시물 2개로 하되, 첫 페이지를 보여주기 1ex(https://fds-json-server-bbs.glitch.me/posts?_sort=id&amp;_order=desc&amp;_limit=2&amp;_page=1 Slice123456789Add \\_start and \\_end or \\_limit(an X-Total-Count header is included in the response)- id가 20인것부터 30인것까지 가져오고 싶다. GET /posts?\\_start=20&amp;\\_end=30GET /posts/1/comments?\\_start=20&amp;\\_end=30GET /posts/1/comments?\\_start=20&amp;\\_limit=10Works exactly as Array.slice (i.e. \\_start is inclusive and \\_end exclusive) OperatorsAdd _gte or _lte for getting a range조회수가 10보다 크거나 같고 조회수가 20이하인 게시물 1GET /posts?views_gte=10&amp;views_lte=20 Add _ne to exclude a value 1GET /posts?id_ne=1 Add _like to filter (RegExp supported) 1GET /posts?title_like=server 비교!! gte = greater than or equal: 크거나 같은 less than or equal: 작거나 같은 정확히 title이 React인 것만 고르고 싶을 때 1https://fds-json-server-bbs.glitch.me/posts?title=React title에 React라는 문자열이 포함되어 있는 경우 다 고르고 싶을 때 12https://fds-json-server-bbs.glitch.me/posts?title_like=React Full-text searchAdd q 1GET /posts?q=internet 텍스트로 상품 검색할 때 prop이라는 문자열이 포함되어 있는 게시물 골라올 때 12ex)https://fds-json-server-bbs.glitch.me/posts?q=prop Relationships자료들 간의 관계가 맺어져 있을 때 ex) 게시물, 댓글간의 관계To include children resources, add _embed 게시물과 댓글을 한꺼번에 가져오고 싶을 때 embed를 사용 1GET /posts?\\_embed=comments 1번 게시물만 가져올 건데, 그 1번 게시물의 자식인 댓글까지 가져오고 싶다. 12GET /posts/1?\\_embed=commentsex) https://fds-json-server-bbs.glitch.me/posts/1?embed=comments 배열이 아닌 객체가 반환된다. 123456&#123; \"id\": 1, \"userId\": 1, \"title\": \"프론트엔드 입문자를 위한 도서 목록\", \"body\": \"자바스크립트 완벽 가이드\\n프론트엔드 개발자를 위한 자바스크립트 프로그래밍\"&#125; comment와 user등등도 관계가 맺어져 있음.To include parent resource, add _expand 1번 게시물의 정보와 + 작성자 정보까지 받아오고 싶을 때 1ex) https://fds-json-server-bbs.glitch.me/posts/1?_expand=user 12345678910&#123; \"id\": 1, \"userId\": 1, \"title\": \"프론트엔드 입문자를 위한 도서 목록\", \"body\": \"자바스크립트 완벽 가이드\\n프론트엔드 개발자를 위한 자바스크립트 프로그래밍\", \"user\": &#123; \"id\": 1, \"username\": \"fds\" &#125;&#125; 12GET /comments?\\_expand=postGET /comments/1?\\_expand=post To get or create nested resources (by default one level, add custom routes for more) 1GET /posts/1/comments posts/1 의 자식이되는 comments를 만들 것이다. 1POST /posts/1/comments 같은 이름의 queryString을 여러 번 사용할 경우에는 URLSearchParams.append()를 사용한다.(특정 키/값을 새로운 검색 매개변수를 추가) embed: 자식 불러오기expand: 부모 불러오기 1ex) const &#123;data: postList&#125; = await api.get(&apos;/posts?\\_expand=user&apos;) 게시물 데이터 - 자식 댓글 데이터 게시글을 기준으로 한 부모 데이터나 자식 데이터는 가져올 수 있으나부모의 부모, 자식의 자식은 가져올 수 X(이런 기능이 X) 12345678const p = new URLSearchParams();// undefinedp.append(\"id\", 1);// undefinedp.append(\"id\", 2);// undefinedp.toString();// \"id=1&amp;id=2\"","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 16일차","slug":"javascript16","date":"2019-01-30T14:39:21.093Z","updated":"2019-04-11T15:22:16.153Z","comments":true,"path":"2019/01/30/javascript16/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/30/javascript16/","excerpt":"","text":"모던 웹 서비스의 구성요소Fetch APIFetch API 웹 브라우저의 XMLHttpRequest를 대체하기 위해 만들어진 새로운 HTTP client 표준 비교적 최근에 도입되어 IE 및 구형 안드로이드 브라우저(4.x)는 지원하지 않음 Fetch Polyfill transfiler는 최신 문법을 예전 문법으로 바꿔줌(문법만 바꿔주지, 최신 기능을 과거 문법으로 사용할 수 있게 하지는 X.) 최신 브라우저 기능과 똑같이 만들어진 라이브러리 = 폴리필 ex) Array.prototype.includes(이 메소드는 ES2015나 ES2016에 추가됨. ) -&gt; 라이브러리에서는 Array.prototype.includes Proposal이라는 라이브러리를 가져다가 사용하면 됨. ex) fetch도 최신 기능인데, 이 기능을 사용하고 싶다면, fetch polyfill을 검색해서 사용하면 됨 isomorphic-fetch(https://www.npmjs.com/package/isomorphic-fetch) cf) XML 문서 json이 만들어지기 전에는 xml이 많이 쓰였음. 정보의 타입은 태그&lt;&gt;로, 내용은 &lt;&gt;안의 컨텐츠로 나타냈음 데이터를 받아와도 그 안에 있는 데이터에 접근하려면 qeurySelector로 접근해야 함.(json은 parse하면 객체로 반환되서 쉽게 접근할 수 있음) Fetch API도 Axios처럼 promise 객체를 반환함 Axios vs Fetch API Axios는 여러 편의기능(instance와 같이 설정을 재사용하거나 요청중인 연결을 취소하는 등)을 제공 다만, Axios는 내부적으로 XMLHttpRequest를 사용하고 있는데Service Worker 등의 최신 기술이 XMLHttpRequest를 지원하지 않으므로,Service Worker를 사용할 예정에 있는 프로젝트에서는 Axios 대신 Fetch API를 사용해야만 함정말 멋진 Fetch API 1234567891011121314151617181920212223// fetch(\"/data.json\")하면 promise 객체가 반환됨// .then(function(res)에서 처음으로 응답을 기다림// fetch를 쓰면 헤더가 먼저 도착. 헤더가 도착하면 =&gt; .then(function(res)&#123;&#125;코드가 실행됨fetch(\"/data.json\").then( function(res) &#123; // res instanceof Response == true. if (res.ok) &#123; // res.json()을 쓰면 응답을 한 번 더 기다려야 함 // 바디가 도착하면 =&gt; 그때, .then(function(data)&#123;&#125;이 실행됨 res.json().then(function(data) &#123; console.log(data.entries); &#125;); &#125; else &#123; console.log( \"Looks like the response wasn't perfect, got status\", res.status ); &#125; &#125;, function(e) &#123; console.log(\"Fetch failed!\", e); &#125;); Fetch API 의 가장 유용하고, 핵심적인 함수는 fetch() 함수이다.가장 간단한 형태의 fetch() 함수는 URL 을 인자로 받고 응답을 처리하기 위한 promise 를 반환한다.응답을 처리할 때 Response 객체를 이용할 수 있다. React 프로젝트에서 봤을 때, 현업에서 fetch와 axios가 반반 정도 사용되고 있음 fetch가 더 확장되서 사용될 예정임 HTTP CacheCache (무기 등의) 은닉처 은닉하다 컴퓨터 분야에서의 캐시는 (주로 접근 속도의 개선을 위해) 데이터를 미리 복사해 놓는 임시 저장소,혹은 그 임시 저장소에 데이터를 저장하는 행위를 가리킴 ‘cache’ 혹은 ‘caching’이라는 용어 자체는 특정 기술을 가리키는 것이 아니라,접근 속도를 개선하기 위해 따로 저장소를 두는 ‘방법’을 가리킴 컴퓨터의 아주 많은 부분(CPU, GPU, HDD, 네트워크, 웹, 데이터베이스…)에서 사용되고 있음 1234567- ex) 하드디스크는 자석으로 0,1을 기록함(7,200 rpm)- 메모리(RAM)에는 전기로 기록함- 하드디스크는 속도가 너무 느리니까 임시 저장소에 넣어서 기록함.- 큰 데이터가 있으면 일단 캐시로 보낸다.- cpu의 동작 속도는 일반 메모리(RAM)보다 훨씬 빠름. But 용량은 작음. - (ex) L3 캐시 메모리: 8MB, 메인 메모리: 8GB)- 프로그램을 실행시키면, 메모리 -&gt; 캐시메모리(cpu옆에 붙어있음)에 올림. 자원의 효율적 로딩을 위한 웹 표준 서버에서 가져온 자원(HTML, CSS, JS, 이미지, …)을 가까운 곳(브라우저, 혹은 다른 서버)에 저장해놓고 재사용 캐시를 할 것인지 말 것인지, 어떻게 할 것인지를 결정하는 규칙이 복잡하고, 브라우저마다 조금씩 다름 캐시를 사용하면, 원본과 사본이 달라지는 경우가 항상 생긴다. -&gt; 그에 대한 처리를 어떻게 할 것인가. ex) 원본과 사본이 달라지는 경우를 방지하기 위해서,자원을 쓸 때마다 서버에 물어보고 쓰라고 하거나 유효기간을 하루로 주거나 등등의 처리를 해줄 수 있다. Common Problem 캐시된 자원과 실제 자원의 내용이 달라지는 문제를 어떻게 해결할 것인가? Solution Expiration (만료): 정해진 시간이 지나면 캐시가 자동으로 삭제되도록 설정 Validation (검증): 서버에 요청을 보내서 캐시를 계속 사용할 수 있는지 확인 Cache 관련 헤더 Cache 범주 Conditionals 범주 Cache-Control: (요청, 응답) 캐시와 관련된 다양한 기능을 하는 지시자를 포함. no-cache, max-age가 많이 사용됨.no-cache, max-age=0 지시자는 캐시를 사용하지 않도록 하거나, 캐시를 아직도 쓸 수 있는지 검증하기 위해 사용됨(각각의 자세한 의미)(유효기간의 만료를 나타내기 위해 max-age를 사용) 123456- 자료를 통째로 보내는 게 X. 서버에서 식별자를 만들어서 예를 들어 1번을 붙임.- 브라우저가 서버에 어떤 내용이 바뀌었는지 물어볼 때, 식별자 1이라는 숫자를 서버에 보내서-&gt; 그 식별자가 바뀌었는지 서버에 물어봄- 전체 자원을 전송하지 않고도 자원이 바꿨는지를 확인할 수 있게 되는 것임- 서버에서 원본 자료가 바뀔 때마다 식별자 번호를 붙임(버전 번호처럼)- 서버에서 브라우저로 응답에 바뀐 자원과 바뀐 식별자 번호를 같이 보내줌. ETag: (응답) 캐시의 검증을 위해 사용되는 자원의 식별자.주로 자원의 해시값이 사용되나, 마지막으로 수정된 시각, 혹은 버전 넘버를 사용하기도 함 해시값을 식별자로 사용함. - [md5 Hash generator](http://www.miraclesalad.com/webtools/md5.php) - 해시(hash): 아래와 같은 특징을 갖고 있는 연산 - 1. 같은 입력을 주면 항상 같은 출력이 나온다. - 2. 입력이 조금이라도 달라지면 완전히 다른 출력이 나온다. &gt;![md5 Hash Generator]() &gt;캡쳐 해둔 이미지 경로 넣기!! - 아무리 긴 문자열의 길이가 길더라도 Hash의 길이는 같다. Expires: (응답) 캐시를 만료시킬 시각을 서버에서 명시적으로 지정 Last-Modified(응답) 원래 자료가 마지막으로 수정된 시각 If-None-Match(요청) 검증을 위해 사용됨. 이전에 저장해두었던 자원의 ETag 값을 If-None-Match 헤더의 값으로 요청에 포함시켜서 보내면,서버는 해당 경로에 있는 자원의 ETag와 비교해보고 자원의 전송 여부를 결정 ETag, If-None-Match 를 묶어서 외울 것!! 식별자가 바뀌지 않았을 경우에는 서버에서 브라우저로 응답을 보낼 때, body가 비어있는 상태로 응답함.(바뀐 내용이 없으므로) 자원이 바뀌었다면, 200 OK 상태 코드와 함께, body에 내용을 실어서 브라우저로 응답함. ETag 캐시가 가장 많이 사용된다. cf) netlify에 ETag 기능이 포함되어 있다. 12 If-Modified-Since(요청) 검증을 위해 사용됨.이전에 저장해두었던 자원의 Last-Modified 값을 If-Modified-Since 헤더의 값으로 요청에 포함시켜서 보내면,서버는 해당 경로에 있는 자원의 Last-Modified와 비교해보고 자원의 전송 여부를 결정 브라우저 실습 ctrl+shift+r or command+shift+r누르면 캐시가 지워지는 새로고침을 할 수 있다. - Cacheable Methods POST 메소드는 Cacheable 범주에 포함되기는 하지만,특별한 조건을 만족시켜야 하며 실무에서는 POST cache가 거의 사용되지 않습니다. delete, post나 fetch, put은 자원을 받아오는 메소드가 X-&gt; 서버와 브라우저가 이 메소드들에는 캐시 기능을 사용하지 X 캐시라는 건 자원을 불러오는 속도를 높이기 위해서 사용하기 때문에 서버에서 자료를 불러오는 경우(읽기)할 때즉, get메소드 등을 사용할 때 캐시를 사용할 수 있다. 캐시의 사용 브라우저는 이미 캐시를 잘 활용하도록 만들어져 있습니다. Express는 이미 캐시를 잘 활용하도록 만들어져 있습니다. Netlify는 이미 캐시를 잘 활용하도록 만들어져 있습니다.오예일단은 별다른 추가작업 없이도 편하게 캐시 기능을 사용할 수 있지만,우리가 원하는대로 캐시가 동작하지 않을 때 그 원인을 파악하기 위해 캐시 관련 헤더는 숙지해두는 것이 좋습니다.그리고 HTTP method를 용도에 맞게 사용하는 것도 중요합니다. 용도에 맞게 메소드를 사용하는 게 중요하다. 서버와 내 컴퓨터 사이에 수많은 컴퓨터가 있다. ex) 서버 - CDN(Contents delivery network) - Porxy - 내 컴퓨터 CDN 자료를 제공하기 위한 네트워크 global Application Delivery Network ex) netlify에도 CDN기능이 내장되어 있다. GraphQL ex) REST API 예시 GET/todos POST/todos GET/todos/3: 3번 글 가져오기 DELETE/todos/3: 3번 글 지우기 REST API의 단점 (보통의 경우) 각각의 자원마다 경로가 따로 있음.즉, 여러 자원이 동시에 필요한 경우에는 요청을 여러 번 보내야 함 (요청의 횟수 면에서 비효율적) (보통의 경우) 자원의 필요한 속성만 얻어올 수 없음.즉, 일부 속성의 필요하더라도 전체 속성을 가져와야만 함 (요청의 용량 면에서 비효율적) GraphQL 프론트엔드에서 쓰는 SQL이라고 보면 됨 Facebook에서 2015년 공개한 데이터 질의 언어 REST API를 대체하기 위해 만들어짐 클라이언트에서 필요한 데이터의 구조를 GraphQL 언어로 정의한 후 질의할 수 있고,서버는 그에 맞게 구조화된 데이터를 응답 서버에서는 GraphQL 질의를 해석하기 위해 별도의 해석기가 필요하며,여러 언어의 구현체가 나와있는 상태 별도의 언어라서 이 언어를 해석할 별도의 해석기가 필요한 것임 예전에는 Node.js에서만 썼지만 현재는 다 사용가능함. 우리나라의 90%는 REST API를 사용하고 있지만 10% 정도는 GraphQL을 사용함 GraphQL Github API 실습 viewer: User! viewer필드는 User타입이다. Rest API: 경로를 queryString으로 표현했음. ex) GEt.todos?title=React graphQL: 내가 어떤 자료를 원하는지 구조적으로 표현할 수 있음. graphQL는 요청 1번으로 우리가 필요로 하는 여러 정보를 한꺼번에 가져올 수 있음. 내가 필요로 하는 정보만 골라서 가져올 수 있기 때문에 용량면에서도 효율적임 apolloGraphQl 책 추천: High Performance Browser Networking의 번역본 컴퓨터 네트워크 HTTP 하부에 TCP / IP가 쓰여지고 있음 템플릿 사용하는 경우 목록 표시(똑같이 생긴 걸 여러 개 보여줘야 함) 페이지 전환 우리는 프론트엔드 개발자니까 페이지를 새로고침하지 않고,DOM API를 만져서 요소들을 넣었다 뺐다 하기 위해서 사용함","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 15일차","slug":"javascript15","date":"2019-01-28T15:13:16.694Z","updated":"2019-04-16T13:04:41.686Z","comments":true,"path":"2019/01/29/javascript15/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/29/javascript15/","excerpt":"","text":"모던 웹 서비스의 구성요소Access Token &amp; JWTJWT 실습 JWT는 서버가 만들어주는 토큰 JWT 실습 토큰 요청하기2로그인 안하면, 정보를 가져올 수 없게 get 요청을 읽기전용, 정보를 보낼때는 post로 요청! 1234567891011121314151617181920212223// 토큰 받아오기let token;axios .post(\"/auth\", &#123; username: \"fast\", password: \"campus\" &#125;) .then((res) =&gt; &#123; token = res.data.token; console.log(`token: $&#123;token&#125;`); &#125;);// axios에 post로 요청 보냄// axios.post('/auth', &#123;// username: 'fast',// password: 'campus'// &#125;).// 까지 실행하면 promise 객체가 반환됨.// 지금은 promise 객체가 비어있는 상태// .then(res =&gt; &#123;// token = res.data.token// console.log(`token: $&#123;token&#125;`)// &#125;)//then이후에 실행되면 promise 객체가 채워짐 1234567891011// 토큰으로 요청하기 1axios .get(\"/auth\", &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125; // promise에 값이 채워지면(작업이 끝나면) 할 일 &#125;) .then((res) =&gt; &#123; prettyPrint(res.data); &#125;); 토큰은 사람마다 달라야 한다. 1234567891011// 토큰으로 요청하기 2// 로그인 안하면, 정보를 가져올 수 없게 한다.axios .get(\"/some-api\", &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125; &#125;) .then((res) =&gt; &#123; prettyPrint(res.data); &#125;); 12345678910// 토큰으로 요청하기 3axios .post(\"/count\", null, &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125; &#125;) .then((res) =&gt; &#123; prettyPrint(res.data); &#125;); 토큰을 포함시키지 않고 요청을 보내면, 401 에러가 난다. postman이든 axios든 정해진 방법으로 요청을 보내면, 정보를 가져올 수 있다. 1234567891011121314// 개발자 도구에서 입력한 코드들// 토큰 받아오기let token;axios.post('/auth', &#123; username: 'fast', password: 'campus'&#125;).then(res =&gt; &#123; token = res.data.token console.log(`token: $&#123;token&#125;`)&#125;)Promise &#123;&lt;pending&gt;&#125;VM138:8 token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZhc3QiLCJpc0FkbWluIjp0cnVlLCJpYXQiOjE1NDExMjU3MTh9.FGx5UZwqhz1QY30vwoGpcVnCpQmOgVuOAQSly87maGItoken\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZhc3QiLCJpc0FkbWluIjp0cnVlLCJpYXQiOjE1NDExMjU3MTh9.FGx5UZwqhz1QY30vwoGpcVnCpQmOgVuOAQSly87maGI\" 12345678910111213// 토큰으로 요청하기 2axios.get('/some-api', &#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;)Promise &#123;&lt;pending&gt;&#125;(index):102 &#123; \"ok\": true, \"message\": \"Hello JWT!\"&#125; 12345678910111213// 토큰으로 요청하기 3axios.post('/count', null, &#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;)Promise &#123;&lt;pending&gt;&#125;(index):102 &#123; \"ok\": true, \"count\": 74&#125; Axios Instance Axios에서는 편의기능을 내장하고 있다. 위의 예제에서는 토큰이 포함된 요청을 보낼 때마다매번 config 객체(axios.get의 두 번째 인자, axios.post의 세 번째 인자)를 통해 헤더를 설정해주고 있습니다.모든 요청에 똑같은 식으로 헤더를 넣어주는 일은 번거롭고, 또 에러를 일으키기 쉽겠죠? (Don’t Repeat Yourself!) Axios는 이렇게 중복된 설정을 하지 않도록 해주는 편의도구를 제공하고 있습니다.그것을 Axios instance라고 부르는데,한 번 config 객체를 넘겨서 Axios instance를 생성하면해당 instance를 통해 보내는 요청에는 config 객체가 자동으로 설정됩니다. 1234567891011121314151617// Axios.createconst authedAxios = axios.create(&#123; // header를 여기서 설정해주면, // 인스턴스를 실행할 때마다 매번 이 헤더가 자동으로 요청을 보낼 때 포함됨 headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125;&#125;);authedAxios.get(\"/auth\").then((res) =&gt; &#123; prettyPrint(res.data);&#125;);authedAxios.get(\"/some-api\").then((res) =&gt; &#123; prettyPrint(res.data);&#125;);authedAxios.post(\"/count\").then((res) =&gt; &#123; prettyPrint(res.data);&#125;); 참고 링크 (https://blog.outsider.ne.kr/1160) react 관련 강의 하시는 velopert님 블로그 출처 url JWT에 대한 소개는 생략하고 Token이 어떻게 구성되어 있는지 간략하게 알아보겠습니다.JSON Web Token은 세 파트로 나뉘어지며, 각 파트는 점(.)에 의해 구분됩니다. 이를 테면 xxxxx.yyyyy.zzzzz 이런식입니다. Header는 토큰의 타입과 해시 암호화 알고리즘으로 구성되어 있습니다. Payload는 claim 정보를 포함하고 있습니다. userId, expire, scope 등이 여기에 해당합니다. 마지막으로 Signature는 secret key를 포함하여 암호화되어 있습니다. 일반적으로 JWT 토큰 기반의 인증 시스템은 위와 같은 프로세스로 이루어집니다. 처음 사용자를 등록할 때 Access token과 Refresh token이 모두 발급되어야 합니다. 먼저 사용자가 id와 password를 입력하여 로그인을 시도합니다. 서버는 요청을 확인하고 secret key를 통해 Access token을 발급합니다. 이후 JWT가 요구되는 API를 요청할 때는 클라이언트가 Authorization header에 Access token을 담아서 보냅니다. 서버는 JWT Signature를 체크하고 Payload로부터 user 정보를 확인해 데이터를 리턴합니다. jwt는 토큰의 한 가지 형식일 뿐이다. 다른 토큰 형식을 사용할 수 있다. 항상 똑같은 형식으로 토큰을 주고 받는 건 아니다. 세부적인 토큰 형식이나 토큰을 포함시키는 방식은 서버마다 다를 수 있다. 토큰을 어떻게 포함시켜야 하는지 서버 개발자에게 물어봐야 한다. 서버 개발자가 토큰을 어떻게 포함시킬지 설명서를 줄 것이다. 쿠키와 토큰의 차이점 인증 토큰(Authentication Token) 인증 토큰 저장소로 어떤 서버는 쿠키를 사용하는 경우 쿠키를 만들어내고 쿠키를 저장하는 것도 서버 개발자가 하는 일이다. 직접 관리하는 경우 여러 가지 방법 중 하나는 localStorage를 사용한다. But 새로고침 버튼을 누르면 정보가 날아간다. (이유: 변수에 정보를 저장했기 때문에) 쿠키는 저장소이고, 토큰은 내가 누구인지 나타내는 값을 의미한다. 토큰의 유효기간을 정하는 방법 김승하, abcd라는 토큰, 2018-11-07일 이라는 정보를 서버에 저장해 둔다. 토큰의 유효기간이 지났으면, 서버에서 토큰이 유효하지 않다는 응답을 준다. 토큰의 유효기간이 얼마 남지 않은 경우, 브라우저에 알려준다. 오랜만에 어떤 사이트에 접속하면 토큰이 유효하지 않다고 뜰 수 있다. 비동기 프로그래밍 이 작업을 해달라고 부탁하고 넘어가는 것 그리고 작업이 끝나면, 이 통에 작업 결과물을 담아줄래? Promise Promise는 ‘언젠가 끝나는 작업’의 결과값’을 담는 통과 같은 객체이다. Promise 객체가 만들어지는 시점에는 그 통 안에 무엇이 들어갈지 모를 수도 있다. 대신 then 메소드를 통해 콜백을 등록해서, 작업이 끝났을 때 결과값을 가지고 추가 작업을 할 수 있다. Promise 객체를 생성하는 가장 쉬운 방법은 Promise.resolve 정적 메소드를 사용하는 것이다. 1const p = Promise.resolve(1); 위 코드에서 1이라는 결과값을 갖는 Promise 객체를 생성했다. 그러나 이 코드는 비동기 작업을 하고 있지는 않다. 비동기 작업을 하는 Promise객체는 Promise생성자를 통해 만들 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 생성자 Promise에 new를 붙여줘서 인스턴스를 생성한다.// new Promise할 때는, 값을 반환하기 위해 resolve를 사용함// then을 쓸 때는 그냥 return해주면 된다.// 브라우저에 부탁할 수도 있지만,// resolve: 작업이 성공했을 때 실행할 것// reject: 작업이 실패했을 때 에러 반환// new Promise((resolve, reject) =&gt; &#123;&#125;) 우리가 직접 Promise를 생성할 수 있다.// resolve, reject 자리에는 각각 함수가 들어온다.const p = new Promise((resolve, reject) =&gt; &#123; // 이 자리에는 동기, 비동기 코드 둘 다 올 수 있다. setTimeout(() =&gt; &#123; // 2초 뒤에 작업큐에 등록됨. -&gt; 호출 스택으로 옮겨져서 실행됨 console.log('2초가 지났습니다.'); // resolve('hello'); // 작업이 성공했을 때 hello라는 문자열이 promise통에 들어감. // 그때! 작업큐에 then메소드로 등록해둔 콜백이 작업큐에 들어감. resolve('hello'); &#125;, 2000);&#125;);// p.then(msg =&gt; &#123;// console.log(msg); // hello// &#125;)이 표현식의 결과도 promise객체를 반환한다.// 함수 매개변수 이름인 msg는 내 마음대로 바꿔도 됨. But 사람들이 보통 많이 쓰는 msg로 썼음// 그 전의 promise통이 채워지면, 그때! 작업큐에 이 콜백이 등록된다.p.then(msg =&gt; &#123; console.log(msg); // hello // 윗 줄의 promise통이 채워지면, 그때 이 then메소드에 있는 콜백 함수가 등록되고, // 이 promise통이 채워지면, 다음 then메소드가 실행된다.&#125;).then((=&gt; &#123; ...&#125;)).then((=&gt; &#123; ...&#125;)).then((=&gt; &#123; ... //에러가 발생하면 catch라는 메소드가 실행됨&#125;)).catch(err =&gt; &#123;&#125;)// then메소드를 쓰면, 값이 채워졌을 때 실행할 코드를 등록할 수 있다.// 실행 순서: 먼저 Promise통이 생기고,// p.then 안에 있는 console.log(msg)가 실행된 후, Promise안에 있는 코드가 실행됨 then 메소드에는 아주 중요한 특징이 있는데, 바로 then 메소드 자체도 Promise 객체를 반환한다는 것입니다.이 때, 콜백에서 반환한 값이 곧 Promise의 결과값이 됩니다. then메소드를 사용하면 연이어 실행할 콜백 함수를 중첩해서 쓰지 않고(cf) 장풍 날리는 그림)깔끔하게 콜백 함수를 쓸 수 있다. 이어붙이는 과정을 체이닝이라고 한다. then 메소드에는 아주 중요한 특징이 있는데, 바로 then 메소드 자체도 Promise 객체를 반환한다는 것입니다.이 때, 콜백에서 반환한 값이 곧 Promise의 결과값이 됩니다. 반환값이 다음 promise에 채워진다. 만일, 반환값이 promise라면(통 자체를 넘기면) -&gt; 그 통을 열어서 안에 있는 내용물이 다음통에 들어간다. 15번 예제 코드(delya-promise-exmaple)는 슬랙에 강사님이 올려주시면, 붙여넣기! 이제 HTTP 통신을 할 때 Promise가 어떻게 사용되는지 살펴보겠습니다.아래에 사용된 axios는 JavaScript를 통해 직접 요청을 보내기 위해 널리 사용되는 라이브러리입니다.GET 메소드로 요청을 보내기 위해 axios.get() 함수를 사용할 수 있는데, 이 때 Promise 객체가 반환됩니다. 1234567891011// 반환된 값이 promise 객체임const axios = require(\"axios\");const API_URL = \"https://api.github.com\";axios .get(`$&#123;API_URL&#125;/repos/facebookincubator/create-react-app/issues?per_page=10`) .then((res) =&gt; &#123; console.log(\"최근 10개의 이슈:\"); res.data.map((issue) =&gt; issue.title).forEach((title) =&gt; console.log(title)); console.log(\"출력이 끝났습니다.\"); &#125;); 9번 예제와 17번 예제가 같은 동작을 하는 코드임 promise의 핵심은 비동기 작업을 값으로 변환했다는 것이다. 비동기 작업을 값으로 바꾸면, 9번 예제 - 콜백으로 하는 방법 17번 예제 - promise 이용 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const API_URL = \"https://api.github.com\";const starCount = &#123;&#125;;const axios = require(\"axios\");// 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다.axios .get( `$&#123;API_URL&#125;/search/repositories?q=language:javascript&amp;sort=stars&amp;per_page=1` ) // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다. .then((res) =&gt; axios.get( `$&#123;API_URL&#125;/repos/$&#123;res.data.items[0].full_name&#125;/contributors?per_page=5` ) ) // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다. .then((res) =&gt; &#123; // ps는 promise로 이루어진 배열 const ps = res.data.map((user) =&gt; axios.get(`$&#123;API_URL&#125;/users/$&#123;user.login&#125;/starred?per_page=10`) ); return Promise.all(ps); &#125;) // promise를 이용함 .then((ress) =&gt; Promise.all(ress.map((r) =&gt; r.data))) // 아래의 코드처럼 콜백으로만 나타냈을 때는 엄청 길고 복잡함 // if (repoArrs.length === 5) &#123; // for (let repoArr of repoArrs) &#123; // for (let repo of repoArr) &#123; // if (repo.full_name in starCount) &#123; // starCount[repo.full_name]++; // &#125; else &#123; // starCount[repo.full_name] = 1; // &#125; // &#125; // &#125; // console.log(starCount); // &#125; // &#125;); // &#125; // 와 같은 코드임 // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다. .then((repoArrs) =&gt; &#123; for (let repoArr of repoArrs) &#123; for (let repo of repoArr) &#123; if (repo.full_name in starCount) &#123; starCount[repo.full_name]++; &#125; else &#123; starCount[repo.full_name] = 1; &#125; &#125; &#125; console.log(starCount); &#125;);console.log(\"fetching...\"); then 메소드보다 더 밑에 있는 문법을 더 자주 사용함 비동기 함수 (Async Function) C#에 있는 async라는 문법을 빌려옴(ES2017에서 도입됨) 비동기 함수(async function)를 사용하면,동기식 코드와 거의 같은 구조를 갖는 비동기식 코드를 짤 수 있다. async 키워드를 붙이면, 이 함수는 비동기 함수가 된다. 12345678910111213141516// 비동기 함수async function func1() &#123; // ...&#125;// 비동기 화살표 함수const func2 = async () =&gt; &#123; // ...&#125;;// 비동기 메소드class MyClass &#123; async myMethod() &#123; // ... &#125;&#125; 비동기 함수는 항상 Promise 객체를 반환한다는 특징을 갖습니다.이 Promise의 결과값은 비동기 함수 내에서 무엇을 반환하느냐에 따라 결정되며,then 메소드와 똑같은 방식으로 동작합니다. 안에서 return을 하든 안하든 항상 Promise 객체를 반환한다.(cf) Generate 함수는 iterator객체를 항상 반환함)(함수에 반환하는 코드를 쓰든 안쓰든) 12345678910111213async function func1() &#123; &gt; 질문: 통이 언제 만들어지는것인지????? return 1;&#125;async function func2() &#123; // 2가 채워진 통을 바로 생성하는 문법 return Promise.resolve(2);&#125;// func1()은 1이 들어있는 promise 객체func1().then(console.log); // 1// func2()는 2가 채워져있는 promise 객체func2().then(console.log); // 2 또 하나의 중요한 특징은 비동기 함수 내에서 await 키워드를 쓸 수 있다는 것입니다.await는 Promise의 then 메소드와 유사한 기능을 하는데,await 키워드 뒤에 오는 Promise가 결과값을 가질 때까지 비동기 함수의 실행을 중단시킵니다.여기서의 ‘중단’은 비동기식이며, 브라우저는 Promise가 완료될 때까지 다른 작업을 처리할 수 있습니다. await는 연산자이기도 하며, await 연산의 결과값은 뒤에 오는 Promise 객체의 결과값이 됩니다. 앞서 then 메소드를 사용했던 예제와 아래의 예제를 비교해보세요. 1234567891011121314151617181920212223// Promise 객체를 반환하는 함수.function delay(ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`$&#123;ms&#125; 밀리초가 지났습니다.`); resolve() &#125;, ms); &#125;);&#125;async function main() &#123; // 실행시키다가 promise통에 값이 채워질 때까지 기다리다가 // 값이 채워지면 실행const str1 = await delay(1000. 'hello');// await는 연산자임. 이 함수를 실행시킬 때 1초 뒤에 hello라는 값이 str1에 들어감.console.log(str1);const str2 = await delay(2000, 'world'); const result = await Promise.resolve('끝'); console.log(result);&#125;main(); await를 이용하면 기다렸다가 함수를 실행할 수 있다. await의 역할 2가지 promise가 값이 채워질 때까지 기다리는 것 promise 안의 결과값을 반환하는 것 비동기 함수의 가장 큰 장점은 동기식 코드를 짜듯이 비동기식 코드를 짤 수 있다는 것입니다.아래 예제는 Github 데이터를 불러오는 예제를 비동기 함수를 사용해 다시 작성한 것입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041// 21번 예제 코드가 3가지 방법중에 가장 간단// 9, 17, 21번 예제 코드 비교const axios = require(\"axios\");const API_URL = \"https://api.github.com\";async function fetchStarCount() &#123; const starCount = &#123;&#125;; // 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다. const topRepoRes = await axios.get( `$&#123;API_URL&#125;/search/repositories?q=language:javascript&amp;sort=stars&amp;per_page=1` ); // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다. const topMemberRes = await axios.get( `$&#123;API_URL&#125;/repos/$&#123; topRepoRes.data.items[0].full_name &#125;/contributors?per_page=5` ); // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다. const ps = topMemberRes.data.map((user) =&gt; axios.get(`$&#123;API_URL&#125;/users/$&#123;user.login&#125;/starred?per_page=10`) ); const starredReposRess = await Promise.all(ps); const starredReposData = starredReposRess.map((r) =&gt; r.data); // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다. for (let repoArr of starredReposData) &#123; for (let repo of repoArr) &#123; if (repo.full_name in starCount) &#123; starCount[repo.full_name]++; &#125; else &#123; starCount[repo.full_name] = 1; &#125; &#125; &#125; return starCount;&#125;fetchStarCount().then(console.log); then 메소드를 사용한 버전과 비교했을 때,비동기 작업을 위해 콜백을 사용하는 부분이 모두 사라졌습니다. await 키워드는 for, if와 같은 제어 구문 안에서도 쓰일 수 있기 때문에,then 메소드를 사용할 때보다 복잡한 비동기 데이터 흐름을 아주 쉽게 표현할 수 있다는 장점이 있습니다.다만, 비동기 함수 역시 Promise를 사용하기 때문에, 비동기 함수를 잘 쓰기 위해서는 여전히 Promise에 대해 잘 알고 있어야 합니다. 비동기 함수는 await 도중 에러가 났을 때 이를 편하게 처리할 수 있는 방법도 지원하는데,이에 대해서는 예외 처리 챕터에서 자세히 살펴보겠습니다. Generate 함수로도 비동기 처리를 할 수 있다. promise가 나오고 async,await가 나오기 전 그 사이에 Generate 함수로 비동기 프로그래밍을 구현했었다. 12345678910111213141516171819202122232425262728293031323334353637383940const co = require(\"co\");const axios = require(\"axios\");const API_URL = \"https://api.github.com\";function* fetchStarCount() &#123; const starCount = &#123;&#125;; // 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다. const topRepoRes = yield axios.get( `$&#123;API_URL&#125;/search/repositories?q=language:javascript&amp;sort=stars&amp;per_page=1` ); // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다. const topMemberRes = yield axios.get( `$&#123;API_URL&#125;/repos/$&#123; topRepoRes.data.items[0].full_name &#125;/contributors?per_page=5` ); // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다. const ps = topMemberRes.data.map((user) =&gt; axios.get(`$&#123;API_URL&#125;/users/$&#123;user.login&#125;/starred?per_page=10`) ); const starredReposRess = yield Promise.all(ps); const starredReposData = starredReposRess.map((r) =&gt; r.data); // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다. for (let repoArr of starredReposData) &#123; for (let repo of repoArr) &#123; if (repo.full_name in starCount) &#123; starCount[repo.full_name]++; &#125; else &#123; starCount[repo.full_name] = 1; &#125; &#125; &#125; return starCount;&#125;co(fetchStarCount).then(console.log); 어떤 회사에서는 Async와 await가 아니라일부러 Generate함수와 yield를 사용하는 경우가 있다. 그 이유는, Generate 함수로 비동기 프로그래밍을 구현하면,yield를 이용해서 일시정지 구간을 개발자가 세밀하게 컨트롤할 수 있어서이다. 개발자의 영어 문서 읽는 습관의 중요성 opensource 기술들이 특히 다 영어로 되어있음. angular는 구글에서 만든 것임 react는 여러 가지 조합을 해서 써야 함.(그 여러가지는 대개 오픈소스이고 그 오픈소스는 다 영어로 되어있음.) 단어 단위로라도 영어로 된 공식 문설르 읽어야 정확하게 개발할 수 있다. 파파고 등을 이용해서 최대한 번역해서라도 읽기 Developer들이 쓰는 어투가 있다. 개발 문서들이 쓰는 단어가 다 비슷하다. 공식 문서 영어로 된 문서를 하루에 10~20분 정도 매일 투자해서 읽기 -&gt; 영어 표현 정리해두기 원본 공식 문서를 읽고 쓸 수 있으면 연봉이 달라진다. 새로운 기술을 빠르고 정확하게 사용할 수 있기 때문에 예제 코드만 잘 읽어도 사용법을 알 수 있다. axios(config) axops는 config라는 객체를 받는다. 123456789// Send a POST requestaxios(&#123; method: \"post\", url: \"/user/12345\", data: &#123; firstName: \"Fred\", lastName: \"Flintstone\" &#125;&#125;); axios(url[, config]) 개발문서에 대괄호[]가 나오면, 배열이 X. []는 생략 가능하다는 뜻으로 널리 사용되는 표기법임. []안에 있는 내용은 써도 되고 안 써도 된다. axios에 config객체를 넣어도, 안 넣어도 잘 작동한다는 의미임 12// Send a GET request (default method)axios(\"/user/12345\"); Request method aliases aliase는 별명이라는 뜻임 For convenience aliases have been provided for all supported request methods. 1234567891011axios.request(config)axios.get(url[, config])// 설정 객체는 생략할 수 있다.- axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])- axios.post(url[, data[, config]])// : 1. url만// 2. url, data 이 2가지를 넘겨줄 수 있다.// 3. url, data, config를 넘겨줄 수 있다.axios.put(url[, data[, config]])- axios.patch(url[, data[, config]]) get과 post의 넘겨주는 객체가 다르다는 걸 기억! Request Config These are the available config options for making requests.Only the url is required. Requests will default to GET if method is not specified. 1234567// `params` are the URL parameters to be sent with the request // Must be a plain object or a URLSearchParams object ... params: &#123; ID: 12345 &#125;, ... Response Schema The response for a request contains the following information. 응답의 본문, 헤더, 상태 코드를 다 볼 수 있는 방법이 있다. json-server는 Node.js로 만들어져 있음 -&gt; npm install로 설치할 수 있음 json-server는 json파일만 만들면 서버를 띄울 수 있다. json-server는 로그인 기능이 X json-server 토큰을 암호화하기 위한 문자열이 필요하다 암호화를 위한 환경변수 설정이 필요 환경변수 설정하기 토큰을 생성할 때 사용할 비밀 키를 JWT_SECRET 환경변수로 설정해주어야 합니다. 혹은 .env 파일을 통해서 비밀 키를 설정해줄 수도 있습니다.프로젝트 폴더에 .env 파일을 생성하고 아래와 같이 작성해주세요. 1JWT_SECRET = mysecret; 내 생각대로 서버가 동작하는지 서버 사용하는 코드를 작성 후에는 postman으로 꼭 확인해보기 Single Source of Truth 상태를 저장하는 저장소가 여러 개 있는 경우에는 상태가 불일치하는 문제가 생길 수 있다. -&gt; 따라서 믿을 수 있는 상태 저장소는 딱 하나만 두는 게 좋다. 이런 원칙을 Single source of Truth 진리의 유일한 원천.이라고 한다. 그래야 동기화가 잘 됨 매번 Single Source로부터 상태를 가져와서 매번 그려주는 게 좋다. -&gt; 동기화해서 변경사항을 적용하고 버그를 줄일 수 있다. 실시간 웹 slack이나 trello같은 사이트 -&gt; 다른 사람이 글 올리면 실시간으로 바로 볼 수 있음 실시간 웹을 구현하기 위해 사용할 수 있는 기능이 여러가지 있는데, 그 중에 한 가지가 ‘웹소켓’이다. 웹소켓을 쓰면, 내가 요청을 보내지 않아도 응답을 받을 수 있다.(cf) 그냥 http를 쓰면 내가 요청을 보내야만 응답을 받을 수 있다.) 웹소켓 연결이 맺어져 있으면 실시간으로 변경 사항이 반영됨","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 14일차","slug":"javascript14","date":"2019-01-27T16:59:12.654Z","updated":"2019-04-11T15:22:15.963Z","comments":true,"path":"2019/01/28/javascript14/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/28/javascript14/","excerpt":"","text":"클래스 프로토타입은 기능을 재사용하기 위해서 사용한다. 클래스는 객체가 공유해서 써야 하는 기능들을 모아둔다. 클래스 상속 (Class Inheritance) 클래스 상속(class inheritance, subclassing) 기능을 통해한 클래스의 기능을 다른 클래스에서 재사용할 수 있다. 1234567class Parent &#123; // ...&#125;class Child extends Parent &#123; // ...&#125; 위 코드에서, extends 키워드를 통해 Child 클래스가 Parent 클래스를 상속했다.이 관계를 보고 ‘부모 클래스-자식 클래스 관계’혹은 ‘슈퍼 클래스(superclass)-서브 클래스(subclass) 관계’라고 말하기도 한다. 어떤 클래스 A가 다른 클래스 B를 상속받으면, 다음과 같은 일들이 가능해진다. 자식 클래스 A를 통해 부모 클래스 B의 정적 메소드와 정적 속성을 사용할 수 있다. 부모 클래스 B의 인스턴스 메소드와 인스턴스 속성을 자식 클래스 A의 인스턴스에서 사용할 수 있다. 12345678910111213141516171819class Parent &#123; static staticProp = \"staticProp\"; static staticMethod() &#123; return \"I'm a static method.\"; &#125; instanceProp = \"instanceProp\"; instanceMethod() &#123; return \"I'm a instance method.\"; &#125;&#125;class Child extends Parent &#123;&#125;console.log(Child.staticProp); // staticPropconsole.log(Child.staticMethod()); // I'm a static method.const c = new Child();console.log(c.instanceProp); // instancePropconsole.log(c.instanceMethod()); // I'm a instance method. super 앞서 봤듯이, 자식 클래스에서 부모 클래스의 정적 속성과 인스턴스 속성에 접근할 수 있었다.하지만, 자식 클래스에 같은 이름의 속성을 정의한 경우 문제가 생긴다. 12345678910111213141516class Melon &#123; // 인스턴스 메소드 getColor() &#123; return \"제 색깔은 초록색이다.\"; &#125;&#125;class WaterMelon extends Melon &#123; // 인스턴스 메소드 getColor() &#123; return \"속은 빨강색이다.\"; &#125;&#125;const waterMelon = new WaterMelon();waterMelon.getColor(); // 속은 빨강색이다. 메소드 오버라이딩: 부모 클래스의 기능을 확장해서 사용하고 싶은 경우,일부러 부모 클래스의 메소드와 같은 이름으로 메소드를 만들어서 사용한다. 이런 경우에, super 키워드를 통해 부모 클래스의 메소드에 직접 접근할 수 있다. 1234567891011121314class Melon &#123; getColor() &#123; return \"제 색깔은 초록색이다.\"; &#125;&#125;class WaterMelon extends Melon &#123; getColor() &#123; return super.getColor() + \" 하지만 속은 빨강색이다.\"; &#125;&#125;const waterMelon = new WaterMelon();waterMelon.getColor(); // 제 색깔은 초록색이다. 하지만 속은 빨강색이다. super 키워드의 동작 방식은 다음과 같다. 생성자 내부에서 super를 함수처럼 호출하면, 부모 클래스의 생성자가 호출된다. 정적 메소드 내부에서는 super.prop과 같이 써서 부모 클래스의 prop 정적 속성에 접근할 수 있다. 인스턴스 메소드 내부에서는 super.prop과 같이 써서 부모 클래스의 prop 인스턴스 속성에 접근할 수 있다. 123456789101112131415161718192021222324252627282930313233class Person &#123; constructor(&#123; name, age &#125;) &#123; this.name = name; this.age = age; &#125; introduce() &#123; return `제 이름은 $&#123;this.name&#125;이다.`; &#125;&#125;class Student extends Person &#123; // 분해 대입과 나머지 속성 // grade = 3, rest에는 객체가 들어감. 그 객체에는 name: '윤아준', age: 19가 들어있음 constructor(&#123; grade, ...rest &#125;) &#123; // 부모 클래스의 생성자를 호출할 수 있다. super(rest); this.grade = grade; &#125; introduce() &#123; // 부모 클래스의 `introduce` 메소드를 호출할 수 있다. return super.introduce() + ` 저는 $&#123;this.grade&#125;학년이다.`; &#125;&#125;// this는 그때 그때 다른 걸 가리킬 수 있다.const p = new Person(&#123; name: \"신하경\", age: 20 &#125;);p.introduce();const q = new Person(&#123; name: \"신하경\", age: 20 &#125;);p.introduce();const s = new Student(&#123; grade: 3, name: \"윤아준\", age: 19 &#125;);s.introduce(); // 제 이름은 윤아준이다. 저는 3학년이다. 클래스 상속과 프로토타입 상속 클래스 상속은 내부적으로 프로토타입 상속 기능을 활용하고 있다. 아래 코드의 클래스 상속에 대한 프로토타입 체인을 그림으로 나타내보면 다음과 같이 된다. 123class Person &#123;&#125;class Student extends Person(&#123;&#125;const student = new Student(); 이와 같이 부모 클래스의 메소드와 이름이 같은 메소드를 자식 클래스에정의하는 것을 보고 메소드 오버라이딩(method overriding)이라고 한다. 자바스크립트에서 클래스는 부모를 하나만 줄 수 있다. (다중 상속이 불가능하다.) 큐, 스택, 트리 어떤 데이터의 구체적인 구현 방식은 생략한 채,데이터의 추상적 형태와 그 데이터를 다루는 방법만을 정해놓은 것을 가지고ADT(Abstract Data Type) 혹은 추상 자료형이라고 한다. 이 챕터에서는 널리 사용되는 ADT인 큐, 스택, 트리에 대해 배운다. 큐 (Queue) 큐(Queue)는 한 줄의 파이프라고 생각하면 된다. 데이터를 집어넣을 수 있는 선형(linear) 자료형이다. 먼저 집어넣은 데이터가 먼저 나온다. 이 특징을 줄여서 FIFO(First In First Out)라고 부른다. 데이터를 집어넣는 enqueue, 데이터를 추출하는 dequeue 등의 작업을 할 수 있다. JavaScript에서는 배열을 이용해서 간단하게 큐를 구현할 수 있다. 1234567891011121314151617class Queue &#123; constructor() &#123; this._arr = []; &#125; enqueue(item) &#123; this._arr.push(item); &#125; dequeue() &#123; return this._arr.shift(); &#125;&#125;const queue = new Queue();queue.enqueue(1);queue.enqueue(2);queue.enqueue(3);queue.dequeue(); // 1 큐는 순서대로 처리해야 하는 작업을 임시로 저장해두는 버퍼(buffer)로서 많이 사용된다. ex) 스트리밍을 할 때, 임시저장소(buffer)에서 대개 큐(Queue)가 사용된다. 스택(Stack) 스택(stack)은 다음과 같은 성질을 갖는 자료형이다. 데이터를 집어넣을 수 있는 선형(linear) 자료형이다. 나중에 집어넣은 데이터가 먼저 나온다. 이 특징을 줄여서 LIFO(Last In First Out)라고 부릅니다. 데이터를 집어넣는 push, 데이터를 추출하는 pop, 맨 나중에 집어넣은 데이터를 확인하는 peek 등의 작업을 할 수 있다. JavaScript에서는 배열을 이용해서 간단하게 스택을 구현할 수 있다. 1234567891011121314151617181920class Stack &#123; constructor() &#123; this._arr = []; &#125; push(item) &#123; this._arr.push(item); &#125; pop() &#123; return this._arr.pop(); &#125; peek() &#123; return this._arr[this._arr.length - 1]; &#125;&#125;const stack = new Stack();stack.push(1);stack.push(2);stack.push(3);stack.pop(); // 3 스택은 서로 관계가 있는 여러 작업을 연달아 수행하면서 이전의 작업 내용을 저장해 둘 필요가 있을 때 널리 사용된다. ex) ctrl + z 되돌리기 기능을 스택을 이용해서 만든다. import를 입력한다. i를 입력했다면, i를 저장했다는 사실이 스택에 저장된다. m를 입력했다면, m를 저장했다는 사실이 스택에 저장된다. p를 입력했다면, p를 저장했다는 사실이 스택에 저장된다. 지우는건 p부터 지운다. (스택에서는 나중에 들어온 p가 먼저 나온다. -&gt; 먼저 지워진다. ) 트리 (Tree) 트리(tree)는 여러 데이터가 계층 구조 안에서 서로 연결된 형태를 나타낼 때 사용된다. 부모-자식 관계가 있는 구조를 트리라고 부른다. 비동기 프로그래밍 한 번에 촥~ 실행되는 게 아니라시간을 나눠서 조금씩 실행되는 프로그래밍을 비동기 프로그래밍이라고 한다. 순서 뿐만 아니라 시간에 대해서도 생각해야 한다. Motivation - 타이머 API 웹 브라우저에는 함수를 특정 시간이 지난 뒤에 실행시키거나,혹은 함수를 주기적으로 실행시키는 작업을 할 수 있게 해 주는 함수가 내장되어 있다. 12345678setTimeout(() =&gt; &#123; console.log(\"setTimeout이 실행된 지 2초가 지났습니다.\");&#125;, 2000);// 특정 간격마다 주기적으로 실행setInterval(() =&gt; &#123; console.log(\"3초마다 출력된다.\");&#125;, 3000); setTimeout과 setInterval은 각각 타이머 식별자를 반환한다. 이 식별자를 가지고 실행 중인 타이머를 취소할 수 있다. setTimeout - clearTimeout setInterval - clearInterval 123456789101112const timeoutId = setTimeout(() =&gt; &#123; console.log(\"setTimeout이 실행된 지 2초가 지났습니다.\");&#125;, 2000);const intervalId = setInterval(() =&gt; &#123; console.log(\"3초마다 출력된다.\");&#125;, 3000);clearTimeout(timeoutId);clearInterval(intervalId);// 아무것도 출력되지 않습니다. 타이머 사용 시 주의할 점 setTimeout과 setInterval은 정확한 지연시간을 보장해 주지 않는다. 1234567const start = new Date();setTimeout(() =&gt; &#123; console.log(new Date() - start);&#125;, 100);// 실제 지연시간과 약간의 차이가 존재한다. 주식 거래나 게임 같은 경우에는 자바스크립트를 사용하지 않는다. 아주 빠르게 반응하는 c언어 같은 언어를 사용해야 한다. 또한 지연시간을 0으로 주었을 때는 코드가 기대한대로 동작하지 않는다.setTimeout 호출 시 지연시간으로 0을 넘기면 어떻게 되는지 확인해보자. 1234567891011// 지연시간을 0으로 준다고 해서 코드가 바로 실행이 되지 않는다.// -&gt; 코드 실행 순서가 뒤죽박죽이 된다.setTimeout(() =&gt; &#123; console.log(\"hello\");&#125;, 0);console.log(\"world\");// 출력 결과:// world// hello 분명 지연시간을 0으로 주었는데도 코드가 뒤늦게 실행되었다.어떻게 된 일일까?이를 이해하기 위해서는 먼저 브라우저에서 JavaScript 코드가 실행되는 과정을 알아야 할 필요가 있다. 브라우저의 JavaScript 코드 실행 과정호출 스택 (Call Stack) 호출 스택(call stack)은 스택 형태의 저장소로,JavaScript 엔진은 함수 호출과 관련된 정보를 이 곳에서 관리한다. 1234567891011121314function add(x, y) &#123; return x + y;&#125;function add2(x) &#123; return add(x, 2); // `add`를 호출&#125;function add2AndPrint(x) &#123; const result = add2(x); // `add2`를 호출 console.log(result); // `console.log`를 호출&#125;add2AndPrint(3); // `add2AndPrint`를 호출 호출 스택에 저장되는 각 항목을 실행 맥락(execution context)이라고 부른다.실행 맥락에는 아래와 같은 정보들이 저장된다. 함수 내부에서 사용되는 변수 - 스코프 체인 - this가 가리키는 객체 브라우저가 JavaScript 코드를 실행시킬 때, 호출 스택을 다음과 같이 조작한다. 스크립트를 불러올 때, 전역 실행 맥락(global execution context)을 호출 스택에 추가한다. 함수가 호출되면, 해당 호출에 대한 실행 맥락을 생성해서 호출 스택에 추가(push)한다. 변수에 대입이 일어나면, 호출 스택에 저장되어 있는 변수의 내용을 변경한다. 함수의 실행이 끝나면, 결과값을 반환하고 호출 스택 가장 위에 있는 실행 맥락을 제거(pop)한다. 스크립트의 실행이 모두 끝나면, 전역 실행 맥락을 호출 스택에서 제거(pop)한다. 이를 통해, 변수에 값을 대입한다거나,함수가 여러 번 중첩되어 호출되는 등의 복잡한 코드의 동작을 단순한 자료구조로 표현할 수 있게 된다. 웹 브라우저는 호출 스택에 실행 맥락이 존재하는 동안,즉 실행 중인 함수가 존재하는 동안에는 먹통이 되어 버린다. 브라우저는 대개 60fps로 동작하기 때문에,대략 16ms 안에 코드의 실행을 완료하지 못하면 브라우저의 애니메이션이 뚝뚝 끊기는 현상이 나타난다.이는 사용자 경험에 악영향을 미칠 수 있다. 123456789101112// 특정 시간동안 계속 루프를 도는 코드function sleep(milliseconds) &#123; // Data.now()는 유닉스 시간 const start = Date.now(); // Data.now()가 실행된 시점의 유닉스 시간(이거는 안 바뀌는 것임) //- 현재 Data.now()실행한 유닉스 시간(시간이 흘렀으니까 start보다는 큰 숫자를 반환함) // while (10, 20, 30........ &lt; 5000) while (Date.now() - start &lt; milliseconds);&#125;sleep(5000);// 5초 동안 while 루프가 실행되므로, 호출 스택이 비워지지 않고 브라우저는 먹통이 된다. 따라서, 브라우저에서 동작하는 JavaScript 코드,특히 사용자와의 상호작용을 위한 코드를 작성할 때에는코드의 실행 시간이 얼마나 될지를 항상 염두에 두어야 한다. 작업 큐 (Task Queue) 하지만 모든 작업을 16ms 안에 처리할 수는 없습니다.어떤 사건(event)이 일어날 때까지 기다리거나, 혹은 큰 데이터에 대한 계산이 완료될 때까지기다리는 데에는 시간이 오래 걸리기 마련이다. 이런 경우, 브라우저에서는 다음과 같은 절차를 통해 오래 기다려야 하는 일을 처리할 수 있다. 기다려야 하는 일을 JavaScript 엔진에서 직접 처리하는 것이 아니라 API를 통해 브라우저에 위임한다.이 때, 일이 끝나면 실행시킬 콜백을 같이 등록한다. 위임된 일이 끝나면, 그 결과와 콜백을 작업 큐(task queue)에 추가한다. JavaScript 엔진은 호출 스택이 비워질 때마다작업 큐에서 가장 오래된 작업을 꺼내와서 해당 작업에 대한 콜백을 실행시킨다.브라우저는 이 과정을 끊임없이 반복하는데, 이를 이벤트 루프(event loop)라고 부릅니다. JavaScript 코드를 작성할 때에는, 호출 스택과 작업 큐의 성질을 반드시 염두에 두어야 한다. 각 작업은 작업 큐에 쌓인 순서대로 실행된다. 이미 작업 큐에 작업이 쌓여있다면, 뒤늦게 추가된 작업은 앞서 추가된 작업이 모두 실행된 다음에,즉 호출 스택이 비워진 다음에야 실행된다. 호출 스택이 비워지지 않는다면, 작업 큐에 쌓여있는 작업을 처리할 수 없습니다. 각 작업 사이에 브라우저는 화면을 새로 그릴 수 있다.즉, 호출 스택이 비워지지 않는다면 브라우저는 화면을 새로 그릴 수 없습니다. 12345678910setTimeout(() =&gt; &#123; console.log(\"hello\");&#125;, 0); // 작업 큐에 콜백이 추가됨// 콜백은 () =&gt; &#123;// console.log('hello');// &#125;, 0// 를 의미함console.log(\"world\"); cf) request Animation Frame: 다음 번 화면을 그릴 때, 함수를 실행시켜달라는 함수(브라우저 내장 기능) 작업큐에 부탁하고 넘어가는 것이라는 개념을 이해할 것 비동기 프로그래밍 (Asyncronous Programming) 이처럼 어떤 일이 완료되기를 기다리지 않고 다음 코드를 실행해 나가는 프로그래밍 방식을일러 비동기 프로그래밍(asynchronous programming)이라고 한다. 반대로 어떤 일이 완료될 때까지 코드의 실행을 멈추고 기다리는 프로그래밍 방식을동기식 프로그래밍(synchronous programming)이라고 부릅니다. 브라우저에서의 비동기 프로그래밍은 주로 통신과 같이 오래 걸리는 작업들을 브라우저에 위임할 때 이루어진다. 비동기 프로그래밍 방식은 대개 프로그램의 성능과 응답성을 높이는 데에 도움을 준다. 하지만 코드가 실제로 실행되는 순서가 뒤죽박죽이 되므로, 코드의 가독성을 해치고 디버깅을 어렵게 만든다는 비판을 받아왔다. 이런 문제를 해결하기 위해 비동기 프로그래밍을 위한 여러 기법이 생겨났고,또 어떤 것들은 JavaScript 언어 자체에 포함되기도 했다. 여기에서는 근래 JavaScript 생태계에서 자주 사용되는 몇 가지 비동기 프로그래밍 기법들을 살펴 보자. 몇몇 예제 코드에서 사용한 Github REST API v3에는 API 사용량 제한이 있어서,이를 초과하면 코드 실행 중에 에러가 날 수도 있다. 이 때에는 한 시간 정도 흐른 뒤에 다시 코드를 실행해보자. 콜백 (Callback) 콜백은 다른 함수의 인수로 넘기는 함수를 말하는데, 이 콜백을 가지고 비동기 프로그래밍을 할 수 있다. 아래 예제는 유명한 JavaScript 라이브러리인 jQuery를 이용해,Github의 create-react-app 프로젝트에 등록되어 있는 이슈 목록을 가져와서 출력하는 코드이다. (여기에서 코드를 직접 실행해볼 것.) 123456789101112131415const $ = require(\"jquery\");const API_URL = \"https://api.github.com/repos/facebookincubator/create-react-app/issues?per_page=10\";$.ajaxSetup(&#123; dataType: \"json\"&#125;);$.get(API_URL, (issues) =&gt; &#123; console.log(\"최근 10개의 이슈:\"); issues.map((issue) =&gt; issue.title).forEach((title) =&gt; console.log(title)); console.log(\"출력이 끝났습니다.\");&#125;);console.log(\"받아오는 중...\"); 콜백이라고 해서 항상 비동기식으로 호출되는 것은 X 콜백은 동기식 or 비동기식으로 호출된다. 예제에서 $.get 메소드의 두 번째 인수로 콜백을 넘겨주었다.$.get 메소드는 비동기식으로 동작하며, Github API 서버와 통신하는 일을 브라우저에 위임한 후 바로 종료된다.통신이 끝나면, 그 결과를 첫 번째 인수로 해서 콜백을 호출하게 된다. 여기서 주의할 것이 있다.콜백을 인수로 받는 함수가 항상 비동기식으로 동작하는 것은 아닙니다.위 예제의 map, forEach의 인수로 넘겨준 것 역시 콜백이지만,이 때에는 콜백이 동기식으로 호출된다.즉, 콜백의 실행이 끝날때까지 코드의 실행 흐름이 다음으로 넘어가지 않습니다.예제 코드를 직접 실행해본 후, 어떤 순서로 출력이 되었는지 살펴보세요. 콜백은 JavaScript가 고차함수를 잘 지원한다는 특징 때문에 가장 많이 사용되는 비동기 프로그래밍 양식이었다.하지만 콜백만으로는 복잡한 비동기 데이터 흐름를 표현하기가 어려워서 많은 프로그래머들이 힘들어했고,결국 콜백 지옥(callback hell)이라는 용어까지 생겨났습니다. 예를 들어, 아래의 흐름대로 데이터를 가져오기 위해서는 복잡한 형태로 콜백을 사용해야 한다. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각각 10개씩 불러온다. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445const $ = require(\"jquery\");const API_URL = \"https://api.github.com\";const starCount = &#123;&#125;;$.ajaxSetup(&#123; dataType: \"json\"&#125;);// 1. Github에 공개되어있는 저장소 중, 언어가 JavaScript이고 별표를 가장 많이 받은 저장소를 불러온다.$.get( `$&#123;API_URL&#125;/search/repositories?q=language:javascript&amp;sort=stars&amp;per_page=1`, (result) =&gt; &#123; // 2. 위 저장소에 가장 많이 기여한 기여자 5명의 정보를 불러온다. $.get( `$&#123;API_URL&#125;/repos/$&#123;result.items[0].full_name&#125;/contributors?per_page=5`, (users) =&gt; &#123; let repoArrs = []; for (let user of users) &#123; // 3. 해당 기여자들이 최근에 Github에서 별표를 한 저장소를 각 기여자마다 10개씩 불러온다. $.get( `$&#123;API_URL&#125;/users/$&#123;user.login&#125;/starred?per_page=10`, (repos) =&gt; &#123; repoArrs.push(repos); // 4. 불러온 저장소를 모두 모아, 개수를 센 후 저장소의 이름을 개수와 함께 출력한다. if (repoArrs.length === 5) &#123; for (let repoArr of repoArrs) &#123; for (let repo of repoArr) &#123; if (repo.full_name in starCount) &#123; starCount[repo.full_name]++; &#125; else &#123; starCount[repo.full_name] = 1; &#125; &#125; &#125; console.log(starCount); &#125; &#125; ); &#125; &#125; ); &#125;);console.log(\"fetching...\"); 위의 2, 3번 과정은 한 비동기 작업이 끝난 후 다른 비동기 작업을 시작하고 있고,이를 위해 콜백 안에서 다시 콜백을 사용하고 있다.또한 4번 과정을 실행하기 위해서는 앞서 3번 과정에서 실행된 10개의 비동기 작업이 모두 끝나는 시점을 알아야 할 필요가 있기 때문에,repoArrs 배열의 길이를 체크하고 있다. 이처럼 순수하게 콜백만 사용했을 때는, 데이터 흐름이 조금만 복잡해져도 코드가 복잡해지는 문제가 생긴다. Promise 위에서 설명한 콜백의 문제를 해결하기 위해 여러 라이브러리들이 등장했고,그 중에서 개발자들에게 널리 선택받은 것이 바로 Promise 패턴을 사용한 라이브러리들(jQuery Deffered, Q, Bluebird)이었다.이 라이브러리들이 표준화되어, 결국 ES2015에 이르러 JavaScript 언어 자체에 포함되게 되었다. Promise는 언젠가 끝나는 작업의 결과값을 담는 통과 같은 객체이다.Promise 객체가 만들어지는 시점에는 그 통 안에 무엇이 들어갈지 모를 수도 있다.대신 then 메소드를 통해 콜백을 등록해서, 작업이 끝났을 때 결과값을 가지고 추가 작업을 할 수 있다. Promise 객체를 생성하는 가장 쉬운 방법은 Promise.resolve 정적 메소드를 사용하는 것이다. 10번 예제는 보면 수강생들이 헷갈려해서 안보고 넘어감 비동기 작업을 하는 Promise 객체는 Promise 생성자를 통해 만들 수 있다. 1234567// 자바스크립트가 resolve, reject라는 함수를 준다.const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"2초가 지났습니다.\"); resolve(\"hello\"); &#125;, 2000);&#125;); Promise 생성자는 콜백을 인수로 받습니다. 이 콜백의 첫 번째 인수로 resolve 함수가 들어오는데,콜백 안에서 resolve를 호출하면 resolve에 인수로 준 값이 곧 Promise 객체의 궁극적인 결과값이 된다. 두 번째 인수로 들어오는 reject 함수는 비동기 작업에서 에러가 발생했을 때 호출하는 함수인데,여기에서는 소개만 하고 넘어가고 예외 처리 챕터에서 자세히 다루도록 할 것이다. 위 예제에서는 setTimeout을 이용해 2초가 지난 뒤에 콜백이 실행되도록 했다.즉, p 변수에 저장된 Promise 객체는 2초 동안은 결과값이 없는 상태가 된다.그리고 2초가 지나면, resolve 함수가 호출되어 p 객체는 결과값을 갖는 객체가 된다. Promise 객체의 결과값을 사용해 추가 작업을 하려면 then 메소드를 호출해야 한다.then 메소드에 콜백을 넘겨서, 첫 번째 인수로 들어온 결과값을 가지고 추가 작업을 할 수 있다. 123p.then((msg) =&gt; &#123; console.log(msg); // hello&#125;); 모던 웹 서비스의 구성요소 모던 웹 서비스의 구성요소에서 배우는 것들은 통신할 때 중요한 것들이기 때문에 반드시 알아야 함!!! 실무에서 잘 써야 함! Cookie쿠키의 필요성 개별 클라이언트의 여러 요청에 걸친 정보의 유지 장바구니 로그인/로그아웃 방문 기록… HTTP Cookie 서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보 웹 브라우저는 쿠키를 저장하기 위한 저장소를 가지고 있음 저장소는 *자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공 쿠키 전송 절차 서버는 브라우저에 저장하고 싶은 정보를 응답과 같이 실어 보낸다 (Set-Cookie 헤더) 123HTTP/1.1 200 OKSet-Cookie: cookieName=cookieValue; Secure; Max-Age=60000... 브라우저는 같은 서버에 요청이 일어날 때마다 해당 정보를 요청에 같이 실어서 서버에 보낸다 (Cookie 헤더) 123GET / HTTP/1.1Cookie: cookieName=cookieValue; anotherName=anotherValue... Set-Cookie Options(쿠키를 저장하는 서버에서) Expires, Max-Age: 쿠키의 지속 시간 설정(ex) 10분간만 로그인이 유지되는 사이트) Secure: HTTPS를 통해서만 쿠키가 전송되도록 설정 HttpOnly: 자바스크립트에서 쿠키를 읽지 못하도록 설정 자바스크립트를 통해서 Cookie를 건드리지 않는 것이 좋다. ex) 게시판을 만들었을 때, 쿠키를 읽어와서 해커에게 전송할 수도 있다. -&gt; HttpOnly 속성을 사용해서 자바스크립트에서 쿠키를 읽지 못하게 만드는 게 좋다. Domain, Path: 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한) Express + Cookie 이 내용은 강사님이 그냥 넘어가심(내용을 읽지 않고 넘어가심) Express에도 Cookie 기능이 내장되어 있다. 쿠키 읽기 - req.cookies: 요청에 실려온 쿠키가 객체로 변환되어 req.cookies에 저장됨 (cookie-parser 미들웨어 필요) 쿠키 쓰기 - res.cookie(name, value): 쿠키의 생성 혹은 수정 쿠키 예제 JavaScript + Cookie 자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다. 자바스크립트에서 쿠키에 접근하지 못하도록 HttpOnly를 항상 설정하는 것이 best practice 쿠키의 한계점 US-ASCII 밖에 저장하지 못함. 보통 percent encoding을 사용 4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못함 브라우저에 저장됨. -&gt; 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보,혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절하다. ex) 보통 이 사람이 누구인지를 쿠키에 저장함. 인증 토큰을 보통 쿠키에 저장한다. 우리는 최종 프로젝트에서는 쿠키를 사용하지 않을 것임 But 회사에 입사했을 때, 로그인 정보를 유지하는 기능을 구현할 때, 쿠키를 써야 할 수도 있음 AjaxHTTP methods 복습 자주 사용할 것: GET, POST, PUT, PATCH, DELETE CRUD C(Create) - POST (만들 때)R(Read) - GET(읽을 때)U(Update) - PUT, PATCH(수정)D(Delete) - DELETE Ajax 비동기적인 웹 어플리케이션의 제작을 위한 클라이언트 측 웹 개발 기법…을 뜻하나 요즈음은 의미가 변형되어 웹 브라우저에서 XMLHttpRequest혹은 fetch를 이용해서 보내는 HTTP 요청을 통칭하기도 함 서버에서 필요한 부분만 받아서 브라우저의 필요한 부분만 수정한다. Ajax의 장점 화면 전체를 다시 로드하지 않고도 내용을 갱신할 수 있어 더 나은 사용자 경험 제공 서버의 응답을 기다리는 동안에도 여전히 웹 어플리케이션을 사용 가능 필요한 자원만 서버에서 받아오게 되므로 트래픽이 줄어듬 Ajax의 단점 클라이언트 구현이 굉장히 복잡해짐 Ajax Library Comparison Axios Promise based HTTP client 브라우저와 Node.js에서 모두 사용 가능 XMLHttpRequest, fetch에 비해 사용하기 편하고 기능이 더 많음(브라우저 내장 기능이라서 쓰기에는 불편함이 있음) 참고글: 내가 fetch API를 쓰지 못했던 이유 Axios + json-server 예제 12345678// GETaxios .get(\"/api/todos\") // 통신이 끝나면 응답 객체를 넣어서 콜백을 실행시킨다. .then((res) =&gt; &#123; // prettyPrint는 강사님이 미리 만들어둔 함수 prettyPrint(res.data); &#125;); 1234// POST: 자료를 등록할 때 사용axios.post(\"/api/todos\", &#123; title: \"ajax 공부\" &#125;).then((res) =&gt; &#123; prettyPrint(res.data);&#125;); put, patch는 수정할 때 사용. (But 미묘하게 다름) 123456// PATCH// 보통, 수정하고 싶은 자료의 식별자를 뒤에 붙여서 주소를 만든다.// 이런 식으로 주소를 만드는 방법은 restAPI라고 한다.axios.patch(\"/api/todos/3\", &#123; title: \"axios 공부\" &#125;).then((res) =&gt; &#123; prettyPrint(res.data);&#125;); GET /api/todos/?title=reactaxios 요청 메소드의 두 번째 인자로 config 객체를 넘길 수 있다.config 객체를 통해 요청의 쿼리 스트링, 요청 헤더, 쿠키 포함 여부 등 많은 것들을 설정할 수 있다. 12345678910111213141516// config 객체axios .get(\"/api/todos\", &#123; params: &#123; // query string title: \"react 공부\" &#125;, headers: &#123; // 요청 헤더 \"X-Api-Key\": \"my-api-key\" &#125;, timeout: 1000 // 1초 이내에 응답이 오지 않으면 에러로 간주 &#125;) .then((res) =&gt; &#123; prettyPrint(res.data); &#125;); 응답 객체 응답 객체를 통해 응답의 여러 정보에 접근할 수 있다. 12345678// config.paramsaxios.get(\"/api/todos/1\").then((res) =&gt; &#123; console.log(`status code: $&#123;res.status&#125;`); console.log(\"headers:\"); prettyPrint(res.headers); console.log(\"data:\"); prettyPrint(res.data);&#125;); 쿠키를 통한 인증 예제 axios 공식 문서 CORSSame-origin Policy(동일 출처 정책) 웹페이지에서 리소스를 불러올 때,리소스의 출처가 웹페이지의 출처와 같으면 안전하다고 보고,출처가 다르면 해당 리소스는 안전하지 않다고 보는 원칙 여기서 ‘출처’란 ‘프로토콜 + 도메인 + 포트번호’의 결합을 가리킴.즉, 세 개가 다 같아야 동일 출처라고 할 수 있고, 셋 중에 하나라도 다르면 동일 출처로 간주되지 않음 웹 보안의 기본 원칙으로, 웹 브라우저의 많은 요소에 적용됨 [Same-origin Policy 실습] 1234567// 크롬 개발자 도구에서 코드 넣기&gt; const child = window.open('http://www.fastcampus.co.kr')// 새로 열린 웹 페이지의 콘솔에서&gt; window.foo = 'bar'// 이전 웹 페이지의 콘솔에서&gt; child.foo// 출처가 같다면 접근 가능, 아니면 불가 Content-Security-Policy Content-Security-Policy 헤더를 이용하면, 동일하지 않은 출처에 대한 리소스를 불러올지 말지 결정할 수 있음 CORS(Cross-Origin Resource Sharing) 클라이언트 측 cross-origin 요청을 안전하게 보낼 수 있는 방법을 정한 표준 쉽게 말하면,스크립트가 전혀 다른 출처를 갖는 API 서버를 사용하려고 하는 상황에서는뭔가 추가적인 처리를 해주어야 한다는 것! ex1) abc.com에서 abc.com/api/todos로 요청 -&gt; 브라우저가 막지 X. ex2) abc.com에서 cdf.com/api/todos로 요청 -&gt; 브라우저가 막음. 추가적인 처리를 해주어야 요청할 수 있음. Cross-origin 요청의 위험성 아래 상황을 가정해보자. mywebsite.com에서 서비스 중인 웹 사이트는 mywebsite.com/api 에서REST API를 통해 필요한 정보를 얻는다.mywebsite.com/api 경로에 대한 인증은 쿠키로 이루어지고 있다. 그런데 만약 evil.com 웹 사이트의 스크립트에서 mywebsite.com API에 요청을 마음대로 보낼 수 있다면,이미 my-website.com 도메인에 대해 브라우저에 저장된 쿠키를 이용해서 API를 마음대로 호출할 수 있을 것이다. Cross-origin 요청 예제 IE8 이상의 모던 웹 브라우저는 cross-origin 요청에 대해 여러가지 제한을 두고 있음 cross-origin 요청을 허용하려면, 서버가 특별한 형태의 응답을 전송해야 함 만약 서버가 cross-origin 요청을 허용하지 않으면, 웹 브라우저는 에러를 발생시킴 Cross-origin 요청 예제 CORS에 관여하는 응답 헤더 Access-Control-Allow-Origin Access-Control-Expose-Headers Access-Control-Max-Age Access-Control-Allow-Credentials Access-Control-Allow-Methods Access-Control-Allow-Headers CORS에 관여하는 요청 헤더 Origin Access-Control-Request-Method (preflighted 전용) Access-Control-Request-Headers (preflighted 전용) CORS - Safe, Unsafe GET, HEAD 요청은 safe(읽기 전용)이기 때문에서버에 요청이 도달한다고 해서 서버의 상태에 영향을 미칠 일은 없으므로,웹 브라우저는 일단 해당 요청을 보내본다.만약 서버가 cross-origin 요청을 허용한다고 응답하면 응답을 그대로 사용하고, 그렇지 않으면 에러를 낸다. POST, PUT, PATCH, DELETE 등의 메소드는 요청이 서버에 전송되는 것 자체가 위험하므로,실제 요청을 보내기 전에 서버가 cross-origin 요청을 허용하는지를 알아보기 위해 시험적으로 요청을 한 번 보내본다.이 요청을 preflighted request라고 한다. (단, 기존 HTML form의 동작방식인 application/x-www-form-urlencoded혹은 multipart/form-data 형태의 POST 요청은 preflighted request가 발생하지 않음) safe, unsafe 말고도 다른 원인에 의해 preflighted request가 발생하는 경우가 있는데,자세한 사항은 MDN 문서를 참고해주세요. CORS with credentials cross-origin 요청에는 기본적으로 쿠키가 포함되지 않으나,XMLHttpRequest 혹은 fetch를 통해서 요청을 보낼 때쿠키를 포함시키는 옵션을 줄 수 있고 이 때 CORS 요건이 더 엄격해짐 (Access-Control-Allow-Credentials 헤더 설정 필요, Access-Control-Allow-Origin 헤더에 와일드카드 허용 안됨) 복잡하면 그냥… 프론트엔드와 API 서버를 같은 도메인으로 제공한다. 불가피하게 둘을 다른 도메인으로 제공해야 한다면 CORS를 허용한다 (cors 미들웨어를 사용하면 간단함) CORS를 허용하는 경우, 쿠키를 쓸 수는 있으나 보안 상 허점이 생기기 쉽고 사용하기도 불편하므로보통 JWT와 같은 토큰 방식의 인증을 사용한다. Access Token &amp; JWT쿠키의 단점 쿠키를 지원하는 클라이언트에서 밖에 사용할 수 없음 적절히 관리되지 않은 쿠키는 보안에 취약하며, 관리를 하려고 해도 CORS 대응이 복잡함 Token Based Auth 토큰이란, 사용자의 자격증명(아이디, 패스워드 등)을 통해 인증이 이루어진 후,특정 자원에 대한 자격증명으로서 대신 사용되는 인증 수단 서버에 요청을 할 때마다 토큰을 요청에 직접 포함시켜서 전송 (주로 Authorization 헤더에 넣어서 전송) 보안 상 주의사항 (당연히) HTTPS를 사용해야 함 토큰을 localStorage에 저장하게 되면 자바스크립트로 토큰을 탈취할 수 있게 되므로,웹사이트에 악성 스크립트를 삽입하는 공격(XSS)에 노출되지 않도록 신경써야 함 JSON Web Token 최근 널리 사용되고 있는 토큰 형식의 표준 토큰 안에 JSON 형식으로 정보를 저장함 보안을 위해 서명 또는 암호화를 사용할 수 있음 JWT 실습(jwt.io) Cookie vs Token 토큰 사용의 장점 쿠키를 지원하지 않는 클라이언트에서도 편하게 사용할 수 있음 쿠키를 사용하지 않음으로써 CORS 관련 문제를 회피할 수 있음 토큰 사용의 단점 매 요청에 토큰이 포함되게 되므로 적당히 짧은 길이를 유지해야 함 토큰 유출에 대한 대비책이 필요 (토큰에 유효기간을 두거나, 유출된 토큰을 강제로 무효화하는 등의 방법을 사용)-&gt; 백엔드 개발자가 신경써야 하는 요소임 쿠키와는 다르게, 클라이언트 개발자가 직접 토큰을 저장하고 관리해야 함 Web Storage 브라우저에서 키-값 쌍을 저장할 수 있는 저장소 쿠키에 비해 사용하기 편리하고 저장 가능한 용량도 큼(10MB 가량) 브라우저 탭이 닫히면 내용이 삭제되는 sessionStorage,브라우저 탭이 닫혀도 내용이 유지되는 localStroage가 있음 [Web Storage 실습] - 크롬 개발자 도구에서 실습함 우리는 앞으로 로그인 유지되는 사이트만 만들 거라서 localStorage를 사용할 것임 보안 상 주의사항 (당연히) HTTPS를 사용해야 함 토큰을 localStorage에 저장하게 되면 자바스크립트로 토큰을 탈취할 수 있게 되므로,웹사이트에 악성 스크립트를 삽입하는 공격(XSS)에 노출되지 않도록 신경써야 함 JSON Web Token 최근 널리 사용되고 있는 토큰 형식의 표준 토큰 안에 JSON 형식으로 정보를 저장함 보안을 위해 서명 또는 암호화를 사용할 수 있음 JWT 실습(jwt.io)","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 13일차","slug":"javascript13","date":"2019-01-27T10:54:29.000Z","updated":"2019-04-11T15:22:15.953Z","comments":true,"path":"2019/01/27/javascript13/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/27/javascript13/","excerpt":"","text":"Express Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크 내장하고 있는 기능은 매우 적으나,미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음 Express 앱의 기본 구조12345678910111213141516171819202122232425262728293031323334353637383940// Express 인스턴스 생성// 서버를 대표하는 앱 객체const app = express();// 미들웨어 주입app.use(sessionMiddleware());app.use(authenticationMiddleware());// 미들웨어란? (출처: 위키백과)// 각기 분리된 두 개의 프로그램 사이에서,// 매개 역할을 하거나 연합시켜주는 프로그램을 말한다.// 데이터베이스와 웹서버를 연결시켜주는 것// ex1) 웹브라우저에 양식을 띄워놓고,// 이를 이용하여 데이터베이스로부터 데이터를 찾아올 수 있게 하는 것// ex2) 사용자의 요청 내용에 따라 페이지를 동적으로 나타낼 수 있게 한다.// 미들웨어는 양 쪽을 연결하여 데이터를 주고 받을 수 있도록// 중간에서 매개 역할을 하는 소프트웨어, 네트워크를 통해서// 연결된 여러 개의 컴퓨터에 있는 많은 프로세스들에게// 어떤 서비스를 사용할 수 있도록 연결해 주는 소프트웨어를 말한다.// 3계층 클라이언트/서버구조에서 미들웨어가 존재한다.// 웹 브라우저에서 데이터베이스로부터 데이터를 저장하거나 읽어올 수 있게// 중간에 미들웨어가 존재하게 된다.// 라우트 핸들러 등록// 요청이 들어왔을 때 분석해서 처리해준다.// app객체에 get방식으로 루트경로로 요청이 들어왔을 때, 일어날 일을 등록할 수 있다.// 요청에 대한 정보가 객체에 담겨서 request 자리에 들어온다.// response 객체에 응답을 담아서 브라우저에게 응답을 보낼 수 있다.app.get(\"/\", (request, response) =&gt; &#123; response.send(\"Hello express!\");&#125;);// 서버 구동// 서버에서 3000번 포트에서 코드를 실행시키고, &#123;&#125; 안의 코드인 console.log를 찍어라.app.listen(3000, () =&gt; &#123; console.log(\"Example app listening on port 3000!\");&#125;); Routing1234567891011121314151617181920// HTTP 요청 메소드(GET, POST, ...)와 같은 이름의 메소드를 사용// ex) /articles로 요청이 들어올 경우, 실행됨app.get(\"/articles\", (req, res) =&gt; &#123; res.send(\"Hello Routing!\");&#125;);// 특정 경로에만 미들웨어를 주입하는 것도 가능app.post(\"/articles\", bodyParserMiddleware(), (req, res) =&gt; &#123; database.articles.create(req.body).then(() =&gt; &#123; res.send(&#123; ok: true &#125;); &#125;);&#125;);// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음// ex) /articles/1로 요청이 들어올 경우, 실행됨app.get(\"/articles/:id\", (req, res) =&gt; &#123; database.articles .find(req.params.id) // `req.params`에 저장됨 .then((article) =&gt; &#123; res.send(article); &#125;);&#125;); [Request 객체] req.body: 요청 바디를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장(body-parser 미들웨어에 의해 처리됨) req.ip: 요청한 쪽의 IP req.params: route parameter req.query: query string이 객체로 저장됨 요청의 구성 요소 메소드(ex) GET, POST) 주소 헤더(ex) 요청에 대한 부가정보) 바디(ex) 새로 등록하고자 하는 정보 등) 응답의 구성 요소 상태 코드 헤더 바디: 본문이 포함되는 영역 res.status(...): 응답의 상태 코드를 지정하는 메소드 res.append(...): 응답의 헤더를 지정하는 메소드 res.send(...): 응답의 바디를 지정하는 메소드 인자가 텍스트면 text/html, 객체면 application/json 타입으로 응답 Express 실습 Template LanguageTemplate Engine 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리 템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 함 ex) jsp(html에 java코드를 넣는 언어), php(html 안에 c#코드를 넣는 언어) EJS(Embedded JavaScript Template) Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진 JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음 EJS VSCode Extension EJS에서 Emmet 사용하기 EJS 예제 Example 1234567891011121314&lt;%# index.ejs %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"message\"&gt;&lt;%= message %&gt;&lt;/div&gt; &lt;!-- showSecret이 truethy이면, my secret을 보여주고, --&gt; &lt;!-- 아니면 보여주지 마라. --&gt; &lt;% if (showSecret) &#123; %&gt; &lt;div&gt;my secret&lt;/div&gt; &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; Express에서 EJS 사용하기 EJS 실습 파일을 그대로 제공하기 내가 가지고 있는 파일을 그대로 응답할 수 있다. ex) 이미지, 폰트 파일 등을 그대로 응답한다. EJS 실습 예제 코딩 퀴즈 2번 풀이 코드를 짤 때 순서: 상태로부터 화면을 그리는 코드를 먼저 짜고,그 후에 이벤트 리스너 코드를 짜는 게 쉽다. 클래스ES2015 class 그 전에 배웠던 프로토타입 부분 보기 123456789101112131415// 생성자function Person(&#123; name, age &#125;) &#123; this.name = name; this.age = age;&#125;Person.prototype.introduce = function() &#123; return `안녕하세요, 제 이름은 $&#123;this.name&#125;입니다.`;&#125;;const person = new Person(&#123; name: \"윤아준\", age: 19 &#125;);console.log(person.introduce()); // 안녕하세요, 제 이름은 윤아준입니다.console.log(typeof Person); // functionconsole.log(typeof Person.prototype.constructor); // functionconsole.log(typeof Person.prototype.introduce); // functionconsole.log(person instanceof Person); // true ES2015에서 도입된 클래스는 생성자의 기능을 대체한다. class 표현식을 사용하면,생성자와 같은 기능을 하는 함수를 훨씬 더 깔끔한 문법으로 정의할 수 있다. 123456789101112131415161718192021// 클래스class Person &#123; // 이전에서 사용하던 생성자 함수는 클래스 안에 `constructor`라는 이름으로 정의합니다. constructor(&#123; name, age &#125;) &#123; this.name = name; this.age = age; &#125; // 객체에서 메소드를 정의할 때 사용하던 문법을 그대로 사용하면, // 메소드가 자동으로 `Person.prototype`에 저장됩니다. introduce() &#123; return `안녕하세요, 제 이름은 $&#123;this.name&#125;입니다.`; &#125;&#125;const person = new Person(&#123; name: \"윤아준\", age: 19 &#125;);console.log(person.introduce()); // 안녕하세요, 제 이름은 윤아준입니다.console.log(typeof Person); // functionconsole.log(typeof Person.prototype.constructor); // functionconsole.log(typeof Person.prototype.introduce); // functionconsole.log(person instanceof Person); // true 12345// 클래스 내에서는 일반 함수에서 쓰는 문법을 사용할 수 X.class Person &#123; console.log('hello');&#125;// 에러: Unexpected token 12345678// 클래스는 객체가 아닙니다!// ',' 쓰지 X// class안에서 ','을 써서 에러난 것임class Person &#123; prop1: 1, prop2: 2&#125;// 에러: Unexpected token 1234567891011121314151617181920212223class Person &#123;&#125;// undefinedPerson();// 에러 메시지// VM135:1 Uncaught TypeError:// Class constructor Person cannot be invoked without 'new'// at &lt;anonymous&gt;:1:1 (anonymous) @ VM135:1new Person();// Person &#123;&#125;function Student(name) &#123; this.name = name;&#125;// undefinedconst s = new Student(\"haha\");// undefined1;// 1s.name;// \"haha\"const s2 = Student(\"haha\");// undefinedwindow.name;// \"haha\" 클래스는 함수로 호출될 수 없다. 클래스 선언은 let과 const처럼 블록 스코프에 선언되며,호이스팅(hoisting)이 일어나지 않는다. function으로 정의한 함수는 var변수와 비슷.호이스팅이 일어난다. 클래스의 메소드 안에서 super 키워드를 사용할 수 있다. 메소드 정의하기 getter, setter는 속성에 접근하기만 해도 함수가 실행된다. 클래스에서 Getter 혹은 setter를 정의하고 싶을 때는 메소드 이름 앞에 get 또는 set을 붙여주면 된다. 123456789101112131415class Account &#123; constructor() &#123; this._balance = 0; &#125; get balance() &#123; return this._balance; &#125; set balance(newBalance) &#123; this._balance = newBalance; &#125;&#125;const account = new Account();account.balance = 10000;account.balance; // 10000 static 키워드를 메소드 이름 앞에 붙여주면 해당 메소드는 정적 메소드가 된다. 정적 메소드는 인스턴스에 . 찍고 사용하는 메서드 (X). 생성자에 . 찍고 사용하는 메소드를 말한다. 메소드 중에 정적 메소드를 제외하면, 다 프로토타입 안에 들어간다. 클래스 필드 (Class Field) 클래스 필드는 내년쯤 정식 표준으로 채택될 것으로 예상됨. 현업에서는 다들 사용하고 있음. 클래스 필드는 최신 문법이라서 일반 repl.it에서는 실행되지 X. constructor vs class repl 코드 123456789101112131415161718192021222324252627282930// constructor vs classclass Person &#123; constructor(&#123; name, age &#125;) &#123; this.name = name; this.age = age; &#125; // 이 메소드는 정적 메소드입니다. static sumAge(...people) &#123; return people.reduce((acc, person) =&gt; acc + person.age, 0); &#125;&#125;// function Person(&#123;name, age&#125;) &#123;// this.name = name;// this.age = age;// &#125;// Person.prototype.introduce = function() &#123;// console.log(`안녕하세요, $&#123;this.name&#125;입니다.`)// &#125;// Person.sumAge = function(...people) &#123;// return people.reduce((acc, person) =&gt; acc + person.age, 0);// &#125;const person1 = new Person(&#123; name: \"윤아준\", age: 19 &#125;);const person2 = new Person(&#123; name: \"신하경\", age: 20 &#125;);// person1.introduce()Person.sumAge(person1, person2); // 39 클래스 필드와 this 메소드를 다른 함수의 인수로 넘겨줘야 하는 경우,화살표 함수를 사용하는 것이 좋다. React를 사용할 때 this 때문에 버그가 많이 일어난다. 클래스를 확실히 이해하려면, 교재의 ‘객체, 함수 더 알아보기’ 읽어보기class field repl 코드 12345678910class MyClass &#123; a = 1; getA = () =&gt; &#123; return this.a; &#125;;&#125;const instance = new MyClass();const getA = instance.getA;getA(); Web FormHTML FORMHTML form의 기본 동작 From Data가 요청 body에 담겨져 전달된다. HTML form을 전송하면,입력된 정보가 기본적으로 percent encoding 되어 요청됨 GET method 12 GET /search?query=%EA%B0%9C&amp;sort=latest HTTP/1.1... 123456POST methodPOST /form HTTP/1.1Content-Type: application/x-www-form-urlencoded...home=Cosby&amp;favorite+flavor=flies HTML Form 예제 - 할일 관리 웹 서비스 브라우저의 새로고침은 이전에 보냈던 요청을 그대로 보내는 것이다. 이런 일이 발생하지 않기 위해서 redirect를 하는 것이다. redirect 하지 x면, 새로고침을 여러 번 누르면 -&gt; POST로 요청이 계속 감 redirect 하면, 새로고침을 여러 번 누르면-&gt; GET으로 요청이 계속 감 DOM API만 사용하면 -&gt; 브라우저 내장 UI인 뒤로 가기, 앞으로 가기 버튼 등이 잘 작동하지 않는다. MIME 타입","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 12일차","slug":"javascript12","date":"2019-01-26T11:26:48.000Z","updated":"2019-04-16T13:04:41.686Z","comments":true,"path":"2019/01/26/javascript12/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/26/javascript12/","excerpt":"","text":"Node.js + HTTPhttp: 통신 규약 이름 처음 만나는 Node.jsREST API 실습 POSTMAN 설치 서버와 통신을 할 때는 주로 JASON 형식으로 주고 받는다. REST API: 통신 규약에 관한 용어 Authentication: 통신을 할 때 내가 누군지를 밝히는 절차 (인증) 내가 누군지를 밝혀야 나에 관한 자료를 받을 수 있다. token: 내가 누구인지 증명하는 보안카드, 주민등록증 같은 것 token 생성하기github.com-&gt; 프로필의 settings-&gt; developer settings-&gt; personal access tokens-&gt; generate new token 버튼 클릭-&gt; Token description에 설명을 적음.아래에 체크박스에는 아무 것도 체크 누르지 말 것.(아무 권한도 없는 식별 코드를 생성)-&gt; 각기 다른 token이 생성됨-&gt; ex) 607d493859c0ddb1cc8e1da472fc49fd66a12724 OAUth2 token(sent as a parameter) 방식 POSTMAN에https://api.github.com/user/repos/?access_token=OAUTH-TOKEN(발급받은 토큰)넣기-&gt; send 버튼 누르기 OAuth2 token (sent in a header) 방식 Developer들이 주로 사용하는 방식POSTMAN의 Headers를 누르고 KEY에 Authorization 입력VALUE에 token, 2번째 칸에 발급받은 토큰 입력reqeust URL에 https://api.github.com/user/repos 입력 Nods.js git bash에서 node를 입력 -&gt; javascript 코드를 입력할 수 있다. .exit를 입력하거나 Ctrl+C를 두 번 입력해서 빠져나갈 수 있다. alert, prompt는 브라우저 내장 기능이기 때문에 Node.js에는 없다. 대신, 브라우저에 내장되지 않은 기능들이 많이 있다. nods.js는 브라우저와 완전히 다른 구동 환경이라는 것을 기억! module: 내장 함수를 가지고 있는 객체 Node.js module 사용하기 123456789// git bash에 입력node;const os = require(\"os\");// undefinedos.platform();//'win32'os.freemem();//2084761600 Node.js란? 아주 빠른 속도로 요청을 처리할 수 있는 기능을 내장하고 있다. Nods.js는 2009년에 만들어짐. 현재는 프론트엔드 개발도 Node.js로 하게 되었다. 세계에서 가장 많은 오픈 소스 라이브러리를 가지고 있다. Node.js Module의 사용법12// git bash에 입력`code name.js`; 123456789// name.js에 아래의 코드 붙여넣기 -&gt; 저장// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음module.exports = &#123; familyName: \"김\", givenName: \"승하\", fullName: function() &#123; return this.familyName + this.givenName; &#125;&#125;; 12// git bash에 입력`code calc.js`; 1234567// calc.js에 아래의 코드 붙여넣기 -&gt; 저장// `exports`로도 참조 가능exports.add = (x, y) =&gt; x + y;exports.sub = (x, y) =&gt; x - y;// 파일을 만들고 다른 곳에서 불러서 쓸 수 있다.// 'require 함수를 이용해서 다른 곳에 있는 코드를 불러올 수 있구나.' 정도를 알고 넘어가면 된다 12345678910111213`node` &gt; `const name = require('./name')` &gt; // undefined `name.fullName()` &gt; // '김승하' `const calc = require('./calc')` &gt; // undefined calc &gt; // &#123; add: [Function], sub: [Function] &#125; `calc.add(1, 2)` &gt; // 3 `calc.sub(1, 2)`;// -1 Hello NPM1234// git bash에 입력`mkdir hello-npm``cd hello-npm``npm init -y``code .`;// npm으로 관리되는 프로젝트를 초기화하겠다.// code .으로 파일을 열어보면, json파일이 생성된 것을 볼 수 있다. pakage.json123456-`npm install --save` - `npm install sweetalert` - // 홈 폴더에서 node_modules 지우기 `rm -rf node_modules` - // 전에 설치했던 라이브러리들이 다시 다 설치됨 `npm install`; 다른 사람과 협업할 때, node_modules 폴더는 파일이 너무 많기 떄문에 git에 올리지 않고, package-lock.json, package.json을 git에 올린다. .gitignore에 modules/를 추가 https://www.npmjs.com/에 접속 -&gt; randomstring을 검색 npm 라이브러리를 사용하는 이유 bower https://bower.io/ npm과 비슷한 프론트엔드 도구. 클라우드 저장소 현재 bower는 거의 사용하지 않는다. 빌드 도구(ex) webpack 등)가 npm을 기반으로 만들어졌다. npm에서 빌드 도구를 다운 받는다.(ex) webpack 등이 Node.js에서 작동하기 때문에) bower와 npm에서 각각 다운 받아야 하는 불편함이 있어서,요즘은 npm에서 거의 대부분의 라이브러리를 다운 받는 게 문화이다. npm install으로 한 번에 다운 받으면 설치된다. 거의 모든 (심지어 CSS코드까지) 라이브러리를 받을 수 있다.ex) css reset, jQuery 등 프론트엔드 라이브러리도 npm에서 다운받을 수 있다. HTTPHTTP 까보기 새로고침을 1번 해도 요청은 여러 번 일어날 수 있다. HTTP(HyperText Transfer Protocol) HTTP의 원래의 목적: 웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약 최근에는 REST API의 부상과 함께 다른 용도로도 널리 사용됨 모바일 앱 - 서버 간 통신 서버 - 서버 간 통신 localhost:8080 localhost: 컴퓨터의 이름 컴퓨터 하나에 통신을 위한 수많은 콘센트가 있다고 생각하면 된다. 그 콘센트에 번호를 매긴 것이라고 생각하면 이해하기 쉽다. ex) interpark.com:80/malls/index.html:80포트가 생략된 것이다. :80을 붙여서 주소를 입력해도 잘 작동한다. http를 사용하면 80번 포트가 기본으로 사용된다. 클라이언트의 요청(request)과 서버의 응답(response)으로 이루어짐 역사: 지금 사용되고 있는 버전은 1999년에 발표한 HTTP 1.1이다. HTTPS HTTP over SSL HTTP 통신을 암호화해 주고받는 내용을 중간에서 가로챌 수 없도록 함 같은 공유기를 사용하는 다른 사용자가 HTTP 사이트에 접속했을 때,어떤 사이트에 무슨 내용으로 접속했는지를 볼 수 있다. (공유기를 해킹한 해커도 그 공유기 사이로 흘러다니는 내용을 다 볼 수 있다.-&gt; HTTP 사이트에 아이디와 비밀번호를 넣어서 접속했을 때 해킹 당할 수 있다.) HTTPS를 사용했을 때는 해커가 알아볼 수 없는 암호화된 형태로 정보가 흘러다니기 때문에 해킹할 수 없다. https를 사용했을 때는 443번 포트를 기본적으로 사용한다. HTTP/2 구글의 SPDY 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준 속도 개선에 중점을 두고 개발됨 반드시 HTTPS를 사용해야 함 현재 전체 웹사이트 중 26% 이상이 사용중 HTTP 1.1에 비해 보안이 강화되고 속도도 빨라짐 HTTP/2로 바뀌는 추세 HTTP 구성요소Request &amp; Response 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄 그에 따라 서버는 클라이언트에 응답(response)를 보냄 웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, [중요!!] 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, …) Request Methods 요청에만 메소드가 있다. (응답에는 메소드가 X) HTTP 명세에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음 GET GET 메소드는 특정 리소스의 표시를 요청한다.GET을 사용하는 요청은 오직 데이터를 받기만 한다. GET 메소드는 정보를 달라는 것 POST: 서버에 등록하는 게 아니라, 정보를 받아올 때는 POST 메소드를 사용 웹 브라우저는 특정 상황에서 특정 메소드로 요청을 보내도록 만들어져 있음. 제출할 때 사용. POST 메소드는 특정 리소스에 엔티티를 제출할 때 쓰임. 이는 종종 서버의 상태의 변화나 부작용을 일으킨다. PUT: PUT 메소드는 목적 리소스 모든 현재 표시를 요청 payload로 바꾼다. Ajax와 같이 요청을 보내는 코드를 직접 짤 때는 요청 메소드를 선택할 수 있음 자료의 본문을 요청하는 GET 메소드와, 새로운 자료를 등록하는 POST 메소드가 가장 많이 쓰임 URL url이 반드시 웹사이트에 대한 주소가 아닐 수 있다. 특정 자원을 가리키기 위해서 url을 사용할 수 있다. 123&lt;a href=\"mailto:seungha.me@gmail.com\"&gt;메일&lt;/a&gt;// 메일 주소에 대한 링크를 만들 때 사용&lt;a href=\"tel:01012345678\"&gt;전화걸기&lt;/a&gt; https://www.example.com:3000/path/resource?id=123#section-id https://www.example.com:3000까지는 서버 주소 그림이 잘못되어있음. 3000 뒤의 /는 경로에 포함됨. /path/resource?id=123#section-id /부터 그 뒤까지는 자원의 주소 7번: 어떤 자원을 가져오고 싶은지, 부가정보를 포함시킬 때 querystring을 사용한다. 8번: #section-id : 문서의 특정 부분을 가리킬 때 #(해시)를 기억할 것! ex) https://www.google.com/search?source=hp&amp;ei=PaDWW7T7EImz8QWZ8ZKoCg&amp;q=http&amp;oq=http&amp;gs_l=psy-ab.3..0i131k1l5j0j0i131k1j0i3k1j0l2.989.1350.0.1568.4.3.0.1.1.0.138.248.0j2.2.0....0...1c.1.64.psy-ab..1.3.255....0._7JtWYsiHlc 해시태그(#) 챕터1: https://s.codepen.io/dbeat999/debug/pxBJNO/yoAZEWKOwOZr#chapter-1 챕터2: https://s.codepen.io/dbeat999/debug/pxBJNO/yoAZEWKOwOZr#chapter-2 url에서 해시태그(#) 뒷 부분이 바뀐다. 아무 의미없는 긴 문자열을 html에 넣고 테스트하고 싶을 때,lorem*50 넣어주기. lorem은 표준 채우기 텍스트 Percent Encoding 주소 표시줄 https://www.google.co.kr/search?q=%ED%95%9C%EA%B5%AD&amp;oq=%ED%95%9C%EA%B5%AD&amp;aqs=chrome..69i57j69i61l2j69i65l2j69i59.2351j0j7&amp;sourceid=chrome&amp;ie=UTF-8 크롬 개발자 도구 -&gt; Network-&gt; Name: search?..로 된 파일을 누르기 -&gt; Reqeust URL https://www.google.co.kr/search?q=%ED%95%9C%EA%B5%AD&amp;oq=%ED%95%9C%EA%B5%AD&amp;aqs=chrome..69i57j69i61l2j69i65l2j69i59.2351j0j7&amp;sourceid=chrome&amp;ie=UTF-8 Response Status Status Category 2xx: 성공 3xx: 추가 작업이 필요함 4xx: 실패 - 클라이언트 책임 5xx: 실패 - 서버 책임 Status Code - 2xx 200 OK: 성공 201 Created: 자료가 성공적으로 생성됨 Status Code - 3xx301 Moved Permanently (Redirection) 자료가 완전히 다른 곳으로 이동했음 서버가 여기에 없고 완전히 이동했다고 서버가 브라우저에 응답을 줌. 302 Found (Redirection) 자료가 일시적으로 다른 곳에 있음 302는 일시적으로 이동했다는 뜻이기 때문에 서버가 다른 곳으로 이동하라고 해도 다시 사용자에게 요청을 함. 304 Not Modified (Cache) 클라이언트가 이미 가지고 있던 자료가 수정되지 않았음 (그대로 사용하면 됨) 어떤 웹사이트들은 다운 받았던 이미지를 그대로 사용하는 경우가 있음. -&gt; 캐시(Cache)라고 한다. 이미지별로 식별번호가 있어서 서버가 브라우저로 이미지와 식별번호를 보내게 된다. ex) 똑같은 주소에 이미지를 요청한다. -&gt; 식별번호와 이미지를 브라우저가 가지고 있음.-&gt; 브라우저가 서버에 내가 이 식별번호와 이미지를 가지고 있는데, 바뀐 사항이 있는지 물어봄.-&gt; ‘브라우저 네가 가지고 있는 그대로 사용하면 돼~’ 라고 알려주는 게 304 Not Modified임. cf) Network에 Preserve log에 체크표시하면, 그 전 기록도 남게 됨. Status Code - 4xx 클라이언트의 책임이다. 400 Bad Request 요청의 형태가 잘못되어 응답할 수 없음 403 Forbidden 요청한 자료에 접근할 권한이 없음 404 Not Found 요청한 자료가 없음 Status Code - 5xx 서버의 책임이다. 500 Internal Server Error 요청을 처리하던 중에 예상치 못한 오류가 발생함 503 Service Unavailable -서버가 일시적으로 응답을 할 수 없음 Header 요청과 응답에 대한 추가 정보를 표현하는 데 사용됨 인증, 캐싱, 쿠키, 보안, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨 Authorization: 요청의 인증 정보- User-Agent: 요청 중인 클라이언트의 정보 Location: 301, 302 응답에서 자료의 위치 Accept: 요청이 어떤 형태의 자료를 원하는지 나타냄 Content-Type: 요청 혹은 응답이 어떤 형태의 자료인지 나타냄 Express Glitch Tutorial 버튼을 클릭 -&gt; github 계정으로 가입 설치 후, 교재의 Glitch Tutorial 버튼을 다시 클릭해서 들어오기 오른쪽 상단의 Remix This 버튼을 누르면, fork 됨 Glitch는 서버를 만드는 도구 우리가 작성한 서버를 클라우드에 띄운 다음 주소를 붙여주는 기능을 제공한다. 좌측 바의 package.json을 클릭 -&gt; add Package를 클릭 -&gt;express를 검색해서 설치 1234567// git bash에 입력// ~/hello-npm// FOO라는 환경변수에 BAR라는 값을 넣는다.FOO=BAR node// 환경변수 FOO를 호출한다.&gt; process.env.FOO// 'BAR' Glitch 튜토리얼 우측 상단의 Sign in 버튼을 눌러 Github 계정으로 로그인 해 주세요. Remix this 버튼을 눌러 프로젝트를 복제하세요. 현재 express가 설치되지 않아서 프로젝트가 실행되지 않는 상태입니다.좌측 파일 목록에서 package.json을 클릭한 후,문서 상단의 Add package 버튼을 클릭해 express를 설치해주세요. Glitch는 코드가 수정될 때마다 자동으로 npm start 명령을 실행합니다.package.json에서 어떤 명령이 실행되는지 확인하고, 해당 파일을 확인한 다음, 상단 Show 버튼을 눌러주세요.Glitch 앱은 기본적으로 HTTPS로 작동합니다. server.js에서 NAME이라는 환경변수를 불러와 표시해주고 있습니다.환경변수는 .env 파일에서 설정할 수 있으며,이 파일의 내용은 소유자와 공동작업자밖에 볼 수 없습니다.외부에 노출하면 안 되는 설정사항을 저장하기에 적합합니다..env에서 NAME 환경변수를 자신의 이름으로 수정하고, 앱이 잘 업데이트 되었는지 확인하세요. 좌측 최상단의 프로젝트 이름을 클릭하면, 프로젝트와 관련된 여러가지 설정을 할 수 있습니다.프로젝트 이름을 수정해주세요.그에 따라 앱의 url도 변경됩니다. 우측 최상단의 아이콘을 클릭하고 Keyboard Shortcuts를 확인해보세요. Glitch를 사용하면 환경 변수 설정, 코드 작성 후-&gt; 서버에서 어떤 응답을 해주는 지 볼 수 있다. 1주일 간, Glitch를 이용해서 서버 코드를 작성할 예정 Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크 내장하고 있는 기능은 매우 적으나,미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음 자바스크립트 교재- JAVASCRIPT 심화2 Iterable 반복 가능한 객체(iterable object)는 for...of 구문과 함께 ES2015에서 도입됨. 반복 가능한 객체를 다른 객체와 구분짓는 특징은,객체의 Symbol.iterator 속성에 특별한 형태의 함수가 들어있다는 것이다. 12const str = \"hello\";str[Symbol.iterator]; // [Function] Symbol은 객체의 속성 key로 사용할 수 있는 원시타입의 값 for...of 구문은 iterable에 대해서 사용하는 함수이다. 내장된 생성자 중 iterable 객체를 만들어내는 생성자에는 아래와 같은 것들이 있다. String Array TypedArray Map Set Iterable의 사용 객체가 Iterable이라면, 그 객체에 대해서 아래의 기능들을 사용할 수 있다. for…of 루프 spread 연산자 (…) 분해대입(destructuring assignment) 기타 iterable을 인수로 받는 함수 12345678910111213141516171819202122// `for...of`for (let c of \"hello\") &#123; console.log(c);&#125;// spread 연산자const chars = [...\"hello\"];// const chars = 'hello'.split('')으로도 가능함console.log(chars);// 분해대입// 배열처럼 분해대입이 가능하다.const [c1, c2] = \"hello\";console.log(c1, c2);// h e// `Array.from`은 iterable 혹은 array-like 객체를 인수로 받습니다.Array.from(\"hello\");const s = new Set([1, 2, 3]);const [c1, c2] = s;console.log(c1, c2); // 1 2 Generator 함수 Iterable을 구현하는 가장 쉬운 방법은 ES2015에 도입된 generator 함수를 사용하는 것이다. Gererator 함수는 만드는 개발자가 반환값을 만들지 않아도 객체를 반환한다. Generator 함수를 호출하면, 무조건 객체를 반환한다. Generator 함수를 호출하면 객체가 생성되는데, 이 객체는 iterable protocol을 만족한다.-&gt; 즉, Symbol.iterator 속성을 갖고 있다. Generator 함수를 실행하면, iterable 객체를 만들 수 있다. Generator 함수는 일시정지가 가능하다. 실무에서는 보통 루프 사용할 때는 거의 사용하지 않고, 일시정지 기능을 사용하고 싶을 때 많이 활용한다. 12345678910111213141516// generator 함수 선언하기function* gen1() &#123; // ...&#125;// 표현식으로 사용하기const gen2 = function*() &#123; // ...&#125;;// 메소드 문법으로 사용하기const obj = &#123; *gen3() &#123; // ... &#125;&#125;; Generator 함수 안에서는 yield라는 특별한 키워드를 사용할 수 있다. Generator 함수 안에서 yield 키워드는 return과 유사한 역할을 하며,iterable의 기능을 사용할 때 yield 키워드 뒤에 있는 값들을 순서대로 넘겨준다. yeild(양보하다) yield는 바깥으로 함수 여러 번 값을 반환한다.(cf) return은 1번만 반환함.) 1234567891011121314151617// yield 뒤에 붙어있는 숫자를 차례대로 반환한다.function* numberGen() &#123; yield 1; yield 2; yield 3;&#125;// 1, 2, 3이 순서대로 출력됩니다.// 첫 번째 실행시: 1이 들어감// 두 번째 실행시: 2가 들어감// 세 번째 실행시: 3이 들어감for (let n of numberGen()) &#123; console.log(n);&#125;// 1// 2// 3 yield* 표현식을 사용하면, 다른 generator 함수에서 넘겨준 값을 대신 넘겨줄 수도 있다. 12345678910111213141516171819202122function* numberGen() &#123; yield 1; yield 2; yield 3;&#125;function* numberGen2() &#123; yield* numberGen(); yield* numberGen();&#125;// 1, 2, 3, 1, 2, 3이 순서대로 출력됩니다.for (let n of numberGen2()) &#123; console.log(n);&#125;// 1// 2// 3// 1// 2// 3 사용자가 루프를 돌리고 싶을 때, 함수를 만들어서 루프를 돌릴 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041// 등차수열 생성하기// start=0 , end= Infinity는 매개변수의 기본값(인자가 들어오지 않으면, 기본값으로 사용)// start= 0, end= 5, step=1로 실행됨function* range(start = 0, end = Infinity, step = 1) &#123; for (let i = start; i &lt; end; i += step) &#123; yield i; &#125;&#125;// for (const item of range(0, 5)) &#123;// console.log(item);// &#125;// 0// 1// 2// 3// 4// 피보나치 수열 생성하기function* fibonacci(count = Infinity) &#123; let x = 1; let y = 1; for (let i = 0; i &lt; count; i++) &#123; yield x; [x, y] = [y, x + y]; &#125;&#125;for (const item of fibonacci(10)) &#123; console.log(item);&#125;// 1// 1// 2// 3// 5// 8// 13// 21// 34// 55 배열과의 차이점: Generator 함수는 순서대로 무한히 값을 반환해주는 무한 배열을 만들 수 있다. 루프를 값으로 다룰 수 있게 된다. Generator로 루프를 값으로 만들면, 조합을 하기 쉬워지고 변경을 하기 자유로워진다. Generator 함수를 사용할 때 주의할 점 123456789101112131415161718// Generator 함수로부터 생성된 iterable은 한 번만 사용될 수 있다.function* gen() &#123; yield 1; yield 2; yield 3;&#125;const iter = gen();for (let n of iter) &#123; // 잘 출력됩니다. console.log(n);&#125;//Generate 함수는 1번만 순회가 가능하므로 이 코드는 무시됨.for (let n of iter) &#123; // `iter`는 한 번 사용되었으므로, 이 코드는 실행되지 않습니다. console.log(n);&#125; 12345678910// Generator 함수 내부에서 정의된 일반 함수에서는 `yield` 키워드를 사용할 수 없다.function* gen2() &#123; // 아예 문법 오류가 난다. (Unexpected token) function fakeGen() &#123; yield 1; yield 2; yield 3; &#125; fakeGen();&#125; Generate 함수의 특징 값을 여러 번 뱉어낼 수 있는 함수 일반 함수와는 다르게 일시정지가 가능한 함수 1234567891011121314151617// Generate로부터 만들어진 함수는 next라는 메소드가 들어있고,// 이 next 메소드를 이용해서 함수를 일시정지 할 수 있다.function* gen() &#123; yield 1; yield 2; yield 3;&#125;const iterable = gen();// 다음 yield를 만날 때까지 함수가 실행됨// value는 yield뒤에 붙어있는 숫자// done은 함수가 끝까지 실행되면 ture가 나옴.iterable.next(); // &#123; value: 1, done: false &#125;iterable.next(); // &#123; value: 2, done: false &#125;iterable.next(); // &#123; value: 3, done: false &#125;iterable.next(); // &#123; value: undefined, done: true &#125;","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 11일차","slug":"javascript11","date":"2019-01-25T13:52:53.097Z","updated":"2019-04-11T15:22:16.153Z","comments":true,"path":"2019/01/25/javascript11/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/25/javascript11/","excerpt":"","text":"previousElementSibling previousElementSibling는 가장 앞에 있는 요소에 주면, null이 반환된다. insertBefore와 appendChild insertBefore에 2번째 인자로 null이 들어가면 appendChild와 똑같이 동작한다. nextElmentSibling 맨 마지막에 있는 요소의 nextElmentSibling은 null을 반환한다.따라서, nextElmentSibling.nextElmentSibling은null.nextElmentSibling이 되므로 -&gt; 타입 에러가 난다. 위로 버튼을 눌렀을 때 mouseover는 부모 요소의 경계선을 지날 때 뿐만 아니라,자식 요소의 경계선을 지나쳤을 때도 부모 요소의 이벤트 리스너가 실행된다. 이런 현상이 일어나는 이유 mouseover, mouseout은 버블링이 일어난다. mouseenter, mouseleave은 버블링이 일어나지 않는다. 2가지 방법1. DOM 객체를 실제로 만들어서 넣기 HTML 문서에 직접 써넣을 수 없는 경우코드 작성 시점에 정확히 요소가 몇 개 표시될 지 모를 경우 ex) 사용자의 입력을 받아서 할 경우(Todo List 할 일 추가할 때) ex) createElement, appendChild, removeChild 등을 사용 2. CSS Style을 다르게 먹이는 방법 코드 작성 시점에 정확히 요소가 몇 개 표시될 지 아는 경우 ex) display: block or none했다가 나타나게 하기 2가지 방법 다 많이 사용되므로 필요에 따라 그때그때 다르게 사용하자. 스타일은 CSS에 작성하고, 자바스크립트에서는 클래스를 넣었다 뺐다 해주자.(자바스크립트에서 스타일을 넣고 빼는 건 할 수 있으나 역할과 책임에 맞지 않는다.) 게임을 만들 때 생각하는 절차 원래 그려져 있던 화면을 시간이 지남에 따라or 사용자의 입력에 따라서,화면을 바꿔주는 과정을 거친다.(화면을 새로 그려준다.) 사용자의 입력 시간의 경과 뭔가 기억하고 있는 것과 화면을 그리는 것이 연관이 있다. 상태(State) 화면을 그리기 위해 기억하고 있는 것을 상태(State)라고 부른다. 사용자의 입력을 받았을 때 어떤 상태가 될 지, 상태의 구조는 어떻게 될 지 프로그램이 기억하는 무언가가 모두 상태가 될 수 있다. 예시1textContent는 해당 텍스트를 기억해뒀다가 화면을 1초에 약 60번씩 계속 그리고 있는 것이다. classList.add, textContent의 상태를 바꾸면화면이 자동으로 다시 그려지게 기능이 내장되어 있다.(브라우저 내장 상태이기 때문에)-&gt; 굳이 ‘그리기’라는 절차를 코딩하지 않아도 된다. 예시2ex) score라는 상태는 우리가 기억하고 있는 상태이기 때문에개발자가 직접 일일히 화면을 그려주는 작업을 해야 한다.(score를 바꿀 때마다 화면이 다시 그려지는 게 X. ) React를 이용하기 React를 이용하면, 우리가 만든 상태를 사용할 때도 그 상태를 바꾸면,자동으로 화면을 다시 그려준다. React는 기술이기도 하지만 사고방식이라고 볼 수 있다. 게임에서 사용하던 기술들을 React에 많이 가져왔다. 프로그래밍하기에 편하도록 바꿔준 기술이다. Parcel은 자바스크립트가 수정될 때마다 다시 실행된다. Style을 수정할 때는 괜찮지만, 자바스크립트를 수정할 때는 그 때마다 새로고침을 눌러주는 게 좋다. Git으로 협업할 때 주의할 점 개행문자 때문에 문제가 생길 수 있다. window 사용자는 설정을 해야 한다. max: LF(/n) window: CRLF(/r/n) Window 사용자 개행문자 관련 설정 방법 자동으로 해결하는 방법이 있음(git에 내장된 기능을 이용) autocrlf기능을 켜기 git이 파일을 가져올 때는 LF(/n)를 CRLF(/r/n)로 저장해준다. 컴퓨터에서 파일을 저장한 걸 git에 커밋하면 LF(/n)로 바꿔줘서 Git에 올려준다. Git Bash에 입력 git config--global core.autocrlf를 입력한 후에 true가 반환되면 그대로 쓰면 된다. 아무것도 안 뜨면 설정이 안된 것이므로 -&gt; git config--global core.autocrlf true를 입력 Git 기본적인 명령어1234git pullgit add .git commit -m \"커밋 메시지\"git push","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 10일차","slug":"javascript10","date":"2019-01-24T08:21:30.791Z","updated":"2019-04-11T15:22:15.953Z","comments":true,"path":"2019/01/24/javascript10/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/24/javascript10/","excerpt":"","text":"DOM API이벤트 객체 e.stopPropagation() - 이벤트 전파 과정을 멈추기 더 이상 이벤트 과정을 실행시키지 않는다. 종종 사용하므로 기억할 것! e.currentTarget - ‘실제로 이벤트를 일으킨 요소’가 저장되어 있음 이벤트를 실제로 일으킨 요소와 이벤트가 등록되어 있는 요소는 같지 않을 수 있다. ex) 버튼을 클릭했을 때 실제로 이벤트를 일으킨 요소는 버튼인데, 이벤트 리스너가 outer에서도 실행될 수 있다. e.target과 e.currentTarget target은 실제로 이벤트를 일으킨 요소 ex) 실제로 클릭한 요소. button을 누른 경우 currentTarget에는 이벤트가 등록되어 있는 요소 ex) outer 클래스를 갖는 div를 가지고 있는 경우: outer가 나옴 보통은 target을 사용함. 항상 캡쳐링이나 버블링이 일어나는 것은 아니다. 버블링이 일어나는 이벤트도 있고, 일어나지 않는 이벤트도 있다. (ex) submit, focus, blur, change 등) submit: form만을 위한 이벤트 foucs, blur: input만을 위한 이벤트 폼 이벤트 자료를 실제로 전송할 수 있는 이벤트 type = “text”인 경우에는 input을 쓰고, 다른 type인 경우에는 change를 쓴다. change vs input change - checkbox, radio 등의 타입을 갖는 input 요소나 select 요소에 사용자의 선택이 일어났을 때 발생 input - text 타입을 갖는 input 요소나 textarea 요소의 값이 변경되었을 때(키보드 입력이 일어났을 때) 발생 contenteditable를 주면 input 이벤트가 발생 focus vs blur focus - 키보드 포커스가 해당 요소에 옮겨졌을 때 발생 마우스를 누르든, 키보드로 누르든 포커스가 오면, focus가 출력됨 blur - 키보드 포커스가 해당 요소에서 벗어났을 때 발생 마우스든, 키보드든 포커스가 해당 요소에서 벗어나면, blur가 출력됨 submit - 폼 전송이 일어났을 때 발생 폼 이벤트(submit)todo List(form 이용) codePen 예시 요즘은 form 태그의 내장 기능으로 전송하지 않고, 자바스크립트로 직접 구현을 해서 전송한다. -&gt; 따라서 form태그의 속성을 세세하게 알 필요는 X. 가끔 예전에 만든 프로젝트를 만져야 할 때 알아야하기 때문에 알고는 있어야 함. 실무에서 폼의 전송 기능을 거의 사용하지 않음에도, 폼 태그를 굉장히 많이 사용한다. (폼에 내장되어 있는 편리한 기능을 사용하기 위해서) 폼 태그에는 전송 기능 외에도 여러 가지 편리한 기능이 내장되어 있다. ex) 폼 태그의 안에서 Enter를 눌렀을 때 전송되는 기능 ex) 폼 안에 있는 input 태그에 required를 주면, 해당 input태그가 입력되지 않고 빈칸이면 ‘이 입력란을 작성하세요’라고 창을 띄워주는 기능 https://httpbin.org/post에 정보를 전송하면, 우리가 전송한 정보를 JSON 형태로 반환해서 보여줌 정보를 전송하는 방식: get방식, post방식 전송 버튼을 누를 때, 폼 안에서 엔터키를 누르거나 하면 정보를 전송할 수 있다. (브라우저의 내장 기능) form 안에 있는 button을 누르면 정보를 전송할 수 있다. (브라우저의 내장 기능) type에는 submit, reset, button 3가지가 있다. submit reset: 초기값으로 다시 되돌아가게 함. button: form기능을 사용하되 브라우저 내장 기능을 사용하고 싶지 않은 경우(비활성화하기 위해서), preventDefault 메소드를 사용한다. 사용자 입력 검증을 할 때, HTML5의 검증 기능을 사용(required를 주기)하거나 자바스크립트로 직접 사용자 입력 검증을 하거나 둘 다 혼합해서 사용하기도 한다. 마우스 이벤트 click / dblclick - 마우스 클릭 / 더블클릭 mouseover / mouseout - 요소에 마우스 포인터가 들어왔을 때 / 나갔을 때 mousedown / mouseup - 요소 위에서 마우스 버튼을 눌렀을 때 / 놓았을 때 mousemove - 요소 위에서 마우스 포인터가 움직일 때마다 Drag&amp;Drop(실습) 스타일링은 자바스크립트에서 할 수도 있지만, 되도록이면 CSS로 스타일을 주는 것이 좋다. 자바스크립트에서는 클래스를 넣었다 뺐다 조작해주고, 스타일링은 css에서 해주자. 마우스 포인터가 갑자기 확 움직이면, 인식 못할 수도 있다. 브라우저가 인식하기에는 점으로 이동하는 것처럼 인식 하기 때문에 123456789101112// boxEl.하면 마우스 포인터가 갑자기 확 움직이면, 인식 못할 수도 있다.// 브라우저가 인식하기에는 점으로 이동하는 것처럼 인식 하기 때문// document.으로 써야 함// boxEl.addEventListener('mousedown', e =&gt; &#123;// // 마우스를 눌렀을 때// dragging = true;// &#125;)document.addEventListener(\"mousedown\", (e) =&gt; &#123; // 마우스를 눌렀을 때 dragging = true;&#125;); [과제] 박스의 중간 지점과 마우스가 일치하게 그 상태로 움직이려면 어떻게 해야 할 지 내가 누른 지점 그대로(마우스 포인터를 올렸을 때 그 마우스 포인터 위치 그대로) 부드럽게 움직이려면 어떻게 해야할 지 키보드 이벤트 한글은 잘 작동하지 않는다는 걸 기억해두기 keydown / keyup - 키보드 버튼을 눌렀을 때 / 놓았을 때 keypress - 문자가 입력되었을 때 keydown에서 charCode와 keyCode는 없어질 예정임. 사용하지 X. input이벤트는 문서가 실행될 때 바로 document에 이벤트를 먹일 수 없으나(querySelector로 가져온 후 이벤트 붙일 수 있다.), keydown은 가능하다. 123document.addEventListener(\"keydown\", (e) =&gt; &#123;&#125;);document.querySelector(\".todo-input\").addEventListener(\"keypress\", (e) =&gt; &#123;&#125;); 스크롤 이벤트 scroll - 요소 내부의 콘텐츠가 스크롤 될 때마다 parallax Scrolling","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 9일차","slug":"javascript9","date":"2019-01-22T15:41:52.969Z","updated":"2019-04-11T15:22:16.169Z","comments":true,"path":"2019/01/23/javascript9/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/23/javascript9/","excerpt":"","text":"내장 객체 및 생성자JSON 자료구조(메모리에 올라간 객체나 배열)은 그대로 전송할 수 없다. 객체나 배열은 메모리에 저장된다.크롬, 익스플로러 등등 각 브라우저가 메모리에 저장하는 방법이 달라서 호환이 되지 않는다. (브라우저 간의 메모리 구조가 다르다.) 따라서 저장/전송 가능한 형태로 변환하는 절차가 필요하다. -&gt; 직렬화(serialization) 텍스트 형태의 데이터를 프로그래밍 언어에서 다시 사용할 수 있도록 변환해주는 절차를 역직렬화(deserialization)라고 한다. JSON(JavaScript Object Notation)은 직렬화 포맷 중에 요즘 압도적으로 사용되고 있는 형식이다. 직렬화 하기: JSON.stringify 역직렬화 하기: JSON.parse 12345678910111213141516// `JSON.stringify`로 직렬화를 할 수 있다.// stringify라는 메소드에 객체를 넘겨준 것이다.// 객체 그대로 전송할 수 없으니 텍스트로 변환해서 전송하는 것이다.// 이 객체를 문자열로 변환해준 것이다.JSON.stringify(&#123; key: \"value\", arr: [1, 2, 3], nullProp: null, undefinedProp: undefined // 값이 `undefined`인 속성은 직렬화 과정에서 제외된다.&#125;); // '&#123;\"key\":\"value\",\"arr\":[1,2,3],\"nullProp\":null&#125;'// `JSON.parse`로 역직렬화를 할 수 있다.JSON.parse('&#123;\"key\":\"value\",\"arr\":[1,2,3],\"nullProp\":null&#125;');const obj = JSON.parse(text);// =&gt; &#123; key: 'value', arr: [ 1, 2, 3 ], nullProp: null &#125; JSON은 JavaScript와 아주 유사한 언어이지, 같은 언어가 아니다. 다른 언어이다. JSON을 직접 편집해야 할 때는 JSON이 JavaScript가 아니라는 사실에 주의!!!! JSON을 편집할 때 주의할 점 속성 이름에 꼭 쌍따옴표(&quot;&quot;)를 둘러주어야 한다. 아주 단순한 객체나 배열만 표현할 수 있다. 객체 리터럴로 만들어진 아주 단순한 형태의 객체만 표현할 수 있다. JSON 문서 안에 함수를 저장할 수 없다. 함수는 JSON으로 변환할 수 없다. Map, Set, Date, Error, RegExp, Function, Promise와 같이특별한 동작방식을 가지는 객체들을 제대로 표현할 수 없다. undefined, NaN, Infinity과 같은 값을 표현할 수 없다. 주석을 쓸 수 없다. Date 협정 세계시(UTC)를 많이 사용한다. 지구 상의 여러 지역에서는 시간대(timezone)와 일광 절약 시간제(DST)에 따라 서로 다른 시각을 사용한다. 조금씩 느려지는 지구 자전 속도에 맞추기 위해 UTC에는 가끔씩 윤초(leap second)가 추가되기도 한다. 유닉스 시간 - 컴퓨터에서는 시간 데이터를 편하게 다루기 위해서 유닉스 시간이라는 특별한 단위를 사용한다.유닉스 시간은 UTC 기준 1970년 1월 1일 0시 0분 0초부터 경과한 시간을 초 단위의 정수로 나타낸다. 자바스크립트에도 유닉스 시간이 사용되고 있다. Date 객체의 생성Date 생성자의 사용 방법 new Date() - 현재 시각을 나타내는 Date 객체를 반환한다. new Date(value) new Date(정수)- value가 정수인 경우,이를 밀리초 단위의 유닉스 시간으로 간주해서 이에 해당하는 Date 객체를 반환한다. new Date(&#39;문자&#39;)- value가 문자열인 경우, 이 문자열이 나타내는 Date 객체를 반환한다. new Date(year, month, day, hour, minutes, seconds, milliseconds)- 년, 월, 일, 시, 분, 초, 밀리초를 직접 입력해서 Date 객체를 생성할 수 있다. ‘월’ 부분은 0부터 11까지의 값을 가집니다. 월 이후의 인수는 생략가능하고, 인수를 생략하면 ‘일’은 1로, 나머지는 모두 0으로 지정됩니다.(월은 0월부터 시작한다. ex) 1월이면, 0을 입력한다.) Date 객체를 생성하고 난 뒤에는, 해당 객체가 나타내는 년, 월, 일, 시, 분, 초, 밀리초를 가져오거나 변경할 수 있다. 12345678910// 현재 날짜와 시간new Date();// =&gt; 2018-10-15T11:37:03.577Zconst d = new Date();// =&gt; undefinedtypeof d;// =&gt; 'object'd.getTime();// =&gt; 1539603459005// 유닉스 시간을 가져옴 123456789101112131415161718192021 new Date();// =&gt; 2018-10-15T02:39:41.453Z const d = new Date();// =&gt; undefined typeof d// =&gt; 'object' d.getTime(); // Date타입을 유닉스 시간으로 바꿈// =&gt; 1539571216084 const msec = d.getTime();// =&gt; undefined new Date(msec - 60000);// 유닉스 시간을 Date타입으로 바꿈(msec- 60000)은 1분 전 객체를 얻기 위해서 연산해준 것임&lt;!-- 60 X 1000 = 60,000 = '1분'을 나타냄--&gt;// =&gt; 2018-10-15T02:39:16.084Z d// =&gt; 2018-10-15T02:40:16.084Znew Date('2018-10-10T01:01:02')// =&gt; 2018-10-09T16:01:02.000Z// Date객체의 포맷으로 value를 넘겨줌// 우리가 입력한 건 한국 시간이고, 결과로 출력되는 건 한국 시간 - 9시간인// 협정 세계시로 나온다.new Date(year, month, day, hour, minutes, seconds, milliseconds) 데이터 객체를 숫자로 바꾼 후에 저장해야 한다. 12345678910obj2 = &#123; date: d.getTime() &#125;;// =&gt; &#123; date: 1539571216084 &#125;const text = JSON.stringify(obj2);// =&gt; undefinedtext;// =&gt; '&#123;\"date\":1539571216084&#125;'const obj3 = JSON.parse(text);// =&gt; undefinedtext;// =&gt; '&#123;\"date\":1539571216084&#125;' 문자열로 변환하기 Date 객체가 나타내는 시각을 여러 가지 방법으로 문자열로 변환할 수도 있다. 12345678910const now = new Date();// new Date().toLocaleString()// 지역 + 언어: Locale// ex) 캐나다 + 불어, 캐나다 + 영어// 해당 지역과 언어에 맞게 현재 시간이 나온다.console.log(now.toLocaleString()); // 2018. 10. 15. 오후 8:47:14// Z가 붙어있으면 UTC기준이라는 뜻이다.// new Date().toISOString()은 사람도 알아보기 쉽기 때문에 시간 표시 형식으로 많이 쓴다.console.log(now.toISOString()); // 2017-12-10T03:49:31.145Z 숫자로 넣고 숫자로 빼서 그걸 Date객체로 바꾸는 게 속편하다. 시간 간격 측정하기 - 연산자를 사용해서 두 Date 객체 사이의 시간 간격이 얼마나 되는지를 밀리초 단위로 측정할 수 있다. 어떤 특정 시간으로부터 경과시간을 계산할 때 사용한다. 123456const start = new Date();alert(\"시간이 가고 있습니다...\");// 경고창을 끈 후 new Date()가 실행된다.const end = new Date();// (뒷쪽 시간 - 처음 시간)을 밀리초 단위로 반환alert(`$&#123;end - start&#125; 밀리초 만큼의 시간이 경과되었습니다.`); 12345678// 주기적으로 코드를 실행하고 싶을 때const start = new Date();setInterval(() =&gt; &#123; const end = new Date(); console.log(`경과시간: $&#123;end - start&#125; 밀리초`);&#125;, 1000);const end = new Date();// 시간이 정확하지 않다는 문제점이 있음 라이브러리 사용하기 moment.js라는 라이브러리를 jquery 다음으로 많이 사용함. 간단한 작업을 할 때는 Date 생성자를 사용하는데,실무에서는 moment.js혹은 date-fns와 같은 별도의 라이브러리를 사용하는 경우가 많다. 123456789101112const moment = require(\"moment\");// 한국어 사용자를 위해서 moment라이브러리를 사용하겠다.moment.locale(\"ko\");// 한국 시간을 가져오려고 locale('')안에 ko를 적어줌.// moment(); 현재 시간을 가져오는 객체const now = moment();// 내가 원하는 형태로 문자열을 만들고 싶을 때, format()에 원하는 형식의 문자열을 넘겨주면 그 형식대로 가져올 수 있다.console.log(now.format(\"dddd, MMMM Do YYYY, h:mm:ss a\")); // 일요일, 12월 10일 2017, 1:02:42 오후// 7일 전의 날짜를 문자열로 바꾸고 싶을 때 사용console.log(now.subtract(7, \"days\").calendar()); // 2017.12.03// \"YYYYMMDD\" 이 형태로 만든 \"20120101\" 이 날짜가 .fromNow() 지금으로부터 얼마 전인지를 나타내라.console.log(moment(\"20120101\", \"YYYYMMDD\").fromNow()); // 6년 전 Symbol ES2015에서 도입된 새로운 원시 타입 참조 타입 X!! Symbol 내장 함수를 통해 새 심볼을 생성할 수 있다. 123const sym = Symbol(); // 새 Symbole값이 만들어짐console.log(typeof sym); //symbolconsole.log(sym); // Symbol() Symbol은 객체의 속성 키로 사용하기 위해서 만들어졌다. 객체의 비밀 통로 역할을 하기 위해서 심볼이 만들어진 것이다. 대괄호 표기법을 통해 심볼을 객체의 속성 키로 사용할 수 있다. 객체의 속성 키로 문자열과 심볼이 사용될 수 있다. 웹프론트엔드 개발자 입장에서 Symbol을 사용할 일은 자주 없으나, Symbol이 무엇인지는 알아야 한다. 1234567891011121314const mySymbol = Symbol(\"my symbol\");const obj = &#123; // 대괄호 표기법: 대괄호[]안의 표현식의 결과값을 속성의 이름으로 사용하고 싶을 때 // mySymbol이 객체의 속성 키로 사용되고 있다. [mySymbol]: \"hello\"&#125;;// obj.mySymbol과 obj[mySymbol]는 완전히 다른 것이다!!// obj.mySymbol; // undefined// obj.mySymbol 이걸 대괄호로 나타내면// obj['mySymbol'] // undefiend// mySymbol이라는 문자열을 속성키로 갖는 속성console.log(obj); // &#123; [Symbol(my symbol)]: 'hello' &#125; 1234567891011121314151617181920212223242526// Symbol.iterator// Symbol에 있는 내장심볼const arr = [1, 2, 3];// 배열 뿐만 아니라 iterable 객체를 순회할 때에도 사용할 수 있다.for (const item of arr) &#123; console.log(item);&#125;// iterable 객체란, Symbol.iterator 속성에 특별한 형태의 함수가 들어있는 객체를 말한다.for (const char of \"hello\") &#123; console.log(char);&#125;const obj = &#123; [Symbol.iterator]: function*() &#123; yield 1; yield 2; yield 3; &#125;&#125;;for (const item of obj) &#123; console.log(item);&#125; Map 객체와 비슷함 Map은 대응시킨다는 의미가 있음 ES2015에서 도입된 Map 생성자는 객체와 유사하게키-값 쌍(key-value pair)을 저장할 수 있는 새로운 자료구조를 제공한다. 1234567891011121314151617181920const m = new Map();// new Map().set('key', 'value');m.set(\"hello\", \"world\");console.log(m.get(\"hello\")); // 'world'// ('hello')라는 키의 값을 가져와라.console.log(m.has(\"hello\")); // true// ('hello')라는 키를 가지고 있냐?m.delete(\"hello\");console.log(m.get(\"hello\")); // undefinedconsole.log(m.has(\"hello\")); // falseconst obj = &#123;&#125;;obj.hello = \"world\";obj.hello;\"hello\" in obj;const obj = &#123; a: 1 &#125;;m.set(obj, 1);console.log(m.get(obj)); 객체에는 문자열 키만 저장할 수 있다는 제한점이 있다. 프로토 타입이 붙기 때문에 무겁다는 특징이 있다. Map에는 문자열이 아닌 키도 만들 수 있다. 속성의 개수를 알고 싶을 때 Object.keys와 Map 비교 1Object.keys(obj).length; Object.keys로 속성의 개수를 알아보려고 하면, 상속 받은 속성까지 알고 싶은지,열거 가능한 속성만 알고 싶은 지 등등을 고려해야 한다. Object.keys는 열거 가능한 속성만 반환한다. Map에는 열거 가능, 상속 이런 개념이 없으므로 단순하게 사용할 수 있다. Map객체는 데이터의 추가/삭제가 빈번하게 일어나는 경우 일반적인 객체보다 훨씬 빠르게 동작한다는 장점이 있다. 반면, JSON 등으로 직렬화 하기 어렵다는 특징이 있다. 키 값에 문자열 말고도 여러 가지 값을 넣을 수 있기 때문이다. 키-값 쌍 형태의 데이터를 다루면서 속도가 중요한 경우에는 Map의 사용을 고려해보자. Set 배열과 비슷함. 집합 형태의 자료구조 제공 중복 제거할 때 자주 사용함 중복된 데이터의 저장을 허용하지 않는다. ex) {1, 2} U {1, 3} = {1, 2, 3} 배열과는 다르게 첫 번째, 두 번째 요소라는 순서 개념이 없다. 배열과 유사한 자료구조가 필요하지만, 순서가 중요하지 않은 경우, 그리고 중복된 데이터의 저장을 허용하지 않아야 할 경우, Set의 사용을 고려해보자. 12345678function removeDuplicates(arr) &#123; // Set에 넣기만 하면, 중복된 요소가 사라진다. const set = new Set(arr); //집합을 다시 배열로 변환하는 함수: Array.from() return Array.from(set);&#125;removeDuplicates([1, 2, 3, 2, 1]); DOM API이벤트 리스너 el.addEventListener(eventName, callback)- 이벤트 리스너 등록 이 함수가 실행될 때마다 callback이 실행된다. el.removeEventListener(eventName, callback)- 이벤트 리스너 제거 DOM 엘리먼트 생성하기 document.createElement(tagName) - 새로운 엘리먼트 객체 생성하기 el.cloneNode()- 엘리먼트 복사하기 HTML 문서의 구조를 바꾸는 방법 12345// createElement는 ()안의 div를 만들기는 했지만,// 아직 HTML 문서를 변경한 게 X.// div 만들기document.createElement('div');&lt;!-- &lt;div&gt;​&lt;/div&gt;​ --&gt; 요소 객체는 문서 바깥에 있을 수 있고, 문서 안에 있을 수 있다. 문서 상에는 아무런 영향을 미치지 않을 수 있다. 문서 밖에서 만들었다면, 안에 집어넣어줘야 문서에 영향을 미칠 수 있다. 12// 문서 내에서 요소 객체를 가져올 때document.querySelector(\"footer\"); DOM 트리 조작하기 el.appendChild(newChild) - 요소 끝에 자식 요소를 삽입하기 el.insertBefore(newChild, beforeWhat) - 원하는 위치에 자식 요소를 삽입하기 el.replaceChild(newChild, oldChild) - 자식 요소를 교체하기 el.removeChild(child) - 자식 요소 제거하기 appendChild와 insertBefore는 요소의 위치를 이동시킬 때도 사용된다. el.appendChild(newChild): 요소 끝에 자식 요소를 삽입하기.무조건 마지막에 넣는 것임 formEl.insertBefore(divEl2, null)은 formEl.appendChild(divEl2)와 같은 것임. insertBefore에 두 번째 인자로 null을 넣으면 appendChild와 같게 작동 이미 문서에 존재하는 요소 객체를 인수에 넣어서 호출하면, 그 요소 객체를 복사하지 않고, 위치를 이동시킨다. dataset el.dataset - data-* 어트리뷰트를 가져오기. (kebab-case가 camelCase로 변환됨) 12345678910formEl.getAttribute(\"data-foo-bar\");// \"hello\"// ES전에는 getAttribute로 로 가져왔었는데,// ES5부터는 dataset으로 짧게 가져올 수 있다.const formEl = document.querySelector(\"form\");// undefinedformEl.dataset.fooBar;// \"hello\"formEl.dataset.index;// \"1\" 노드 간 관계 el.childNodes - 자식 노드 el.firstElementChild - 첫 번째 자식 요소 el.lastElementChild - 마지막 자식 요소 el.previousElementSibling - 이전 형제 요소 el.nextElementSibling - 다음 형제 요소 el.parentElement- 부모 요소 el.offsetParent: 포지션 세팅이 되어있는 가장 가까운 조상 요소DOM 트리 조작하기 &amp; 노드 간 관계 이용 예시 코드(추가/ 삭제 기능 Todo List) 요소의 크기 및 위치 el.getBoundingClientRect()- 화면 좌측 상단으로부터의 요소의 위치 및 요소의 크기를 반환 el.offsetHeight / el.offsetWidth- border를 포함한 요소의 크기 el.clientHeight / el.clientWidth - border를 제외한 요소의 크기 el.scrollHeight / el.scrollWidth - 요소 내부에 포함된 콘텐츠의 크기 (스크롤 가능한 영역의 크기) el.offsetTop / el.offsetLeft - offsetParent로부터의 요소의 위치 el.clientTop / el.clientLeft - border의 너비 el.getBoundingClientRect()를 가장 많이 사용함. formEl.getBoundingClientRect()했을 때, 반환되는 값 중 x, y는 익스플로러에서는 사용할 수 없다. bottom, height, left, right, top, width 이 6가지 요소를 사용하도록 하자. absolute position을 할 때 기준이 되는 부모가 있는데, 이 부모는 position: relative가 된다. 이벤트 객체 e.target - 실제로 이벤트를 일으킨 요소 e.currentTarget - 이벤트 전파 과정 중 현재 이벤트가 위치한 요소 e.stopPropagation() - 이벤트 전파 과정을 멈추기. e.stoprPropagation()를 만나면, 이벤트 전파 과정이 멈추고 그 이후 이벤트는 실행되지 않는다. MouseEventaltKey: false // altKey를 누른채로 실행하면 true가 반환됨button:clientX: 화면 가장 왼쪽 위, 끝에서부터의 X좌표clientY: 화면 가장 왼쪽 위, 끝에서부터의 Y좌표 e.preventDefault(): 이벤트가 일으키는 브라우저의 기본 동작과정을 취소하기 ex) 링크를 클릭해도 페이지가 넘어가지 않게 만들기 이벤트는 해당 태그가 아니라 그 안에 있는 태그를 클릭해도 발생할 수 있다. ex) form 태그에 마우스 이벤트를 걸었는데, 안에 있는 label태그를 눌러도 마우스 이벤트가 작동한다. 이벤트 전파 Capturing At Target Bubbling 이벤트의 실행 순서가 중요할 때가 있다. ex) 부모 요소의 이벤트가 먼저 실행되어야 하는 경우, Capturing단계에 이벤트를 등록해줘야 하는 경우가 있다. Capturing과정에 걸렸을 때 이벤트를 실행할 것인지, Bubbling과정에 걸렸을 때 이벤트를 실행할 것인지 정해줄 수 있다. 그냥 addEventListener하면 Bubbling과정에서 이벤트가 실행된다. Capturing 단계에 이벤트가 실행되게 하려면, addEverListener의 3번째 인수로 true를 넘겨주면, capturing단계에서 이벤트가 실행되게 할 수 있다. 이벤트 전파 관련 예시 (Capturing &amp; Bubbling 실습)","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 8일차","slug":"javascript8","date":"2019-01-21T17:01:07.000Z","updated":"2019-04-11T15:22:16.168Z","comments":true,"path":"2019/01/22/javascript8/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/22/javascript8/","excerpt":"","text":"연산자 더 알아보기표현식(Expression) 표현식: 코드 중에 값으로 변환될 수 있는 부분 평가: 표현식을 값으로 변환하기 위해 실제로 해당 표현식을 실행시키는 절차 단축 평가(Short-circuit Evaluation)단축 평가의 연산자는 React할 때 많이 쓰인다. &amp;&amp; 왼쪽 피연산자가 falsy이면 이 값을 반환.오른쪽 피연산자는 코드가 실행조차 안된다. 왼쪽 피연산자가 falsy가 아니면,오른쪽 피연산자를 평가한 후, 이 값을 반환 || 왼쪽 피연산자를 평가해서 truthy이면, 이 값을 바로 반환. 아니라면 오른쪽 피연산자를 평가한 결과값을 반환. 특히 || 연산자는 ‘기본 매개변수’ 문법이 생기기 전까지매개변수의 기본값을 지정하는 용도로 많이 사용됐다. 12345678910111213141516171819function func1(arg = \"hello\") &#123; console.log(arg); // arg가 undefined일 때만 'hello'를 출력&#125;function func2(arg) &#123; arg = arg || \"hello\"; // 매개변수 자리에 아무것도 안들어오면 undefined // -&gt; arg가 falsy이므로 오른쪽 피연산자를 평가하게 됨. // arg가 falsy이면 'hello'를 출력 console.log(arg);&#125;function func3(arg) &#123; if (arg === undefined) &#123; arg = \"hello\"; &#125; console.log(arg);&#125; 삼항 연산자 (Ternary Operator) 삼항 연산자 역시 평가할 필요가 없는 부분은 평가하지 않는다. if...else구문처럼 작동한다. 1234console.log(true ? 1 : 2); // 1// : 오른쪽의 코드는 실행조차 안함console.log(false ? 1 : 2); // 2// : 왼쪽의 코드는 실행조차 안함 증가/감소 연산자 (Increment/Decrement Operator) 증가/감소 연산자의 결과값을 어딘가에 저장하거나 사용할 때 코드의 실행 결과가 달라진다. 1234567891011// 아래 코드 예제의 위에 있는 루프는 3번 실행되지만,// 아래 있는 루프는 2번 밖에 실행되지 않는다.let i = 3;while (i--) &#123; console.log(\"감소 연산자를 뒤에 쓰면 어떻게 될까요?\");&#125;let j = 3;while (--j) &#123; console.log(\"감소 연산자를 앞에 쓰면 어떻게 될까요?\");&#125; 할당 연산자 (Assignment Operator) j -= 1과 --j는 같은 의미 j를 1감소시킨 후에 j에 대입하므로 같은 의미이다. 할당 연산자에 대한 표현식의 결과값은 왼쪽 피연산자에 실제로 할당된 값이 된다. 1234let i, j, k, l, m, n;i = j = k = l = m = n = 1;// 이런 표현식도 쓸 수 있다.// =연산자는 오른쪽부터 계산된다. 연산자 우선 순위 (Operator Precedence)연산자 결합 순서 (Operator Associativity) 부등호를 연달아 2개 쓸 수 없다. 12345678// 위아래 식은 완전히 같은 방식으로 동작합니다.// 결과적으로 `true &gt; 1`이 되어 결과값이 `false`가 됩니다.3 &gt; 2 &gt; 1;3 &gt; 2 &gt; 1;true &gt; 1; // false// 세 개의 수에 대한 비교를 하고 싶다면 아래와 같이 해야 합니다.3 &gt; 2 &amp;&amp; 2 &gt; 1; // true 1234// 삼항 연산자 예제 코드const num = 4;const str = num === 1 ? \"one\" : num === 2 ? \"two\" : num === 3 ? \"three\" : \"?\";console.log(str); 삼항연산자를 너무 여러 개 이어서 쓰면 한 눈에 알아보기 어렵다. if...else처럼 작동하게 하고 싶은데 꼭 표현식이어야 한다면 삼항연산자를 사용해야 한다. 거듭제곱 연산자, 할당 연산자는 오른쪽부터 실행된다. 삼항연산자는 괄호는 오른쪽부터 쳐지는데, 실행은 왼쪽부터 작동한다. 123// 위아래 식은 완전히 같은 방식으로 동작합니다.a ? b : c ? d : e ? f : g;a ? b : c ? d : e ? f : g; 값을 비교하는 여러 가지 방법 ==연산자는 두 피연산자의 타입이 다를 때는 타입을 변환한 후 비교한다. null check할 때만 ==연산자를 사용하자. 엄격한 동일성(Strict Equality) ===, !== 연산자는 두 피연산자의 타입이 다른 경우에는 무조건 false를 반환한다. NaN은 ===로 비교하면 자기 자신에 대해서도 같지 않다고 false가 반환된다. NaN인지 아닌지 검사할 때는 Number.isNaN을 사용해야 한다. 1234567// `===` 연산에서, `NaN`은 number 타입의 **모든** 값과 다릅니다.// 이는 자기 자신에 대해서도 마찬가지입니다.NaN === NaN; // false// `0`과 `-0`은 서로 다른 값이지만,// `===` 연산은 이 둘을 같은 것으로 취급합니다.0 === -0; // true Object.is 두 인수가 정말로 같은 값인지를 검사 아래의 두 예외를 제외하고는 === 연산자와 같은 방식으로 동작 12Object.is(NaN, NaN); // trueObject.is(0, -0); // false 무엇을 써야 하나요? 특별한 경우를 제외하고는 === 혹은 !==연산자를 사용해서 비교를 하면 된다. Spread Syntax 배열을 이어붙이거나 복사할 때 사용한다. 배열이 들어가는 게 아니라 배열의 요소들이 펼쳐져서 들어간다. Spread 문법을 통해 배열 리터럴의 중간에 다른 배열을 이어붙일 수 있다. 이 때, arr1 안에 있는 요소들이 arr2 안으로 복사된다. 배열을 복사할 때는 Spread Sytax보다는 slice 메소드가 더 자주 사용된다. Spread Syntax도 slice 메소드와 마찬가지로 얕은 복사를 한다. 12345const arr1 = [3, 4];const arr2 = [1, 2, ...arr1, 5]; // [1, 2, 3, 4, 5]// 이전에는 같은 작업을 하기 위해 `Array.prototype.concat` 메소드를 사용했습니다.[1, 2].concat(arr1).concat([5]); // [1, 2, 3, 4, 5] Spread 문법은 *함수 호출 시에도 사용할 수 있다.8 이 때 배열의 모든 요소를 함수의 인수로 넘긴다. Spread 문법은 배열을 펼쳐서 요소들을 넣고 싶을 때,함수의 인수로 배열을 넘기고 싶을 때 사용한다. 123456789const arr = [1, 2, 3, 4, 5];// 배열 앞에 ...붙이는 건 ES2018에 추가된 문법.// 어떤 브라우저에서는 동작하지 않을 수 있으므로 꼭 변환한 코드로 적용해야 한다.// 아래 코드는 `Math.max(1, 2, 3, 4, 5)`와 동일합니다.Math.max(...arr); // 5// 이전에는 같은 작업을 하기 위해 `Function.prototype.apply` 메소드를 사용했습니다.Math.max.apply(null, arr); // 5 객체123//Object Spread 예제 코드const obj1 = &#123; prop: 1 &#125;;const obj2 = &#123; ...obj1 &#125;; 123456789101112const obj1 = &#123; prop: 1, a: 2, b: 3 &#125;;const obj2 = &#123; a: 3, b: 4 &#125;;const obj = &#123; a: 7, b: 8, ...obj1, ...obj2, c: 4, d: 5&#125;;console.log(obj); 123456789// array spread flatten 코드const arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];function flatten(arr) &#123; return arr.reduce((acc, item) =&gt; [...acc, ...item], []); // return arr.reduce((acc, item) =&gt; acc.concat(item), [])&#125;flatten(arr); 분해대입. 비구조할당 (Destructuring Assignment)배열의 분해대입 배열 순서 섞을 때, [x, y] = [y, x]를 이용해 보기 객체의 분해대입 수의 선언과 동시에 객체의 속성을 해당 변수에 대입할 수 있다. 123const &#123; a: prop1, b: prop2 &#125; = &#123; a: 1, b: 2 &#125;;console.log(prop1, prop2); // 1 2 속성 이름과 변수 이름이 같다면 변수 이름을 생략할 수 있다. 1234// 위의 예제보다 이 예제처럼 변수 이름을 생략하는 경우가 훨씬 압도적으로 더 많이 사용된다.const &#123; a, b &#125; = &#123; a: 1, b: 2 &#125;;console.log(a, b); // 1 2 12345678910let a, b;// 자바스크립트에서는 문장이 여는 중괄호`&#123;&#125;`로 시작되면 이는 '블록'으로 간주되므로,// &#123;a, b&#125;가 블록이라고 간주되서 에러가 난다.&#123;a, b&#125; = &#123;a: 1, b: 2&#125;; //SyntaxError: Unexpected token// 아래와 같이 분해대입을 할 때는 식 전체를 괄호()로 둘러싸주어야 합니다.//()가 문장의 첫 글자이면 아~ &#123;&#125; 블록이랑 다른거구나~ 라고 자바스크립트가 인식한다.(&#123;a, b&#125; = &#123;a: 1, b: 2&#125;);console.log(a, b); // 1 2 화살표 함수에서 중괄호{}가 등장하면,객체라고 인식하는게 아니라 ‘구문이구나.표현식이구나’ 라고 인식하므로객체를 반환하고 싶으면 괄호()로 감싸줘야 한다. 화살표 함수에서 객체를 바로 반환하고 싶은 경우,괄호()로 객체를 둘러싸주어야 한다. 123456const returnObj = (x, y) =&gt; &#123; x, y;&#125;;// 표현식의 결과는 y. 아무 리턴도 하고 있지 않음.const returnObj = (x, y) =&gt; (&#123; x, y &#125;);console.log(returnObj(1, 2)); 객체가 중첩되어 있으면, 해당 객체에 대해서 분해대입을 할 수 있다. 객체의 나머지 속성 분해대입 시 무시된 속성들을 가지고 새로운 객체를 만들고 싶다면,...을 붙여주면 된다. 123const &#123; a, b, ...rest &#125; = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;console.log(rest); // &#123; c: 3, d: 4 &#125; 분해대입의 기본값 분해대입 시, 만약 좌측 변수의 위치에 해당하는 값이 우측의 배열 혹은 객체에 존재하지 않으면거기에는 대입이 일어나지 않는다.-&gt; undefined가 나온다. 좌측 변수에 기본으로 대입될 값으로 미리 지정해둘 수 있다. 12345// 많이 사용되는 기능임// `c` 위치에는 대입될 값이 없으므로, 기본값인 `3`이 대신 사용됩니다.let [a, b, c = 3] = [1, 2];console.log(c); // 3 매개변수에서의 분해대입 함수의 매개변수에서 분해대입을 할 수 있다. 123456789function func(&#123; prop, array: [item1, item2, item3 = 4] &#125;) &#123; console.log(prop); console.log(item1); console.log(item2); console.log(item3);&#125;// 1, 2, 3, 4가 차례대로 출력됩니다.func(&#123; prop: 1, array: [2, 3] &#125;); 분해 대입은 요즘 덧셈만큼 많이 쓰인다. 특히, 할당할 때 많이 쓰이므로 잘 익혀두어야 한다. 123456789101112131415161718// 매개변수에서 객체를 분해대입하는 코드가 많이 쓰이고 있다.function func1(name, age, address, country) &#123;&#125;// 특정 매개변수의 역할을 바로 알아보기 어렵다.// 함수를 사용할 때마다 매개변수의 이름과 순서를 기억해야 한다는 불편함이 있다.// 순서를 바꿔서 쓰면 문제가 생긴다.func(31, \"김승하\", \"관악구\", \"대한민국\");func(\"김승하\", 31, \"관악구\", \"대한민국\");function func2(&#123; name, age, address, country &#125;) &#123;&#125;func2(&#123; // 직관적으로 알아보기 쉽고, 순서를 바꿔도 이상없이 잘 동작한다. name: \"김승하\", age: 31, address: \"관악구\", country: \"대한민국\"&#125;); FDS 브라우저 측 JavaScriptDOM API 실무에서는 DOM API를 직접 쓸 일은 거의 없다. React가 DOM API를 기반으로 되어 있기 떄문에 이해가 필요하다. React를 벗어나는 수준의 고급 웹 개발에도 필요하기 때문에 DOM API를 공부할 필요가 있다. DOM API: 문서를 조작하는 API 라우터가 내장하고 있는 수많은 WEB API들 중에 하나임(통신을 위한 API, 모바일 화면이 가로인지 세로인지 등을 인식하는 API 등이 있음) 메모리에 올라간 html파일을 편집하고 있는 것이므로하드디스크에 저장되어있는 html 문서 내용이 바뀌는 건 X. 요소 선택하기 document.querySelector(selector) - CSS 선택자를 통해 단일 요소 가져오기 이 selector와 일치하는 가장 첫번째 요소 하나를 가져온다. el은 요소 객체 document.querySelectorAll(selector) - CSS 선택자를 통해 여러 요소 가져오기 못 찾은 경우 null 반환 el.querySelector(selector)- CSS 선택자를 통해 단일 자식 요소를 가져오기 el.closest(selector)- 엘리먼트의 조상 중에 CSS 선택자와 일치하는 가장 가까운 조상 요소 가져오기 el.matches(selector)- 해당 요소가 CSS 선택자와 일치하는지 검사하기 요소 내용 조작하기 내용을 읽어오거나 변경하는 방법 2가지 el.textContent: 요소 본문을 가져오거나 변경할 때 사용하는 속성 (텍스트).태그를 제외하고 텍스트 내용만 넣거나 반환 el.innerHTML - 요소 본문을 가져오거나 변경할 때 사용하는 속성 (HTML).태그를 포함해서 html으로써 넣거나 반환 대부분은 textContent를 사용한다. 특히, 사용자로부터 입력받은 텍스트를 innerHTML에 대입해서는 절대로 안된다.textContent를 사용하자. 악의적인 사용자가 자바스크립트로 해킹하는 코드를 게시물로 올렸을 때,사용자로부터 입력받은 텍스트를 innerHTML에 대입하도록 하면 해킹하는 데에 이용될 수 있다. 요소 선택하기 &amp; 조작하기 실습 코드(Counter 실습) 요소 어트리뷰트 조작하기 el.hasAttribute(attrName)- 어트리뷰트가 있는지 검사하기 el.getAttribute(attrName)- 어트리뷰트의 값 가져오기 el.setAttribute(attrName, attrValue)- 어트리뷰트 설정하기 el.removeAttribute(attrName)- 어트리뷰트 삭제하기 리스너 붙이기, 떼기 실습 코드 요소 클래스 조작하기 el.classList.add(className, ...) - 클래스 추가 el.classList.remove(className, ...)- 클래스 삭제 el.classList.contains(className)- 클래스 포함 여부 검사 클래스 추가, 제거 실습 코드(Form Scripting 실습) boolean attribute: 붙어있으면 true, 없으면 false기능을 하는 attribute 클래스명이 여러 개 들어있을 때,setAttribute를 하면 기존의 여러가지 클래스들이 다 지워진다는 버그가 있다.-&gt; setAttribute로 클래스 이름을 추가하는 작업은 거의 하지 않는다.-&gt;classList.add(className,...)하면 쉽게 클래스 이름을 추가할 수 있다. 인라인 스타일 조작하기 el.style- 요소의 인라인 스타일을 읽고 쓸 때 사용하는 객체. camelCase 사용 el.style.backgroundColor = &#39;#000000&#39;- 요소의 배경색을 검은색으로 변경","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"Recursion의 응용 - Counting Cells in a Blob","slug":"recursion-counting-cells-in-a-blob","date":"2019-01-21T03:45:09.000Z","updated":"2019-01-21T07:08:10.101Z","comments":true,"path":"2019/01/21/recursion-counting-cells-in-a-blob/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/21/recursion-counting-cells-in-a-blob/","excerpt":"","text":"이번에는 Recursion의 응용 - Counting Cells in a Blob에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. Counting Cells in a Blob Binary 이미지 각 픽셀은 background pixel(white)이거나혹은 image pixel(blue) 서로 연결된 image pixel들의 집합을 blob이라고 부름 상하좌우 및 대각방향으로도 연결된 것으로 간주 입력: N * N 크기의 2차원 그리드(grid) 하나의 좌표 (x, y) 출력: 픽셀 (x, y)가 포함된 blob의 크기, (x, y)가 어떤 blob에도 속하지 않는 경우에는 0 Recursive Thinking바로 코드부터 작성하지 않고먼저, 순환적인 사고를 글로 적어보자. 123456789현재 픽셀이 이 속한 blob의 크기를 카운트하려면 현재 픽셀이 image color가 아니라면 0을 반환한다 현재 픽셀이 image color라면 먼저 현재 픽셀을 카운트한다 (count=1). 현재 픽셀이 중복 카운트되는 것을 방지하기 위해 다른 색으로 칠한다. 현재 픽셀에 이웃한 모든 픽셀들에 대해서 그 픽셀이 속한 blob의 크기를 카운트하여 카운터에 더해준다. 카운터를 반환한다. 순환적 알고리즘N * N 크기의 2차원 그리드(grid)를 보고, blob의 크기를 계산해보자.blob의 크기는 count값에 누적하여 계산하자. 1. count = 0 2.현재 cell을 칠했기 때문에 count에 1 증가시킨다. count = 1 인접한 8개의 픽셀 각각에 대해서 &gt; 순서대로 그 픽셀이 포함된 blob의 크기를 count한다. &gt; 북, 북동, 동, 동남, … 이런 순서로 고려한다. 3. 북쪽 픽셀을 검사 count = 1 4-1) 북동쪽 픽셀을 검사 count = 1 4-2) count = 1 + 3 = 4 5. 동쪽과 남동쪽 픽셀을 검사 count = 4 6-1) 남쪽 픽셀을 검사 count = 4 6-2) count = 4 + 9 = 13 7. 남서, 서, 북서 방향으로 픽셀을 검사 count = 13 Counting Cells in a Blob1234567891011121314151617181920212223Algorithm for countCells (x, y) &#123; // 예외 처리: pixel (x, y)가 유효한 좌표가 아닐 때(grid의 범위를 벗어날 때) // -&gt; (x &lt; 0 || y &lt; 0 || x &gt; N || y &gt; N) if the pixel (x, y) is outside the grid // 0을 return하고 함수를 종료한다. the result is 0; // Base Case: 1) pixel (x, y)가 0이 아니거나 // (-&gt; 즉, 이 함수에서는 image pixel이 아니면-&gt; background pixel을 의미) // 2) 이미 카운트된 (빨간색으로 칠해진)셀일 경우 else if pixel (x, y) is not an image pixel or already counted // 0을 return하고 함수를 종료한다. the result is 0; // 이미 카운트된 pixel도 아니고 image pixel일 경우 else // 이미 카운트했다는 걸 표시하기 위해서 // 그 pixel (x, y)를 빨간색으로 칠한다; set the colour of the pixel (x, y) to a red colour; // 1) 그 pixel에 1(자기 자신)을 더한 후, // 2) 이 pixel에 인접한 8개의 인접 pixel 각각에 대해서 recursion을 호출한다. // 3) recursion을 8번 호출한 그 결과들을 다 더해준다. the result is 1 plus the number of cells in each piece of the blob that includes a nearest neighbour;&#125; Java 코드로 구현해보기위의 알고리즘을 Java 코드로 구현해 봅시다. 123456789101112131415161718192021222324252627282930private static int BACKGROUND_COLOR = 0;private static int IMAGE_COLOR = 1;private static int ALREADY_COUNTED = 2;public int countCells (int x, int y) &#123; int result; // N * N 그리드는 0 ~ N-1까지가 유효한 좌표이므로 if (x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= N) return 0; // grid[x][y]가 IMAGE_COLOR이 아니라는 건, // grid[x][y]이 // 1) 0 (BACKGROUND_COLOR)이거나 // 2) 0 (ALREADY_COUNTED)일 경우라는 뜻이다. else if (grid[x][y] != IMAGE_COLOR) return 0; // 그렇지 않다면, 카운트할 셀이기 때문에 ALREADY_COUNTED를 표시하기 위해 // 해당 셀을 빨간색으로 칠해준다. else &#123; grid[x][y] = ALREADY_COUNTED; // grid[x][y]의 값인 1과 // (여기에서 더하는 1은 자기자신을 의미한다.) // 이 셀에 인접한 8개의 셀 각각의 recursion을 호출해서 // 그 결과를 다 더해준 값이 답이 된다. return 1 + countCells(x - 1, y + 1) + countCells(x, y + 1) + countCells(x + 1, y + 1) + countCells(x - 1, y) + countCells(x + 1, y) + countCells(x - 1, y - 1) + countCells(x, y - 1) + countCells(x + 1, y - 1) &#125;&#125;","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"순환 함수","slug":"순환-함수","permalink":"https://JihyeHwang09.github.io/tags/순환-함수/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"recursion","slug":"recursion","permalink":"https://JihyeHwang09.github.io/tags/recursion/"},{"name":"Counting Cells in a Blob","slug":"counting-cells-in-a-blob","permalink":"https://JihyeHwang09.github.io/tags/counting-cells-in-a-blob/"}]},{"title":"자바스크립트 7일차","slug":"javascript7","date":"2019-01-20T15:29:09.000Z","updated":"2019-04-11T15:22:16.022Z","comments":true,"path":"2019/01/21/javascript7/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/21/javascript7/","excerpt":"","text":"클래스 클래스는 생성자의 기능을 대체한다. (세부적인 기능상의 차이는 있지만) 함수형 프로그래밍 프로그래밍의 큰 흐름: 객체 지향 프로그래밍 vs 함수형 프로그래밍 고차 함수(Higher-order Function) 함수를 인수로 받는 함수, 또는 함수를 반환하는 함수를고차 함수(higher-order function)라고 한다. 자바스크립트에서는 함수도 값이다. 함수를 호출할 때 함수를 넘기는 함수나 함수를 반환하는 함수(ex) this를 바꿔치기 하는 메소드: bind)가 고차 함수에 속한다. 함수를 인수로 받는 Array의 많은 메소드들(forEach, map, reduce, filter, sort, every, some, find 둥)은 고차 함수이다. 다른 함수의 인수로 넘겨지는 함수를 콜백(callback)이라고 부른다. 클로저(Closure) 자바스크립트에서 스코프는 함수 단위 자기 자신 스코프에 없으면(자기 자신 스코프 내에서 찾는 해당 변수가 정의되어 있지 않거나 함수 등이 없으면)상위 스코프로 올라가서 찾는다. 찾을 때까지 상위 스코프로 올라가서 찾으면 가져다가 쓴다. 없으면 global까지 올라간다. 둘러싸고 있는 것. 성질. 좀비같은 것임 예전에는 자바스크립트에서 아주 중요한 개념이었으나 요즘은 자주 쓰이지는 않음 클로저의 2가지 의미 바깥 스코프에 있는 변수를 가져다가 사용하는 함수변수가 저장되는 저장소 고차함수를 사용할 때 클로저의 성질을 이용할 수 있다. threshould: 임계값, 기준값 클로저는 데이터를 숨기고 정해진 방법을 통해서만 데이터에 접근할 수 있도록 제한을 두는 데 활용된다. 다른 프로그래머가 내가 만든 값에 실수로라도 접근하거나 변경하지 못하게 하고 싶을 때 클로저를 사용한다. 1234567891011121314151617function personFactory(initialAge) &#123; let age = initialAge; return &#123; getOlder() &#123; age++; &#125;, getAge() &#123; return age; &#125; &#125;;&#125;// `age`를 직접 변경할 수 있는 방법이 없습니다!const person = personFactory(20);person.getAge();// age가 비밀스런 저장공간인 클로저에 저장되었으므로 person.getAge()로 값을 가져올 수 있다.// 밑에 코드를 추가해서 나이값을 바꿀 수는 없다. 화살표 함수와 고차 함수 화살표 함수 문법을 이용하면, 적은 양의 코드만 사용해서(간단하게) 고차 함수를 만들 수 있다. 1234const makeAdder = (x) =&gt; (y) =&gt; x + y;// 매개변수: x, 반환값: 함수임. y =&gt; x + yconst add2 = makeAdder(2);add2(3); // 5 1234567const makeCounter = (x = 1) =&gt; () =&gt; x++;// 매개변수: (x = 1), x의 기본값을 1로 지정// 반환값: 함수임. () =&gt; x++const counter = makeCounter();console.log(counter()); // 1console.log(counter()); // 2 재귀 함수(Recursive Function) 재귀 함수(recursive function): 함수 내부에서 자기 자신을 호출하는 함수 문제를 같은 형태의 부분 문제로 쪼갤 수 있을 때, 재귀함수를 활용할 수 있다. 프론트엔드 개발자가 실무에서 자주 사용하지는 않으나, 어떤 문제는 재귀 함수로 푸는 게 편할 때가 있다. 12sb(5) = 1 + 2 + 3 + 4 + 5 = sb(4) + 5 12345678910111213141516171819202122232425262728293031323334353637383940414243function sumBy(n) &#123; let memory = 0; for (let i = 1; i &lt;= n; i++) &#123; memory += i; &#125; return memory;&#125;sumBy(5);function sumByRec(n) &#123; // Rec를 붙여주는 건 -&gt; '재귀 함수'라는 의미임. if (n === 1) &#123; return 1; &#125; else &#123; return sumByRec(n - 1) + n; // return에 오는 표현식이 다 계산이 되어서 실행이 되어야 // 그 다음에 결과값을 return하고 함수 호출을 종료된다. // return은 함수 호출을 종료시키는 것이지, 함수 실행 자체를 종료시키는 게 X. // 일시중지 되어있는 함수들이 촤라락 있고 다시 되감기되면서 연산을 수행한다. &#125;&#125;sumByRec(5);// 위의 코드를 삼항연산자로function sumByRec(n) &#123; return n === 1 ? 1 : sumByRec(n - 1) + n;&#125;// 함수 안에서 함수가 호출되면, 코드의 실행 흐름이 일시정지, 재개를 반복한다.function add(x, y) &#123; return x + y;&#125;function mult(x, y) &#123; return x * y;&#125;function calc(x, y) &#123; return add(x, y) + mult(x, y);&#125;calc(1, 2); 1234567891011121314151617181920212223242526272829303132333435363738// 피보나치 수를 루프로 구현function fibo(n) &#123; // 다음 단계의 수는 이전 두 단계 수의 합 let x = 0; let y = 1; for (let i = 0; i &lt; n; i++) &#123; // 다음 x = 원래 y // 다음 y = 원래 x + 원래 y const sum = x + y; x = y; y = sum; &#125; return x;&#125;fibo(5);// 피보나치 수를 재귀 함수로 바꿔보기// 아이디어// fibo(5) = fibo(3) + fibo(4);// fibo(4) = fibo(2) + fibo(3);// fibo(1) = 1;// fibo(0) = 0;function fiboRec(n) &#123; if (n === 0) &#123; return 0; &#125; else if (n === 1) &#123; return 1; &#125; else &#123; return fiboRec(n - 2) + fiboRec(n - 1); &#125;&#125;fiboRec(7);// 피노나치 수, 팩토리얼 등의 개념이 중요한 게 X.// 재귀 함수를 이용해서 루프를 다시 구현할 수 있다는 걸 아는 게 중요. 재귀 함수를 작성할 때는부분 문제와 종료 조건(재귀 함수가 멈추는 부분)을 생각해 봐야 한다.그 후에 코드로 구현하자. 객체 더 알아보기객체 자신의 속성(Own Property) 객체 자신이 특정 속성을 가지고 있는지를 확인하기 위해 Object.prototype.hasOwnProperty메소드를 사용한다. true or false값을 반환 데이터 속성(Data Property)의 부수속성(Property Attribute) 내장 객체 중에 어떤 속성은 delete 연산자를 통해 삭제하려고 해도 삭제가 되지 않는 것이 있다. JavaScript에서는 각 속성마다 동작 방식이 다를 수 있다. 생성자.메소드() -&gt; 정적 메소드 객체의 부수속성을 알아보려면,Object.getOwnPropertyDescriptor라는 정적 메소드를 사용해 부수속성을 나타내는 객체를 얻을 수 있다.-&gt; 이 객체를 속성 기술자(property descriptor)라고 한다. 데이터 속성(data property)에 대한 속성 기술자가 갖는 속성 value: 속성에 어떤 값이 저장되어 있으면 true, 아니면 false를 반환 writable: 변경할 수 있으면 true, 아니면 false를 반환 enumerable: 열거 가능한 속성이면 true, 아니면 false를 반환 configurable: 부수속성을 변경하거나 속성을 삭제할 수 있으면 true, 아니면 false를 반환 속성의 성질을 가지고 있는 객체를 가져오는 방법 속성 하나에 대한 속성 기술자 가져올 때 Object.getOwnPropertyDescriptor 속성 전체에 대한 속성(여러 속성) 기술자 가져올 때 Object.getOwnPropertyDescriptors 엄격 모드에서는 writable: false, configurable: false인 속성을 변경하거나 삭제하려고 하면 에러가 난다. 속성 기술자를 통해 객체의 속성 정의하기12345678const obj = &#123;&#125;;Object.defineProperty(obj, \"prop\", &#123; // Object.defineProperty(객체 이름, '속성명', &#123;속성 정의하는 내용&#125;); value: 1, writable: false, enumerable: true, configurable: false&#125;); 접근자 속성(Accessor Property)과 그 부수속성 단위를 하나로 통일해서 저장해둔다. 넣고 꺼낼 때 환율 적용한다. 일일히 메소드를 사용하지 않고 getter와 setter 기능을 사용해서, 코드를 조금 더 깔끔하게 작성할 수 있다. 메소드 이름 앞에 get을 써주면, 이 메소드는 getter 메소드가 된다. 메소드 이름 앞에 set을 써주면, 이 메소드는 setter 메소드가 된다. 함수를 실행한 적도 없는데, 속성을 읽어오기만 해도 getter가 실행된다. 1234567891011121314151617181920212223242526272829303132const obj = &#123; // 메소드 이름 앞에 `get`을 써주면, 이 메소드는 getter 메소드가 됩니다. get prop() &#123; console.log(\"getter가 호출되었습니다.\"); return this._hidden; &#125;, // 메소드 이름 앞에 `set`을 써주면, 이 메소드는 setter 메소드가 됩니다. set prop(arg) &#123; console.log(\"setter가 호출되었습니다.\"); this._hidden = arg; &#125;&#125;;// `set prop` 메소드가 `1`을 인수로 해서 호출됩니다.// 값을 저장하려면 인수가 필요하다.obj.prop = 1;// `get prop` 메소드가 호출되고 해당 메소드의 반환값을 읽어옵니다.// 저장된 값을 불러올 때는 따로 인수가 필요없다.obj.prop; // 1Object.getOwnPropertyDescriptors(obj);// &#123;// prop: &#123;// get: [Function: get],// set: [Function: set],// enumerable: true,// configurable: true// &#125;,// ...// &#125; obj 객체 리터럴 안에서 함수 앞에 get과 set 키워드를 사용했다. 이 두 함수는 각각 prop이라는 속성의 getter와 setter가 된다. getter는 속성을 읽어올 때, setter는 속성을 변경할 때 호출됩니다. getter와 setter가 정의된 속성을 접근자 속성(accessor property)라고 한다. 1234567891011121314151617181920212223242526272829303132333435// 위 Money 생성자 예제를 접근자 속성을 통해 재작성function Money(won) &#123; this._won = won;&#125;// `Object.defineProperties` 정적 메소드를 사용해서// 속성 기술자를 통해 특정 객체의 여러 속성을 한꺼번에 정의할 수 있습니다.Object.defineProperties(Money.prototype, &#123; // `Money.prototype` 객체에 `won` 이라는 속성을 정의합니다. won: &#123; get: function() &#123; return this._won; &#125;, set: function(arg) &#123; this._won = arg; &#125; &#125;, // `Money.prototype` 객체에 `dollar` 라는 속성을 정의합니다. dollar: &#123; get: function() &#123; return this._won / 1086; &#125;, set: function(arg) &#123; this._won = arg * 1086; &#125; &#125;&#125;);const w = new Money(1086);w.won += 1086;console.log(w.dollar); // 2w.dollar += 1;console.log(w.won); // 3258 객체의 속성 열거하기1234567891011const obj = &#123; a: 1, b: 2&#125;;Object.keys(obj); // ['a', 'b']// Object.keys(객체명): 속성 이름만 다 뽑아내서 배열로 반환해준다.// Object.values(객체명): 속성 값만 다 뽑아내서 배열로 반환해준다.// Object.entries(객체명): [속성 이름, 값] 다 뽑아내서 배열로 반환해준다.// [[속성 이름, 값], [속성 이름, 값], [속성 이름, 값]] 공부방법: 각 기능을 기억할 것! Object.keys - 객체 자신의 속성 중 열거 가능한(enumerable) 속성의 이름을 배열로 반환합니다. 상속받은 속성은 반환하지 X. 객체 자신의 속성만 반환한다. Object.values - 객체 자신의 속성 중 열거 가능한(enumerable) 속성의 속성 값을 배열로 반환합니다. Object.entries - 객체 자신의 속성 중 열거 가능한(enumerable) 속성의 이름과 값을 배열로 반환합니다. Object.getOwnPropertyNames - 객체 자신의 모든 속성의 이름을 배열로 반환합니다. 열거 불가능한 속성도 포함합니다. for...in 구문 - 객체 자신의 속성 및 상속받은 속성 중 열거 가능한(enumerable) 속성의 이름을 배열로 반환합니다. for...in 구문은 꼭 필요할 때만 사용하자. 123456789101112131415161718192021222324252627282930313233const parent = &#123; d: 4, e: 5&#125;;const obj = &#123; a: 1, c: 3&#125;;Object.defineProperty(obj, \"b\", &#123; value: 2, enumerable: false&#125;);Object.setPrototypeOf(obj, parent);console.log(obj.b);// obj.hasOwnProperty('b')// '객체 자신의 속성' 중 '열거 가능한 속성'만 반환Object.keys(obj); // ['a', 'b']for (let name in obj) &#123; console.log(name);&#125;// a// c// d// e// 브라우저에 따라 순서가 다르게 나올 수 있음.// 대부분의 브라우저들은 먼저 넣은 걸 먼저 꺼내서 출력해주는 경향이 있다.// 어떤 공식 명세서에도 마치 넣은 순서대로 출력되는 것처럼 보이지만,// 사실은 random으로 나온다고 생각하고 프로그래밍 해야 함. 얕은 복사(Shallow Copy) &amp; 깊은 복사(Deep Copy)1234const obj = &#123;&#125;;Object.assign(obj, &#123; a: 1 &#125;, &#123; b: 2 &#125;);// Object.assign(대상객체, 넣을 속성, 넣을 속성)console.log(obj); // &#123; a: 1, b: 2 &#125; Object.assign 정적 메소드는 인수로 받은 객체들의 모든 열거 가능한 속성을 대상 객체에 복사한다.- 배열을 복사할 때는 slice메소드를 사용하고, 객체를 복사할 때는 Object.assign을 사용한다. 첫번째 인수에 빈 객체{}를 넣어준다. 사본을 바꿔도 원본에는 영향이 없다. 객체의 원본을 바꾸고 싶지 않을 경우에는객체를 복사한 후에, 그 사본으로 작업을 하면 된다. 12345678const obj = &#123; a: 1, b: 2&#125;;// 빈 객체를 대상으로 `Object.assign`을 사용하면, 객체를 간단히 복제할 수 있습니다.const obj2 = Object.assign(&#123;&#125;, obj);console.log(obj2); // &#123; a: 1, b: 2 &#125; 1234567const obj = &#123; innerObj: &#123; // innderObj에는 객체 자체가 아니라 객체에 대한 참조가 저장된다. a: 1, b: 2 &#125;&#125;; Object.assign, slice메소드는 객체가 중첩되어 있다면,내부에 있는 객체는 복사되지 않는다. 가장 겉에 있는 한겹만 복사된다. 배열 안의 배열, 객체 안의 배열, 배열 안의 객체 등등 중첩되어 있는 자료구조까지 복사하지는 못한다. 간편해서 많이 사용하는데, 겉껍질만 복사하기 때문에 조심해서 써야한다. 깊은 복사(deep copy)를 하고 싶다면JavaScript에 깊은 복사를 위한 기능이 내장되어 있지 않기 때문에,Immutable.js와 같은 관련 라이브러리를 사용하자. Object.preventExtensions Object.preventExtensions: 특정 객체에 더 이상 속성을 추가하지 못하도록 막아버리는 기능 12345678910111213const obj = &#123; a: 1;&#125;;// Object.seal(obj); 객체에 속성이 삭제되는 것을 막는다.Object.freeze(obj);// Object.freeze(obj); 속성 변경까지 막는다.function func() &#123; 'use strict'; delete obj.a;&#125;func(); // TypeError: Cannot add property a, object is not extensible","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"미로 찾기(Decision Thinking)","slug":"recursion-maze","date":"2019-01-20T08:17:57.000Z","updated":"2019-01-21T03:48:47.307Z","comments":true,"path":"2019/01/20/recursion-maze/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/20/recursion-maze/","excerpt":"","text":"이번에는 Recursion의 응용 - 미로 찾기에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 미로 찾기 Recursive Thinking현재 위치에서 출구까지 가는 경로가 있으려면 현재 위치가 출구이거나 혹은 이웃한 셀들 중 하나에서 현재 위치를 지나지 않고 출구까지 가는 경로가 있거나 미로 찾기(Decision Problem) 답이 yes or no인 문제 어떤 위치를 나타내는 x, y값이 주어졌을 때 (x, y)로부터 출구로까지 가는 경로가 있는지 없는지를 판단 경로가 있으면 true를, 없으면 flase를 반환한다. 123456789101112131415161718192021222324252627282930313233boolean findPath(x, y) &#123; // Base Case: 현재 위치 자체가 출구인지를 검사 if (x, y) is the exit // 현재 위치 = 출구라면, true를 return하고 종료 return true; // 현재 위치가 출구가 X라면, else // 현재 위치와 인접한 셀들(이 경우에는 4개) 중에(현재 위치를 지나지 않고!!) // 출구까지 가는 경우가 만약에 있다면 // 현재 위치로부터 해당 셀로 가서 경로를 따라가면 // 출구까지 가는 경로가 있는 것이다. // (x', y')가 (x, y)의 인접한 셀들 4개 //for each니까 각각에 대해서! for (each neighbouring cell (x', y') of (x, y) do)&#123; // (x', y')가 통로에 속한 셀이라면(지나다닐 수 있는 셀이라면) // (x', y')가 통로에 속한 셀이 X(벽에 위치한 셀)라면, // 무시하고 넘어가면 된다. if (x', y') is on the pathway // 한 칸 이동한 위치에서 recursion으로 다시 검사 if findPath(x', y') return true; &#125; // for문을 빠져나와서 여기까지 왔다는 것은 // 위에 있는 코드의 if findPaht(x', y')&#123;return true;&#125;에서 // return true하지 않았다는 뜻이다. // -&gt; 따라서, 출발하는 현재 위치가 출구가 X고, // 인접한 셀들도 통로가 아니라면(벽이라면) // 미로를 빠져나갈 수 있는 경로가 X므로 // false를 return한다. return false;&#125; Recursion 코드를 작성할 때는 항상 이것이 무한루프에 빠지지는 않는가? 생각해야 한다.따라서 Base Case(무한 루프에서 빠져나올 수 있는 조건)이 반드시 필요Recursion을 반복하다보면, 반드시 Base Case로 수렴한다는 게 보장되어야 한다! 미로 찾기 1자신이 미로에 갇혔다고 생각해보자. 가장 중요한 일 중에 하나가 무엇인가? 내가 가 본 위치와 아직 가보지 않은 위치를 구분하는 것이다.이를 구분하지 않으면, 무한루프를 돌 수 있겠죠? 미로 찾기 문제를 푸는 것도 마찬가지이다. 이미 방문해 본 위치와 방문하지 않은 위치를 적절하게 표시해서 구분할 필요가 있다. 1234567891011121314151617181920212223boolean findPath(x, y) &#123; // 현재 위치가 출구라면 if (x, y) is the exit // true를 return하고 함수를 종료한다. reutrn true; else // (x, y)가 방문한 위치라면, 방문한 위치라고 표시를 해둔다. // recursion이 1번 반복될 때마다 // 새로운 셀이 visited로 표시가 되고, 셀의 개수는 유한하기 때문에 // -&gt; 어떤 경우에도 무한 루프에 빠지지 않게 된다. mark (x, y) as a visited cell; // (x, y_)와 인접한 4개의 위치 각각(x', y')에 대해서 for (each neigthbouring cell (x', y') of (x, y) do) &#123; // 1. (x', y')의 셀이 pathway가 아니거나(벽의 일부거나) // 2. 이미 방문한 셀이라면, 그 셀을 검사해볼 필요가 X // -&gt; (x', y')가 통로이면서 방문한 적이 없는 셀일 경우만 검사하면 된다! // (그 셀에서 출구로 가는 경로가 있는지를 검사하면 됨) if (x', y') is on the pathway and not visited if findPath(x', y') return true; &#125; return false;&#125; point 11mark (x, y) as a visited cell; recursion이 1번 반복될 때마다새로운 셀이 visited로 표시가 되고, 셀의 개수는 유한하기 때문에-&gt; 무한 루프에 빠지지 않게 된다. point 2123if (x', y') is on the pathway and not visited if findPath(x', y') return true; recursion에 들어가기 전에 먼저,그 지점(x’, y’)이 벽이 아닌지 혹은 이미 방문한 지점이 아닌지를 체크 한다. 둘 다에 해당되지 않으면, recursion에 들어가게 설계한다. 미로 찾기 2 무조건 (x, y)에 인접한 각각의 셀(x&#39;, y&#39;)이 벽인지, 이미 방문한 셀인지체크하지 X고, 그냥 findPath(x’, y’)로 recursion을 호출한다. 대신, 이 함수의 맨 앞에 조건을 준다. 만약에 호출된 (x, y)가 1. 벽이나 2. 방문한 위치라면 즉시 false를 return한다. 이 경우에는 미로 찾기 1번 방식보다 recursion이 호출되는 횟수는 많아진다.대신 코드는 간결해진다는 장점이 있다. cf) 미로 찾기 1번, 2번 코드는 어느 코드가 더 낫다고 결론지을 수 없고, 보통 취향에 따라 선택해서 작성한다. 1234567891011121314151617181920212223242526272829303132boolean findPath(x, y) &#123; // First Base Case: (x, y)가 벽이거나 이미 방문한 셀이라면, if (x, y) is either on the wall or visited cell // 즉시 false를 return하고 함수를 종료한다. return false; // 그렇지 않으면서 (x, y)가 출구라면 else if (x, y) is the exit // (x, y)부터 출구까지가는 경로가 존재하는 것이므로 // true를 return하고 함수를 종료한다. return true; // 그렇지 않다면((x, y)가 출구가 아니라면) else // 이 셀(x, y)를 visited라고 표시를 해서 // 이 위치를 중복 방문하는 일을 방지한 다음에 mark (x, y) as a visited cell; // 그 위치(x, y)에 인접한 각각의 셀(x', y')에 대해서 for (each neighbouring cell (x', y') of (x, y) do) &#123; // (x', y')가 벽인지, 방문했는지 여부를 검사하지 않고 // 그냥 recursion을 호출한다. // 왜냐하면, recursion을 호출하면 함수가 실행되고 // 즉시(맨 처음 코드) if절에 걸려서 false가 return될 것이기 때문에 // 여기에서 굳이 검사해 주지 않는다! if findPath(x', y') // 인접한 셀이 최대 4개이므로 4번 호출하고, // 그 중 하나라도 true라면 true를 반환하고 함수를 종료한다. return true; &#125; // 아래 코드까지 왔다는 것은 전부 false라는 뜻이다. // -&gt; 따라서, false를 return 한다. return false; &#125;&#125; class MazeMaze의 출구를 찾는 함수를 Java로 구현해보자. 123456789101112131415161718public class Maze &#123; private static int N = 8; private static int[][] maze = &#123; &#123;0, 0, 0, 0, 0, 0, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 0, 0, 0, 1&#125;, &#123;0, 1, 0, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 0, 0, 0, 1, 0, 1&#125;, &#123;0, 0, 0, 1, 0, 0, 0, 1&#125;, &#123;0, 1, 1, 1, 0, 1, 0, 0&#125;, &#125;; private static final int PATHWAY_COLOUR = 0; // white private static final int WALL_COLOUR = 1; // blue private static final int BLOCKED_COLOUR = 2; // red private static final int PATH_COLOUR = 3; // green PATHWAY_COLOUR: 아직 가본 적 없는 cell (지나다닐 수 있는 통로) WALL_COLOUR: 벽이어서 사람들이 지나다닐 수 없는 cell 방문했던 셀을 표시하기 위해 2가지 색깔이 필요함 출구까지의 경로가 막힌 셀 출구까지 가는 경로가 될 가능성이 있는 셀 BLOCKED_COLOR: visited이며, 출구까지의 경로상에 있지 않음이 밝혀진 cell(가본 셀인데 꽝인 경로) PATH_COLOR: visited이며, 아직 출구로 가는 경로가 될 가능성이 있는 cell 12345678910111213141516171819202122232425262728293031 // recursion으로 미로의 출구를 찾는 함수인 findMazePath public static boolean findMazePath(int x, int y) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= N || y &gt;= N) return false; else if (maze[x][y] != PATHWAY_COLOUR) return false; else if (x == N-1 &amp;&amp; y == N-1) &#123; maze[x][y] = PATH_COLOUR; return true; &#125; else &#123; maze[x][y] = PATH_COLOUR; if (findMazePath(x-1, y) || findMazePath(x, y + 1) || findMazePath(x+1, y) || findMazePath(x, y - 1)) &#123; return true; &#125; maze[x][y] = BLOCKED_COLOR; // dead end return false; &#125; &#125; public static void main(String [] args) &#123; printMaze(); // (0, 0)로부터 출발해서 미로를 탈출할 수 있는 경로가 있는지 알고 싶다. // -&gt; 매개변수를 (0, 0)로 준다. // -&gt; (0, 0)인 입구로부터 미로의 출구가 있는지를 검사하게 된다. findMazePath(0, 0); printMaze(); &#125;// 아래 중괄호는 public class Maze를 닫아주는 중괄호임&#125; point 1123456else &#123; maze[x][y] = PATH_COLOUR; if (findMazePath(x-1, y) || findMazePath(x, y + 1) || findMazePath(x+1, y) || findMazePath(x, y - 1)) &#123; return true; &#125; recursion으로 호출할 때findMazePath의 매개변수인 (x, y)가음수인지, 양수인지 또는 0인지를 검사하지 않고 무작정 호출하기 한다. 이렇게 recursion이 호출되면, 가장 먼저[x][y]가 유효한 범위에 있는가를 검사해야 한다. point 2123456// x &lt; 0 || y &lt; 0 || x &gt;= N || y &gt;= N라는 것은// 미로의 범위 바깥에 있다는 것을 의미한다.// -&gt; 현재 위치(x, y)가 미로의 범위 바깥에 위치한다면, if (x &lt; 0 || y &lt; 0 || x &gt;= N || y &gt;= N) // 즉시 false를 return 한다. return false; N X N 그리드이므로 유효한 좌표는 0 ~ N -1이다. point 312else if (maze[x][y] != PATHWAY_COLOUR) return false; [x][y]가 벽의 일부이거나 이미 방문한 셀이라면 false를 retrun 한다.이걸 뒤집어 말하면[x][y]의 color가 PATHWAY_COLOUR가 아니라면,즉, visited(green, red)나 wall(blue)라면 false를 return하면 된다. point 41234else if (x == N-1 &amp;&amp; y == N-1) &#123; maze[x][y] = PATH_COLOUR; return true;&#125; x == N-1 &amp;&amp; y == N-1라는 것은 이 [x][y]가 출구라는 뜻이다.따라서, 이 경우에는 true를 return 한다.그리고 이 위치를 PATH_COLOUR인 초록색으로 칠한다. point 5123456else &#123; maze[x][y] = PATH_COLOUR; if (findMazePath(x-1, y) || findMazePath(x, y + 1) || findMazePath(x+1, y) || findMazePath(x, y - 1)) &#123; return true; &#125; 북 -&gt; 동 -&gt; 남 -&gt; 서 순으로 검사한다. 이 4가지 방향을 시도해 봐서 그 중 하나라도 출구로 가는 경로가 있다면,true를 return하고 함수를 종료한다. point 612maze[x][y] = BLOCKED_COLOR; // dead endreturn false; 코드의 실행흐름이 여기까지 도달했다는 것은이 위치에서 어느 방향으로 가더라도이미 가본 셀을 거치지 않고서는 출구까지 가는 경로가 없다.-&gt; 즉, 이 maze[x][y]는 꽝이다! 이 자리를 BLOCKED_COLOR인 빨간색으로 칠한다. 그 후 false를 return하고 함수를 종료한다. 움직인 경로 아래 그림은 방금 위에서 살펴본 알고리즘을 호출했을 때실제로 미로상에서 어떻게 움직이는지를 그림으로 그린 것이다. 물론, 실제로 움직이는 경로는 각각의 위치에서 어느 쪽(동, 서, 남, 북)을먼저 시도해보느냐에 따라 달라질 수 있다. 이 그림의 예는 항상 어떤 위치에서 북 -&gt; 동 -&gt; 남 -&gt; 서 순으로검사한다는 가정하에 그린 것이다.","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"순환 함수","slug":"순환-함수","permalink":"https://JihyeHwang09.github.io/tags/순환-함수/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"recursion","slug":"recursion","permalink":"https://JihyeHwang09.github.io/tags/recursion/"},{"name":"미로 찾기","slug":"미로-찾기","permalink":"https://JihyeHwang09.github.io/tags/미로-찾기/"},{"name":"Decision Thinking","slug":"decision-thinking","permalink":"https://JihyeHwang09.github.io/tags/decision-thinking/"}]},{"title":"자바스크립트 6일차","slug":"javascript6","date":"2019-01-19T03:50:27.000Z","updated":"2019-04-11T15:22:16.232Z","comments":true,"path":"2019/01/19/javascript6/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/19/javascript6/","excerpt":"","text":"6일차let, const 변수와 블록 스코프 let과 const는 같은 이름을 갖는 변수의 재선언을 허용하지 X. 유효범위: 블록 스코프 함수의 매개변수나, var 변수는 함수 스코프를 갖는다. 유효범위: 함수 var변수를 둘러싸고 있는 함수가 없을 경우, 유효범위는 전체가 된다. 12345678910111213&#123; let i = 0; console.log(i);&#125;let i = 0;console.log(i, \"a\");let i = 0;console.log(i, \"b\");let i = 0;console.log(i, \"c\"); 비슷한 작업을 여러 번 하는데, 같은 이름의 변수가 사용될 때 ,{}로 묶어주면 같은 이름의 let 변수를 여러 번 선언해도 오류가 나지 않도록 해준다. (유효범위가 블록 스코프이므로) var 변수와 함수 스코프 var 변수는 변수의 선언부를 맨 위로 끌어올린다. 대입부는 그 자리에 그대로. -&gt; 이 과정을 호이스팅이라고 한다. 1234function print() &#123; console.log(foo); var foo = 1;&#125; 123456// 호이스팅function print() &#123; var foo; console.log(foo); // 대입하기 전에 변수의 값을 읽으면, undefined가 반환됨. foo = 1;&#125; var 변수는 함수 스코프를 갖기 때문에 함수가 아닌 블록에서 정의된 var변수가 해당 블록 바깥에서도 유효할 수 있다. var변수를 사용하면, 중첩된for`루프와 같이 블록이 중첩된 코드에서 의도치 않은 동작을 할 수 있다. 12345678910var i;for (var i = 0; i &lt; 3; i++) &#123; console.log(\"outer\"); // 위아래 두 `i` 변수는 같은 함수 스코프에서 정의된 같은 변수입니다. // 바깥쪽 루프를 한 번 도는 동안, 안쪽 루프를 도느라 이미 `i`의 값이 3이 되어버렸습니다. for (var i = 0; i &lt; 3; i++) &#123; console.log(\"inner\"); &#125;&#125;// let은 유효범위가 블록스코프이기 때문에 for이 중첩되어 있을 때 변수 이름을 똑같은 i로 써도 의도대로 잘 작동한다. 전역 변수 (Global Variable) 전역 변수라는 용어는 쓰이고, 요즘은 지역 변수라는 용어는 쓰이지 않는다. 전역 스코프는 스코프 체인의 가장 바깥쪽에 있는 스코프 전역 스코프에 선언된 변수를 전역 변수(global variable)라고 한다. 변수를 전역 스코프에서 선언하지 않고, 한 번도 선언되지 않은 이름으로 안쪽 스코프에서 let, const, var를 붙여주지 않고 변수를 선언하면, 전역 스코프에 변수가 만들어진다. - 변수를 선언할 때, let이나 const를 꼭 써주자. 전역 변수에 의존해서 프로그래밍을 하는 것은 굉장히 금기시되는 일이다. - 값을 공유해야 할 일이 생긴다면, 다른 방식으로 값을 공유하자. 전역 객체 (Global Object) var변수로 전역 변수를 만들었을 때, 전역 객체의 속성이 되어 전역 객체를 통해서 접근할 수 있게 된다. let, const변수는 전역 객체의 속성이 되지 않는다. 참조 (Reference) 객체가 컴퓨터 메모리 상에서 어디에 저장되었는지를 가리키는 값 화살표를 생각하면 됨. 사실 변수에 저장되는 건 객체 그 자체가 아니라 참조(화살표)다. 원시 타입(primitive type) 참조 타입(reference type) 함수 호출 값이 전달되는 것이지, 변수가 전달되는 것이 X. 함수를 호출하면, 변수 안에 값은 그대로 있고, 그 값이 복사되어 인수로 넘긴다. 원시 타입을 인수로 넘길 때는 원본을 변경할 수 없지만, 참조 타입으로 인수로 넘길 때는 원본을 변경할 수 있다. 12345678910const obj = &#123;&#125;;function addProp(o) &#123; o.prop = 1;&#125;// 변수 `obj`에 저장되어 있는 참조가 매개변수 `o`에 복사됩니다.addProp(obj);console.log(obj.prop); // 1 객체의 같음 (Equality) ===로 비교를 하면, 같은 객체를 가리키고 있으면 true, 다른 객체를 가리키고 있지 않으면 -&gt; false를 반환 내가 지금 객체의 내용이 다른지, 아닌지를 판별하고 싶은지 or 두 참조가 정말로 같은 객체를 가리키고 있는지를 알고 싶은지를 구분해야 한다. 12var equal = require(\"fast-deep-equal\");console.log(equal(&#123; foo: \"bar\" &#125;, &#123; foo: \"bar\" &#125;)); // true 객체를 내용을 통해서 비교하고 싶을 때 깊은 비교기능을 지원하는 라이브러리를 이용 Node.js에 require라는 함수가 들어있다. 정확히 어떤 내용을 비교하고 싶은지를 가지고 함수 혹은 메소드를 작성 -&gt; 그것을 이용 불변성 (Immutability) 원시 타입의 특징 Object타입(ex) 객체, 배열, 함수)가 아닌 원시타입(ex) boolean, null, number, string 등)은 원본의 값 자체를 변경할 수 있는 방법은 없다. ex) 문자열을 변형하는 메소드는 모두 기존 문자열의 내용을 바꾸는 게 아니라 새 문자열을 반환한다. -&gt; 원시타입의 값을 바꾸려면, 오직 변수에 다른 값을 재대입하는 방법 밖에 없다. 객체는 가변(mutable)이다. 객체는 가변이지만 일부러 불변으로 만들어주고 사용할 때도 있다. 어떤 값이 가변이면 그 값이 변경되지 않았을까? 걱정하면서 프로그래밍 할 수 있는데, 이럴 경우를 대비하기 위해 객체를 불변으로 만들기도 한다. ex1) Object.freeze를 사용해서 객체를 얼려서 속성의 추가/변경/삭제를 막는다. But 사용하기 조금 불편하다. Object.freeze를 호출한다고 해서 객체 안에 있는 객체까지 얼리는 것은 아니기 떄문이다. 중첩된 객체는 Object.freeze를 사용하기가 조금 까다롭다. 123456789101112const obj = &#123; prop: 1&#125;;Object.freeze(obj);// 모두 무시됩니다.obj.prop = 2;obj.newProp = 3;delete obj.prop;console.log(obj); // &#123; prop: 1 &#125; ex2) Immutable.js같은 라이브러리를 사용 Object.freeze처럼 객체를 정말로 얼려버리지는 않음. 이 객체들은 메소드를 통해 내용이 조금이라도 달라지면 아예 새로운 객체를 반환 내용이 달라지면 참조 역시 달라지게 된다. 12345678import &#123; List &#125; from \"immutable\";// Immutable.js에서 제공하는 `List`는 배열과 유사하지만, 불변인 것처럼 다룰 수 있는 자료구조입니다.const list = List.of(1, 2, 3);const newList = list.push(4); // 새 List 인스턴스를 반환합니다.// 내용이 달라지면, 참조도 달라집니다.list === newList; // false const와 불변성을 잘 구분해야 한다. const는 재대입을 막는 것이지, 원본이 변경되지 않는다는 걸 보장해주는 게 X. 불변성은 값 자체가 변하지 않는 것을 의미한다. 래퍼 객체 (Wrapper Object) 원시 타입의 값에 대해 속성을 읽으려고 시도하면, 그 값을 그 순간에만 객체로 변환되어 마치 객체인 것처럼 작동한다. 12345678910const s = \"hello\";s.toUpperCase(); // 'HELLO's.length; // 5const n = 1.2345;n.toFixed(2); // '1.23'// 소수점 아래 2자리 소수로 바꿔줘라.const b = true;b.toString(); // 'true' 함수 더 알아보기객체로서의 함수 함수는 Function 생성자로부터 생성되는 객체 다른 객체들과는 다르게 호출할 수 있다는 특징이 있다. length - 함수의 매개변수의 개수를 반환합니다. name - 함수의 이름을 반환합니다. 주인 없는 this 생성자나 메소드가 아닌 함수에서 this 키워드를 사용하면 에러는 나지 않지만, this가 전역 객체를 가리키게 된다. 123456789function Person(name) &#123; this.name = name;&#125;// `new`를 빠트린 채 생성자를 호출하면, `this`는 전역 객체를 가리키게 됩니다!Person(\"john\");// 의도치 않게 전역 객체의 속성이 변경되었습니다.console.log(window.name); // john 엄격 모드(Strict Mode)12345678910function Person(name) &#123; // 엄격 모드를 활성화합니다. \"use strict\"; // `undefined`의 속성을 변경하려고 하고 있기 때문에, 에러가 납니다. this.name = name;&#125;Person(\"john\"); // TypeError: Cannot set property 'name' of undefined// this는 undefined의 name이라는 속성을 지정해줄 수 없다. 항상 엄격 모드를 켜고 프로그래밍을 하는 게 좋다. 실무에서는 항상 ‘use strict’를 써줄 필요는 없다. -&gt; 나중에 모듈을 쓴다면 자동으로 엄격 모드가 켜지기 떄문에 만약, react에서 작동하지 않는데, repl.it에서는 작동할 경우 -&gt; repl.it에서는 엄격 모드가 꺼진 채로 작동하기 때문에 ‘엄격모드’ 떄문일 수 있다. this 바꿔치기 window.name에는 빈문자열(‘’)이 저장되어 있다. call과 apply는 인수를 넘겨주는 형식에 차이가 있다. 12345678910function printGrade(grade) &#123; console.log(`$&#123;this.name&#125; 님의 점수는 $&#123;grade&#125;점입니다.`);&#125;const student = &#123; name: \"Mary\" &#125;;printGrade.call(student, 100); // Mary 님의 점수는 100점입니다.// printGrad를 실행하되, this는 student로 하고, 첫 번째 인수를 100으로 한 채 실행하라.printGrade.apply(student, [100]); // Mary 님의 점수는 100점입니다.// this는 student로 하고, 배열의 첫 번째 요소가 첫 번쨰 인수가 되서 실행된다. arguments와 나머지 매개변수 (Rest Parameters) 인수의 개수에 제한이 없는 함수 function 구문을 통해 생성된 함수가 호출될 때, arguments라는 변수가 함수 내부에 자동으로 생성된다. 1234567function add() &#123; // `arguments[0]`에는 `x`와 같은 값이, `arguments[1]`에는 `y`와 같은 값이 저장됩니다. console.log(arguments[0], arguments[1]); return arguments[0] + arguments[1];&#125;add(1, 2); // 1 2 arguments는 ES2015 이전까지 인수의 개수에 제한이 없는 함수를 정의하는 데에 사용되곤 했다. ES2015에서 도입된 나머지 매개변수(rest parameters) 문법을 통해서 똑같은 기능을 더 깔끔한 문법으로 구현할 수 있기 떄문에 arguments는 더 이상 사용되지 않는 기능이다. ... 문법은 마지막 매개변수에만 사용할 수 있다. 자바스크립트는 매개변수의 개수와 인수의 개수가 일치하지 않아도 에러가 나지 않는다는 특징이 있다. 123456789101112131415161718function func() &#123; console.log(\"haha\");&#125;func(1, 2, 3, 4);const arr = [1, 2, 3, 4];arr.reduce((acc, item, index, arr) =&gt; acc + item);arr.map((item, index, arr) =&gt; item * 2);function map(func) &#123; func(item, index, arr);&#125;// map은 함수를 인수로 받는다.// map 입장에서 실행할 때 item, index, arr를 넘겨받지만,// 우리가 필요한 것만 골라서 사용할 수 있다.// 필요없는 매개변수는 생략해서 써도 에러가 나지 않는다. 화살표 함수(Arrow Function) ES2015에서 도입된 새로운 유형의 함수 화살표 함수는 생성자로 사용될 수 없다. 따라서, 화살표 함수는 prototype 속성을 가지고 있지 X. function 키워드로 만든 함수는 모두 생성자로 사용될 수 있다. 12345function func() &#123; console.log(\"haha\");&#125;const obj = new func(); 123456const func = () =&gt; &#123; console.log(\"haha\");&#125;;const obj = new func();// TypeError: func is not a constructor 화살표 함수는 스스로의 this를 가지지 않는다. 화살표 함수는 자기 this가 없으므로, 바로 바깥에 있는 this를 가져다 쓴다. 화살표 함수 내부에서 this를 사용하면, 함수가 정의된 스코프에 있는 this를 가리킨다. 화살표 함수 내부의 this는 화살표 함수가 정의된 문맥에 의해 결정되고, 그 후에는 절대 바꿀 수 없다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function Person(name) &#123; this.name = name; this.getName = () =&gt; &#123; // 여기에서 사용된 `this`는 '함수가 정의된 스코프', // 즉 'Person 함수 스코프'에 존재하는 `this`를 가리키게 됩니다. return this.name; &#125;;&#125;const mary = new Person1(\"mary\");console.log(\"mary.getName():\", mary.getName());// `this`를 바꿔보려고 해도, 아무런 효과가 없습니다.console.log( \"mary.getName.call(&#123;name: 'john'&#125;):\", mary.getName.call(&#123; name: \"john\" &#125;));// function 키워드를 통해 정의된 함수는 '어떻게 호출되느냐에 따라' this의 값이 결정됩니다.function getName() &#123; return this.name;&#125;const john = &#123; name: \"john\", getName&#125;;const bob = &#123; name: \"bob\", getName&#125;;// .getName() 앞에 있는 john이 함수 내부의 this로 사용됩니다.console.log(\"john.getName():\", john.getName());// .getName() 앞에 있는 bob이 함수 내부의 this로 사용됩니다.console.log(\"bob.getName():\", bob.getName());function Person2(name) &#123; this.name = name; this.getName = () =&gt; &#123; return this.name; &#125;; this.getName2 = function() &#123; return this.name; &#125;;&#125;const kate = new Person2(\"kate\");// 함수를 인수로 받는 함수function printResult(func) &#123; // 아래 func는 '메소드로서 호출'되고 있지 않습니다. // 따라서 function 키워드를 통해 생성된 함수일 경우 문제가 생길 수 있습니다. console.log(func());&#125;// 화살표 함수로 정의된 메소드를 다른 함수의 인수로 넘겨도 아무런 문제가 없습니다!console.log(\"printResult(kate.getName)\");printResult(kate.getName);// function 키워드 함수의 경우 this에 문제가 생깁니다. '메소드로서 호출'되고 있지 않기 때문입니다.console.log(\"printResult(kate.getName2)\");printResult(kate.getName2);// 위와 같은 경우 bind 메소드를 사용하면 됩니다만, 좋아보이지는 않습니다.console.log(\"printResult(kate.getName2.bind(kate))\");printResult(kate.getName2.bind(kate));// 화살표 함수가 if문이나 for문 같은 스코프 안에서 정의되지 않음. -&gt; 전역 스코프에 정의됨. -&gt; `this`가 전역 객체를 가리키게 된다.// 위의 화살표 함수는 전역 스코프에서 정의되었기 때문에, `this`는 전역 객체를 가리킵니다.// `mary`의 메소드로 사용된다고 해도, 이 사실이 변하지 않습니다. 브라우저 환경의 전역 객체인 window는 name이라는 속성에 빈 문자열을 갖고 있기 때문에, 이 값이 대신 반환됩니다. 객체의 속성 값에 메소드를 직접 정의할 때는 화살표 함수를 사용해서는 안 된다. 화살표 함수는 어떻게 호출되지는 상관 X. 어떻게 정의되었는지에 따라서 동작한다. 1234// 매개변수로 function keyword 함수를 넘겨주면, this의 주인이 없는채로 실행된다.// 이유는 function keyword함수는 메소드를 실행하려면 `객체.`메소드();해야 하기 때문에// 화살표 함수로 정의된 메소드는 다른 함수의 인수로 넘겨도 아무런 문제가 없습니다! 매개변수의 기본값(Default Parameter) 함수 호출 시에 인수에 값을 넘겨주지 않으면, 매개변수가 undefined가 대입된다. name은 var변수처럼 재대입이 가능하다. 매개변수의 기본값 지정하기 12345678910// 'Mary'가 `name` 매개변수의 기본값이 됩니다.// 만약에 name에 값이 들어오면 그 값이 사용되지만, name에 값이 들어오지 않으면, 'Mary'가 값으로 사용된다.function hello(name = \"Mary\") &#123; // 코드가 훨신 더 깔끔해졌습니다! console.log(`Hello, $&#123;name&#125;!`);&#125;hello(\"John\"); // Hello, John!hello(); // Hello, Mary!hello(undefined); // Hello, Mary!","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 5일차","slug":"javascript5","date":"2019-01-18T06:16:20.000Z","updated":"2019-04-11T15:22:16.016Z","comments":true,"path":"2019/01/18/javascript5/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/18/javascript5/","excerpt":"","text":"프로토타입(Prototype) 함수가 실행될 때마다 객체가 새로 만들어지고 함수도 매번 새로 만들어진다. 객체 안에 메소드를 만들어서 이렇게 매번 만들어지는건 메모리 낭비다. 비슷한 객체들의 속성을 하나로 모아두기 위해서 쓰는 게 프로토타입(Prototype)이다. 프로토타입 상속(prototype inheritance):프로토타입 기능을 이용해 한 객체에서 다른 객체의 기능을 가져와 사용하는 것을 말한다. 프로토타입 상속은 기능을 물려받는 것이다. 부모, 자식으로 표현하기도 한다. ex) personPrototype의 자식에는 person1, person2가 있다. 상속을 받은 객체라고 하더라도 실제로 상속받은 게 이 객체 안에 들어있는 게 X. 12345678910const parent = &#123; a: 1&#125;;const child = &#123; b: 2&#125;;Object.setPrototypeOf(child, parent);// childe가 parent를 상속받는다고 하더라도,// child 안에는 실제로 a라는 속성이 없다.console.log(child); // &#123; 'b': 2 &#125; child 객체에 확인해 봤는데 없으면 계속 부모를 따라 올라가서 확인해본다. object까지 올라갔는데도 없으면 undefined를 반환한다.(없는 속성을 반환하라고 하면 undefined를 반환하므로) 프로토타입의 체인(연쇄)(Prototype Chain) 프로토타입의 체인을 올라가다가 처음 만나는 속성을 사용한다. 더 위의 부모까지 올라가지 않는다. 객체를 쓸 때마다 프로토타입 체인은 항상 동작한다. cf) 배열에는 push라는 메소드가 없다. 배열의 부모에 push라는 메소드가 있다. 프토타입 체인이 동작해서 push라는 메소드가 작동하는 것이다. 자식.isPrototypeOf(부모) 메소드 어떤 객체가 다른 객체의 프로토타입 체인에 존재하는지 확인하기 위해 사용한다. 12obj1.isPrototypeOf(obj3); // trueobj2.isPrototypeOf(obj3); // true 속성 가리기 (Property Shadowing) 프로토타입 체인의 상위에 있는 속성이 하위 속성에 의해 가려지는 현상 프로토타입을 간접적으로 변경하는 것은 불가능 속성을 읽어올 때만 프로토타입 체인을 사용할 수 있다. 속성을 쓰거나 지우는 등의 작업을 할 때는 프로토타입 체인을 사용할 수 없다. 즉, 자식 객체를 통해서 프토토타입 체인을 이용해서 부모 객체의 속성을 변경하거나 삭제할 수 X. 어떤 객체의 속성을 변경하거나 속성을 삭제하는 작업은 그 객체의 프로토타입에 아무런 영향을 미치지 않는다. 생성자 (Constructor) Person.prototype에 객체를 저장한 적이 없지만 객체가 저장이 되어 있다. 생성자로부터 인스턴스를 생성하면, 인스턴스의 부모는 생성자.prototype이 된다. 1234567891011121314151617181920212223242526// Person 생성자 예제function Person(name) &#123; this.name = name; this.age = age;&#125;Person.prototype.familyName = \"김\";// person1.familyName;의 결과값은 '김'이 된다.Person.prototype.introduce = function() &#123; console.log(`안녕하세요, $&#123;this.familyName&#125;$&#123;this.name&#125;입니다.`); // 이 this는 person1을 가리킨다.&#125;;erson.compareAge = function(person1, person2) &#123; if (person1.age &lt; person2.age) &#123; return \"첫 번째 사람의 나이가 더 많습니다.\"; &#125; else if (person1.age === person2.age) &#123; return \"두 사람의 나이가 같습니다.\"; &#125; else &#123; return \"두 번째 사람의 나이가 더 많습니다.\"; &#125;&#125;;const person1 = new Person(\"승하\");// person1의 부모는 Person.prototype이 된다.person1.introduce();const person2 = new Person(\"아준\");person2.introduce(); 요즘은 클래스를 많이 쓰는 편. 클래스를 알려면 먼저 이걸 잘 이해해야 한다. (function keyword 함수로 만들어진) 메소드 내부의 this는 호출되는 시점에 결정된다.(화살표 함수에서의 this는 동작 방식이 다르다.) cf) 화살표 함수의 this는 정의되는 시점에 결정된다. 함수가 정의되는 시점 함수가 호출되는 시점 함수가 만들어질 때(정의될 때), this가 무엇을 가리키는지 정해지는 게 X. constructor 객체.constructor를 사용하면 객체가 어떤 생성자로부터 생성되었는지를 알아낼 수 있다. 정적 메소드 생성자 속성에 직접 지정된 메소드를 정적메소드라고 한다. ex) Number.isNaN, Object.getPropertyOf등의 함수들은 모두 정적 메소드이다. reduce 메소드123const arr = [1, 2, 3];arr.reduce((acc, item) =&gt; acc + item, 0); // 6 초기 누적값: 0 마지막의 누적값이 결과값이 된다. 누적값: accumulator ex) 문자열 길이의 총합을 구하고 싶다. reduce 메소드를 가지고 map, filter, sort 등 다른 메소드를 만들수도 있다. 12345678910111213// fileter 직접 구현하기function filter(arr, func) &#123; return arr.reduce(function(acc, item) &#123; if (func(item)) &#123; acc.push(item); &#125; return acc; &#125;, []);&#125;const arr = [1, 2, 3, 4, 5];filter(arr, (x) =&gt; x % 2 === 0); 배열을 반환할 거니까 빈 배열을 초기 누적값으로 줌. reduce메소드에 초기누적값을 넘겨주지 않으면, 배열의 첫번째 값이 초기누적값으로 사용됨. reduce를 쓸 때는 항상 초기값을 넣어주자. 123const arr = [\"Denton\", \"Roy\", \"Jay\"];arr.reduce((acc, item) =&gt; acc + item, 0);// Denton33 배열을 순회할 때, 순회 중인 배열을 편집하면 안된다. 루프를 돌면서 배열에 뭔가를 편집하고 싶다면, 새 배열을 만들어서 편집해라.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"CSS 박스모델","slug":"css-box-model","date":"2019-01-17T13:38:24.000Z","updated":"2019-04-11T15:22:16.083Z","comments":true,"path":"2019/01/17/css-box-model/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/17/css-box-model/","excerpt":"","text":"1일차1교시123.wing &#123; 색상: 빨강;&#125; 웹사이트는 .html이라는 확장자를 가진 파일이 실행된다. https://www.naver.com에 접속하면, 실제로는 index.html파일이 실행되는 것이다. https://www.naver.com/index.html Ctrl + + / Ctrl + -로 화면을 확대, 축소를 할 수 있다. 전체 큰 틀부터 작성하라. 123456789101112&lt;!DOCTYPE html&gt;&lt;!--태그`&lt;&gt;`안에 들어있는 내용은 이미 약속된 내용--&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Orange&lt;/title&gt; &lt;!--Orange라고 작성한 내용은 내가 작성하고 싶은 내용--&gt; &lt;/head&gt; &lt;body&gt; Orange &lt;/body&gt;&lt;/html&gt;&lt;!--태그의 시작부분에 `/`가 있으면 종료 태그를 의미--&gt; 작성한 html 파일을 웹 브라우저를 통해 해석하는 개념이므로,꼭 저장을 한 후! 실행한 html파일에서 F5를 눌러서 새로고침해서 웹사이트를 확인 검색 엔진에 정보를 전달하기 위해서 내가 어떤 태그를 써야할까 고민하는 게 첫 번째 일이다. html의 목표는 시각화 하는게 목적이 X. 검색 엔진을 위한 것이기 때문에 디자인적인 요소는 들어가지 않는다. 엔터를 쳤다고 해서 목록으로 정렬되는 게 X. 태그를 사용해서, 목록이라는 의미를 부여해 줘야 한다. ul(Unordered List): 순서가 정해지지 않은 목록 이미지 삽입 html문서에 이미지가 포함되는 게 X. 이미지를 별도의 파일로 만들고, 불러오기만 가능하다. image를 줄여서 &lt;img&gt;라는 태그를 사용한다. 는 다른 태그와 목적이 다르기 때문에 닫는 태그가 없다. 태그는 태그 자체가 컨텐츠이기 때문에. 어떤 내용물을 꾸며주는 태그가 아니라, 이미지 자체가 내용물이기 때문에 닫는 태그가 없다. src(source)는 이미지 경로를 줄 때 사용 2교시1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt; /* 문서의 버전을 명시(이렇게 작성하면, 최신 버전으로 만들어줌) */&lt;html&gt;/* &lt;head&gt;안에는 문서의 정보가 들어감 */ &lt;head&gt; &lt;title&gt;Orange&lt;/title&gt; /* html과는 별개로 head안에 style태그를 넣어줌 */ &lt;style&gt; body &#123; /* background-repeat: no-repeat; background-position: center;*/ background-image: url(fruit/orange-bg.png); background-color: #c5b1fc; color: red; &#125; div &#123; background-color: white; width: 400px; /* margin은 바깥쪽 여백을 주어 전체 요소가 내려갈 수 있게 해줌.*/ /* margin-top: 50px;*/ /* auto는 내가 쓸 수 있는 공간 다 쓸게.*/ /* margin-left: auto; margin-right: auto; margin의 상단, 하단, 왼쪽, 오른쪽 다 auto로 준다. margin: auto;*/ /* 상하 좌우 margin주는 걸 실무에서 가장 많이 사용함 */ margin: 20px auto; /* 상하 좌우 */ margin: 30px auto 40px; /* 상 좌우 하 */ margin: 30px auto 40px 50px; /* (시계 방향을 생각) 상 우 하 좌 */ padding: 50px; /* border-width: 10px; border-style: solid; border-color: orange;*/ /*단축속성인 border로 여러가지의 속성들을 한꺼번에 줄 수 있다. */ /* div야, 네 안에 있는 text들이 다 가운데 정렬되게 해라. */ /* div 자체가 가운데 정렬되는 게 X */ /* text-align: center;*/ /* height값을 주지 않았을 때는 자동으로 조절되지만, 고정값을 주면 나중에 내용이 넘칠 경우에 내용이 밖으로 나가게 된다. */ /* height는 안 적는게 좋다. */ /* height: 400px;*/ /* 넘쳐 흐르는 내용 처리하는 방법*/ /* overflow: hidden;*/ /* overflow: scroll;*/ &#125; h1 &#123; border-bottom: 5px solid orange; /* background-color: antiquewhite; */ width: 110px; /* 기본적으로 배치가 왼쪽으로 붙으므로 */ /* h1도 박스다. h1은 기본적으로 div처럼 부모의 너비만큼 너비를 차지한다. /* 따라서 -&gt; margin을 주려면, width값을 먼저 줘야 적용된다. */ /* width값을 따로 주지 않으면, 꽉 차있는 상태니까 margin이 적용되지 않는다. ex) 꽉 차 있는 방을 어떻게 가운데 정렬할 수 있겠어요?! */ margin-left: auto; margin-right: auto; padding-bottom: 5px; text-align: center; &#125; &lt;/style&gt; /* 태그`&lt;&gt;`안에 들어있는 내용은 이미 약속된 내용 */ /* Orange라고 작성한 내용은 내가 작성하고 싶은 내용 */ &lt;/head&gt; /* 실제 우리 눈에 보이는 영역 */ &lt;body&gt; &lt;div&gt; &lt;img src=\"fruit/orange.png\" /&gt; /* heading1의 의미. 제목을 적을 때 작성 */ /* h1태그는 웹브라우저에 미리 저장되어 있는 CSS가 적용된 것이다. */ &lt;h1&gt;Orange&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Orange&lt;/li&gt; &lt;li&gt;Kiwi&lt;/li&gt; &lt;li&gt;Strawberry&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;/* 태그의 시작부분에 `/`가 있으면 종료 태그를 의미 */ 부모 태그자식 태그 들여쓰기 해주는 이유? 부모 - 자식 간의 관계를 직관적으로 인지하게끔 하는 것임 Brackets에 ul&gt;li라고 작성후 tab키 누르면, 부모-자식 관계로 자동 완성할 수 있음 Brackets에 실시간 미리보기라는 기능으로 Chrome에서 F5키를 누르지 않고, 바로 확인이 가능하나 오류가 많기 때문에 수동으로 새로고침하기를 권장 CSS(Cascading Style Sheets) 어떤 요소를 파악하려면, 어떻게 공간을 차지하고 있나를 파악하기 위해서 배경색(background-color)을 많이 사용한다. h1, body 등은 선택자(Selector)라고 하고, 이 선택자에 {}안에 디자인 코드를 적어주면 스타일을 적용할 수 있다. background-color, color 등은 속성(property) :는 구분자 : 구분자 다음에 나오는 내용을 값(value)라고 한다. ; CSS에서 ;를 잘 적어줘야 한다. 빠뜨리면 스타일이 적용되지 x. Ctrl+ E를 누르면, 컬러를 선택할 수 있는 표가 나온다. background-image: url() url()안에 이미지의 경로를 적어준다. background-image와 background-color는 작성 순서가 중요하지 X ex) background-repeat: no-repeat; h1과 ul을 같이 묶어야 같이 옮길 수 있다. -&gt; 새로운 태그로 감싼다.cf) 이사 다닐 때 박스에 물건을 함께 넣으면 옮기기 편하다는 걸 떠올려라. div(division): 내가 그룹핑하고 싶은 태그들을 감싸는 역할 ul처럼 목록, h1은 제목 등 의미가 있는데, div는 의미는 없다. div의 너비(width)는 부모인 body가 가지고 있는 너비만큼이다. div의 높이(height)는 자식들의 높이만큼 자동으로 조절이 된다. 주석(Comments) 작성법: /**/사이에 메모를 적으면, 브라우저가 이 사이에 있는 내용은 해석하지 않는다. 해당 요소를 가운데 정렬 CSS는 급격하게 발전하면서, 정렬에 대한 키워드가 따로 없다. margin은 바깥쪽 여백을 나타냄. 사용자들은 각기 다른 화면으로 웹 브라우저를 보기 때문에 왼쪽 기준으로 여백을 주는 것이기 때문에 고정된 px로 주지 말고, auto로 주자. auto는 내가 쓸 수 있는 공간 다 쓴다는 뜻 12margin-left: auto;margin-right: auto; 여백의 개념은 2가지이다. 안쪽 여백(padding)을 지정할 수 있다. 안쪽 공간이라고 해서 width가 유지되는 게 아니라, width에 padding이 양 옆으로 붙음. ex) width 400에 padding이 양 옆에 50px씩 붙으니까 500px이 됨. 테두리border border도 padding처럼 width, height값에 추가 된다. border-width border-style border-color CSS에는 단축속성이 있다.여러가지의 속성들을 한꺼번에 적어줄 수 있다. 1border: 10px solid orange; 오늘의 핵심 키워드는 CSS 박스 모델(Box Model) 5가지이다. &gt; width, height, margin, padding, border CSS를 잘하려면, 재료를 잘 이해하고 아이들이 물감 놀이 하듯이 많이 연습해보아야 한다. 123456789/* 내가 작성한 내용 */h1 &#123; color: orange; border-bottom: 6px solid orange; /* h1도 박스다. margin을 주려면, width값을 먼저 줘야 적용된다. */ width: 120px; margin: auto; padding: 6px;&#125; 12345678910111213141516/* 강사님이 작성하신 내용 */h1 &#123; border-bottom: 5px solid orange; /* background-color: antiquewhite; */ width: 110px; /* 기본적으로 배치가 왼쪽으로 붙으므로 */ /* h1도 박스다. h1은 기본적으로 div처럼 부모의 너비만큼 너비를 차지한다. */ /* 따라서 -&gt; margin을 주려면, width값을 먼저 줘야 적용된다. */ /* width값을 따로 주지 않으면, 꽉 차있는 상태니까 margin이 적용되지 않는다. ex) 꽉 차 있는 방을 어떻게 가운데 정렬할 수 있겠어요?! */ margin-left: auto; margin-right: auto; padding-bottom: 5px; text-align: center;&#125; h1도 박스다. margin을 주려면, width값을 먼저 줘야 적용된다.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"}]},{"title":"자바스크립트 4일차","slug":"javascript4","date":"2019-01-16T00:45:56.000Z","updated":"2019-04-11T15:22:15.962Z","comments":true,"path":"2019/01/16/javascript4/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/16/javascript4/","excerpt":"","text":"객체(Object) 자바스크립트의 자료구조에는 객체와 배열이 있다. 객체는 한꺼번에 여러 값을 담을 수 있는 통(container)과 같은 자료구조(data structure)이다. 객체 안에는 이름-값 쌍(name-value pair)이 저장되는데, 이를 객체의 속성(property)라고 한다. 객체 리터럴(Object Literal) 객체 리터럴에서 속성을 정의할 때는 &#39;&#39;를 써도 되고 안써도 된다. 식별자 규칙을 만족하는 문자열을 속성 이름으로 사용할 때는 따옴표를 생략해도 된다. 식별자 이름 규칙을 만족하지 않는 경우, &#39;&#39;로 감싸줘야 한다. 식별자의 이름에 공백은 허용되지 않으므로 ex) ‘한국 나이’ 따옴표로 둘러싸줘야 한다. ‘한국 나이’: 20 + 3 해도 된다. 표현식의 결과값이 속성값이 된다. 축약 표기법 내가 갖고 있는 변수의 이름과 똑같은 이름을 갖는 속성을 만들고 싶을 때, 1234567const name = \"윤아준\";const person = &#123; name, // `name: name`과 똑같이 동작합니다. age: 19 // ...&#125;; 왼쪽: 속성 이름- name, 오른쪽: 속성 값이 될 표현식- name 객체 리터럴에서 속성을 정의하는 세 가지 방법 아래와 같이 대괄호를 사용해서 다른 변수에 저장된 문자열을 그대로 속성의 이름으로 쓰는 것도 가능합니다. []로 둘러싸여있으면 이 표현식의 결과값이 속성의 이름이 된다. 1234567891011121314const propName = 'prop3'const obj = &#123; // 아래 두 예제는 왼쪽 부분이 문자열로 간주된다. // 그리고 그 문자열이 그대로 속성 이름으로 사용된다. prop1: 1, // prop1이 속성 이름이 된다. 'prop2': 2, // prop2가 속성 이름이 된다. // 아래 예제는, 대괄호 내부의 표현식의 결과값이 // 속성 이름으로 사용된다. [propName]: 1 // prop3이 속성 이름이 된다. [propName + propName]: 1 // prop3prop3이 속성 이름이 된다.&#125;;// 아래의 표기법들은, 주로 '코드 작성 시점에 속성 이름을 알 수 없는 경우'에 사용된다. 점 표기법, 대괄호 표기법123456const person = &#123;&#125;; // 빈 객체// 점 표기법 (Dot notation)person.name = \"윤아준\";person.age = 19;person.languages = [\"Korean\", \"English\"]; 문자열이 그대로 속성 이름으로 사용되는가 표현식의 결과값이 속성 이름으로 사용되는지를 봐야 한다. 객체 리터럴을 통해 이미 만들어진 객체에도 얼마든지 속성을 추가할 수 있다. 속성 접근자를 통해서 접근할 때 식별자 규칙을 만족하는 경우에만 점 표기법을 통해 접근할 수 있다. 식별자 규칙을 만족하지 X경우, 반드시 대괄호 표기법을 사용해야 한다. 12345// 대괄호 표기법(Bracket notation)person.한국 나이 = 20;//이렇게 쓸 수 X. 식별자 이름에 공백이 있어서 쓸 수 X.person.'한국 나이' = 20;//이렇게 쓸 수 X.person.['한국 나이'] = 20; // 식별자 규칙을 만족하지 않으므로 []안에 써준다.person.['한국' +' 나이'] = 20; // 이렇게도 쓸 수 있음. []안에 있는 건 표현식이라는 걸 보여주기 위한 예시 코드 보통 점표기법이 많이 사용되나 대괄호 표기법을 사용해야 하는 경우가 있다. 접근하고자 하는 사용자로부터 입력받은 문자열을 속성 이름으로 사용하고 싶을 경우, 코드 작성 시점에는 어떤 이름이 될지 모르므로 대괄호 표기법을 사용한다. 12345678// 사용자로부터 입력받은 문자열을 속성 이름으로 사용하는 예제const propName = prompt(\"속성 이름을 입력하세요\");const propValue = prompt(\"속성 값을 입력하세요\");const obj = &#123;&#125;;obj[propName] = propValue;// propName이라는 변수에 저장되어있는 값을 속성 이름으로 사용하는 경우이므로// 이때는 사용자가 입력한 값이 속성의 이름이 되는 게 아니라 값이 된다. 객체 다루기123// 속성 삭제하기delete person.address;// delete는 연산자이다. 객체의 속성이 삭제되면 true값이 반환된다.객체의 속성이 사라지는 걸 막는 경우가 있는데 그 경우에는 delete연산자로 속성을 삭제하려고 하면, false값이 반환된다. 1234// 속성이 객체에 존재하는지 확인하기\"name\" in person; // true\"phoneNumber\" in person; // false// in도 연산자이다. 메소드 (Method)1234567const person = &#123; greet: function() &#123; return \"hello\"; &#125;&#125;;person.greet(); // 'hello'; 12345678// 축약 표기법. 위 예제와 완전히 똑같이 동작한다.const person = &#123; greet() &#123; return \"hello\"; &#125;&#125;;person.greet(); // 'hello'; 1234567891011121314151617181920212223const person = &#123; name: \"윤아준\", age: 19, introduce() &#123; // `this`를 사용해서 객체의 속성에 접근함 return `안녕하세요, 제 이름은 $&#123;this.name&#125;입니다. 제 나이는 $&#123; this.age &#125;살 입니다.`; &#125;, getOlder() &#123; // `this`를 사용해서 객체의 속성을 갱신함 this.age += 3; // 3살 더하기 &#125;, getYounger() &#123; this.age--; // 1살 빼기 &#125;&#125;;// person.introduce(); // '안녕하세요, 제 이름은 윤아준입니다. 제 나이는 19살 입니다.'person.getOlder(); // undefinedperson.introduce(); // '안녕하세요, 제 이름은 윤아준입니다. 제 나이는 20살 입니다.' 객체 리터럴 안에서는 객체 속성값으로 함수를 지정할 때 ,를 찍어줘야 한다. 화살표 함수와 function keyword함수를 사용했을 때는 ‘this’를 사용했을 때, 동작 방식이 다르게 동작한다. 생성자(Constructor) new를 써서 호출하는 함수를 생성자라고 한다. 12345678910111213// 생성자 정의function Person(name) &#123; this.name = name; this.age = 0; this.getOlder = function() &#123; this.age++; &#125;;&#125;// 생성자를 통한 객체 생성const person1 = new Person(\"윤아준\");person1.getOlder();console.log(person1); // Person &#123; name: '윤아준', age: 1, getOlder: [Function] &#125; 12345678910111213// 생성자 정의function Person(name, age) &#123; this.name = name; this.age = age; this.getOlder = function() &#123; this.age++; &#125;;&#125;// 생성자를 통한 객체 생성const person1 = new Person(\"윤아준\", 0);person1.getOlder();console.log(person1); //Person &#123; name: '윤아준', age: 1, getOlder: [Function] &#125; 인스턴스 (Instance) 생성자를 통해 생성된 객체를 그 생성자의 인스턴스(instance)라고 한다. instanceof 연산자를 사용하면, 객체가 특정 생성자의 인스턴스가 맞는지를 확인할 수 있다. 1person1 instanceof Person; // true 12const obj = &#123;&#125;;obj instanceof Object; // true ‘자바스크립트’에서 생성자와 일반적인 함수 간의 차이는 없다. 함수를 생성자로 쓰면 생성자가 되는 것이었다. 이것이 자바스크립트의 부족한 점이었다. ES6에 객체를 만드는 일만 하는 함수인 클래스가 생겼다. 현재는 생성자를 많이 쓰진 않으나 클래스를 이해하려면 생성자를 먼저 이해해야 한다. 프로토 타입 prototype은 메소드를 넣는 방법 중의 하나다. cf) 참고 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes 배열 객체에서는 안에 들어있는 값들을 속성, 배열 안에 들어있는 값들을 요소 또는 항목이라고 한다. 배열 생성하기배열 리터럴 배열 안에 객체 등을 넣을 수 있다. Array 생성자 자주 쓰이지는 X. 인수를 하나 넘기면 그 개수만큼 빈칸이 있는 비어있는 배열이 만들어진다. 인수가 2개 이상이면 그 인수들을 요소로 갖는 배열을 생성한다. Array.of Array 생성자의 단점을 보완하기 위해 만들어짐. 자주 쓰이진 X Array.of 메소드를 사용하면 인수가 하나이더라도 그 인수를 요소로 갖는 배열을 반환한다. Array.from 간간히 사용되는 편임. 외울 것. 12Array.from(\"hello\"); // [\"h\", \"e\", \"l\", \"l\", \"o\"]// 'hello'.split('');으로 만들수도 있음. 요소 읽기요소 수정하기fill 메소드 하나의 값으로 배열 전체나 일부분을 채울 수 있다. arr.fill(배열을 채울 값, index시작, index 끝번호-1 ) 123// 인덱스 2와 4 사이를 1로 채우기arr.fill(1, 2, 4);console.log(arr); // [ 0, 0, 1, 1, 0 ]; Array 생성자와 fill 메소드를 사용하면, 큰 배열을 만들고 값을 채워넣는 일을 쉽게 할 수 있다. 12// 1000칸의 빈칸이 있는 배열을 만들고 5로 배열을 가득 채운다.new Array(1000).fill(5); // [5, 5, 5, 5, ...] 배열의 끝 부분에서 요소를 추가/제거하기배열의 오른쪽 끝 부분에서 요소를 추가/제거하기push 메소드와 pop 메소드를 사용하면 배열의 오른쪽 끝 부분에서 요소를 추가하거나 제거할 수 있다.push 메소드 - 배열의 오른쪽에 요소를 추가한다. - push 메소드에 여러 개의 인수를 동시에 넘길 수도 있다.pop 메소드 - 배열의 오른쪽 맨 끝에 있는 값을 끄집어내서 반환한다. - 배열의 오른쪽 맨 끝에 있는 요소를 삭제한다. 123456789101112const arr = [];arr.push(\"one\"); // 1 (요소가 추가된 후의 배열의 길이를 반환)arr.push(\"two\", \"three\"); // 결과값: 3// 배열의 오른쪽에 요소를 추가한다.console.log(arr); // [ 'one', 'two', 'three' ]// 배열의 요소 삭제하기arr.pop(); // 'three'arr.pop(); // 'two'arr.pop(); // 'one'arr.pop(); // undefined (더 이상 배열에 요소가 남아있지 않으면 `undefined`를 반환) 배열의 왼쪽 끝 부분에서 요소를 추가/제거하기 반대로 unshift, shift 메소드를 사용해 배열의 시작 부분(왼쪽 부분)에서 요소를 추가하거나 제거할 수도 있다. 기능은 push 메소드와 pop 메소드와 같으나 방향만 다름.(왼쪽 부분부터) 요소를 배열 중간에 삽입하기 splice메소드: 열에 속해있는 연속된 여러 요소, 즉 배열의 일부분을 통째로 바꿔버릴 수 있다. splice메소드 끄집어 낸(바꿔치기 당한) 요소를 끄집어내서 반환한다. 배열의 요소들을 바꿔치치 한다. arr.splice(시작 index 번호, 바꿀 요소의 개수, 바꿔서 채울 요소); splice는 반드시 같은 개수의 요소만 바꿔치기 할 수 있는 게 X.끄집어내는 개수와 채우는 개수가 달라도 된다. 123let arr = [1, 2, 3, 4, 5];arr.splice(1, 3, \"three\"); // [2, 3, 4]console.log(arr); // [ 1, 'three', 5] 바꿀 요소의 개수 자리에 0을 넣으면 해당 index의 요소를 빼기만 하고 채워지는 건 X. 이렇게 splice 메소드를 배열의 중간 부분에 있는 요소를 제거하는 데도 활용할 수 있다. splice의 두 번째 인수로 0을 사용하면, 특정 위치에 여러 요소를 삽입할 수도 있다. 1234// 인덱스가 `1`인 요소 앞에 여러 요소를 추가합니다.const arr = [1, 5];arr.splice(1, 0, 2, 3, 4); // []console.log(arr); // [ 1, 2, 3, 4, 5] 배열 뒤집기 reverse 메소드: 원본 배열을 거꾸로 뒤집어 버린다. 뒤집은 원본 배열을 반환한다. sort 메소드 뭐가 앞에 와야하는지, 뒤에 와야하는지 그 기준이 있어야 한다. sort 메소드를 쓸 때는 비교 함수를 넘겨주어야 한다. 오름차순: 작 -&gt; 큰 내림차순: 큰 -&gt; 작 비교 함수를 인수로 넘겨주지 않으면, sort메소드는 먼저 요소를 전부 문자열올 변환한 후, 유니코드 코드 포인트를 비교하는 방식으로 정렬한다. 12345678910[20, 3, 100].sort(); // [100, 20, 3]&lt;!-- 각 숫자를 문자열로 변환 후 첫글자를 비교. --&gt;&lt;!-- 100은 첫글자가 1, 20의 첫글자: 2, 3의 첫글자: 3이므로 --&gt;&lt;!-- 유니코드 코드 포인트순으로 정렬 해서 [100, 20, 3]임 --&gt;['abc', 'DEF', 'aBC'].sort(); // [ 'DEF', 'aBC', 'abc' ]// 대문자의 유니코드 코드 포인트가 소문자보다 작으므로 'DEF'가 가장 첫 번째 배열의 요소로 정렬된다.['abc', 'DEF', 'aBC'].sort((x, y) =&gt; x.localeCompare(y)); // [ 'abc', 'aBC', 'DEF' ]// 사전순 비교를 하려면 localeCompare 메소드를 사용한다. 배열의 길이 length 속성: 배열의 길이가 변하면서 length 속성의 값도 자동으로 달라진다. 12345// 배열의 길이 줄이기 (줄어든 만큼 뒤쪽에 있는 요소들은 버려집니다.)// 이렇게 사용하는건 권장되지 X. push, pop, shift, unshift 사용해서 할 것.arr.fill(1);arr.length = 2;console.log(arr); // [1, 1] 배열 순회하기for 구문forEach 메소드 ES5에 추가된 메소드 forEach 메소드를 사용하면, 배열의 각 요소에 대해 함수를 호출할 수 있다.const arr = [1, 2, 3]; 123arr.forEach((item) =&gt; &#123; console.log(`현재 요소 $&#123;item&#125;에 대해 함수가 실행되고 있습니다.`);&#125;); 1234const arr = [1, 2, 3];arr.forEach((item, index, array) =&gt; &#123; console.log(`현재 $&#123;index + 1&#125;번째 요소에 대해 함수가 실행되고 있습니다.`);&#125;); for..of 구문 현재 가장 많이 사용됨 ES6에 추가된 메소드 배열도 반복가능한 객체이다. index가 들어오는 매개변수가 없다. index가 필요없는 경우- for..of 구문을 사용하고, index가 필요한 경우 for 구문이나 forEach 구문을 사용하자. 코드의 실행 속도가 가장 빠른 건 for 구문이다. ex) 게임 같이 실행 속도가 중요할 경우에는 for구문을 사용한다. 12345const arr = [1, 2, 3, 4, 5];for (let item of arr) &#123; console.log(item);&#125; 123456const arr = [1, 2, 3];for (const item of arr) &#123; console.log(item);&#125;// for of 구문에서는 const로 써도 된다. 변수를 매번 새로 생성하기 때문에.// 변수가 블록 스코프에서만 유효하다. 배열로부터 새로운 값 생성slice 원본 배열에 변화를 주지 않고, 배열을 복사하고 싶을 때 slice를 사용해서 새로운 배열을 만들고 그 새로운 배열로 작업한다. ex) 원본 배열에 sort하면 원본 배열이 바뀜 slice는 얕은 복사를 한다. 배열의 일부분에 해당하는 새로운 배열을 반환한다. 원본 배열에는 아무 변화 X. 첫 번째 인수의 기본값은 0, 두 번째 인수의 기본값은 배열의 length 속성입니다. 즉, 인수 없이 호출하면 배열 전체가 복사된다. arr.slice();와 arr(0, 5);는 같게 작동한다. const는 재대입이 되지 않는 키워드다. 값이 변하지 않는 걸 보장하는 게 X. 123const arr = [3, 1, 2, 4, 5];// arr.sort()하면 원본 배열이 바뀌므로 const로 변수를 만든다고 해서// 그 값이 변하지 않는 게 X. map map 메소드는 배열의 각 요소에 함수를 적용해서, 그 반환값을 요소로 갖는 새로운 배열을 만듭니다. forEach와 비슷해 보이지만, 새로운 배열을 만든다는 점이 다르다. concat concat 메소드는 여러 배열을 연결해서 새 배열을 만들 때 사용된다.- filter 새로운 배열을 생성한다. 원본 배열을 변경하지 않는다. filter 역시 (현재 요소, 인덱스, 배열)의 세 인수를 받는다. join join 메소드는 배열의 요소들을 문자열로 변환 한 후, 메소드에 주어진 구분자(separator)를 이용해 하나의 문자열로 결합하여 반환한다. 123const arr = [1, 2, 3];arr.join(\"&amp;\"); // '1&amp;2&amp;3' 구분자를 넘기지 않으면, , 문자가 구분자로 사용된다. 123const arr = [1, 2, 3];arr.join(); // '1,2,3' 요소 찾기 indexOf 메소드: 배열의 왼쪽부터 lastIndexOf 메소드: 오른쪽부터 검색해서 처음 만나는 요소의 인덱스를 반환 12345678const arr = [\"a\", \"b\", \"c\", \"b\", \"a\"];arr.indexOf(\"b\"); // 1arr.lastIndexOf(\"b\"); // 3arr.indexOf(\"z\"); // -1// 예전에는 이 값이 -1인지 아닌지를 확인해서 이 요소가 배열에 있는지 없는지를 판별했었음.arr.lastIndexOf(\"z\"); // -1 find findIndex 배열이 특정 조건을 만족하는지 판별하기 includes 메소드 배열이 특정 요소를 포함하고 있는지를 판별 진리값을 반환 every 메소드 모든 요소가 조건을 만족하면 true, 하나라도 조건을 만족하지 않으면 false를 반환 &amp;&amp;를 이어붙인 느낌 some 메소드 하나라도 조건을 만족하면 true, 모두 조건을 만족하지 않으면 false 반환 ||를 이어붙인 느낌 배열인지 아닌지 판별하기 Array.isArray 사용(중요하진 X) 문자열과 배열 문자열의 메소드 중에는 배열의 메소드 중에 몇몇과 이름이 같고 완전히 같은 방식으로 동작하는 것들이 있다. 12345\"hello\"[0]; // 'h'\"hello\".slice(2, 4); // 'll'for (let c of \"hello\") &#123; console.log(c);&#125; 다차원 배열 (Multidimensional Array) 표, 좌표, 게임판 등을 저장하기 위해서 많이 사용된다. 1234const table = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];table[0][1]; // 2table[2][0]; // 7","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"CSS 배경(Background)","slug":"css-background","date":"2019-01-15T09:45:41.000Z","updated":"2019-04-11T15:22:16.084Z","comments":true,"path":"2019/01/15/css-background/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/15/css-background/","excerpt":"","text":"CSS 배경(Background)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. CSS 배경(Background) 스타일링Background Design 요소의 배경(background)은 요소의 content-box, border-box 아래에 있는 영역이다.(margin-box 제외)모던 브라우저에서는 배경을 차지하는 영역을 background-clip 속성을 사용하여 변경할 수 있다. background-color: 배경색을 설정한다. background-image: 요소의 배경에 표시할 배경 이미지를 지정한다. background-position: 배경이 요소 배경 안에 표시되어야 하는 위치를 설정한다. positionbackground-position: left|right top|bottom;기본값: left top 2) 좌표(pixel) background-position: x축 좌표 y축 좌표 ex) background-position: 200px 200px; percentagebackground-position: x축 y축 ex) background-position: 20% 0%;background-position: 100% 0%;오른쪽 끝 background-repeat: 배경을 반복할지 여부를 설정한다. background-repeat: repeat | repeat-x | repeat-y | no-repeat 기본값: repeat; repeat repeat-x: x축으로 배경 이미지 반복 repeat-y: y축으로 배경 이미지 반복 no-repeat: 배경 이미지 반복하지 X background-attachment: 내용이 스크롤 될 때 요소의 배경 동작을 설정한다. ex) background-attachment: fixed; 배경 이미지가 고정된 형태로 그 자리에 머물러 있음. background: 배경 속성을 모아 작성하는 속기법 모든 배경 속성을 묶어서 쓰고 싶을 때, background를 사용. transparent는 기본값이기 떄문에 안 넣어줘도 상관 X. background-size: 배경 이미지의 크기를 동적으로 조정할 수 있다.background-size: width height ex) background-size: 100px 100px; background-clip background-origin 123456789101112131415161718192021222324252627282930313233body &#123;&#125;#css-background &#123;&#125;.bg-image &#123; background: url(\"../images/NewYork-US.jpg\") no-repeat center -20px; &lt;!-- background-size: 100%쓰면 이미지가 다 들어오기는 한다. But 비율이 맞지 않는다. 이미지가 작을 경우, 늘려서 끼워맞춰지게 됨. -&gt; 이미지가 왜곡됨 --&gt; &lt;!-- background-size: contain; 사용 --&gt; background-size: cover; &lt;!-- 이미지를 늘려서 끼워맞추는 게 X. 원래 비율대로 이미지를 넣되, 커버를 씌우듯이 이미지 넣을 공간만큼만 이미지를 넣는 것임. --&gt;&#125;.is-floral &#123;&#125;.is-model &#123;&#125;.background-clip &#123;&#125;","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"배경","slug":"배경","permalink":"https://JihyeHwang09.github.io/tags/배경/"},{"name":"background","slug":"background","permalink":"https://JihyeHwang09.github.io/tags/background/"}]},{"title":"자바스크립트 3일차","slug":"javascript3","date":"2019-01-15T09:19:29.000Z","updated":"2019-04-11T15:22:15.956Z","comments":true,"path":"2019/01/15/javascript3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/15/javascript3/","excerpt":"","text":"null과 undefined 값이 대입되지 않은 변수 혹은 속성을 사용하려고 하면 undefined를 반환 null은 ‘객체가 없음’을 나타낸다. 12typeof null; // 'object'typeof undefined; // 'undefined' 변수를 선언한 적이 있는지 확인하고 싶을 때에도 typeof 연산자를 사용하고, 이 때, 변수를 선언한 적이 없다면 &#39;undefined&#39;가 반환된다. 저장을 한 적이 없는지와 내가 ‘없음’이라는 사실을 저장했는지를 구분하기 위해서는 undefined를 저장하면 구분이 안되므로, 명시적으로(확 드러나게) ‘없음’을 나타내고 싶다면 항상 null을 사용하는 것이 좋다. (법칙은 아니고 관례임. ) 다만, 객체를 사용할 때 어떤 속성의 부재를 null을 통해서 나타내는 쪽보다는, 그냥 그 속성을 정의하지 않는 방식이 간편하므로 더 널리 사용된다. 12345678910111213141516// 이렇게 하는 경우는 많지 않습니다.&#123; name: 'Seungha', address: null&#125;// 그냥 이렇게 하는 경우가 많습니다.&#123; name: 'Seungha'&#125;// 어쨌든 이렇게 하지는 말아주세요.&#123; name: 'Seungha', address: undefined&#125; Null Checkstrict equality=== 엄밀한 비교.abstract equality== 추상적인 비교. null check를 할 때는 ==를 쓰는 것이 편리하다. 123456789101112131415null === undefined; // falsenull == undefined; // truenull == null; // trueundefined == null; // trueundefined == undefined; // truenull == 1; // falsenull == \"hello\"; // falsenull == false; // falseundefined == 1; // falseundefined == \"hello\"; // falseundefined == false; // false 즉, == 연산자는 한 쪽 피연산자에 null 혹은 undefined가 오면, 다른 쪽 피연산자에 null 혹은 undefined가 왔을 때만 true를 반환하고, 다른 모든 경우에 false를 반환한다. 따라서 null check를 할 때 만큼은 ==를 사용하는 것이 편합니다. 다른 모든 경우에는 ===를 사용하는 것이 좋다. 함수함수의 구성 요소매개변수와 인수 함수를 호출할 때 인수 자리에 변수를 써주면, 이 변수가 넘어가는 게 아니라 값이 넘어가는 것임. 이 표현식의 값이 넘어가는 것이지, 변수 자체가 넘어가는 게 X. 매개변수에는 재대입이 가능하다.(let으로 선언한 변수와는 미묘하게 다른 점이 있음.) 반환값 return 키워드 바로 다음에 오는 값이 함수 호출의 결과값으로 반환되며, 반환되는 즉시 함수 실행이 종료된다. 즉, return 다음에 오는 코드는 실행되지 않는다. return 뒤에 아무 값도 써주지 않거나, 아예 return 구문을 쓰지 않으면 함수는 undefined를 반환한다. 스코프 (Scope) 매개변수와 같이 함수 안에서 정의된 변수는 함수 바깥에서는 접근할 수 없기 때문에 함수 안에서만 사용할 수 있다. 즉, 변수는 코드의 일정 범위 안에서만 유효하다는 성질이 있다. 특정 변수가 유효한 코드 상의 유효 범위를 가지고 스코프(scope)라고 합니다. 매개변수는 함수 스코프를 갖습니다. 즉, 함수의 중괄호 안에서만 유효하다. 스코프 연쇄 (Scope Chain) 중첩된 스코프 안에서는 바깥 스코프의 변수를 가져다 쓸 수 있다. 코드의 실행 흐름이 변수 이름에 도달하면, 그 변수와 같은 이름을 갖는 변수를 현재 스포크에서 찾아보고, 만약 없으면 바로 바깥쪽, 없으면 바같쪽 스코프로 올라가서 계속 찾아보는 과정이 되풀이 된다. 바깥 스코프에서 찾을 때는 부모-부모-부모 …를 찾는 것이지, 다른 함수 안에서만 쓰인 변수를 가져다 쓸 수는 X. 가장 바깥에 있는 스코프를 최상위 스코프(top-level scope) 혹은 전역 스코프(global scope)라고 부른다. 12345678const five = 5;function add5(x) &#123; function add(y) &#123; `return` x + y; &#125; `return` add(five);&#125;add5(3); // 8 reference Error같은 게 뜨면, 내 변수가 스코프 안에서 잘 들어있는지 확인할 것! 변수 가리기 (Variable Shadowing) 안쪽 스코프의 변수가 바깥쪽 스코프에 있는 변수를 가리는 현상을 말한다. 바깥 스코프와 상관없이 매개변수를 자유롭게 사용할 수 있게끔 하는 성질이다. 바깥 스코프에 있는 변수를 일일히 기억하지 않고 사용하고 싶은 매개변수를 자유롭게 사용할 수 있도록 이런 성질이 존재한다. 123456789101112const x = 3;function add5(x) &#123; // `x`라는 변수가 다시 정의됨 function add(x, y) &#123; // `x`라는 변수가 다시 정의됨 `return` x + y; &#125; `return` add(x, 5);&#125;add5(x); 어휘적 스코핑 (Lexical Scoping) 스코프는 코드가 작성된 구조에 의해서 결정되는 것이지, 함수 호출의 형태에 의해 결정되는 것이 아니다. 12345678910function add5(x) &#123; const five = 5; `return` add(x);&#125;add5(3); // 8function add(x) &#123; `return` five + x; // ReferenceError: five is not defined&#125; add라는 함수가 add5라는 함수 안에서 호출되었다고 해서, add 함수 내부에서 add5 함수의 스코프 안에 있는 변수에 접근할 수 있는 것은 아니다. 스코프는 코드가 작성된 구조에 의해 결정되는 성질이다. 위 코드를 동작시키려면, 아래와 같이 작성해야 한다. 1234567function add5(x) &#123; const five = 5; function add(x) &#123; `return` five + x; &#125; `return` add(x);&#125; 값으로서의 함수 JavaScript에서는 함수도 값이다. cf) filter는 함수를 인수로 넘겨줘야 사용할 수 있는 메소드. 원본 배열을 변경시키지 X. 새 배열을 반환함. &#39;일급 객체&#39;라는 용어는 면접에 종종 나옴 자바스크립트의 객체는 일급 객체다. 조건: 변수나 데이터 구조안에 담을 수 있다. 파라미터로 전달 할 수 있다. 반환값(return value)으로 사용할 수 있다. 할당에 사용된 이름과 관계없이 구별이 가능하다 동적으로 프로퍼티 할당이 가능하다cf) c나 java의 함수는 일급 함수가 아니다. url(https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4) 익명 함수 (Anonymous Function) JavaScript에서 함수를 선언할 때 꼭 이름을 붙여주어야 하는 것은 아니다. 이름을 붙이지 않은 함수를 가지고 익명 함수(anonymous function)라고 한다. 익명 함수는 함수를 만든 쪽이 아니라 다른 쪽에서 그 함수를 호출할 때 많이 사용된다. 화살표 함수 (Arrow Function) function keyword 함수는 값을 반환하려면 반드시 return을 사용해야 한다. 화살표 함수의 경우 중괄호가 없으면 바로 반환이 된다. 코드의 길이나 표기법이 굉장히 간단해진다. 화살표 함수는 익명 함수 밖에 없다. 이름이 있는 화살표 함수는 없다. 123456789// 바로 반환시키지 않고 function 키워드를 통한 함수 정의처럼 여러 구문을 사용하려면 curly braces(&#123;...&#125;) 로 둘러싸주어야 한다.// `=&gt;` 다음 부분을 **중괄호로 둘러싸면**, 명시적으로 ``return`` 하지 않는 한 아무것도 반환되지 않습니다.const add = (x, y) =&gt; &#123; const result = x + y; `return` result;&#125;;//매개변수가 하나밖에 없다면, 매개변수 부분의 괄호를 쓰지 않아도 된다.const negate = x =&gt; !x; cf) function keyword 함수 vs 화살표 함수 비교 123[1, 2, 3, 4, 5].filter(function(x) &#123; `return` x % 2 === 0;&#125;); // [2, 4] 1[1, 2, 3, 4, 5].filter((x) =&gt; x % 2 === 0); 제어 구문 if...else 구문에서 중괄호 내부에 있는 구문이 하나라면, 중괄호를 생략할 수 있으나 나중에 문장을 추가할 수도 있으니 항상 중괄호를 쓰는 습관을 들이자. switch 바로 뒤의 괄호의 값: ‘코드 실행 여부를 판별할 기준이 되는 값’, 이 기준이 되는 값과 case 바로 뒤에 오는 값이 일치하면 콜론(:) 뒤의 코드 영역이 실행된다. -case쪽의 코드 영역 마지막에 break를 써주지 않으면, 해당 case가 실행될 때 바로 뒤의 case 코드 영역이 뒤이어 실행되게 된다. -&gt; case문에 break를 꼭 써줘야 한다!! 1234567891011121314151617181920function translateColor(english) &#123; let result; switch (english) &#123; case \"red\": result = \"빨강색\"; break; // 이 break를 생략할 경우, 'red'를 넣었을 때 ,result = '빨강색';후에 result = '파랑색';으로 실행흐름이 넘어가서 '파랑색'이 결과값으로 나온다. case \"blue\": result = \"파랑색\"; break; case \"purple\": case \"violet\": // 이 코드 영역은 english 변수의 값이 'purple'일 때와 'violet'일 때 모두 실행됩니다. result = \"보라색\"; break; default: result = \"일치하는 색깔이 없습니다.\"; &#125; `return` result;&#125; do…while 구문 do…while 구문은 while 구문과 사용법은 크게 다르지 않으나, 내부 코드를 무조건 한 번은 실행시킨다는 차이점이 있다. 절대 true가 될 수 없는 구문을 무조건 한 번은 실행시킬 수 있다. 배열의 순회 배열의 각 항목을 방문하면서 차례대로 도는 것을 말한다. forEach메소드 - 배열의 각 항목을 차례대로 실행시키고 싶을 때 사용하는 메소드(ES5에 추가된 문법임) 12345const arr = [1, 2, 3, 4, 5];arr.forEach((item, index) =&gt; &#123; console.log(`배열의 $&#123;index + 1&#125; 번째 요소는 $&#123;item&#125; 입니다.`);&#125;); for 구문의 종류 for for...in 구문 for...of 구문 12345678910const arr = [1, 2, 3, 4, 5];for (let item of arr) &#123; console.log(`현재 요소는 $&#123;item&#125; 입니다.`);&#125;// 현재 요소는 1 입니다.// 현재 요소는 2 입니다.// 현재 요소는 3 입니다.// 현재 요소는 4 입니다.// 현재 요소는 5 입니다. arr의 요소(item)들이 순서대로 item이라는 변수에 들어가면서 차례대로 실행됨. break, continue12345678910111213alert(\"퀴즈를 시작합니다.\");while (true) &#123; const answer = prompt(\"빨강의 보색은 무엇일까요?\"); if (answer === \"초록\") &#123; alert(\"정답입니다! 🎉\"); break; // 루프를 종료하고 다음 코드로 넘어감 // break를 만나면 while 구문 아예 바깥으로 빠져나오게 됨. 따라서 정답인 // 초록을 입력했을 때는 정답입니다!를 출력하고 while문을 빠져나가서 alert('퀴즈가 끝났습니다.')로 실행흐름이 옮겨간다. &#125; else &#123; alert(\"틀렸습니다! 다시 시도해보세요.\"); &#125;&#125;alert(\"퀴즈가 끝났습니다.\"); continue를 만나면, 나머지 코드를 실행하지 않고 루프의 처음으로 되돌아가는 효과가 있다. 반복문의 시작(조건문)으로 돌아가게 된다. break는 break를 둘러싸고 있는 가장 가까운 루프만 종료시킨다. 가장 바깥의 루프까지 다 빠져나오는 게 X. 함수를 즉시 종료하기 return과 throw는 함수의 나머지 코드를 건너뛰고 함수를 즉시 종료시킨다는 걸 기억하라! switch구문을 쓸 때는 break를 써야 하지만, return이 있으면 함수의 나머지 코드를 건너뛰고 함수를 즉시 종료시킨다. 함수의 나머지 코드를 건너뛰고 즉시 종료시키는 결과를 낳기 때문에 break를 더 추가해서 쓸 필요가 X.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"자바스크립트 2일차","slug":"javascript2","date":"2019-01-14T12:06:43.000Z","updated":"2019-04-11T15:22:16.225Z","comments":true,"path":"2019/01/14/javascript2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/14/javascript2/","excerpt":"","text":"string 타입문자열 리터럴 &#39;&#39; &quot;&quot; backtick(backquote) 따옴표는 표기법일 뿐, 실제 저장되는 값에 영향을 미치지는 X. ‘’ 안에 “”는 쓸 수 O “” 안에 ‘’는 쓸 수 O ‘’안에 ‘’는 쓰면 X. “”안에 “”는 쓸 수 X. -&gt; 서로 다른 따옴표는 안에 중첩되서 자유롭게 쓸 수 있다. 템플릿 리터럴 (Template Literal) ${} 변수 안에 들어있는 값이 문자열의 값으로 바꿔치기 됨. 동적으로 삽입하고 싶을 때 사용한다. 템플릿은 빈칸을 만들어두고 삽입할 때 사용하는 거니까 템플릿 리터럴이라고 부른다. 여러 줄로 이루어진 문자열을 쉽게 표현할 수 있다. 이 외의 경우에는 ‘’나 “”를 사용한다. 1234const name1 = \"Foo\";const name2 = \"Bar\";const sentence = `$&#123;name1&#125; meets $&#123;name2&#125;!`;console.log(sentence); 12345678`helloworldhellojavascript!`;// 일반적인 문자열 리터럴로는 아래와 같이 해야 합니다.(\"hello\\nworld\\nhello\\njavascript!\\n\"); Escape Sequence 잠깐 문자열 문법에서 탈출해서 표기를 한다는 뜻 \\ 하나를 넣었는데 잘 안될 경우, \\ 를 넣어볼 것.(\\ 하나 넣으면 잘 안될 때가 있음.) \\r\\n: 윈도우 개행문자 \\n: 맥, 리눅스 개행문자 운영체제에 따라 개행문자가 다르기 떄문에 협업할 때 문제가 생길 수 있다.(프로젝트 전에 통일할 필요가 있다.) &#39;&#39;안에 개행문자를 넣고 싶다면 \\n을 쓰자. 유니코드 문자는 Unicode Code Point를 가지고 문자를 넣을 수 있다. ‘\\uac00’로 ‘가’를 입력하든지 ‘가’ 문자열로 입력하든지 같은 것임. 이모티콘도 이제 유니코드에 포함되면서 정식 문자로 인정 받음. \\uXXXX: 4자리수 유니코드 문자 \\u{X...}: 5자리수 유니코드 문자 1console.log(\"\\u&#123;1F435&#125;\"); // 🐵 연산에서 문자열이 하나라도 들어있다고 해서 다 문자열로 변환되는 게 X. 문자열 이어붙이기를 할 때는 주의해야 함. 이럴 때는 템플릿 리터럴을 사용하는 것이 좋다. 1234\"number\" + 1 + 3;// =&gt; 'number13' 덧셈은 왼쪽부터 계산되니까 'number' + 1 먼저 계산됨.1 + 3 + \"number\";// =&gt; '4number' 연산 순서만 바뀌었는데 숫자 덧셈 계산이 먼저 일어나서 4가 되고 뒤에 문자열 'number'가 붙는다. 부등호로 문자열을 비교하면 유니코드 코드포인트의 크기를 기준으로 비교를 한다. 사전순 비교를 하고 싶을 때는 localeComapare 메서드를 사용한다. .localeComapare() 문자열을 배열로 바꾸기 12[...'hello'];&lt;!-- ['h', 'e', 'l', 'l', 'o'] --&gt; (최근에 추가된 기능). 객체나 배열에 대해서도 쓸 수 있는 연산자. 쓰임이 많음. MDNMDN 문서를 읽을 때 주의할 점 번역의 품질이 굉장히 떨어지는 경우가 있음. 번역된 버전이 옛날 버전인 경우를 주의해야 함. 되도록 영어 버전으로 읽는 게 좋다. 한국어 번역이 좋지 않을 경우 -&gt; 영어쪽으로 가서 번역기로 돌려서 비교해보면서 읽어볼 것. MDN 빠르게 mdn 문서에 접근하고 싶을 때: https://devdocs.io/ 개발 문서에서 사용하는 영어 문서에 사용되는 영어 단어나 문법은 많지 않다. 읽는 연습을 꾸준히 할 것. 속성 및 메소드 공백도 문자열로 취급함.‘hello javascript’.indexOf(‘java’); ‘hello javascript’.indexOf(‘python’); 예전에는 indexOf의 결과값이 -1인지 아닌지를 판별함으로써 문자열을 포함하고 있는지 여부를 판단했으나, includes 메소드가 나오면서 includes로 판별함. 문자열의 일부를 잘라낸 새 문자열 생성하기 1\"hello\".slice(2, 4); // 'll' 틈에다가 번호를 매긴다고 생각하면 쉽다. 끝까지 자르고 싶다면, 뒷자리 인수를 안주면 됨. 1-\"hello\".slice(2); // 2번째 자리부터 끝까지 자르겠다. slice 메소드는 원본 문자열을 변경하지 X! 12\"abc@gmail.com\".split(\"@\")[0];// =&gt; 'abc'.split한 후에 다 배열이기 떄문에 바로 뒤에 대괄호로 index 번호를 주면 배열안에 있는 값을 가져올 수 있다. split은 원본 데이터를 변경하지 X. toLowerCase, toUpperCase 대소문자 관계없이 비교하고 싶을 때 주로 사용함. 게시물 검색 기능에서 사용자가 소문자를 입력했다고 해서 대문자로 된 게시물을 보여주지 않으면 안되므로 유니코드와 UTF-8, UTF-16 문자열은 JavaScript 내부적으로 UTF-16 형식으로 인코딩된 값으로 다뤄진다. 유니코드와 UTF-8을 헷갈리면 안됨! 유니코드 - 문자 정보 데이터베이스, 문자 집합, 문자 인코딩 등 전 세계의 UTF-8은 인코딩 방식. 유니코드를 위한 가변 길이 문자 인코딩 방식 중의 하나임. 컴퓨터 내부적인 메모리 상에 저장할 때는 프로그래밍 해석기 안에서 계산을 할 때는 UTF-16으로 하는 게 UTF-8보다 더 속도가 빠름. (UTF-8처럼 압축하는 게 아니라 그대로 저장하므로) 웹에서는 UTF-8을 사용하는 게 약속임. 유니코드가 실무에서 중요한 건 아니지만, 면접에서 종종 물어봄. 유니코드가 무엇인지 UTF-8과 UTF-16의 장단점 boolean 타입논리연산자 !true not ture라고 읽음. !false not false라고 읽음. 긴 식 앞에 !를 사용할 수 있다. 삼항 연산자 (ternary operator) if else구문보다 축약된 느낌. 12345const result = if (true) &#123; 1&#125; else &#123; 2&#125; 1const result = true ? 1 : 2; if로 둘러싸여진 전체는 표현식이 X. 삼항연산자는 표현식임. if else구문에는 여러 개의 명령이 올 수 있지만, 삼항연산자에는 여러 개의 명령이 올 수 X. 특정 조건을 만족할 때 어떤 결과값을 바로 반환하고 싶다. -&gt; 삼항연산자 사용 특정 조건을 만족할 때 여러 개의 명령을 실행하고 싶으면 -&gt; if else 구문 사용 react할 때 삼항연산자를 많이 사용함. 연산자 우선순위 (Operator Precedence) &amp;&amp;와 ||에는 우선순위가 있기 떄문에 주의해야 함. 이 우선순위 때문에 버그가 생길 수 있음. 논리 연산의 여러 가지 법칙1!!a === a; not을 2번 붙이면 원래대로 돌아옴 // 분배 법칙 12* a || (b &amp;&amp; c) === (a || b) &amp;&amp; (a || c);* a &amp;&amp; (b || c) === (a &amp;&amp; b) || (a &amp;&amp; c); 우변에 잇는 식을 짧게 코드를 사용하고 싶을 때 좌변에 있는 식을 사용함. 논리 연산의 여러 가지 법칙들을 표를 그려서 확인해보기 truthy &amp; falsy true로 취급되는 값: truthy false로 취급되는 값: falsy falsy로 취급되는 값 꼭 외울 것! 이 외의 모든 값들은 truty이다. falsy로 취급되는 값 false null undefined 0 NaN &#39;&#39; cf) truthy에는 객체, 배열 등도 다 포함됨. (심지어 배열이 비어있더라도 truty임. ) 12345678910111213const input = prompt(\"이름이 무엇인가요?\")if (input) &#123;&lt;!-- truthy와 falsy의 성질을 이용해서 if의 조건식 부분에 input은 truethy라는 성질을 이용해서 짧게 코드를 줄일 수 있음. --&gt; alert(`안녕하세요, $&#123;input&#125;님!`)&#125; else &#123; alert('이름을 입력해주세요.')&#125;// if (input.length &gt; 0) &#123;// alert(`안녕하세요, $&#123;input&#125;님!`)// &#125; else &#123;// alert('이름을 입력해주세요.')// &#125; truthy와 falsy의 성질을 이용하면 편하지만, 논리의 허점이 생길 수 있다. 자바스크립트는 타입 체크를 하지 않는 언어임. 1234567function add(x, y) &#123; if (typeof x === \"number\" &amp;&amp; typeof y === \"number\") &#123; return x + y; &#125; else &#123; throw new Error(\"x 혹은 y의 타입이 number가 아닙니다.\"); &#125;&#125; javascript의 타입을 체크하는 방법 매번 이렇게 타입 체크하는 조건식을 쓸 수 없으므로 요즘은 타입스크립트를 많이 사용함. 타입스크립트는 타입 체크가 되는 자바스크립트의 확장 언어임. 대개 실무에서는 타입 스크립트를 많이 사용한다. throw하면 에러가 나면서 나머지 코드가 실행되지 X. 정적 타이핑 언어(statically-typed language) c, c++, java 등 동적 타이핑 언어(dynamically-typed language) javascript, python, ruby등 다른 타입의 값을 진리값으로 변환하기123456!\"hello\"; // false!!\"hello\"; // true// 'hello'가 truthy이기 때문에(true로 취급되었기 떄문에)!NaN; // true!!NaN; // false toString: 숫자를 문자열로 변환하는 메소드 12// if (str.includes('3' || '6' || '9')) &#123;// &#125; 틀린 것임. ‘3’이 truthy이기 떄문에 결과값이 ‘3’으로 나와버림.따라서 조건식을 이렇게 쓰면 X!!.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"CSS 타이포그래피(Typography)","slug":"css-typography","date":"2019-01-14T12:06:34.000Z","updated":"2019-04-11T15:22:16.153Z","comments":true,"path":"2019/01/14/css-typography/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/14/css-typography/","excerpt":"","text":"CSS 타이포그래피(Typography)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. CSS 타이포그래피(Typography)폰트(Fonts) 스타일 속성 폰트에 영향을 주는 속성으로 적용되는 모양, 크기, 굵기, 기울임 등. font-family: 글자 모양 font-size: 글자 크기 font-weight: 글자 굵기(두께) font-style: 글자 기울임 font-variant: 소문자를 작은 대문자로 바꾸는 속성 ※ 글자 색상은 color 속성으로 설정. color keywords: red, green, blue, pink, black hex color code: #RRGGBB / 0 ~ 9, a ~ f 예) #1868a7 rgb VS rgba의 차이 rgba는 불투명도까지 나타낸다. 각 256가지 색을 나타내고, 0부터 시작하기 떄문에 번호는 256까지 X. 256-1인 255까지가 정상적인 색으로 나옴! rgb, rgba: RED, GREEN, BLUE, ALPHA 예) rgba(127,255,0,1): a가 1이면 불투명한 색 rgba(127,255,0,0.3): a가 0.3이면 반투명한 색 hsl, hsla HUE(각도), `ATURATION(채도), LIGHTNESS(명도), ALPHA (투명도) 1hsla(360,60%,70%,1) saturation(채도): 100%면 순색(원색)에 가까움. lightness(명도): 0%에 가까우면, 검정색 100%에 가까우면, 흰색임. 웹브라우저는 운영체제가 지원하는 기본 폰트(웹 안전 폰트)만화면에 렌더링 한다. (참고: cssfontstack.com) 즉, 사용된 폰트가 사용자 컴퓨터에 없으면 렌더링 X. 웹 안전 폰트 Arial [sans-serif]: 고딕체 Verdana [sans-serif]: 고딕체 Courier New [monospace]: 코드체(공간이 동일) Georgia [serif]: 명조체 Times New Roman [serif]: 명조체 Trebuchet MS [serif]: 명조체 하지만 웹 안전 폰트만으로 디자인 하는 디자이너는 없다!Helvetica는 디자이너가 애용하는 폰트이지만…Windows는 기본 지원하지 않는다. (Mac OSX는 지원) ※ 비주얼 디자인 과정에서 적용 가능한 웹폰트를 사용해야 한다.폰트 저작권에 주의! (참고: hyundaicard.com) ※ 저작권 걱정 없는 폰트fonts.google.comgoogle.co.kr/search?q=무료+웹폰트 텍스트(Text) 레이아웃 속성 텍스트 간격 및 레이아웃 기능에 영향을 주는 속성으로 행간, 자간, 어간, 정렬, 변형, 꾸밈, 그림자 사용자가 읽기 편한 간격: 자간 &lt; 어간 &lt; 행간 순으로 넓어야 한다.-&gt; 염두에 두고 디자인할 것! line-height줄 높이를 정하는 속성 default: 1.25임. 1.5이상 줘야 글을 읽기가 용이해짐. 1ex)line-height: 1.5; letter-spacing 글자 사이의 간격(자간) default값: 0 1ex)letter-spacing: -0.024em; word-spacing 단어 사이의 간격픽셀 단위나 em으로 조정할 것 12ex)word-spacing: 1px;word-spacing: 0.02em; text-align 정렬 default값: 왼쪽 123456ex)text-align: center;/* 가운데 정렬 */text-align: right;/* 오른쪽 정렬 */text-align: left;/* 왼쪽 정렬 */ text-indent 들여쓰기 +값, -값 사용할 수 있음. +: 오른쪽으로 들여쓰기됨. -: 왼쪽으로 내어쓰기됨. 1234ex1)text-indent: 1em;/* 각 문단의 첫째줄만 들여쓰고 싶을 때 */cf)padding-left: 1em;/* 텍스트 전체를 들여쓰고 싶을 때 */ text-transform 대문자로 또는 소문자로 바꾸는 속성 1234text-transform: `uppercase`;/* 모두 대문자로 바꿈 */text-transform: lowercase;/* 모두 소문자로 바꿈 */ text-decoration 선으로 텍스트를 꾸미는 속성 12345678ex) text-decoration: underline;/* 밑줄 치기 글자를 판독하기 어렵게 하기 때문에 권장되지 X.*/text-decoration: overline underline line-through;text-decoration: overline /* 위에 공간을 만들어서 줄을 그어줌. */text-decoration: line-through;/* -&gt; 글씨 중간에 취소선을 그어줌. */ text-shadow 그림자x축 y축 blur sprea color; 12ex1)text-shadow: 4px -3px 10px #9bdbde;ex2)text-shadow: 0px 3px 10px #943978; white-space 공백을 처리하는 방법 white-space: pre white-space: pre-line; white-space: nowrap; nowrap은 가로 한줄로 쭈욱~ 나열됨. 단어의 분리를 어떻게 할 것인지 결정 (공백/띄어쓰기) 수고했어 오늘도(음절) 수 고 했 어 오 늘 도 word-break: break-all; 박스의 가로 영역을 넘친 단어 내에서임의의 분리 여부를 결정하여 줄바꿈에 관여 word-wrap 긴 단어 처리하는 방법 default: normal normal: 글자가 길어도 끊어지지 않고 한 줄에 나타냄 break-word: 강제로 끊어서 줄바꿈함","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"타이포그래피","slug":"타이포그래피","permalink":"https://JihyeHwang09.github.io/tags/타이포그래피/"},{"name":"Typography","slug":"typography","permalink":"https://JihyeHwang09.github.io/tags/typography/"}]},{"title":"자바스크립트 1일차","slug":"javascript1","date":"2019-01-13T14:54:55.000Z","updated":"2019-04-11T15:22:16.168Z","comments":true,"path":"2019/01/13/javascript1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/13/javascript1/","excerpt":"","text":"값과 리터럴 값으로 변환될 수 있는 부분을 모두 표현식이라 한다. 변수는 값에 붙이는 이름이다. html의 속성: attribute, javascript의 속성: property 객체 자바스크립트의 객체는 가변 길이이다. 자바스크립트는 자료구조의 유연성이 좋다. 객체의 속성 이름에는 x, ‘x’ 둘 다 쓸 수 있다. 다른 점은 차후에 설명해주실 예정. 속성 값에는 무엇이든 올 수 있다. 객체 안에 객체가 중첩될 수 있다. 123456789const obj = &#123; x: 0, y: &#123; x: 1, y: 2 &#125;&#125;;obj.y.x; 대입을 할 때는 = 오른쪽 식이 먼저 실행된다. 1234567let x = 1;x = x + 1;&lt;!-- x += 1;x *= 3;x /= 3; --&gt;console.log(x); delete 연산자: 객체의 속성을 삭제할 수 있다. 객체의 속성을 아예 없애버릴 수 있다. 123456789const obj = &#123; x: 0, y: 1&#125;delete obj.x;obj;&lt;!-- &#123;y: 1&#125; 객체의 x속성이 없어짐. --&gt; 메소드 객체 안에 있고, 객체의 속성을 통해서 사용하는 함수를 메소드라고 부른다. 12345678910111213141516171819const obj = &#123; x: 0, increaseX: function() &#123; this.x = this.x + 1; &#125;&#125;;const obj = &#123; x: 0, increaseX: function() &#123; this.x = this.x + 1; &lt;!-- this는 자기 자신을 가리키는 키워드. 실행하는 순간, this가 obj로 샤샤샥 바뀜. --&gt; &#125;&#125;;obj.increaseX();&lt;!-- 어떤 객체의 메소드 안에 this가 있으면, 그 this는 '메소드가 호출될 때' 해당 객체를 가리키게 된다. --&gt;console.log(obj.x); 객체와 배열의 차이객체는 속성 이름과 속성값이 연결되어 있다. 순서가 X . 배열은 순서가 있다.배열에 담는 객체는 요소(element) 혹은 항목(item)이라고 부른다. .점을 찍고 호출하는 함수를 메소드라고 한다. push메소드: 배열의 오른쪽 끝에 값을 추가한다. 12345const arr = [1, 2, 3];arr.push(4);arr.push(5);arr.push(6); slice 메소드: 특정 요소부터 한 개 혹은 여러 개의 요소를 지우고 싶을 때 사용ex) .slice(index값, 지우고 싶은 요소의 개수); 언어와 구동 환경 자바스크립트라는 언어와 구동 환경을 나누어서 생각해야 한다. ex) Node.js에서는 alert를 쓸 수 X. 자바스크립트 언어, 자바스크립트를 돌릴 수 있는 구동환경에는 어떤 기능이 있는지를 배워야 한다. 프론트엔드 자바스크립트 개발자 vs 백엔드 자바스크립트 개발자 프론트엔드 자바스크립트 개발자는 자바스크립트 언어와 브라우저 구동환경을 배운다.vs 백엔드 자바스크립트 개발자는 자바스크립트 언어와 Node.js 구동환경을 배운다. ES2015, 그 이후 ES5 2009년에 나온 자바스크립트 버전. ES2015 = ES6 값과 리터럴 값과 리터럴을 구분할 줄 알아야 한다. 리터럴: 값의 표기법을 말한다. 변수 (Variable) let, const, while, for등 프로그래밍에서 특별한 의미를 지니는 단어들을 키워드라고 부른다. let은 ES6에서 도입된 변수이다. ES6에서는 var를 쓰지 않고, let이나 const를 사용한다. ‘best practice: 좋은 관례’ 이다.(프로그래밍에서 많이 쓰이는 용어) let vs const let은 재대입이 가능. const는 재대입이 불가능한 변수. const는 재대입이 불가능하기 때문에 선언과 대입을 동시에 해줘야 한다. let은 선언, 대입을 따로 해도 된다. const로 변수를 선언할 때는 반드시 선언 시에 값을 대입해주어야 한다. 값 없이 선언만 하게 되면 에러가 발생한다. 또한 추후에 다른 값을 대입할 수 없다. let을 꼭 써야하는 경우가 아니라면, const를 사용하는 것이 좋다. let을 사용하면 의도치 않게 다른 값이 대입되어 버리는 일이 생길 수 있기 때문입니다. 정말로 재대입이 필요한 경우에만 let을 사용하는 것이 좋은 습관입니다. 특정 부분을 확신할 수 있으면 나머지 부분을 작성하기 쉬워지기 때문에 왠만하면 항상 const를 쓰는 습관을 들이는 것이 좋다. token은 프로그래밍에서 문자를 의미한다. Error 정리 SyntaxError: Unexpected token (28:7) 28번째 줄의 7번째 글자에 문법 에러가 있다는 뜻 SyntaxError: Assignment to constant variable: a at 29:0 29번째 줄의 첫번째 글자에 상수 변수에 대입을 했다는 에러가 있다. 12let seven = 7;let seven = 77; SyntaxError: Duplicate declaration “seven” at 33:4 변수 seven은 중복된 선언이라는 에러이다.** 식별자 변수의 이름은 식별자라고 한다. 식별자는 (‘’)없이 속성의 이름으로 이용할 수 있다. 식별자가 되기 위한 규칙들 숫자, 알파벳, 달러 문자(\\$), 언더스코어(_)가 포함될 수 있다. 단, 숫자로 시작되어서는 안 된다. 예약어는 식별자가 될 수 없다. ex) for, while, function 등은 사용할 수 X. 식별자로 쓸 수 없는 단어를 식별자로 사용하고 싶을 때’’로 묶는다. 12345678const obj = &#123; a: 1, '7seven': 7 &lt;!-- 식별자 규칙에 어긋나는 이름을 사용하려고 하므로 ''로 감싸줘야 에러나지 X --&gt;&#125;console.log(obj['7sever']);&lt;!-- 호출할 때도 ['']로 감싸줘야 한다. --&gt; 식별자는 한글로 쓸 수 있지만, 영어로 쓰는 것이 좋다. Camel Case ex) let helloWorldJavaScript 단어의 첫 글자를 소문자, 그 다음 단어부터 첫 글자를 대문자로 쓴다. 자바스크립트에서는 Camel Case로 쓰는 게 예의이고 관례이다. 1234567const one = 1;typeof 1 + 3;&lt;!-- 결과: 'number' + 3; --&gt;&lt;!-- typeof 1에 문자열 3이 붙어서 나온 것임. --&gt;&lt;!-- 연산자 우선순위가 typeof가 +보다 높다. --&gt;&lt;!-- 연산자 우선순위를 다 외우기가 너무 복잡하므로 우선 연산이 되었으면 하는 부분에 ()로 묶어주는 게 좋다. --&gt;typeof (1 + 3); 변수는 가장 첫 글자를 소문자로, 클래스는 첫 글자를 대문자로 쓰는 게 관례이다. number 타입number 타입 리터럴 리터럴이 다르더라도 값은 같을 수 있다. 자바스크립트는 정수와 실수를 별도의 타입으로 다루지 X. 정수와 실수 둘 다 number타입으로 구분하지만, 정수인지 실수인지 판별하기 위해서는 Number.isInteger를 사용한다. Number.isInteger(정수 or 실수); -&gt; 정수이면 true, 실수이면 false를 반환한다. number 타입에 대한 연산12* 2 ** 3;// 거듭제곱(거듭제곱 연산자는 ES2018에 추가됨) cf) 거듭제곱 함수 12Math.pow(2, 3);&lt;!-- 파이썬에서 가져온 함수임. --&gt; 자바스크립트에서 ==보다는 ===를 쓰는 게 더 좋다. 둘 다 되긴 하지만 ===를 쓰는 게 관례다. 123451 === '1'&lt;!--결과값: false --&gt;1 == '1'&lt;!-- 결과값: true 타입이 달라도 결과값이 true로 같다고 나오기 때문에 버그가 생기기 쉽다. --&gt; 12345let a = 1;a++; &lt;!-- 1 증가시키기 **전** 값을 표현식의 결과값으로 반환 --&gt;++a;&lt;!-- 1 증가시킨 **후**의 값을 표현식의 결과값으로 반환 --&gt; 1234let b = a++;&lt;!-- b에 증가하기 **전** 값인 1이 저장됨--&gt;let b = ++a;&lt;!-- b에 증가한 **후**의 값인 2가 저장됨--&gt; 연산자 우선순위 ()로 묶으면 우선순위가 가장 높기 때문에 가장 먼저 연산된다. typeof가 덧셈(+)보다 우선순위가 높기 때문에 +먼저 연산된 뒤에 문자열 3이 붙음. ex) typeof 1 + 3; 단항 연산자 ex) +1 다항 연산자 ex) 3 + 2 부동 소수점 (Floating Point) vs 고정 소수점 (Fixed Point) 컴퓨터에서 실수를 다루는 2가지 방식 부동 소수점 vs 고정 소수점 컴퓨터는 소수도 2진수로 저장하기 때문에 10진수 소수를 정확히 다룰 수 없다. 실수를 정확하게 나타내기 위해 사용하는 방법은 고정 소수점이다. 커리큘럼에서는 고정 소수점을 사용하는 라이브러리를 사용하지X. 컴퓨터로 실수를 다룰 때는 조심해야 한다. 컴퓨터는 실수를 정확하게 다룰 수 없기 때문에. number 타입의 특이한 값들NaN NaN은 Not a Number의 약자이다. 계산 불가능한 연산의 결과값을 나타내기 위해 사용한다. parseInt(‘’) 문자열을 숫자로 바꿔주는 함수 parseInt(‘’)에 이상한 문자열을 넣으면 NaN이 결과값으로 나온다. 12parseInt('asdf'); &lt;!--결과값: NaN --&gt; 어떤 값이 Nan인지 아닌지를 알고 싶을 때, ==를 쓰면 절대 X!! ===를 써야 됨. 꼭 기억!! ===는 숫자 비교에 특화되어 있는 연산자이다. “NaN은 숫자가 아니기 때문에, 어떤 숫자와도 같지 않다.”는 규칙이 있다. =&gt; 즉, NaN은 number 타입인 NaN가 같지 X ===NaN이 들어간 식은무조건 어떤 경우에도 false가 나오는 식임.(NaN은 자기자신과도 같지 X 때문에) 이거 때문에 버그 많이 생김. NaN은 JavaScript의 값들 중 유일하게 자기 자신과 같지 않은 값 1234 Number.isNaN(1);&lt;!-- 결과값: false --&gt; Number.isNaN(NaN);&lt;!-- 결과값: true --&gt; 12345678910111213141516171819202122const a = prompt(\"a: \");const b = prompt(\"b: \");const parsedA = parseInt(a);const parsedB = parseInt(b);// 이렇게 하면 안 됩니다!!!// if (parsedA === NaN || parsedB === NaN) &#123;// alert('숫자를 입력해주세요')// &#125; else &#123;// alert(parsedA + parsedB)// &#125;// \"NaN은 숫자가 아니기 때문에, 어떤 숫자와도 같지 않다.\" 는 규칙이 있다.// =&gt; 즉, NaN은 number 타입인 NaN과 같지 않다.if (Number.isNaN(parsedA) || Number.isNaN(parsedB)) &#123; alert(\"숫자를 입력해주세요\");&#125; else &#123; alert(parsedA + parsedB);&#125;1 + (2 + 3 + (4 + 5)); evaluate(평가)- 표현식을 값으로 반환하는 절차. 계산과 비슷 -0 자바스크립트의 세계에서 그냥 0과 -0은 다르다. 1234560 === -0; // true// 수의 세계에서 0*-1 한 거는 0이기 때문에 true로 나옴Object.is(0, -0);&lt;!-- 결과값: false. 자바스크립트 세계에서는 0과 -0을 다르게 취급함. --&gt; Object.is(,); 수의 세계에서 같은 지, 다른 지를 판별하는 게 x.자바스크립트 상에서 같은지, 다른지를 판별하는 것이다. 실무에서는 ===을 제일 많이 사용하는 편임!! Infinity 어떤 수가 Infinity인지 아닌지를 판별해야 할 때가 있음. Number.isFinite(): 유한한지 아닌지 판별 값이 유한하면 true, 무한하면 false를 반환함. 1234567if (Number.isNaN(parsedA) || Number.isNaN(parsedB)) &#123; alert(\"숫자를 입력해주세요\");&#125; else if (Number.isFinite(parsedA / parsedB)) &#123; alert(parsedA / parsedB);&#125; else &#123; alert(\"0으로 나눌 수 없습니다.\");&#125; isFinite(‘1’);쓰지 말고, 버전업된 Number.isFinite();를 써라. parseInt, parseFloat parseInt: 문자열 -&gt; 정수 parseFloat: 문자열 -&gt; 실수 1parseInt(\"110\", 2); // 6 (문자열 '110'을 2진수로 해석하겠다. 문자열을 2진수로 간주한다.) 되도록 숫자는 숫자랑만 연산한다. 문자열을 숫자로 바꾼 후에 연산한다. 숫자랑 문자열 연산을 하지 않는다. (아주 간단한 문자열끼리 이어붙이기 정도 빼고는) 사용자로부터 입력받은 데이터는 undefined 혹은 문자열일 가능성이 높다. 수와 문자열 계산은 반드시 전부 다 숫자로 안전하게 변환한 뒤에 연산할 것! Math 객체123456789101112131415161718192021Math.floor(-3.6);// 더 작은 숫자인 -4가 됨.Math.trunc(-3.6);// 더 큰 숫자인 -3이 됨.Math.max(1, 2);&lt;!-- 결과값: 2;들어온 숫자들 중에 제일 큰 숫자를 반환해준다.--&gt;Math.min(1, 2);&lt;!-- 결과값: 1;들어온 숫자들 중에 제일 작은 숫자를 반환해준다.--&gt;Math.random(); // 0과 1 사이의 값이 임의로 반환됩니다. Math.random() * 10; &lt;!-- 0과 10 사이의 실수를 반환함. 10을 넘을 수 X. --&gt; Math.floor(Math.random() * 10); &lt;!-- 0부터 9까지의 정수가 똑같은 확률로 나오게 만드는 식 --&gt; 주사위 만들기(1-6까지 나옴) 12Math.ceil(Math.random() * 6);Math.floor(Math.random() * 6) + 1; 카드 게임(A, B, C 중에 1장 나오는 게임) 123const CARDS = [\"A\", \"B\", \"C\"];CARDS[Math.floor(Math.random() * 3)]; number 타입의 메소드 number 타입은 객체가 아니지만, 마치 객체처럼 메소드를 사용할 수 있다. 매개변수 (parameter) 코드를 실행하다가 return을 만나면 실행 흐름을 종료시킨다. 1234567891011121314151617function evenOrOdd(x) &#123; // 만약 x가 짝수면 'x: 짝수' 라고 출력 if (x%2 === 0) &#123; console.log(x + ': 짝수'); &#125; else &#123; console.log(`$&#123;x&#125;: 홀수`); &#125; // 아니면 'x: 홀수'라고 출력&#125;for (let i = 0; i &lt; 20; i++) &#123; evenOrOdd(i + 1);&#125;`$&#123;&#125;` 사이에 어떤 값을 집어넣을 수 있다.","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"JavaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"CSS 상속(Inheritance)과 케스케이드(Cascade)","slug":"css-inheritance&cascade","date":"2019-01-12T14:31:47.000Z","updated":"2019-04-11T15:22:16.084Z","comments":true,"path":"2019/01/12/css-inheritance&cascade/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/12/css-inheritance&cascade/","excerpt":"","text":"CSS 상속(Inheritance)과 케스케이드(Cascade)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. CSS 상속 (Inheritance)상속되는 속성 (글자색, 글자 디자인에 관련된 것) color: 글자 색상 (배경색은 상속되지 X) font-size: 글자 크기 font-family: 글자의 모양(글꼴) letter-spacing: 자간 상속되지 않는 속성 (공간에 관련된 것) outline: 외곽 테두리선 margin: 외곽 영역의 공간 border: 테두리 padding: 테두리 안쪽의 공간 CSS 케스케이드(Cascade) 케스케이딩(Cascading)이란? cascading: The process of combining several style sheetsand resolving conflicts between them. Håkon Wium Lie (CSS 공동 창시자)는 CSS에 관한PHD 논문에서“여러 스타일 시트를 결합하고 이들 사이의충돌을 해결하는 프로세스”라는 용어로 “Cascade”를말하고 있다. https://www.wiumlie.no/2006/phd/ CSS(Cascading Style Sheets )는 캐스케이드 개념이중요하다는 것을 약어에서 강조. 가장 기본적인 수준에서는규칙 순서가 중요하지만 그보다 더 복잡하다는 것을 말한다. 중요성 (Importance)!important 선언은 다른 모든 선언보다 우선권을 가진다. [NOTE]!important가 적용된 속성을 덮어 쓰려면, 다시 !important를사용해야 하기에 최대한(절대!!) 사용하지 않도록 노력해야 한다. 특성 (Specificity)선택자의 우선권에 대한 척도.각 척도를 1, 10, 100, 1000 단위로생각하면 이해하기 좋다. 요소 선택자 &lt; 클래스 선택자 &lt; ID 선택자 &lt; 인라인 스타일0,0,0,1 0,0,1,0 0,1,0,0 1,0,0,0 [NOTE]*, &gt;, +, ~ 등 콤비네이터(Combinators),:not() 가상 클래스는 특성에 영향을 주지 X! [예시]* – 0000 a – 0001 (a요소는 요소선택자이기 때문에 1점) a.link – 0011 (a요소: 1점 + link라는 이름의 클래스니까 10점) li:nth-child(2) a:hover – 0022 (li요소: 1점 + a요소: 1점 + li:nth-child(2)는 가상클래스이다.가상클래스도 클래스이기 때문에 10점 + :hover도 가상클래스이기 떄문에 10점) .nav:nth-child(2) a:hover – 0031 .nav: 실제 클래스 10점 + v:nth-child(2): 가상클래스 10점 + :hover 10점 + a요소 1점) #outer a – 0101 (#outer: id선택자 100점 + a요소: 1점) #outer #inner a – 0201 (#outer: id선택자 100점 + #inner: id선택자 100점 + a요소: 1점 ) style=&quot;color: tan&quot; – 1000 (inline 스타일 시트: 1000점) !important(inline 스타일 시트도 무력화 시키는 게 !important이다.!important를 쓰면 함께 지옥에 가는 것임. 안 쓰는 게 좋다!! 최대한 쓰지 않도록! ) 소스 코드의 순서: 중요성, 특성이 설정되지 않았거나 동일한 경우나중에 나온 소스의 스타일이 우선권을 가진다. [예시] 1234567891011121314151617p &#123; color: #930212; &#125;p &#123; color: #d5727e; &#125;/* 우선권을 가진다. */p.note &#123; color: #930212; &#125;/* note라는 클래스 10점 + p요소 1점= 11점이 되므로 -&gt; 우선권을 가진다. */p &#123; color: #d5727e; &#125;p.note &#123; color: #930212; &#125;/* .note 클래스: 10점 + p요소: 1점 = 11점 */#target p &#123; color: #d5727e; &#125; /* #target: id선택자 100점 + p요소 1점 = 101점 *//* 우선권을 가진다. */&lt;p style=\"color: maroon\"&gt; /* inline 스타일은 1000점 */ 가장 약한 점수를 가지고 있다고 해도 !important flag를 꽂게 되면,!important가 우선하게 된다. html 파일 요소에 직접 스타일링 하는 것이다. (inline 스타일)","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"상속","slug":"상속","permalink":"https://JihyeHwang09.github.io/tags/상속/"},{"name":"Inheritance","slug":"inheritance","permalink":"https://JihyeHwang09.github.io/tags/inheritance/"},{"name":"케스케이드","slug":"케스케이드","permalink":"https://JihyeHwang09.github.io/tags/케스케이드/"},{"name":"Cascade","slug":"cascade","permalink":"https://JihyeHwang09.github.io/tags/cascade/"}]},{"title":"CSS 선택자(Selectors)","slug":"css-selectors","date":"2019-01-11T14:30:19.000Z","updated":"2019-04-11T15:22:16.147Z","comments":true,"path":"2019/01/11/css-selectors/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/11/css-selectors/","excerpt":"","text":"CSS 선택자(Selectors)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP강의 내용을 정리한 것임을 알려드립니다. 선택자는 CSS뿐만 아니라 자바스크립트에서도 유용하게 사용될 수 있다. CSS는 HTML 요소를 선택하는데 있어 다양한 선택자 옵션을 제공한다. selector(대상) {property(속성):value(값)} 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; h1 &#123;font-size: 100%&#125; /* Element Type Selector */ a &#123;text-decoration:none&#125; img &#123;border: 0&#125; &lt;/style&gt;&lt;/head&gt; 123456789&lt;head&gt; &lt;style type=\"text/css\"&gt; h1, h2, h3, h4, h5,h6&#123;font-wieght: normal&#125; /* Grouping: 여러 개의 요소(태그 선택자)를 일괄적으로 묶어주고, 일괄적으로 디자인해주는 것 */ a, img, p &#123;border:none&#125; h3 span, h4 span&#123;position:fixed:left:-2em&#125; &lt;/style&gt;&lt;/head&gt; 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; * &#123;margin:0:padding:0&#125;; /* Universal Selector(전체 선택자): HTML에 존재하는 모든 요소에 일괄적으로 스타일링 주고자 할 때*/ html body * &#123;text-decoration:none&#125; p.declation * &#123;text-transform:capitalize&#125; &lt;/style&gt;&lt;/head&gt; 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; p.note&#123;&#125; /* Class Selector(클래스 선택자) */ .floatLeft&#123;&#125; .positionAbs&#123;&#125; &lt;/style&gt;&lt;/head&gt; 12345678910&lt;head&gt; &lt;style type=\"text/css\"&gt; p.note.floatLeft&#123;&#125; /* Multi Class Selector(말 그대로 여러 개의 클래스가 붙은 선택자) 단락 요소(p)가 note라는 클래스와 floatLeft라는 클래스를 둘 다 가질 때 .note와 .floatLeft 사이에 띄면 X! */ .section.article&#123;&#125; .positionAbs&#123;&#125; &lt;/style&gt;&lt;/head&gt; 123456789&lt;head&gt; &lt;style type=\"text/css\"&gt; ul#nav&#123;&#125; /* ID Selector(아이디 선택자) Hash(#)값을 통해서 아이디를 선택하게 된다.*/ div#figure&#123;&#125; #site_info&#123;&#125; &lt;/style&gt;&lt;/head&gt; 123456789101112&lt;head&gt; &lt;style type=\"text/css\"&gt; p strong&#123;&#125; /* Descendant Selector */ /* '단락 내부에 있는 strong을 찾아서 꾸며주세요~'라는 뜻 */ ul li a &#123;&#125; /* 비순차 목록인 ul 내부의 li 요소를 찾은 다음에 a 요소 결국 꾸며지는 건 ul도 X, li도 X!! a요소를 최종적으로 찾은 다음에 꾸민다. 맨 마지막에 나오는 요소를 꾸민다. */ h3 span &#123;&#125; &lt;/style&gt;&lt;/head&gt; CSS 선택자(Selector) 요소 선택자 (Element Type Selector)figure { … } 그룹핑 (Grouping)a, abbr, .note, #about-css { … } -&gt; class도 묶어 줄 수 있다. 전체 선택자 (Universal Selector) { … } -&gt;*를 사용해서 모든 요소를 선택할 때 쓴다. 특정 영역 내에 있는 모든 요소를 선택할 때도 쓸 수 있다.ex) #about-css * {} -&gt; id가 about-css 속성값을 가진 내부의 모든 요소를 가리키게 된다.section이라든가 body는 포함되지 X. 클래스 선택자 (Class Selector) 대소문자 구분하기 때문에 반드시 확인해야 한다..class { … } 멀티 클래스 선택자 (Multi Class Selector)&lt;비교&gt; 띄어쓰기에 따라 의미가 완전히 달라진다..class1.class2 { … }: 하나의 요소가 2개의 클래스를 가진 형태 (멀티 클래스 선택자).class1. class2 { … }: class1을 가진 요소가 내부에 class2를 가지고 있을 때 쓴다. (자손 선택자) ex) .note.box {} -&gt;note라는 클래스 가진 요소 중에 box라는 클래스를 가지고 있다면, note와 box 클래스 2개가 모두 가지고 있다면~ 아이디 선택자 (ID Seletor): id값이 동일한 대상을 찾는다.#id { … }ex) #about-css {} -&gt; id가 about-css인 요소에 적용한다. 자손 선택자 (Descendent Selector): 클래스 or 아이디를 이용해서 꾸밀 수 있다.h1 abbr { … } -&gt; ‘h1이 포함한 abbr을 찾아서 꾸며주세요~’ 라는 뜻.note abbr { … } 자식 선택자 (Descendent Selector): 부모의 직접적인 자식만 나타낸다..parent &gt; .child { … } 자손 선택자 vs 자식 선택자 자손 선택자: ex) 아들, 손주 자식 선택자: 직계 자식만 선택할 수 있음. ex) 아들 123456ex1) &lt;h1&gt; &lt;strong&gt; &lt;strong&gt; &lt;abbr&gt; h1의 자손 선택자: &lt;strong&gt;, &lt;strong&gt;, &lt;abbr&gt; h1의 자식 선택자: 바로 밑의 &lt;strong&gt;만 해당 됨. 123ex2) body * &#123;&#125; : body 요소 내부의 모든 자손 선택 body &gt; * &#123;&#125; : body 요소 내부의 모든 자식(Child) 선택 속성 선택자 (Attribute Selector): 속성 선택자[] 앞에 아무것도 붙어있지 않다면. *가 생략되어 있다고 보면 된다. [id] { … } -&gt; id 속성을 가지고 있다면~ex)a[id] { … } -&gt; a요소가 id 속성값을 가지고 있다면~ [class] { … }[title] { … }[shape] { … } [shape][title]{ … } -&gt; shape과 title 속성을 둘 다 가지고 있다면~ [class=”note box”] { … } -&gt; 정확하게 “note box”라는 이름의 클래스를 찾기 때문에클래스명이 “box note”일 경우에는 찾을 수 X. -&gt; class의 경우에는.box {}.note {}가 좀 더 유연하게 사용할 수 있다. [id=”about-css] { … } -&gt; id값이 about-css라면~ 해당 요소를 선택해서 꾸며주게 된다.이걸 쉽게 쓰라고 만들어진 표현법이 hash(#) 표현법이다. #about-css { … } [class=”note”] { … }.note { … } ^=&quot;&quot;: ~로 시작하는 것ex)[title^=”Scalable”] { … } -&gt; title 요소 중, “”안의 Scalable이라는 단어로 시작하는 것을 모두 찾고 싶을 때 $=&quot;&quot;: ~로 끝나는 것ex)[title$=”Language”] { … } -&gt; title 요소 중, “”안의 Language이라는 단어로 끝나는 것을 모두 찾고 싶을 때 *=&quot;&quot;: ~를 포함하는 것ex)[title*=”Markup”] { … } -&gt; title 요소 중, “”안의 Markup이라는 단어를 포함하는 것을 모두 찾고 싶을 때 -&gt; CSS는 완벽하게 대소문자를 구분하기 때문에 “Markup”과 “markup”을 다르게 받아들인다. [href^=”http://“] { … } -&gt; href 속성값이 ^로 시작한다면, 속성값이 “http://“로 (“”안의 단어로) 꼭 시작해야 한다. [src$=”.svg”] { … } -&gt; .svg는 확장자임(‘.’으로 시작하므로) 확장자가 svg인 파일들을 이미지로 불러오는 모든 요소들을 찾게되는 것이다. [src*=”phone”] { … } -&gt; src에 포함된 단어 중에 “phone”이 들어간 걸 모두 찾아온다. 고급 속성 선택자 가상 클래스 선택자(Link Pseudo-class)a:link, a:visited{}anchor element가 기본적으로 가지고 있는 상태는 link element이다.1번 이상 방문한 사이트는 표시가 되어야 한다. -&gt; visited 방문했다는 가상클래스를 사용할 수 있다. a:hover, a:active{}hover: 마우스가 올라간 상태active: 마우스로 클릭한 순간 -&gt; 마우스 클릭한 걸 떼게 되면 active가 해제되는 것임 p:hover{} input:focus -&gt; focus가 된 상태input:focus:hover -&gt; focus가 된 상태에서 마우스가 올라가면(hover)~ [가상 클래스(Pseudo Class)] :link { … }:visited { … } :hover { … } hover는 마우스에 의존하는 속성:active { … } :focus { … }:focus:hover { … } -&gt; keyboard에 focusing이 간 상태에서 마우스가 올라가게 되면, 디자인이 변경된다. :focus:active { … } -&gt; focus가 된 후에 클릭이 될 때 디자인이 변경된다. 가상 클래스는 연이어서 사용할 수 있다. :first-child { … } :first-child는 :nth-child(1)과 같다. :last-child { … } 자식이 4개 라면 -&gt; last-child와 nth-child(4)와 같다.:nth-child(n) { … }()안에는 공식이 사용될 수 있다.1st2nd3rd4th5th…nth ex)link-list last-child(2n-1) {}link-list last-child(odd) {} 홀수 번째link-list last-child(2n) {}link-list last-child(even) {}짝수 번째CSS에서는 단축해서 홀수는 (odd),(even)을 사용한다.link-list last-child(3n) {}3의 배수 번째에만 :lang(ko) { … } ex) 디자인 상에서 한글과 영문은 각기 다른 디자인을 적용해달라는 요구가 있을 수 있음. 그 나라의 언어에 맞게 폰트를 변경할 떄 가상클래스를 사용하면 된다. :lang(en) {font-family: “Times New Roman”; &lt;!– 명조계열체 - -&gt;}:lang(ko-KR) {font-family: “Spoqa Han Sans”;&lt;!– 고딕계열체 - -&gt;} 가상 요소(Pseudo Element): 가상 클래스와는 다르다.: 1개 사용 -&gt; 가상 클래스vs :: 2개 사용 -&gt; 가상 요소::first-letter { … }::first-line { … }::before { … }::after { … }","categories":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"CSS","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"CSS","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"선택자","slug":"선택자","permalink":"https://JihyeHwang09.github.io/tags/선택자/"},{"name":"selector","slug":"selector","permalink":"https://JihyeHwang09.github.io/tags/selector/"}]},{"title":"주니어 개발자가 기억 & 주의해야 할 점","slug":"to-remember-things-for-junior-developer","date":"2019-01-10T14:13:52.000Z","updated":"2020-03-04T14:25:40.840Z","comments":true,"path":"2019/01/10/to-remember-things-for-junior-developer/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/10/to-remember-things-for-junior-developer/","excerpt":"","text":"이번에는 주니어 개발자가 기억해야 할 것과 주의해야 할 점에 대해 정리해봅시다. 주니어 개발자가 기억해야 할 것프로그래머는 복잡성(complexity)와 항상 싸워야 한다. 함수, 클래스, 모듈로 나누고 주석도 잘 쓰면 복잡성이 내려간다. 복잡성을 낮춰야 하는 이유와 방법 큰 프로그램을 작성하기 위해 필요 유지보수를 위해 필요 코드를 작성하고 한참 뒤에 코드를 추가하거나 수정할 때 협업을 위해서 필요하다. 다른 프로그래머가 사용하기 쉽도록 프로그램의 구조 자체를 잘 짜야 한다. (다른 개발자가 작성한 프로그램을 파악하기 위해서 전체 코드를 다 읽어봐야 한다면 시간이 너무 오래 걸린다.) 디자인 패턴이 잘 짜여진 React.js, Angular.js, Vue.js와 같은프레임워크 또는 라이브러리를 사용하면,프로젝트의 복잡도를 관리하기 보다 수월해질 수 있으며,장기적인 관점으로 보았을 때 유지보수를 하는데 도움이 되는 것 같다. 협업을 하는 다양한 방식 ex1) 주로 대기업에서 사용하는 협업 방식: 폭포수(waterfall) 개발 방법론 절차: 기획 -&gt; 디자인 -&gt; HTML -&gt; CSS -&gt; JS 장점: 쇼핑몰 만드는 것처럼 크게 변경할 부분이 없는 경우(비슷한 방식을 반복하는 경우)에는 속도가 더 빠르다. 단점: 속도가 느리다. 앞 단계에서 결정된 사항을 바꾸기 어렵다. 3개월 프로젝트 시간이 주어지면, 1개월 기획, 1개월 디자인, 1개월 개발로 나눌 수 있다. ex2) 주로 스타트업 기업에서 사용하는 협업 방식: 애자일(Agile)(기능별로 나누는 방식) 로그인 게임판 점수판 3개월 프로젝트 시간이 주어진다면, 2주 동안 6번 로그인, 게임판, 점수판 기능을 기획부터 JS까지 반복하자. Developer들도 기획이나 디자인 단계에 참여해서 의견을 내고 서로 질문을 주고 받는다. 장점: 개발 단계에서 수정 사항이 생겨도 결정된 사항을 바꾸기 쉽기 때문에 실험적인 도전을 할 수 있다. 제품을 빨리 만들고 수정 사항을 반영해서 바꾸기에 적합하다. 단점: 개발자들이 기획이나 디자인 단계에도 참여하기 때문에 개발자들이 시간을 굉장히 많이 소비하게 된다. 전문 영역이라는 게 부족해지게 된다. -&gt; 그 결과로 제품의 퀄리티가 떨어질 수 있다. 취업 전에 애자일(Agile) 도서를 꼭 1권 이상 읽고 취업할 것을 추천 주니어 개발자가 프로젝트 진행시 주의할 점 프로젝트를 할 때는 해야 하는 일과 하고 싶은 일을 구분해야 한다. 주니어 개발자 때는 소요 시간을 예상하기 쉽지 않다. 할 일 목록을 쭉 적어놓고 일정을 잡기 자신이 예상한 시간에 X 2 X 3을 해서 예상 시간 산정하기 ex) 내 예상으로는 3시간 걸리는 기능이라면 9시간 소요될 것으로 예상하고 일정 잡기 버그를 잡는 데 시간이 오래 걸릴 수 있다. 기술 a를 적용할 수 있다고 생각했는데,a를 적용 못해서 기술 b를 새로 배워서 적용해야 하는 경우가 분명히 생긴다. 꼭 해야 되는 일부터 해야 한다. MVP(Minimum Viable Product)(최소 기능 제품)을 먼저 만든 후에 그 뒤에 하고 싶은 기능을 만든다. MVP를 세워뒀다고 해도 시간이 부족할 수 있다.항상 플랜 B를 세워둬야 한다.이것보다 기능이 적어도 기능이 있어서 클라이언트에게 납품할 수 있는 결과물을 넘겨줘야 하기 때문에 어느 선까지는 꼭 만들 것인지 정해둬야 한다. ex) 목표: 오목 게임 꼭 구현해야 하는 기능 클릭 반응 승자 판별","categories":[{"name":"Developer","slug":"developer","permalink":"https://JihyeHwang09.github.io/categories/developer/"},{"name":"면접","slug":"developer/면접","permalink":"https://JihyeHwang09.github.io/categories/developer/면접/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"Front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"interview","slug":"interview","permalink":"https://JihyeHwang09.github.io/tags/interview/"}]},{"title":"순환(Recursion)의 개념과 기본 예제3","slug":"recursion3","date":"2019-01-09T02:42:47.788Z","updated":"2019-01-21T03:47:33.193Z","comments":true,"path":"2019/01/09/recursion3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/09/recursion3/","excerpt":"","text":"이번에는 지난 포스트에 이어서, 순환적 알고리즘 설계 방법에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 순환적 알고리즘 설계적어도 하나의 base case, 즉 순환되지 않고 종료되는 case가 있어야 함 모든 case는 결국 base case로 수렴해야 함 암시적(implicit) 매개변수를 명시적(explicit) 매개변수로 바꾸어라. 순차 탐색 이 함수의 미션은 data[0]에서 data[n-1] 사이에서 target을 검색하는 것이다. 하지만, 검색 구간의 시작 인덱스 0은 보통 생략한다. -&gt; 즉, 암시적 매개변수이다. 이 함수는 시작 위치는 0으로 암시, 끝 위치는 명시되어 있다. 12345678910// \"배열의 데이터가 n개이니까 당연히 인덱스 0부터 시작하겠지.\"라고// 암묵적으로 동의한 것이므로 생략됨// 배열의 시작지점이 명시적으로 0이라고 표현되어 있지 Xint search(int [] data, int n, int target) &#123; for (int i = 0; i &lt; n; i++) &#123; if (data[i] == target) return i; &#125; return -1;&#125; 매개변수의 명시화: 순차 탐색 이 함수의 미션은 data[begin]에서 data[end] 사이에서 target을 검색한다. 즉, 검색구간의 시작점을 명시적(explicit)으로 지정한다. 시작 위치가 begin으로 명시, 끝 위치는 end로 명시되어 있다. 이 함수를 search(data, 0, n-1, target)으로 호출한다면, 위의 순차 탐색에서 예시로 든 search함수와 완전히 동일한 일을 한다. 1234567891011int search(int [] data, int begin, int end, int target) &#123; // begin &gt; end이면, 데이터가 0개이다. if (begin &gt; end) &#123; return -1; // begin = end는 데이터가 1개라는 뜻&#125; else if (target == data[begin]) &#123; // end를 찾을 필요 없이 begin을 return한다. return begin;&#125; else if &#123; return search(data, begin + 1, end, target);&#125; 순차 탐색: 다른 버전 이 함수의 미션은 data[begin]에서 data[end] 사이에서 target을 검색한다. 즉, 검색구간의 시작점을 명시적(explicit)으로 지정한다. 예제1123456789int search(int [] data, int begin, int end, int target) &#123; if (begin &gt; end) &#123; return -1; &#125; else if (target == items[end]) &#123; return end; &#125; else &#123; return search(data, begin, end-1, target); &#125;&#125; 예제212345678910111213141516int search(int [] data, int begin, int end, int target) &#123; if (begin &gt; end) &#123; return -1; &#125; else &#123; int middel = (begin + end) / 2; if (data[middle] == target) &#123; return middle; &#125; int index = search(data, begin, middle - 1, target); if (index != -1) &#123; return index; &#125; else &#123; return search(data, middle + 1, end, target); &#125; &#125;&#125; 매개변수의 명시화: 최대값 찾기 이 함수의 미션은 data[begin]에서 data[end] 사이에서 최대값을 찾아 반환한다. begin &lt;= end라고 가정한다. 12345678910int findMax(int [] data, int begin, int end) &#123; // base case: 데이터가 0개 일 경우가 X. 1개일 경우이다. // 데이터가 0개일 경우, 최대값이 정의되지 X 때문이다. // begin = end일 경우, 데이터가 1개이다. if (begin == end) &#123; return data[begin]; &#125; else &#123; return Math.max(data[begin], findMax(data, begin + 1, end)); &#125;&#125; 최대값 찾기: 다른 버전12345678910int findMax(int [] data, int begin, int end) &#123; if (begin == end) &#123; return data[begin]; &#125; else &#123; int middle = (begin + end) / 2; int max1 = findMax(data, begin, middle); int max2 = findMax(data, middle + 1, end); return Math.max(max1, max2); &#125;&#125; 이진 탐색(Binary Search) items[begin]부터 items[end] 사이에서 target을 검색한다. 12345678910111213141516171819202122public static int binarySearch(String[] items,String target, int begin, int end) &#123; // base case: 데이터의 개수가 0일 경우 if (begin &gt; end) &#123; return -1; &#125; else &#123; int middle = (begin + end) / 2; // Java에서 문자열끼리의 비교는 compareTo() 메서드를 이용한다. // cf) s1.compareTo(s2) 메서드는 문자열의 사전적 값을 비교 // s1 &lt; s2일 경우, 음의 정수를 반환 // s1 == s2일 경우, 0을 반환 // s1 &gt; s2일 경우, 양의 정수를 반환 int compResult = target.compareTo(items[middle]); if (comResult == 0) &#123; return middle; &#125; else if (compResult &lt; 0) &#123; return binarySearch(items, target, begin, middle -1); &#125; else &#123; return binarySearch(items, target, middle + 1, end); &#125; &#125;&#125;","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"순환 함수 - recursion","slug":"순환-함수-recursion","permalink":"https://JihyeHwang09.github.io/tags/순환-함수-recursion/"},{"name":"순환적 알고리즘 설계","slug":"순환적-알고리즘-설계","permalink":"https://JihyeHwang09.github.io/tags/순환적-알고리즘-설계/"},{"name":"명시적 매개변수","slug":"명시적-매개변수","permalink":"https://JihyeHwang09.github.io/tags/명시적-매개변수/"},{"name":"explicit","slug":"explicit","permalink":"https://JihyeHwang09.github.io/tags/explicit/"},{"name":"순차 탐색","slug":"순차-탐색","permalink":"https://JihyeHwang09.github.io/tags/순차-탐색/"},{"name":"최대값 찾기","slug":"최대값-찾기","permalink":"https://JihyeHwang09.github.io/tags/최대값-찾기/"},{"name":"이진 탐색","slug":"이진-탐색","permalink":"https://JihyeHwang09.github.io/tags/이진-탐색/"},{"name":"Binary Search","slug":"binary-search","permalink":"https://JihyeHwang09.github.io/tags/binary-search/"}]},{"title":"순환(Recursion)의 개념과 기본 예제2","slug":"recursion2","date":"2019-01-08T10:16:09.508Z","updated":"2019-01-21T03:47:36.953Z","comments":true,"path":"2019/01/08/recursion2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/08/recursion2/","excerpt":"","text":"이번에는 지난 포스트에 이어서, 순환적으로 사고하기와 문자열의 길이 계산, 배열의 합 등의 예제에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 순환적으로 사고하기(Recursive Thinking)Recursion은 수학함수 계산에만 유용한가? 수학함수 뿐 아니라 다른 많은 문제들을 recursion으로 해결할 수 있다. 문자열의 길이 계산 문자열의 길이를 계산하고 싶다면, 첫 번째 문자열을 뺀 나머지 문자열의 길이를 계산 1을 더하면 된다. 12345678// base case: 문자열의 길이가 0인 경우// -&gt; 첫 번째 문자열이 존재하지 Xif the string is empty return 0;// 첫 번째 문자열을 제거한 그 문자열의 길이를 계산한 다음, 1을 더한다.else return 1 plus the length of the string that excludes the first character; 1234567int length(char *str) &#123; if (*str == '\\0') &#123; return 0; &#125; else &#123; return 1 + length(str + 1); &#125;&#125; 12345678910111213141516171819// 문자열 str을 입력받아 길이를 계산하는 메서드 lengthpublic static int length(String str) &#123; // base case: 문자열의 길이가 0인 문자열과 동일하다면 // -&gt; 즉, 문자열의 길이가 0라면 if (str.equals(\"\")) &#123; return 0; &#125; else &#123; // Java에서 substring(n)은 // index값이 n보다 작은(앞에 있는) 문자열을 제거한 문자열을 반환한다. // str.substring(1)은 // str에서 index값이 1인 위치 이후부터의 문자열을 가져온다. // -&gt; 즉, 입력받은 str에서 // index값이 0인 첫 글자를 제외한 문자열을 반환한다. // 1 + length(str.substring(1))는 그것의 길이를 계산한 다음, // 1을 더해서 반환한다. return 1 + length(str.substring(1)); &#125;&#125; 문자열의 프린트123456789101112// 입력한 하나의 문자열을 출력하는 메서드 printCharspublic static void printChars(String str) &#123; if (str.length() == 0) &#123; return; &#125; else &#123; // 문자열의 첫 글자를 화면에 출력한다. // Java에서 str.charAt(n)은 인덱스 n의 위치에 해당되는 문자를 추출해준다. System.out.print(str.charAt(0)); // 첫 글자를 제외한 나머지 문자열을 화면에 출력한다. printChars(str.substring(1)); &#125;&#125; 문자열을 뒤집어 프린트 이 문자열을 뒤집어 프린트하려면, 먼저 첫 글자를 제외한 문자열을 뒤집어 프린트 한다. 마지막으로, 첫 글자를 프린트 한다. 123456789101112public static void printCharsReverse(String str) &#123; // base case: 입력된 문자열 str의 길이가 0라면, 아무 일도 일어나지 X if (str.length() == 0) return; // 문자열의 길이가 1 이상이라면, else &#123; // 1. 먼저 첫 글자를 제거한 문자열을 화면에 뒤집어서 출력한다. printCharsReverse(str.substring(1)); // 2. 마지막으로, 원래 문자열의 첫 글자를 화면에 출력한다. System.out.print(str.charAt(0)); &#125;&#125; 2진수로 변환하여 출력12345678910111213// 음이 아닌 정수 n을 이진수로 변환하여 출력한다.public void printInBinary(int n) &#123; if (n &lt; 2) &#123; System.out.print(n); &#125; else &#123; // n을 2로 나눈 몫을 먼저 2진수로 변환하여 출력한다. // 마지막 비트를 제외한 나머지 비트가 표현하는 숫자이다. printInBinary(n/2); // n을 2로 나눈 나머지를 출력한다. // 마지막 비트를 표현하는 숫자이다. System.out.print(n%2); &#125;&#125; 배열의 합 구하기1234567891011121314// n개인 data의 합 구하기// data[0]에서 data[n-1]까지의 합을 구하여 반환한다.public static int sum(int n, int[] data) &#123; if (n &lt;= 0) return 0; else //sum(n-1, data) 을 호출하면, // data[0]에서 data[n-2]까지 데이터의 합을 구한다. // 그 후, 마지막 데이터인 data[n-1]을 더해준다. // recursion이 1씩 줄어들다가 0이 될 때, 빠져나온다. // -&gt; 무한루프에 빠질 일이 X return sum(n-1, data) + data[n-1];&#125; 데이터 파일로부터 n개의 정수 읽어오기실제로 자주 쓰는 코드 형태는 Xrecursion 예제로만 참고 123456789101112131415// Scanner in이 참조하는 파일로부터 n개의 정수를 입력받아// 배열 data의 data[0], ..., data[n-1]에 저장한다.public void readFrom(int n, int [] data, Scanner in) &#123; // base case: n이 0일 때는 아무것도 하지 X if (n == 0) &#123; return; &#125; else &#123; // 1. n-1개의 데이터를 읽어온다. // -&gt; data[0], ..., data[n-2]에 저장한다. readFrom(n-1, data, in); // 2. 마지막 한 개의 데이터를 읽어온다. // -&gt; 읽어온 데이터를 data[n-1]에 저장한다. data[n-1] = in.nextInt(); &#125;&#125; Recursion vs Interation 모든 순환함수는 반복문(interation)으로 변경 가능 그 역도 성립함. 즉, 모든 반복문은 순환함수(recursion)으로 표현 가능함 순환함수는 복잡한 알고리즘을 단순하고 알기쉽게 표현하는 것을 가능하게 함 하지만, 함수 호출에 따른 오버헤드가 있음(매개변수 전달, 액티베이션 프레임 생성 등)","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://JihyeHwang09.github.io/tags/알고리즘/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"Computer Science","slug":"computer-science","permalink":"https://JihyeHwang09.github.io/tags/computer-science/"},{"name":"Algorithms","slug":"algorithms","permalink":"https://JihyeHwang09.github.io/tags/algorithms/"},{"name":"순환 함수 - recursion","slug":"순환-함수-recursion","permalink":"https://JihyeHwang09.github.io/tags/순환-함수-recursion/"},{"name":"Recursion Function","slug":"recursion-function","permalink":"https://JihyeHwang09.github.io/tags/recursion-function/"},{"name":"수학적 귀납법","slug":"수학적-귀납법","permalink":"https://JihyeHwang09.github.io/tags/수학적-귀납법/"},{"name":"Mathematical Induction","slug":"mathematical-induction","permalink":"https://JihyeHwang09.github.io/tags/mathematical-induction/"},{"name":"Interation","slug":"interation","permalink":"https://JihyeHwang09.github.io/tags/interation/"}]},{"title":"순환(Recursion)의 개념과 기본 예제1","slug":"recursion1","date":"2019-01-07T08:51:43.427Z","updated":"2019-01-21T03:47:39.434Z","comments":true,"path":"2019/01/07/recursion1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/07/recursion1/","excerpt":"","text":"순환 함수란 무엇이며, 무한 루프에 빠지지 않으려면 어떤 경우가 존재해야 하는지 그리고 수학적 귀납법에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 순환이란? recursion은 항상 무한루프에 빠질까? 12345678910111213// 1 ~ n까지의 합을 구한다.int main() &#123; int result = func(4);&#125;int func(int n) &#123; if (n == 0) &#123; return 0; &#125; else &#123; return n + func(n-1); &#125;&#125; 무한루프에 빠지지 않으려면? &amp; recursion의 해석123456789101112// 이 함수의 mission은 0 ~ n까지의 합을 구하는 것이다.int func(int n) &#123; // Base case: 적어도 하나의 recursion에 빠지지 않는 경우가 존재해야 한다. // n = 0이라면, 합은 0이다. if (n == 0) return 0; else // Recursive case: recursion을 반복하다보면 결국 base case로 수렴해야 한다. // n이 0보다 크다면, // 0에서 n까지의 합은 0에서 n-1까지의 합에 n을 더한 것이다. return n + func(n-1);&#125; 순환함수와 수학적 귀납법정리: func(int n)은 음이 아닌 정수 n에 대해서 0에서 n까지의 합을 올바르게 계산한다.증명: n=0인 경우: n=0인 경우 0을 반환한다. 올바르다. 임의의 양의 정수 k에 대해서 n &lt; k인 경우, 0에서 n까지의 합을 올바르게 계산하여 반환한다고 가정하자. n = k인 경우를 고려해보자. func은 먼저 func(k-1) 호출하는데 2번의 가정에 의해서0에서 k-1까지의 합을 올바르게 계산하여 반환한다.메서드 func은 그 값에 n을 더해서 반환한다.따라서 메서드 func는 0에서 k까지의 합을 올바로 계산하여 반환한다. 12345678910111213141516171819package lec00.algorithm;public class Alg02 &#123; public static void main(String[] args) &#123; int n = 4; func(n); &#125; public static void func(int k) &#123; if (k &lt;= 0) return;// Base case: 적어도 하나의 recursion에 빠지지 않는 경우가 존재해야 한다. else &#123; System.out.println(\"Hello...\"); func(k-1);// Recursive case: recursion을 반복하다보면 결국 base case로 수렴해야 한다. &#125; &#125;&#125;// recursion이 항상 무한루프에 빠지는 것은 아니다. 123456789101112131415161718192021222324252627282930package lec00.algorithm;// 1 ~ n까지의 합을 구한다.public class Alg03 &#123; public static void main(String[] args) &#123; int result = func(4); System.out.println(result); &#125; public static int func(int n) &#123; if(n &lt;= 0) return 0; else &#123; return n + func(n-1); &#125; /* public static int func(int n) &#123;// 이 함수의 mission은 0~n까지의 합을 구하는 것이다. if (n == 0) return 0;// n=0이라면 합은 0이다. else return n + func(n-1);// n이 0보다 크다면 0에서 n까지의 합은// 0에서 n-1까지의 합에 n을 더한 것이다.&#125;*/ &#125;&#125; Factorial: n! 12345678int factorial(int n)&#123; if (n == 0) &#123; return 1; &#125; else &#123; return n* factorial(n-1); &#125;&#125; 정리: factorial(int n)은 음이 아닌 정수 n에 대해서 n!을 올바르게 계산한다.증명: n = 0인 경우: n=0인 경우 1을 반환한다. 올바르다. 임의의 양의 정수 k에 대해서 n &lt; k인 경우 n!을 올바르게 계산한다고 가정하자. n = k인 경우를 고려해보자. factorial은 먼저 factorial(k-1) 호출하는데 2번의 가정에 의해서 (k-1)!을 올바르게 계산하여 반환한다. 따라서 메서드 factorial은 k \\* (k-1)! = k!을 반환한다. 123456public static int factorial(int n)&#123; if (n == 0) return 1; else return n * factorial(n-1);","categories":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/"},{"name":"알고리즘","slug":"컴퓨터-과학/알고리즘","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학/알고리즘/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://JihyeHwang09.github.io/tags/알고리즘/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"Computer Science","slug":"computer-science","permalink":"https://JihyeHwang09.github.io/tags/computer-science/"},{"name":"Algorithms","slug":"algorithms","permalink":"https://JihyeHwang09.github.io/tags/algorithms/"},{"name":"순환 함수 - recursion","slug":"순환-함수-recursion","permalink":"https://JihyeHwang09.github.io/tags/순환-함수-recursion/"},{"name":"Recursion Function","slug":"recursion-function","permalink":"https://JihyeHwang09.github.io/tags/recursion-function/"},{"name":"수학적 귀납법","slug":"수학적-귀납법","permalink":"https://JihyeHwang09.github.io/tags/수학적-귀납법/"},{"name":"Mathematical Induction","slug":"mathematical-induction","permalink":"https://JihyeHwang09.github.io/tags/mathematical-induction/"}]},{"title":"카르노 도표(KARNAUGH MAP)","slug":"karnaugh-map","date":"2019-01-06T13:53:35.896Z","updated":"2019-01-07T10:33:28.058Z","comments":true,"path":"2019/01/06/karnaugh-map/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/06/karnaugh-map/","excerpt":"","text":"부울함수의 간소화 방법 중의 하나인 카르노 도표(KARNAUGH MAP)에 대해 알아봅시다. 카르노 도표 방법 카르노 도표는 여러 개의 사각형으로 된 다이어그램 사각형은 각각 하나의 최소항이나 최대항을 의미 여섯 개 이하의 변수를 가진 부울함수에 사용 카르노 도표는 부울함수의 입력변수의 수에 따라서 기본 도표의 형태가 결정됨 입력변수의 수가 n인 경우를 n변수 카르노 도표라고 하며, 2^n개의 사각형으로 구성됨 카르노 도표를 이용하면, 정규형 부울 함수 -&gt; 표준형 부울함수로 간소화할 수 있음 카르노 도표를 이용해서 부울함수의 각 항들을 곱이나 합 형태로 간소화 최소항의 합 -&gt; 곱의 합 최대항의 곱 -&gt; 합의 곱 형태로 간소화 됨 최소항의 합형을 곱의 합형으로 간소화하는 순서 입력변수의 수 n에 따라 n변수 카르노 도표 작성(도표는 2^n개의 정사각형) 최소항의 인덱스에 대응되는 사각형을 1로 표시 1로 표시된 사각형들 중 서로 인접한 사각형끼리 묶음 (주의! 이때 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.) 각 묶음이 입력변수 각각에 대해 도표상의 어떤 위치에 있는지 파악 4)에서 구한 각 묶음에 대한 곱항들을 논리합(OR)으로 연결시키면, 간소화된 표준형(곱의 합형)이 구해진다. 최대항의 곱형을 합의 곱형으로 간소화하는 순서 입력변수의 수 n에 따라 n변수 카르노 도표 작성(도표는 2^n개의 정사각형) 최소항의 인덱스에 대응되는 사각형을 0으로 표시 0으로 표시된 사각형들 중 서로 인접한 사각형끼리 묶음 (주의! 이때 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.) 각 묶음이 입력변수 각각에 대해 도표상의 어떤 위치에 있는지 파악 4)에서 구한 각 묶음에 대한 합항들을 논리곱(AND)으로 연결시키면, 간소화된 표준형(합의 곱형)이 구해진다. 인접 사각형의 정의 카르노 도표에서 각 정사각형은 하나의 최소항(또는 최대항)을 의미 따라서, 인접 사각형이란 두 정사각형에 대응되는 각 최소항(또는 최대항)의 구성변수 중 다른 모든 변수는 동일하되 오직 하나의 변수만 서로 보수관계에 있을 때 두 정사각형은 서로 인접한다”라고 정의 ex) 입력변수가 X, Y, Z 3개의 경우 인접 사각형끼리 묶는 방법 한 묶음 내의 정사각형의 수는 2^n(n = 0, 1, 2... n)개가 되도록 묶는다. 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"카르노 도표","slug":"카르노-도표","permalink":"https://JihyeHwang09.github.io/tags/카르노-도표/"},{"name":"카르노 맵","slug":"카르노-맵","permalink":"https://JihyeHwang09.github.io/tags/카르노-맵/"},{"name":"karnaugh map","slug":"karnaugh-map","permalink":"https://JihyeHwang09.github.io/tags/karnaugh-map/"}]},{"title":"논리게이트(LOGIC GATE)","slug":"logic-gate","date":"2019-01-05T09:18:57.757Z","updated":"2019-01-07T10:28:28.084Z","comments":true,"path":"2019/01/05/logic-gate/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/05/logic-gate/","excerpt":"","text":"논리게이트(LOGIC GATE)의 종류에는 어떤 것들이 있는지와 각 논리게이트에 대한 기호, 진리표, 입출력 파형에 대해 알아봅시다. 논리게이트(LOGIC GATE)의 종류기본 논리게이트 AND 게이트 OR 게이트 NOT 게이트 NAND 게이트와 NOR 게이트 NAN 게이트 NOR 게이트 XOR 게이트와 XNOR 게이트 XOR 게이트 XNOR 게이트 논리게이트(LOGIC GATE)의 기호와 진리표, 입출력 파형1. 기본 논리게이트1) AND 게이트 반달 모양으로 표현 입력값이 둘 다 1일 경우에만 1이 출력되고, 나머지 경우에는 결과값이 0이 된다. 2) OR 게이트 반달 모양이되, 입력 부분이 움푹 들어간 모양으로 표현 입력값이 둘 다 0일 경우에만 결과값이 0이 되고,나머지 경우에는 결과값이 1이 된다. 3) NOT 게이트 세모 모양으로 표현, 출력부분에 작은 원을 그려준다. 입력값과 반대값이 출력된다. 2. NAND 게이트와 NOR 게이트1) NAND 게이트 AND 게이트의 반대 입력값이 둘 다 1일 경우에만 0이 출력되고, 나머지 경우에는 결과값이 1이 된다. 2) NOR 게이트 OR 게이트의 반대 입력값이 둘 다 0일 경우에만 1이 출력되고, 나머지 경우에는 결과값이 0이 된다. 반달 모양이되, 출력부분에 작은 원을 그려준다. 3. XOR 게이트와 XNOR 게이트1) XOR 게이트 입력값이 서로 다른 값이 들어온 경우에만 결과값이 1이 된다. 나머지 경우에는 0이 출력된다. 2) XNOR 게이트 입력값으로 서로 다른 값이 들어온 경우에만 결과값이 0이 된다. 나머지 경우에는 1이 출력된다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"논리게이트","slug":"논리게이트","permalink":"https://JihyeHwang09.github.io/tags/논리게이트/"},{"name":"logic gate","slug":"logic-gate","permalink":"https://JihyeHwang09.github.io/tags/logic-gate/"}]},{"title":"불 대수(Boolean algebra)","slug":"book-boolean-algebra","date":"2019-01-03T17:20:57.925Z","updated":"2019-10-22T23:43:52.691Z","comments":true,"path":"2019/01/04/book-boolean-algebra/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/04/book-boolean-algebra/","excerpt":"","text":"2진 디지털 시스템에서 입출력 관계를 표현하는 방법과 불 대수의 기본 개념 및 공식에 대해서 알아보고, 불 함수의 대수적 간소화에 대해서 공부해봅시다. 1. 2진 디지털 시스템에서 입출력 관계를 표현하는 방법1) 그래프나 진리표로 표시 2) 논리함수로 표시 입력에 따라 변수가 어떻게 변하는지를 나타내는 함수로 표현 입력이 2진 논리값이므로 논리함수로 나타낸다. 2. 불 대수의 기본 개념1) 불 대수(Boolean Algebra): 0과 1의 값을 갖는 논리변수와 논리연산을 다루는 대수 불 대수(Boolean algebra)는 하나의 명제가 참 또는 거짓인지를 판별하기 위해 이용되는 수학적 방법으로 19세기 중반 영국의 수학자 조지 불(George Boole)에 의해 개발되었다. 컴퓨터는 참과 거짓을 나타내기 위해 0과 1의 두 가지 상태로 표현하는 2진 논리회로로 구성되어 있다. 이러한 논리회로를 간략하게 표현할 때 불 대수가 사용된다. 2) 불 함수(Boolean Function): 논리변수의 상호관계를 나타내기 위해 불 변수, 불 연산기호, 괄호 및 등호 등으로 나타내는 대수적인 표현 AND 연산 입력값이 모두 1일 경우에만 결과값이 1이 된다. 표현법 X AND Y 또는 XY로 표현한다. 점으로 표시, 생략 가능 OR 연산 입력값 중 한 개라도 1일 경우 결과값이 1이 된다. 표현법 X OR Y 또는 X + Y로 표현한다. 덧셈 기호(+)로 표시 NOT 연산 입력값의 반대값이 출력된다. 표현법: NOT X 또는 X&#39;로 표현 변수 위에 줄(-)을 그어 표시 3. 불 대수의 기본 공식교환법칙, 결합법칙, 분배법칙, 드모르간의 법칙, 흡수 법칙 등을 이용하여회로를 쉽게 간소화할 수 있다. 4. 불 함수(논리식)의 대수적 간소화불 대수의 기본 공식을 이용해서 논리식을 간소화한다. 1) 합의 곱 표현을 곱의 합표현으로 변환한다. 합의 곱: (A + B)(C + D) 곱의 합: AC + AD + BC + BD 2) 공통 인수를 뽑아서 묶는다.3) 기본 공식 형태로 유도해서 식을 줄여 나간다.항 결합 X + X&#39; = 1이라는 성질을 이용한다. 문자 소거","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"boole","slug":"boole","permalink":"https://JihyeHwang09.github.io/tags/boole/"},{"name":"boolean algebra","slug":"boolean-algebra","permalink":"https://JihyeHwang09.github.io/tags/boolean-algebra/"}]},{"title":"Hexo를 이용한 블로그 만들기","slug":"hexo-blog","date":"2019-01-03T09:09:51.675Z","updated":"2020-03-04T14:05:35.462Z","comments":true,"path":"2019/01/03/hexo-blog/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/03/hexo-blog/","excerpt":"","text":"지난 포스트에서 정적블로그 플랫폼의 종류와 차이에 대해 소개했습니다.이번에는 Hexo를 이용한 블로그 만드는 방법에 대해 정리해봅시다. 1. Git, Nods.js 설치하기Hexo 블로그를 만들기 전, Git과 Node.js가 설치되어 있어야 합니다.Git과 Node.js가 이미 설치되어 있으신 분들은 2번부터 읽으시면 됩니다:) 1) Git 설치Git 다운로드 페이지 2) Node.js 설치Node.js 다운로드 페이지 2. GitHub 프로젝트(Repository) 만들기블로그의 포스트를 관리할 GitHub Repository를 만드는 과정입니다. GitHub 홈페이지 GitHub에 회원가입 후, 로그인을 합니다. 로그인 후, 우측 상단에 있는 초록색의 New를 눌러줍니다. Repository name에는 GitHub 계정명과 동일한 username을 사용하여 username.github.io로 작성한 후, Create repository 버튼을 누릅니다. 3. Hexo 설치하기 Git을 설치하면,Git Bash가 있으실 겁니다. 1) Git Bash를 실행시킵니다. 2) 터미널 화면에 $를 제외한 부분을 작성하고 Enter를 누르면,Hexo가 설치됩니다.1$ npm install -g hexo-cli 3) 블로그를 만들고 싶은 폴더 위치로 이동합니다. 그 후, 아래 코드를 입력합니다.blog 자리에 자신이 원하는 블로그 이름을 넣습니다.1$ hexo init blog 4) 자신이 원하는 폴더 위치에 blog 이름으로 된 폴더가 생성됩니다.현재 위치에서 블로그 이름으로 된 폴더로 이동합니다.1$ cd blog 5) npm을 설치합니다.1$ npm install 4. Hexo 실행해보기1$ hexo server 로컬서버인 http://localhost:4000로 접속하면, Hexo 블로그가 만들어진 것을 확인할 수 있습니다. Hexo 서버를 종료하려면, Ctrl + C를 눌러줍니다. Tip! 코드를 복사하고 싶은 경우에는 Ctrl + C가 아닌, Ctrl+Ins를 눌러줍니다. 5. Hexo 포스트 작성하기위와 같이 Hexo 설치가 완료되었다면, 이제 포스트를 작성해볼까요? 기본 명령어와 축약 명령어 중에 편하신 명령어를 입력해 줍니다. hexo new나 hexo n 뒤에는 포스트 제목을 적어줍니다. 1234$ hexo new firstpost// 기본 명령어$ hexo n firstpost// 축약 명령어 위의 명령어를 실행하여, firstpost.md라는 마크다운 파일을 생성합니다. 1$ code . 현재 생성된 firstpost.md파일을 Visual Studio Code로 열어줍니다. 위와 같은 디렉토리에 firstpost.md이라는 마크다운 파일이 생성된 것을 확인할 수 있습니다. firstpost.md 파일을 열면, 다음과 같이 작성되어 있습니다. 12345---title: firstpostdate: 2019-01-03 19:42:59tags:--- title은 자동으로 파일명과 똑같이 설정됩니다. 원하는 title로 수정한 후,아래의 ---의 다음 줄부터 마크다운 문법을 이용하여 글을 작성하시면 됩니다. 글 작성시, 실시간으로 포스팅한 모습을 확인하고 싶을 때는 터미널에 아래와 같은 명령어를 입력해줍니다. 1234$ hexo server// 기본 명령어$ hexo s// 축약 명령어 웹 브라우저에서 localhost:4000 경로로 접속하시면, 블로그의 모습을 실시간으로 확인할 수 있습니다. 포스트를 작성한 후, 실제로 서버에 올라갈 정적 페이지를 생성해줍니다. 1234$ hexo generate// 기본 명령어$ hexo g// 축약 명령어 터미널에서 위 코드를 실행하면, blog/public/ 디렉토리 아래에 실제 서버에 올라갈 웹페이지가 생성된 것을 확인할 수 있습니다. 6. GitHub과 Hexo를 연결해주기 로컬 외에 외부에서도 볼 수 있도록 서버에 올립니다. 1) GitHub에 Deploy 해 줄 플러그인을 설치합니다.1$ npm install --save hexo-deployer-git 2) Hexo 설정파일인 _config.yml를 열어서 #URL부분과 #Deployment부분을 수정해 줍니다. #URL부분을 위와 같이 수정해줍니다. #Deployment부분 역시 위와 같이 수정해줍니다. 3) GitHub 서버에 파일 올리기 터미널에서 명령어를 실행하여, GitHub 서버에 블로그 파일을 올려줍니다. 1234$ hexo deployment// 기본 명령어$ hexo d// 축약 명령어 Tip! 정적 페이지 생성과 배포를 함께 하고 싶다면, 아래 코드를 입력해줍니다.1$ hexo g -d 포스트 작성시 참고한 링크 [블로그 프레임워크 Hexo]:https://mechanickim.github.io/2018/03/17/20180317_blog_hexo/index.html [Github pages와 Hexo를 이용하여 블로그 만들기]:http://blog.lattecom.xyz/2016/06/28/hexo-blog-github-pages [GitLab Pages에 Hexo 블로그 설치하기]:http://inote.gitlab.io/2017/GitLab%EC%97%90%EC%84%9C%20Hexo%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0 [Hexo 블로그 만들기 1]:https://wonheesoo.github.io/2018/01/13/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-1-%EC%84%9C%EB%A1%A0-Hexo%EC%99%80-Github-Page-%EC%A1%B0%ED%95%A9%ED%95%98%EA%B8%B0 [Hexo, 정말 쉬운 블로그 프레임워크]:https://m.blog.naver.com/future_creator/220722153999 [Hexo로 Github 블로그 만들기]:https://medium.com/@dongmi.public/why-hexo-67070b1e0cc3 Reference [Hexo 공식 홈페이지 문서(한글)]:https://hexo.io/ko/docs/ [마크다운 문서 작성법]:https://gist.github.com/ihoneymon/652be052a0727ad59601","categories":[{"name":"Tool","slug":"tool","permalink":"https://JihyeHwang09.github.io/categories/tool/"},{"name":"Blog","slug":"tool/blog","permalink":"https://JihyeHwang09.github.io/categories/tool/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/tags/blog/"},{"name":"framework","slug":"framework","permalink":"https://JihyeHwang09.github.io/tags/framework/"},{"name":"platform","slug":"platform","permalink":"https://JihyeHwang09.github.io/tags/platform/"},{"name":"hexo","slug":"hexo","permalink":"https://JihyeHwang09.github.io/tags/hexo/"},{"name":"Static Web Generator","slug":"static-web-generator","permalink":"https://JihyeHwang09.github.io/tags/static-web-generator/"},{"name":"git","slug":"git","permalink":"https://JihyeHwang09.github.io/tags/git/"},{"name":"Node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"정적블로그 플랫폼(Static Web Generator)의 비교","slug":"blog-platform","date":"2019-01-02T08:09:11.680Z","updated":"2020-03-04T14:05:59.281Z","comments":true,"path":"2019/01/02/blog-platform/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/02/blog-platform/","excerpt":"","text":"정적 블로그 플랫폼 설명에 앞서,정적 웹페이지와 동적 웹페이지란 무엇이며 어떤 차이가 있는지를 살펴봅시다. 정적 페이지 VS 동적 페이지정적(static) 페이지 단순히 사이트 관리자가 미리 만들어놓은 웹 페이지를 볼 수 있는 사이트 데이터베이스(DB)를 사용하지 않음 Jekyll, Hexo, Hugo 등 동적(dynamic) 페이지 컨텐츠 내용이 서버에 있는 DB에 저장-&gt; 그 결과가 웹페이지에 반영되는 형태로 동작 일반적인 게시판 형태의 사이트들이 사용하는 방식 티스토리, 네이버 블로그 등 정적블로그 플랫폼(Static Web Generator)의 비교(Jekyll, Hexo, Hugo) Jekyll 특징 Ruby 기반 Github Page에 Git History 충돌 없이 포스트 버전관리 가능 GitHub Page는 Jekyll에 최적화되어 있음 한글 레퍼런스가 가장 많음 현재 가장 많은 사용자를 보유(Github 별 개수가 가장 많음) 단점 Ruby기반으로 초기 구축에 어려움이 있음(Ruby를 모르면, 플러그인 등 커스터마이징 하는데 불편할 수 있음) 윈도우 공식 지원 안됨 컴파일 속도가 느림 Hugo 특징 Golang 기반 컴파일 속도가 빠름(Jekyll, Hexo와 비교시 가장 빠름) 문서화가 잘 되어 있음 단점: 한글 레퍼런스가 거의 없음 Hexo 특징 자바스크립트(Node.js) 기반 Node.js가 설치되어 있어야 하며, 기본적인 npm 사용 방법을 알아야 함 마크다운 문서로 만든 포스팅을 하는 방법이 간단함 윈도우 지원됨 컴파일 속도가 빠름 단점 Git으로 포스트 버전관리가 불가능함-&gt; 버전 관리를 위해서는 두 가지 브랜치를 따서 관리해야 함 Node.js의 템플릿 엔진을 그대로 사용 불가능(Github Page에는 Jekyll이 내장되어 있기 때문) 영어보다는 중국어로 된 질의응답이 많음 결론 앞서 살펴보았듯이 블로그 플랫폼 각각이 장단점을 가지고 있기 때문에우위를 따질 수는 없는 것 같습니다. 다만, 각 플랫폼의 장단점을 고려한 후, 본인에게 맞는 블로그 플랫폼을 선택하시는 게 좋겠죠:) 저는 비교적 익숙한 언어인 JavaScript 기반인 Hexo로 블로그를 시작하고, 차후에 Hugo로 이전을 고려해보는 방향으로 가닥을 잡았습니다. 포스트 작성시 참고한 링크 [정적 웹페이지 vs 동적 웹페이지]: http://snowdeer.github.io/blog/2016/03/21/static-dynamic-webpage [jekyll 블로그 프레임워크 비교, 왜 지킬인가? (feat. jekyll, hexo, hugo)]: https://qvil.github.io/blog/why-jekyll/#what [hugo + github 블로그 만들기 (feat. hugo &amp; github page)]: https://github.com/Integerous/Integerous.github.io [깃헙을 이용하여 호스팅하기]: https://www.slideshare.net/ssuser458523/ss-77033329 [정적 블로그, hexo 설치]: https://engineering.huiseoul.com/%EC%A0%95%EC%A0%81-%EB%B8%94%EB%A1%9C%EA%B7%B8-hexo-%EC%84%A4%EC%B9%98-f8df865a693a [웹의 이해 정적 페이지,동적 페이지 ]: http://coashanee5.blogspot.com/2017/07/blog-post_25.html","categories":[{"name":"Tool","slug":"tool","permalink":"https://JihyeHwang09.github.io/categories/tool/"},{"name":"Blog","slug":"tool/blog","permalink":"https://JihyeHwang09.github.io/categories/tool/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/tags/blog/"},{"name":"framework","slug":"framework","permalink":"https://JihyeHwang09.github.io/tags/framework/"},{"name":"platform","slug":"platform","permalink":"https://JihyeHwang09.github.io/tags/platform/"},{"name":"Jekyll","slug":"jekyll","permalink":"https://JihyeHwang09.github.io/tags/jekyll/"},{"name":"hexo","slug":"hexo","permalink":"https://JihyeHwang09.github.io/tags/hexo/"},{"name":"Hugo","slug":"hugo","permalink":"https://JihyeHwang09.github.io/tags/hugo/"},{"name":"Static Web Generator","slug":"static-web-generator","permalink":"https://JihyeHwang09.github.io/tags/static-web-generator/"}]}]}