{"meta":{"title":"꿈꾸는 지구별 개발자, Phang","subtitle":"꿈꾸는 지구별 개발자, Phang's IT Blog","description":"Phang's IT Blog using Hexo","author":"Phang","url":"https://JihyeHwang09.github.io"},"pages":[],"posts":[{"title":"자바스크립트 1일차","slug":"javascript1","date":"2019-01-13T14:54:55.000Z","updated":"2019-01-13T14:56:08.313Z","comments":true,"path":"2019/01/13/javascript1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/13/javascript1/","excerpt":"","text":"값과 리터럴 값으로 변환될 수 있는 부분을 모두 표현식이라 한다. 변수는 값에 붙이는 이름이다. html의 속성: attribute, javascript의 속성: property 객체 자바스크립트의 객체는 가변 길이이다. 자바스크립트는 자료구조의 유연성이 좋다. 객체의 속성 이름에는 x, ‘x’ 둘 다 쓸 수 있다. 다른 점은 차후에 설명해주실 예정. 속성 값에는 무엇이든 올 수 있다. 객체 안에 객체가 중첩될 수 있다. 123456789const obj = &#123; x: 0, y: &#123; x: 1, y: 2 &#125;&#125;obj.y.x; 대입을 할 때는 = 오른쪽 식이 먼저 실행된다. 1234567let x = 1;x = x + 1;&lt;!-- x += 1;x *= 3;x /= 3; --&gt;console.log(x); delete 연산자: 객체의 속성을 삭제할 수 있다. 객체의 속성을 아예 없애버릴 수 있다.123456789const obj = &#123; x: 0, y: 1&#125;delete obj.x;obj;&lt;!-- &#123;y: 1&#125; 객체의 x속성이 없어짐. --&gt; 메소드 객체 안에 있고, 객체의 속성을 통해서 사용하는 함수를 메소드라고 부른다.12345678910111213141516171819const obj = &#123; x: 0, increaseX: function() &#123; this.x = this.x + 1; &#125;&#125;;const obj = &#123; x: 0, increaseX: function() &#123; this.x = this.x + 1; &lt;!-- this는 자기 자신을 가리키는 키워드. 실행하는 순간, this가 obj로 샤샤샥 바뀜. --&gt; &#125;&#125;;obj.increaseX();&lt;!-- 어떤 객체의 메소드 안에 this가 있으면, 그 this는 '메소드가 호출될 때' 해당 객체를 가리키게 된다. --&gt;console.log(obj.x); 객체와 배열의 차이객체는 속성 이름과 속성값이 연결되어 있다. 순서가 X . 배열은 순서가 있다.배열에 담는 객체는 요소(element) 혹은 항목(item)이라고 부른다. .점을 찍고 호출하는 함수를 메소드라고 한다. push메소드: 배열의 오른쪽 끝에 값을 추가한다. 12345const arr = [1, 2, 3];arr.push(4);arr.push(5);arr.push(6); slice 메소드: 특정 요소부터 한 개 혹은 여러 개의 요소를 지우고 싶을 때 사용ex) .slice(index값, 지우고 싶은 요소의 개수); 언어와 구동 환경 자바스크립트라는 언어와 구동 환경을 나누어서 생각해야 한다. ex) node.js에서는 alert를 쓸 수 X. 자바스크립트 언어, 자바스크립트를 돌릴 수 있는 구동환경에는 어떤 기능이 있는지를 배워야 한다. 프론트엔드 자바스크립트 개발자 vs 백엔드 자바스크립트 개발자 프론트엔드 자바스크립트 개발자는 자바스크립트 언어와 브라우저 구동환경을 배운다. vs 백엔드 자바스크립트 개발자는 자바스크립트 언어와 node.js 구동환경을 배운다. ES2015, 그 이후 ES5 2009년에 나온 자바스크립트 버전. ES2015 = ES6 값과 리터럴 값과 리터럴을 구분할 줄 알아야 한다. 리터럴: 값의 표기법을 말한다. 변수 (Variable) let, const, while, for등 프로그래밍에서 특별한 의미를 지니는 단어들을 키워드라고 부른다. let은 ES6에서 도입된 변수이다. ES6에서는 var를 쓰지 않고, let이나 const를 사용한다. ‘best practice: 좋은 관례’ 이다.(프로그래밍에서 많이 쓰이는 용어) let vs const let은 재대입이 가능. const는 재대입이 불가능한 변수. const는 재대입이 불가능하기 때문에 선언과 대입을 동시에 해줘야 한다. let은 선언, 대입을 따로 해도 된다. const로 변수를 선언할 때는 반드시 선언 시에 값을 대입해주어야 한다. 값 없이 선언만 하게 되면 에러가 발생한다. 또한 추후에 다른 값을 대입할 수 없다. let을 꼭 써야하는 경우가 아니라면, const를 사용하는 것이 좋다. let을 사용하면 의도치 않게 다른 값이 대입되어 버리는 일이 생길 수 있기 때문입니다. 정말로 재대입이 필요한 경우에만 let을 사용하는 것이 좋은 습관입니다. 특정 부분을 확신할 수 있으면 나머지 부분을 작성하기 쉬워지기 때문에 왠만하면 항상 const를 쓰는 습관을 들이는 것이 좋다. token은 프로그래밍에서 문자를 의미한다. Error 정리 SyntaxError: Unexpected token (28:7) 28번째 줄의 7번째 글자에 문법 에러가 있다는 뜻 SyntaxError: Assignment to constant variable: a at 29:0 29번째 줄의 첫번째 글자에 상수 변수에 대입을 했다는 에러가 있다. 12let seven = 7;let seven = 77; SyntaxError: Duplicate declaration “seven” at 33:4 변수 seven은 중복된 선언이라는 에러이다.** 식별자 변수의 이름은 식별자라고 한다. 식별자는 (‘’)없이 속성의 이름으로 이용할 수 있다. 식별자가 되기 위한 규칙들 숫자, 알파벳, 달러 문자($), 언더스코어(_)가 포함될 수 있다. 단, 숫자로 시작되어서는 안 된다. 예약어는 식별자가 될 수 없다. ex) for, while, function 등은 사용할 수 X. 식별자로 쓸 수 없는 단어를 식별자로 사용하고 싶을 때’’로 묶는다. 12345678const obj = &#123; a: 1, '7seven': 7 &lt;!-- 식별자 규칙에 어긋나는 이름을 사용하려고 하므로 ''로 감싸줘야 에러나지 X --&gt;&#125;console.log(obj['7sever']);&lt;!-- 호출할 때도 ['']로 감싸줘야 한다. --&gt; 식별자는 한글로 쓸 수 있지만, 영어로 쓰는 것이 좋다. Camel Case ex) let helloWorldJavaScript 단어의 첫 글자를 소문자, 그 다음 단어부터 첫 글자를 대문자로 쓴다. 자바스크립트에서는 Camel Case로 쓰는 게 예의이고 관례이다. 1234567const one = 1;typeof 1 + 3;&lt;!-- 결과: 'number' + 3; --&gt;&lt;!-- typeof 1에 문자열 3이 붙어서 나온 것임. --&gt;&lt;!-- 연산자 우선순위가 typeof가 +보다 높다. --&gt;&lt;!-- 연산자 우선순위를 다 외우기가 너무 복잡하므로 우선 연산이 되었으면 하는 부분에 ()로 묶어주는 게 좋다. --&gt;typeof (1 + 3); 변수는 가장 첫 글자를 소문자로, 클래스는 첫 글자를 대문자로 쓰는 게 관례이다. number 타입number 타입 리터럴 리터럴이 다르더라도 값은 같을 수 있다. 자바스크립트는 정수와 실수를 별도의 타입으로 다루지 X. 정수와 실수 둘 다 number타입으로 구분하지만, 정수인지 실수인지 판별하기 위해서는 Number.isInteger를 사용한다. Number.isInteger(정수 or 실수); -&gt; 정수이면 true, 실수이면 false를 반환한다. number 타입에 대한 연산12* 2 ** 3; // 거듭제곱(거듭제곱 연산자는 ES2018에 추가됨) cf) 거듭제곱 함수 12Math.pow(2, 3);&lt;!-- 파이썬에서 가져온 함수임. --&gt; 자바스크립트에서 ==보다는 ===를 쓰는 게 더 좋다. 둘 다 되긴 하지만 ===를 쓰는 게 관례다.123451 === '1'&lt;!--결과값: false --&gt;1 == '1' &lt;!-- 결과값: true 타입이 달라도 결과값이 true로 같다고 나오기 때문에 버그가 생기기 쉽다. --&gt; 12345let a = 1;a++; &lt;!-- 1 증가시키기 **전** 값을 표현식의 결과값으로 반환 --&gt;++a;&lt;!-- 1 증가시킨 **후**의 값을 표현식의 결과값으로 반환 --&gt; 1234let b = a++;&lt;!-- b에 증가하기 **전** 값인 1이 저장됨--&gt;let b = ++a;&lt;!-- b에 증가한 **후**의 값인 2가 저장됨--&gt; 연산자 우선순위 ()로 묶으면 우선순위가 가장 높기 때문에 가장 먼저 연산된다. typeof가 덧셈(+)보다 우선순위가 높기 때문에 +먼저 연산된 뒤에 문자열 3이 붙음. ex) typeof 1 + 3; 단항 연산자 ex) +1 다항 연산자 ex) 3 + 2 부동 소수점 (Floating Point) vs 고정 소수점 (Fixed Point) 컴퓨터에서 실수를 다루는 2가지 방식 부동 소수점 vs 고정 소수점 컴퓨터는 소수도 2진수로 저장하기 때문에 10진수 소수를 정확히 다룰 수 없다. 실수를 정확하게 나타내기 위해 사용하는 방법은 고정 소수점이다. 커리큘럼에서는 고정 소수점을 사용하는 라이브러리를 사용하지X. 컴퓨터로 실수를 다룰 때는 조심해야 한다. 컴퓨터는 실수를 정확하게 다룰 수 없기 때문에. number 타입의 특이한 값들NaN NaN은 Not a Number의 약자이다. 계산 불가능한 연산의 결과값을 나타내기 위해 사용한다. parseInt(‘’) 문자열을 숫자로 바꿔주는 함수 parseInt(‘’)에 이상한 문자열을 넣으면 NaN이 결과값으로 나온다. 12parseInt('asdf'); &lt;!--결과값: NaN --&gt; 어떤 값이 Nan인지 아닌지를 알고 싶을 때, ==를 쓰면 절대 X!! ===를 써야 됨. 꼭 기억!! ===는 숫자 비교에 특화되어 있는 연산자이다. “NaN은 숫자가 아니기 때문에, 어떤 숫자와도 같지 않다.”는 규칙이 있다. =&gt; 즉, NaN은 number 타입인 NaN가 같지 X ===NaN이 들어간 식은무조건 어떤 경우에도 false가 나오는 식임.(NaN은 자기자신과도 같지 X 때문에) 이거 때문에 버그 많이 생김. NaN은 JavaScript의 값들 중 유일하게 자기 자신과 같지 않은 값 1234 Number.isNaN(1);&lt;!-- 결과값: false --&gt; Number.isNaN(NaN);&lt;!-- 결과값: true --&gt; 12345678910111213141516171819202122const a = prompt('a: ');const b = prompt('b: ');const parsedA = parseInt(a);const parsedB = parseInt(b);// 이렇게 하면 안 됩니다!!!// if (parsedA === NaN || parsedB === NaN) &#123;// alert('숫자를 입력해주세요')// &#125; else &#123;// alert(parsedA + parsedB)// &#125;// \"NaN은 숫자가 아니기 때문에, 어떤 숫자와도 같지 않다.\" 는 규칙이 있다.// =&gt; 즉, NaN은 number 타입인 NaN과 같지 않다.if (Number.isNaN(parsedA) || Number.isNaN(parsedB)) &#123; alert('숫자를 입력해주세요')&#125; else &#123; alert(parsedA + parsedB)&#125;1 + (2 + 3 + (4 + 5)); evaluate(평가)- 표현식을 값으로 반환하는 절차. 계산과 비슷 -0 자바스크립트의 세계에서 그냥 0과 -0은 다르다. 1234560 === -0; // true// 수의 세계에서 0*-1 한 거는 0이기 때문에 true로 나옴Object.is(0, -0);&lt;!-- 결과값: false. 자바스크립트 세계에서는 0과 -0을 다르게 취급함. --&gt; Object.is(,); 수의 세계에서 같은 지, 다른 지를 판별하는 게 x.자바스크립트 상에서 같은지, 다른지를 판별하는 것이다. 실무에서는 ===을 제일 많이 사용하는 편임!! Infinity 어떤 수가 Infinity인지 아닌지를 판별해야 할 때가 있음. Number.isFinite(): 유한한지 아닌지 판별 값이 유한하면 true, 무한하면 false를 반환함. 1234567if (Number.isNaN(parsedA) || Number.isNaN(parsedB)) &#123; alert('숫자를 입력해주세요')&#125; else if (Number.isFinite(parsedA / parsedB)) &#123; alert(parsedA / parsedB)&#125; else &#123; alert('0으로 나눌 수 없습니다.')&#125; isFinite(‘1’);쓰지 말고, 버전업된 Number.isFinite();를 써라. parseInt, parseFloat parseInt: 문자열 -&gt; 정수 parseFloat: 문자열 -&gt; 실수1parseInt('110', 2); // 6 (문자열 '110'을 2진수로 해석하겠다. 문자열을 2진수로 간주한다.) 되도록 숫자는 숫자랑만 연산한다. 문자열을 숫자로 바꾼 후에 연산한다. 숫자랑 문자열 연산을 하지 않는다. (아주 간단한 문자열끼리 이어붙이기 정도 빼고는) 사용자로부터 입력받은 데이터는 undefined 혹은 문자열일 가능성이 높다. 수와 문자열 계산은 반드시 전부 다 숫자로 안전하게 변환한 뒤에 연산할 것! Math 객체123456789101112131415161718192021Math.floor(-3.6);// 더 작은 숫자인 -4가 됨.Math.trunc(-3.6);// 더 큰 숫자인 -3이 됨.Math.max(1, 2);&lt;!-- 결과값: 2; 들어온 숫자들 중에 제일 큰 숫자를 반환해준다.--&gt;Math.min(1, 2);&lt;!-- 결과값: 1; 들어온 숫자들 중에 제일 작은 숫자를 반환해준다.--&gt;Math.random(); // 0과 1 사이의 값이 임의로 반환됩니다. Math.random() * 10; &lt;!-- 0과 10 사이의 실수를 반환함. 10을 넘을 수 X. --&gt; Math.floor(Math.random() * 10); &lt;!-- 0부터 9까지의 정수가 똑같은 확률로 나오게 만드는 식 --&gt; 주사위 만들기(1-6까지 나옴)12345678910 Math.ceil(Math.random() * 6); Math.floor(Math.random() * 6) + 1;``` * 카드 게임(A, B, C 중에 1장 나오는 게임)```jsconst CARDS = ['A', 'B', 'C'];CARDS[Math.floor(Math.random() * 3)]; number 타입의 메소드 number 타입은 객체가 아니지만, 마치 객체처럼 메소드를 사용할 수 있다. 매개변수 (parameter) 코드를 실행하다가 return을 만나면 실행 흐름을 종료시킨다. 1234567891011121314151617function evenOrOdd(x) &#123; // 만약 x가 짝수면 'x: 짝수' 라고 출력 if (x%2 === 0) &#123; console.log(x + ': 짝수'); &#125; else &#123; console.log(`$&#123;x&#125;: 홀수`); &#125; // 아니면 'x: 홀수'라고 출력 &#125;for (let i = 0; i &lt; 20; i++) &#123; evenOrOdd(i + 1);&#125;`$&#123;&#125;` 사이에 어떤 값을 집어넣을 수 있다.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"javaScript","slug":"front-end/javascript","permalink":"https://JihyeHwang09.github.io/categories/front-end/javascript/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"}]},{"title":"CSS 상속","slug":"css-inheritance","date":"2019-01-12T14:31:47.000Z","updated":"2019-01-12T14:54:24.400Z","comments":true,"path":"2019/01/12/css-inheritance/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/12/css-inheritance/","excerpt":"","text":"CSS 상속(Inheritance)과 케스케이드(Cascade)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. CSS 상속 (Inheritance) 상속되는 속성 (글자색, 글자 디자인에 관련된 것) color: 글자 색상 (배경색은 상속되지 X) font-size: 글자 크기 font-family: 글자의 모양(글꼴) letter-spacing: 자간 상속되지 않는 속성 (공간에 관련된 것) outline: 외곽 테두리선 margin: 외곽 영역의 공간 border: 테두리 padding: 테두리 안쪽의 공간 CSS 케스케이드(Cascade) 케스케이딩(Cascading)이란? cascading: The process of combining several style sheetsand resolving conflicts between them. Håkon Wium Lie (CSS 공동 창시자)는 CSS에 관한PHD 논문에서“여러 스타일 시트를 결합하고 이들 사이의충돌을 해결하는 프로세스”라는 용어로 “Cascade”를말하고 있다. https://www.wiumlie.no/2006/phd/ CSS(Cascading Style Sheets )는 캐스케이드 개념이중요하다는 것을 약어에서 강조. 가장 기본적인 수준에서는규칙 순서가 중요하지만 그보다 더 복잡하다는 것을 말한다. 중요성 (Importance)!important 선언은 다른 모든 선언보다 우선권을 가진다. [NOTE]!important가 적용된 속성을 덮어 쓰려면, 다시 !important를사용해야 하기에 최대한(절대!!) 사용하지 않도록 노력해야 한다. 특성 (Specificity)선택자의 우선권에 대한 척도.각 척도를 1, 10, 100, 1000 단위로생각하면 이해하기 좋다. 요소 선택자 &lt; 클래스 선택자 &lt; ID 선택자 &lt; 인라인 스타일0,0,0,1 0,0,1,0 0,1,0,0 1,0,0,0 [NOTE]*, &gt;, +, ~ 등 콤비네이터(Combinators),:not() 가상 클래스는 특성에 영향을 주지 X! [예시]* – 0000 a – 0001 (a요소는 요소선택자이기 때문에 1점) a.link – 0011 (a요소: 1점 + link라는 이름의 클래스니까 10점) li:nth-child(2) a:hover – 0022 (li요소: 1점 + a요소: 1점 + li:nth-child(2)는 가상클래스이다.가상클래스도 클래스이기 때문에 10점 + :hover도 가상클래스이기 떄문에 10점) .nav:nth-child(2) a:hover – 0031 .nav: 실제 클래스 10점 + v:nth-child(2): 가상클래스 10점 + :hover 10점 + a요소 1점) #outer a – 0101 (#outer: id선택자 100점 + a요소: 1점) #outer #inner a – 0201 (#outer: id선택자 100점 + #inner: id선택자 100점 + a요소: 1점 ) style=&quot;color: tan&quot; – 1000 (inline 스타일 시트: 1000점) !important(inline 스타일 시트도 무력화 시키는 게 !important이다.!important를 쓰면 함께 지옥에 가는 것임. 안 쓰는 게 좋다!! 최대한 쓰지 않도록! ) 소스 코드의 순서: 중요성, 특성이 설정되지 않았거나 동일한 경우나중에 나온 소스의 스타일이 우선권을 가진다. [예시] 1234567891011121314151617p &#123; color: #930212; &#125;p &#123; color: #d5727e; &#125;/* 우선권을 가진다. */p.note &#123; color: #930212; &#125;/* note라는 클래스 10점 + p요소 1점= 11점이 되므로 -&gt; 우선권을 가진다. */p &#123; color: #d5727e; &#125;p.note &#123; color: #930212; &#125;/* .note 클래스: 10점 + p요소: 1점 = 11점 */#target p &#123; color: #d5727e; &#125; /* #target: id선택자 100점 + p요소 1점 = 101점 *//* 우선권을 가진다. */&lt;p style=\"color: maroon\"&gt; /* inline 스타일은 1000점 */ 가장 약한 점수를 가지고 있다고 해도 !important flag를 꽂게 되면,!important가 우선하게 된다. html 파일 요소에 직접 스타일링 하는 것이다. (inline 스타일)","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"css","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"css","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"상속","slug":"상속","permalink":"https://JihyeHwang09.github.io/tags/상속/"},{"name":"inheritance","slug":"inheritance","permalink":"https://JihyeHwang09.github.io/tags/inheritance/"}]},{"title":"CSS 선택자(Selectors)","slug":"css selectors","date":"2019-01-11T14:30:19.000Z","updated":"2019-01-12T14:54:25.837Z","comments":true,"path":"2019/01/11/css selectors/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/11/css selectors/","excerpt":"","text":"CSS 선택자(Selectors)에 대해 알아봅시다. 본 포스팅은 &lt; 패스트캠퍼스 야무 강사님의 프론트엔드 개발 시작하기 CAMP &gt; 강의 내용을 정리한 것임을 알려드립니다. 선택자는 CSS뿐만 아니라 자바스크립트에서도 유용하게 사용될 수 있다. CSS는 HTML 요소를 선택하는데 있어 다양한 선택자 옵션을 제공한다. selector(대상) {property(속성):value(값)} 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; h1 &#123;font-size: 100%&#125; /* Element Type Selector */ a &#123;text-decoration:none&#125; img &#123;border: 0&#125; &lt;/style&gt;&lt;/head&gt; 123456789&lt;head&gt; &lt;style type=\"text/css\"&gt; h1, h2, h3, h4, h5,h6&#123;font-wieght: normal&#125; /* Grouping: 여러 개의 요소(태그 선택자)를 일괄적으로 묶어주고, 일괄적으로 디자인해주는 것 */ a, img, p &#123;border:none&#125; h3 span, h4 span&#123;position:fixed:left:-2em&#125; &lt;/style&gt;&lt;/head&gt; 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; * &#123;margin:0:padding:0&#125;; /* Universal Selector(전체 선택자): HTML에 존재하는 모든 요소에 일괄적으로 스타일링 주고자 할 때*/ html body * &#123;text-decoration:none&#125; p.declation * &#123;text-transform:capitalize&#125; &lt;/style&gt;&lt;/head&gt; 12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; p.note&#123;&#125; /* Class Selector(클래스 선택자) */ .floatLeft&#123;&#125; .positionAbs&#123;&#125; &lt;/style&gt;&lt;/head&gt; 12345678910&lt;head&gt; &lt;style type=\"text/css\"&gt; p.note.floatLeft&#123;&#125; /* Multi Class Selector(말 그대로 여러 개의 클래스가 붙은 선택자) 단락 요소(p)가 note라는 클래스와 floatLeft라는 클래스를 둘 다 가질 때 .note와 .floatLeft 사이에 띄면 X! */ .section.article&#123;&#125; .positionAbs&#123;&#125; &lt;/style&gt;&lt;/head&gt; 123456789&lt;head&gt; &lt;style type=\"text/css\"&gt; ul#nav&#123;&#125; /* ID Selector(아이디 선택자) Hash(#)값을 통해서 아이디를 선택하게 된다.*/ div#figure&#123;&#125; #site_info&#123;&#125; &lt;/style&gt;&lt;/head&gt; 123456789101112&lt;head&gt; &lt;style type=\"text/css\"&gt; p strong&#123;&#125; /* Descendant Selector */ /* '단락 내부에 있는 strong을 찾아서 꾸며주세요~'라는 뜻 */ ul li a &#123;&#125; /* 비순차 목록인 ul 내부의 li 요소를 찾은 다음에 a 요소 결국 꾸며지는 건 ul도 X, li도 X!! a요소를 최종적으로 찾은 다음에 꾸민다. 맨 마지막에 나오는 요소를 꾸민다. */ h3 span &#123;&#125; &lt;/style&gt;&lt;/head&gt; CSS 선택자(Selector) 요소 선택자 (Element Type Selector)figure { … } 그룹핑 (Grouping)a, abbr, .note, #about-css { … } -&gt; class도 묶어 줄 수 있다. 전체 선택자 (Universal Selector) { … } -&gt;*를 사용해서 모든 요소를 선택할 때 쓴다. 특정 영역 내에 있는 모든 요소를 선택할 때도 쓸 수 있다.ex) #about-css * {} -&gt; id가 about-css 속성값을 가진 내부의 모든 요소를 가리키게 된다.section이라든가 body는 포함되지 X. 클래스 선택자 (Class Selector) 대소문자 구분하기 때문에 반드시 확인해야 한다..class { … } 멀티 클래스 선택자 (Multi Class Selector)&lt;비교&gt; 띄어쓰기에 따라 의미가 완전히 달라진다..class1.class2 { … }: 하나의 요소가 2개의 클래스를 가진 형태 (멀티 클래스 선택자).class1. class2 { … }: class1을 가진 요소가 내부에 class2를 가지고 있을 때 쓴다. (자손 선택자) ex) .note.box {} -&gt;note라는 클래스 가진 요소 중에 box라는 클래스를 가지고 있다면, note와 box 클래스 2개가 모두 가지고 있다면~ 아이디 선택자 (ID Seletor): id값이 동일한 대상을 찾는다.#id { … }ex) #about-css {} -&gt; id가 about-css인 요소에 적용한다. 자손 선택자 (Descendent Selector): 클래스 or 아이디를 이용해서 꾸밀 수 있다.h1 abbr { … } -&gt; ‘h1이 포함한 abbr을 찾아서 꾸며주세요~’ 라는 뜻.note abbr { … } 자식 선택자 (Descendent Selector): 부모의 직접적인 자식만 나타낸다..parent &gt; .child { … } 자손 선택자 vs 자식 선택자 자손 선택자: ex) 아들, 손주 자식 선택자: 직계 자식만 선택할 수 있음. ex) 아들 123456ex1) &lt;h1&gt; &lt;strong&gt; &lt;strong&gt; &lt;abbr&gt; h1의 자손 선택자: &lt;strong&gt;, &lt;strong&gt;, &lt;abbr&gt; h1의 자식 선택자: 바로 밑의 &lt;strong&gt;만 해당 됨. 123ex2) body * &#123;&#125; : body 요소 내부의 모든 자손 선택 body &gt; * &#123;&#125; : body 요소 내부의 모든 자식(Child) 선택 속성 선택자 (Attribute Selector): 속성 선택자[] 앞에 아무것도 붙어있지 않다면. *가 생략되어 있다고 보면 된다. [id] { … } -&gt; id 속성을 가지고 있다면~ex)a[id] { … } -&gt; a요소가 id 속성값을 가지고 있다면~ [class] { … }[title] { … }[shape] { … } [shape][title]{ … } -&gt; shape과 title 속성을 둘 다 가지고 있다면~ [class=”note box”] { … } -&gt; 정확하게 “note box”라는 이름의 클래스를 찾기 때문에클래스명이 “box note”일 경우에는 찾을 수 X. -&gt; class의 경우에는.box {}.note {}가 좀 더 유연하게 사용할 수 있다. [id=”about-css] { … } -&gt; id값이 about-css라면~ 해당 요소를 선택해서 꾸며주게 된다.이걸 쉽게 쓰라고 만들어진 표현법이 hash(#) 표현법이다. #about-css { … } [class=”note”] { … }.note { … } ^=&quot;&quot;: ~로 시작하는 것ex)[title^=”Scalable”] { … } -&gt; title 요소 중, “”안의 Scalable이라는 단어로 시작하는 것을 모두 찾고 싶을 때 $=&quot;&quot;: ~로 끝나는 것ex)[title$=”Language”] { … } -&gt; title 요소 중, “”안의 Language이라는 단어로 끝나는 것을 모두 찾고 싶을 때 *=&quot;&quot;: ~를 포함하는 것ex)[title*=”Markup”] { … } -&gt; title 요소 중, “”안의 Markup이라는 단어를 포함하는 것을 모두 찾고 싶을 때 -&gt; CSS는 완벽하게 대소문자를 구분하기 때문에 “Markup”과 “markup”을 다르게 받아들인다. [href^=”http://“] { … } -&gt; href 속성값이 ^로 시작한다면, 속성값이 “http://“로 (“”안의 단어로) 꼭 시작해야 한다. [src$=”.svg”] { … } -&gt; .svg는 확장자임(‘.’으로 시작하므로) 확장자가 svg인 파일들을 이미지로 불러오는 모든 요소들을 찾게되는 것이다. [src*=”phone”] { … } -&gt; src에 포함된 단어 중에 “phone”이 들어간 걸 모두 찾아온다. 고급 속성 선택자 가상 클래스 선택자(Link Pseudo-class)a:link, a:visited{}anchor element가 기본적으로 가지고 있는 상태는 link element이다.1번 이상 방문한 사이트는 표시가 되어야 한다. -&gt; visited 방문했다는 가상클래스를 사용할 수 있다. a:hover, a:active{}hover: 마우스가 올라간 상태active: 마우스로 클릭한 순간 -&gt; 마우스 클릭한 걸 떼게 되면 active가 해제되는 것임 p:hover{} input:focus -&gt; focus가 된 상태input:focus:hover -&gt; focus가 된 상태에서 마우스가 올라가면(hover)~ [가상 클래스(Pseudo Class)] :link { … }:visited { … } :hover { … } hover는 마우스에 의존하는 속성:active { … } :focus { … }:focus:hover { … } -&gt; keyboard에 focusing이 간 상태에서 마우스가 올라가게 되면, 디자인이 변경된다. :focus:active { … } -&gt; focus가 된 후에 클릭이 될 때 디자인이 변경된다. 가상 클래스는 연이어서 사용할 수 있다. :first-child { … } :first-child는 :nth-child(1)과 같다. :last-child { … } 자식이 4개 라면 -&gt; last-child와 nth-child(4)와 같다.:nth-child(n) { … }()안에는 공식이 사용될 수 있다.1st2nd3rd4th5th…nth ex)link-list last-child(2n-1) {}link-list last-child(odd) {} 홀수 번째link-list last-child(2n) {}link-list last-child(even) {}짝수 번째CSS에서는 단축해서 홀수는 (odd),(even)을 사용한다.link-list last-child(3n) {}3의 배수 번째에만 :lang(ko) { … } ex) 디자인 상에서 한글과 영문은 각기 다른 디자인을 적용해달라는 요구가 있을 수 있음. 그 나라의 언어에 맞게 폰트를 변경할 떄 가상클래스를 사용하면 된다. :lang(en) {font-family: “Times New Roman”; &lt;!– 명조계열체 - -&gt;}:lang(ko-KR) {font-family: “Spoqa Han Sans”;&lt;!– 고딕계열체 - -&gt;} 가상 요소(Pseudo Element): 가상 클래스와는 다르다.: 1개 사용 -&gt; 가상 클래스vs :: 2개 사용 -&gt; 가상 요소::first-letter { … }::first-line { … }::before { … }::after { … }","categories":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/categories/front-end/"},{"name":"css","slug":"front-end/css","permalink":"https://JihyeHwang09.github.io/categories/front-end/css/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"css","slug":"css","permalink":"https://JihyeHwang09.github.io/tags/css/"},{"name":"선택자","slug":"선택자","permalink":"https://JihyeHwang09.github.io/tags/선택자/"},{"name":"selector","slug":"selector","permalink":"https://JihyeHwang09.github.io/tags/selector/"}]},{"title":"interview","slug":"interview","date":"2019-01-10T14:13:52.000Z","updated":"2019-01-10T14:17:54.594Z","comments":true,"path":"2019/01/10/interview/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/10/interview/","excerpt":"","text":"이번에는 프론트엔드 개발자가 면접에서 만날 수 있는 질문들에 대해 정리해봅시다.","categories":[{"name":"취업","slug":"취업","permalink":"https://JihyeHwang09.github.io/categories/취업/"},{"name":"면접","slug":"취업/면접","permalink":"https://JihyeHwang09.github.io/categories/취업/면접/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"https://JihyeHwang09.github.io/tags/front-end/"},{"name":"javaScript","slug":"javascript","permalink":"https://JihyeHwang09.github.io/tags/javascript/"},{"name":"interview","slug":"interview","permalink":"https://JihyeHwang09.github.io/tags/interview/"}]},{"title":"순환(Recursion)의 개념과 기본 예제3","slug":"recursion3","date":"2019-01-09T02:42:47.788Z","updated":"2019-01-09T07:07:38.857Z","comments":true,"path":"2019/01/09/recursion3/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/09/recursion3/","excerpt":"","text":"이번에는 지난 포스트에 이어서, 순환적 알고리즘 설계 방법에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌자료를 인용하였음을 알려드립니다. 순환적 알고리즘 설계적어도 하나의 base case, 즉 순환되지 않고 종료되는 case가 있어야 함 모든 case는 결국 base case로 수렴해야 함 암시적(implicit) 매개변수를 명시적(explicit) 매개변수로 바꾸어라. 순차 탐색 이 함수의 미션은 data[0]에서 data[n-1] 사이에서 target을 검색하는 것이다. 하지만, 검색 구간의 시작 인덱스 0은 보통 생략한다. -&gt; 즉, 암시적 매개변수이다. 이 함수는 시작 위치는 0으로 암시, 끝 위치는 명시되어 있다. 12345678910// \"배열의 데이터가 n개이니까 당연히 인덱스 0부터 시작하겠지.\"라고// 암묵적으로 동의한 것이므로 생략됨// 배열의 시작지점이 명시적으로 0이라고 표현되어 있지 Xint search(int [] data, int n, int target) &#123; for (int i = 0; i &lt; n; i++) &#123; if (data[i] == target) return i; &#125; return -1;&#125; 매개변수의 명시화: 순차 탐색 이 함수의 미션은 data[begin]에서 data[end] 사이에서 target을 검색한다. 즉, 검색구간의 시작점을 명시적(explicit)으로 지정한다. 시작 위치가 begin으로 명시, 끝 위치는 end로 명시되어 있다. 이 함수를 search(data, 0, n-1, target)으로 호출한다면, 위의 순차 탐색에서 예시로 든 search함수와 완전히 동일한 일을 한다. 1234567891011int search(int [] data, int begin, int end, int target) &#123; // begin &gt; end이면, 데이터가 0개이다. if (begin &gt; end) &#123; return -1; // begin = end는 데이터가 1개라는 뜻&#125; else if (target == data[begin]) &#123; // end를 찾을 필요 없이 begin을 return한다. return begin;&#125; else if &#123; return search(data, begin + 1, end, target);&#125; 순차 탐색: 다른 버전 이 함수의 미션은 data[begin]에서 data[end] 사이에서 target을 검색한다. 즉, 검색구간의 시작점을 명시적(explicit)으로 지정한다. 예제1123456789int search(int [] data, int begin, int end, int target) &#123; if (begin &gt; end) &#123; return -1; &#125; else if (target == items[end]) &#123; return end; &#125; else &#123; return search(data, begin, end-1, target); &#125;&#125; 예제212345678910111213141516int search(int [] data, int begin, int end, int target) &#123; if (begin &gt; end) &#123; return -1; &#125; else &#123; int middel = (begin + end) / 2; if (data[middle] == target) &#123; return middle; &#125; int index = search(data, begin, middle - 1, target); if (index != -1) &#123; return index; &#125; else &#123; return search(data, middle + 1, end, target); &#125; &#125;&#125; 매개변수의 명시화: 최대값 찾기 이 함수의 미션은 data[begin]에서 data[end] 사이에서 최대값을 찾아 반환한다. begin &lt;= end라고 가정한다. 12345678910int findMax(int [] data, int begin, int end) &#123; // base case: 데이터가 0개 일 경우가 X. 1개일 경우이다. // 데이터가 0개일 경우, 최대값이 정의되지 X 때문이다. // begin = end일 경우, 데이터가 1개이다. if (begin == end) &#123; return data[begin]; &#125; else &#123; return Math.max(data[begin], findMax(data, begin + 1, end)); &#125;&#125; 최대값 찾기: 다른 버전12345678910int findMax(int [] data, int begin, int end) &#123; if (begin == end) &#123; return data[begin]; &#125; else &#123; int middle = (begin + end) / 2; int max1 = findMax(data, begin, middle); int max2 = findMax(data, middle + 1, end); return Math.max(max1, max2); &#125;&#125; 이진 탐색(Binary Search) items[begin]부터 items[end] 사이에서 target을 검색한다. 12345678910111213141516171819202122public static int binarySearch(String[] items,String target, int begin, int end) &#123; // base case: 데이터의 개수가 0일 경우 if (begin &gt; end) &#123; return -1; &#125; else &#123; int middle = (begin + end) / 2; // Java에서 문자열끼리의 비교는 compareTo() 메서드를 이용한다. // cf) s1.compareTo(s2) 메서드는 문자열의 사전적 값을 비교 // s1 &lt; s2일 경우, 음의 정수를 반환 // s1 == s2일 경우, 0을 반환 // s1 &gt; s2일 경우, 양의 정수를 반환 int compResult = target.compareTo(items[middle]); if (comResult == 0) &#123; return middle; &#125; else if (compResult &lt; 0) &#123; return binarySearch(items, target, begin, middle -1); &#125; else &#123; return binarySearch(items, target, middle + 1, end); &#125; &#125;&#125;","categories":[{"name":"컴퓨터 과학(Computer Science)","slug":"컴퓨터-과학-computer-science","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학-computer-science/"},{"name":"알고리즘(Algorithms)","slug":"컴퓨터-과학-computer-science/알고리즘-algorithms","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학-computer-science/알고리즘-algorithms/"}],"tags":[{"name":"순환 함수","slug":"순환-함수","permalink":"https://JihyeHwang09.github.io/tags/순환-함수/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"순환적 알고리즘 설계","slug":"순환적-알고리즘-설계","permalink":"https://JihyeHwang09.github.io/tags/순환적-알고리즘-설계/"},{"name":"명시적 매개변수","slug":"명시적-매개변수","permalink":"https://JihyeHwang09.github.io/tags/명시적-매개변수/"},{"name":"explicit","slug":"explicit","permalink":"https://JihyeHwang09.github.io/tags/explicit/"},{"name":"순차 탐색","slug":"순차-탐색","permalink":"https://JihyeHwang09.github.io/tags/순차-탐색/"},{"name":"최대값 찾기","slug":"최대값-찾기","permalink":"https://JihyeHwang09.github.io/tags/최대값-찾기/"},{"name":"이진 탐색","slug":"이진-탐색","permalink":"https://JihyeHwang09.github.io/tags/이진-탐색/"},{"name":"Binary Search","slug":"binary-search","permalink":"https://JihyeHwang09.github.io/tags/binary-search/"}]},{"title":"순환(Recursion)의 개념과 기본 예제2","slug":"recursion2","date":"2019-01-08T10:16:09.508Z","updated":"2019-01-08T14:43:51.262Z","comments":true,"path":"2019/01/08/recursion2/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/08/recursion2/","excerpt":"","text":"이번에는 지난 포스트에 이어서, 순환적으로 사고하기와 문자열의 길이 계산, 배열의 합 등의 예제에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 순환적으로 사고하기(Recursive Thinking)Recursion은 수학함수 계산에만 유용한가? 수학함수 뿐 아니라 다른 많은 문제들을 recursion으로 해결할 수 있다. 문자열의 길이 계산 문자열의 길이를 계산하고 싶다면, 첫 번째 문자열을 뺀 나머지 문자열의 길이를 계산 1을 더하면 된다. 12345678// base case: 문자열의 길이가 0인 경우// -&gt; 첫 번째 문자열이 존재하지 Xif the string is empty return 0;// 첫 번째 문자열을 제거한 그 문자열의 길이를 계산한 다음, 1을 더한다.else return 1 plus the length of the string that excludes the first character; 1234567int length(char *str) &#123; if (*str == '\\0') &#123; return 0; &#125; else &#123; return 1 + length(str + 1); &#125;&#125; 12345678910111213141516171819// 문자열 str을 입력받아 길이를 계산하는 메서드 lengthpublic static int length(String str) &#123; // base case: 문자열의 길이가 0인 문자열과 동일하다면 // -&gt; 즉, 문자열의 길이가 0라면 if (str.equals(\"\")) &#123; return 0; &#125; else &#123; // Java에서 substring(n)은 // index값이 n보다 작은(앞에 있는) 문자열을 제거한 문자열을 반환한다. // str.substring(1)은 // str에서 index값이 1인 위치 이후부터의 문자열을 가져온다. // -&gt; 즉, 입력받은 str에서 // index값이 0인 첫 글자를 제외한 문자열을 반환한다. // 1 + length(str.substring(1))는 그것의 길이를 계산한 다음, // 1을 더해서 반환한다. return 1 + length(str.substring(1)); &#125;&#125; 문자열의 프린트123456789101112// 입력한 하나의 문자열을 출력하는 메서드 printCharspublic static void printChars(String str) &#123; if (str.length() == 0) &#123; return; &#125; else &#123; // 문자열의 첫 글자를 화면에 출력한다. // Java에서 str.charAt(n)은 인덱스 n의 위치에 해당되는 문자를 추출해준다. System.out.print(str.charAt(0)); // 첫 글자를 제외한 나머지 문자열을 화면에 출력한다. printChars(str.substring(1)); &#125;&#125; 문자열을 뒤집어 프린트 이 문자열을 뒤집어 프린트하려면, 먼저 첫 글자를 제외한 문자열을 뒤집어 프린트 한다. 마지막으로, 첫 글자를 프린트 한다. 123456789101112public static void printCharsReverse(String str) &#123; // base case: 입력된 문자열 str의 길이가 0라면, 아무 일도 일어나지 X if (str.length() == 0) return; // 문자열의 길이가 1 이상이라면, else &#123; // 1. 먼저 첫 글자를 제거한 문자열을 화면에 뒤집어서 출력한다. printCharsReverse(str.substring(1)); // 2. 마지막으로, 원래 문자열의 첫 글자를 화면에 출력한다. System.out.print(str.charAt(0)); &#125;&#125; 2진수로 변환하여 출력12345678910111213// 음이 아닌 정수 n을 이진수로 변환하여 출력한다.public void printInBinary(int n) &#123; if (n &lt; 2) &#123; System.out.print(n); &#125; else &#123; // n을 2로 나눈 몫을 먼저 2진수로 변환하여 출력한다. // 마지막 비트를 제외한 나머지 비트가 표현하는 숫자이다. printInBinary(n/2); // n을 2로 나눈 나머지를 출력한다. // 마지막 비트를 표현하는 숫자이다. System.out.print(n%2); &#125;&#125; 배열의 합 구하기1234567891011121314// n개인 data의 합 구하기// data[0]에서 data[n-1]까지의 합을 구하여 반환한다.public static int sum(int n, int[] data) &#123; if (n &lt;= 0) return 0; else //sum(n-1, data) 을 호출하면, // data[0]에서 data[n-2]까지 데이터의 합을 구한다. // 그 후, 마지막 데이터인 data[n-1]을 더해준다. // recursion이 1씩 줄어들다가 0이 될 때, 빠져나온다. // -&gt; 무한루프에 빠질 일이 X return sum(n-1, data) + data[n-1];&#125; 데이터 파일로부터 n개의 정수 읽어오기실제로 자주 쓰는 코드 형태는 Xrecursion 예제로만 참고 123456789101112131415// Scanner in이 참조하는 파일로부터 n개의 정수를 입력받아// 배열 data의 data[0], ..., data[n-1]에 저장한다.public void readFrom(int n, int [] data, Scanner in) &#123; // base case: n이 0일 때는 아무것도 하지 X if (n == 0) &#123; return; &#125; else &#123; // 1. n-1개의 데이터를 읽어온다. // -&gt; data[0], ..., data[n-2]에 저장한다. readFrom(n-1, data, in); // 2. 마지막 한 개의 데이터를 읽어온다. // -&gt; 읽어온 데이터를 data[n-1]에 저장한다. data[n-1] = in.nextInt(); &#125;&#125; Recursion vs Interation 모든 순환함수는 반복문(interation)으로 변경 가능 그 역도 성립함. 즉, 모든 반복문은 순환함수(recursion)으로 표현 가능함 순환함수는 복잡한 알고리즘을 단순하고 알기쉽게 표현하는 것을 가능하게 함 하지만, 함수 호출에 따른 오버헤드가 있음(매개변수 전달, 액티베이션 프레임 생성 등)","categories":[{"name":"컴퓨터 과학(Computer Science)","slug":"컴퓨터-과학-computer-science","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학-computer-science/"},{"name":"알고리즘(Algorithms)","slug":"컴퓨터-과학-computer-science/알고리즘-algorithms","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학-computer-science/알고리즘-algorithms/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"Computer Science","slug":"computer-science","permalink":"https://JihyeHwang09.github.io/tags/computer-science/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://JihyeHwang09.github.io/tags/알고리즘/"},{"name":"Algorithms","slug":"algorithms","permalink":"https://JihyeHwang09.github.io/tags/algorithms/"},{"name":"순환 함수","slug":"순환-함수","permalink":"https://JihyeHwang09.github.io/tags/순환-함수/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"Recursion Function","slug":"recursion-function","permalink":"https://JihyeHwang09.github.io/tags/recursion-function/"},{"name":"수학적 귀납법","slug":"수학적-귀납법","permalink":"https://JihyeHwang09.github.io/tags/수학적-귀납법/"},{"name":"Mathematical Induction","slug":"mathematical-induction","permalink":"https://JihyeHwang09.github.io/tags/mathematical-induction/"},{"name":"Interation","slug":"interation","permalink":"https://JihyeHwang09.github.io/tags/interation/"}]},{"title":"순환(Recursion)의 개념과 기본 예제1","slug":"recursion1","date":"2019-01-07T08:51:43.427Z","updated":"2019-01-07T10:40:34.898Z","comments":true,"path":"2019/01/07/recursion1/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/07/recursion1/","excerpt":"","text":"순환 함수란 무엇이며, 무한 루프에 빠지지 않으려면 어떤 경우가 존재해야 하는지 그리고 수학적 귀납법에 대해 알아봅시다. 본 포스팅은&lt;인프런 - 권오흠 강사님의 영리한 프로그래밍을 위한 알고리즘 강좌 &gt; 자료를 인용하였음을 알려드립니다. 순환이란? recursion은 항상 무한루프에 빠질까? 12345678910111213// 1 ~ n까지의 합을 구한다.int main() &#123; int result = func(4);&#125;int func(int n) &#123; if (n == 0) &#123; return 0; &#125; else &#123; return n + func(n-1); &#125;&#125; 무한루프에 빠지지 않으려면? &amp; recursion의 해석123456789101112// 이 함수의 mission은 0 ~ n까지의 합을 구하는 것이다.int func(int n) &#123; // Base case: 적어도 하나의 recursion에 빠지지 않는 경우가 존재해야 한다. // n = 0이라면, 합은 0이다. if (n == 0) return 0; else // Recursive case: recursion을 반복하다보면 결국 base case로 수렴해야 한다. // n이 0보다 크다면, // 0에서 n까지의 합은 0에서 n-1까지의 합에 n을 더한 것이다. return n + func(n-1);&#125; 순환함수와 수학적 귀납법정리: func(int n)은 음이 아닌 정수 n에 대해서 0에서 n까지의 합을 올바르게 계산한다.증명: n=0인 경우: n=0인 경우 0을 반환한다. 올바르다. 임의의 양의 정수 k에 대해서 n &lt; k인 경우, 0에서 n까지의 합을 올바르게 계산하여 반환한다고 가정하자. n = k인 경우를 고려해보자. func은 먼저 func(k-1) 호출하는데 2번의 가정에 의해서0에서 k-1까지의 합을 올바르게 계산하여 반환한다.메서드 func은 그 값에 n을 더해서 반환한다.따라서 메서드 func는 0에서 k까지의 합을 올바로 계산하여 반환한다. 12345678910111213141516171819package lec00.algorithm;public class Alg02 &#123; public static void main(String[] args) &#123; int n = 4; func(n); &#125; public static void func(int k) &#123; if (k &lt;= 0) return;// Base case: 적어도 하나의 recursion에 빠지지 않는 경우가 존재해야 한다. else &#123; System.out.println(\"Hello...\"); func(k-1);// Recursive case: recursion을 반복하다보면 결국 base case로 수렴해야 한다. &#125; &#125;&#125;// recursion이 항상 무한루프에 빠지는 것은 아니다. 123456789101112131415161718192021222324252627282930package lec00.algorithm;// 1 ~ n까지의 합을 구한다.public class Alg03 &#123; public static void main(String[] args) &#123; int result = func(4); System.out.println(result); &#125; public static int func(int n) &#123; if(n &lt;= 0) return 0; else &#123; return n + func(n-1); &#125; /* public static int func(int n) &#123;// 이 함수의 mission은 0~n까지의 합을 구하는 것이다. if (n == 0) return 0;// n=0이라면 합은 0이다. else return n + func(n-1);// n이 0보다 크다면 0에서 n까지의 합은// 0에서 n-1까지의 합에 n을 더한 것이다.&#125;*/ &#125;&#125; Factorial: n! 12345678int factorial(int n)&#123; if (n == 0) &#123; return 1; &#125; else &#123; return n* factorial(n-1); &#125;&#125; 정리: factorial(int n)은 음이 아닌 정수 n에 대해서 n!을 올바르게 계산한다.증명: n = 0인 경우: n=0인 경우 1을 반환한다. 올바르다. 임의의 양의 정수 k에 대해서 n &lt; k인 경우 n!을 올바르게 계산한다고 가정하자. n = k인 경우를 고려해보자. factorial은 먼저 factorial(k-1) 호출하는데 2번의 가정에 의해서 (k-1)!을 올바르게 계산하여 반환한다. 따라서 메서드 factorial은 k \\* (k-1)! = k!을 반환한다. 123456public static int factorial(int n)&#123; if (n == 0) return 1; else return n * factorial(n-1);","categories":[{"name":"컴퓨터 과학(Computer Science)","slug":"컴퓨터-과학-computer-science","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학-computer-science/"},{"name":"알고리즘(Algorithms)","slug":"컴퓨터-과학-computer-science/알고리즘-algorithms","permalink":"https://JihyeHwang09.github.io/categories/컴퓨터-과학-computer-science/알고리즘-algorithms/"}],"tags":[{"name":"컴퓨터 과학","slug":"컴퓨터-과학","permalink":"https://JihyeHwang09.github.io/tags/컴퓨터-과학/"},{"name":"Computer Science","slug":"computer-science","permalink":"https://JihyeHwang09.github.io/tags/computer-science/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://JihyeHwang09.github.io/tags/알고리즘/"},{"name":"Algorithms","slug":"algorithms","permalink":"https://JihyeHwang09.github.io/tags/algorithms/"},{"name":"순환 함수","slug":"순환-함수","permalink":"https://JihyeHwang09.github.io/tags/순환-함수/"},{"name":"재귀 함수","slug":"재귀-함수","permalink":"https://JihyeHwang09.github.io/tags/재귀-함수/"},{"name":"Recursion Function","slug":"recursion-function","permalink":"https://JihyeHwang09.github.io/tags/recursion-function/"},{"name":"수학적 귀납법","slug":"수학적-귀납법","permalink":"https://JihyeHwang09.github.io/tags/수학적-귀납법/"},{"name":"Mathematical Induction","slug":"mathematical-induction","permalink":"https://JihyeHwang09.github.io/tags/mathematical-induction/"}]},{"title":"카르노 도표(KARNAUGH MAP)","slug":"karnaugh-map","date":"2019-01-06T13:53:35.896Z","updated":"2019-01-07T10:33:28.058Z","comments":true,"path":"2019/01/06/karnaugh-map/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/06/karnaugh-map/","excerpt":"","text":"부울함수의 간소화 방법 중의 하나인 카르노 도표(KARNAUGH MAP)에 대해 알아봅시다. 카르노 도표 방법 카르노 도표는 여러 개의 사각형으로 된 다이어그램 사각형은 각각 하나의 최소항이나 최대항을 의미 여섯 개 이하의 변수를 가진 부울함수에 사용 카르노 도표는 부울함수의 입력변수의 수에 따라서 기본 도표의 형태가 결정됨 입력변수의 수가 n인 경우를 n변수 카르노 도표라고 하며, 2^n개의 사각형으로 구성됨 카르노 도표를 이용하면, 정규형 부울 함수 -&gt; 표준형 부울함수로 간소화할 수 있음 카르노 도표를 이용해서 부울함수의 각 항들을 곱이나 합 형태로 간소화 최소항의 합 -&gt; 곱의 합 최대항의 곱 -&gt; 합의 곱 형태로 간소화 됨 최소항의 합형을 곱의 합형으로 간소화하는 순서 입력변수의 수 n에 따라 n변수 카르노 도표 작성(도표는 2^n개의 정사각형) 최소항의 인덱스에 대응되는 사각형을 1로 표시 1로 표시된 사각형들 중 서로 인접한 사각형끼리 묶음 (주의! 이때 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.) 각 묶음이 입력변수 각각에 대해 도표상의 어떤 위치에 있는지 파악 4)에서 구한 각 묶음에 대한 곱항들을 논리합(OR)으로 연결시키면, 간소화된 표준형(곱의 합형)이 구해진다. 최대항의 곱형을 합의 곱형으로 간소화하는 순서 입력변수의 수 n에 따라 n변수 카르노 도표 작성(도표는 2^n개의 정사각형) 최소항의 인덱스에 대응되는 사각형을 0으로 표시 0으로 표시된 사각형들 중 서로 인접한 사각형끼리 묶음 (주의! 이때 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.) 각 묶음이 입력변수 각각에 대해 도표상의 어떤 위치에 있는지 파악 4)에서 구한 각 묶음에 대한 합항들을 논리곱(AND)으로 연결시키면, 간소화된 표준형(합의 곱형)이 구해진다. 인접 사각형의 정의 카르노 도표에서 각 정사각형은 하나의 최소항(또는 최대항)을 의미 따라서, 인접 사각형이란 두 정사각형에 대응되는 각 최소항(또는 최대항)의 구성변수 중 다른 모든 변수는 동일하되 오직 하나의 변수만 서로 보수관계에 있을 때 두 정사각형은 서로 인접한다”라고 정의 ex) 입력변수가 X, Y, Z 3개의 경우 인접 사각형끼리 묶는 방법 한 묶음 내의 정사각형의 수는 2^n(n = 0, 1, 2... n)개가 되도록 묶는다. 한 묶음은 크게, 전체 묶음의 수는 적게 묶는다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"카르노 도표","slug":"카르노-도표","permalink":"https://JihyeHwang09.github.io/tags/카르노-도표/"},{"name":"카르노 맵","slug":"카르노-맵","permalink":"https://JihyeHwang09.github.io/tags/카르노-맵/"},{"name":"karnaugh map","slug":"karnaugh-map","permalink":"https://JihyeHwang09.github.io/tags/karnaugh-map/"}]},{"title":"논리게이트(LOGIC GATE)","slug":"logic-gate","date":"2019-01-05T09:18:57.757Z","updated":"2019-01-07T10:28:28.084Z","comments":true,"path":"2019/01/05/logic-gate/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/05/logic-gate/","excerpt":"","text":"논리게이트(LOGIC GATE)의 종류에는 어떤 것들이 있는지와 각 논리게이트에 대한 기호, 진리표, 입출력 파형에 대해 알아봅시다. 논리게이트(LOGIC GATE)의 종류기본 논리게이트 AND 게이트 OR 게이트 NOT 게이트 NAND 게이트와 NOR 게이트 NAN 게이트 NOR 게이트 XOR 게이트와 XNOR 게이트 XOR 게이트 XNOR 게이트 논리게이트(LOGIC GATE)의 기호와 진리표, 입출력 파형1. 기본 논리게이트1) AND 게이트 반달 모양으로 표현 입력값이 둘 다 1일 경우에만 1이 출력되고, 나머지 경우에는 결과값이 0이 된다. 2) OR 게이트 반달 모양이되, 입력 부분이 움푹 들어간 모양으로 표현 입력값이 둘 다 0일 경우에만 결과값이 0이 되고,나머지 경우에는 결과값이 1이 된다. 3) NOT 게이트 세모 모양으로 표현, 출력부분에 작은 원을 그려준다. 입력값과 반대값이 출력된다. 2. NAND 게이트와 NOR 게이트1) NAND 게이트 AND 게이트의 반대 입력값이 둘 다 1일 경우에만 0이 출력되고, 나머지 경우에는 결과값이 1이 된다. 2) NOR 게이트 OR 게이트의 반대 입력값이 둘 다 0일 경우에만 1이 출력되고, 나머지 경우에는 결과값이 0이 된다. 반달 모양이되, 출력부분에 작은 원을 그려준다. 3. XOR 게이트와 XNOR 게이트1) XOR 게이트 입력값이 서로 다른 값이 들어온 경우에만 결과값이 1이 된다. 나머지 경우에는 0이 출력된다. 2) XNOR 게이트 입력값으로 서로 다른 값이 들어온 경우에만 결과값이 0이 된다. 나머지 경우에는 1이 출력된다.","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"논리게이트","slug":"논리게이트","permalink":"https://JihyeHwang09.github.io/tags/논리게이트/"},{"name":"logic gate","slug":"logic-gate","permalink":"https://JihyeHwang09.github.io/tags/logic-gate/"}]},{"title":"불 대수(Boolean algebra)","slug":"boolean-algebra","date":"2019-01-03T17:20:57.925Z","updated":"2019-01-07T10:30:50.797Z","comments":true,"path":"2019/01/04/boolean-algebra/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/04/boolean-algebra/","excerpt":"","text":"2진 디지털 시스템에서 입출력 관계를 표현하는 방법과 불 대수의 기본 개념 및 공식에 대해서 알아보고, 불 함수의 대수적 간소화에 대해서 공부해봅시다. 1. 2진 디지털 시스템에서 입출력 관계를 표현하는 방법1) 그래프나 진리표로 표시 2) 논리함수로 표시 입력에 따라 변수가 어떻게 변하는지를 나타내는 함수로 표현 입력이 2진 논리값이므로 논리함수로 나타낸다. 2. 불 대수의 기본 개념1) 불 대수(Boolean Algebra): 0과 1의 값을 갖는 논리변수와 논리연산을 다루는 대수 불 대수(Boolean algebra)는 하나의 명제가 참 또는 거짓인지를 판별하기 위해 이용되는 수학적 방법으로 19세기 중반 영국의 수학자 조지 불(George Boole)에 의해 개발되었다. 컴퓨터는 참과 거짓을 나타내기 위해 0과 1의 두 가지 상태로 표현하는 2진 논리회로로 구성되어 있다. 이러한 논리회로를 간략하게 표현할 때 불 대수가 사용된다. 2) 불 함수(Boolean Function): 논리변수의 상호관계를 나타내기 위해 불 변수, 불 연산기호, 괄호 및 등호 등으로 나타내는 대수적인 표현 AND 연산 입력값이 모두 1일 경우에만 결과값이 1이 된다. 표현법 X AND Y 또는 XY로 표현한다. 점으로 표시, 생략 가능 OR 연산 입력값 중 한 개라도 1일 경우 결과값이 1이 된다. 표현법 X OR Y 또는 X + Y로 표현한다. 덧셈 기호(+)로 표시 NOT 연산 입력값의 반대값이 출력된다. 표현법: NOT X 또는 X&#39;로 표현 변수 위에 줄(-)을 그어 표시 3. 불 대수의 기본 공식교환법칙, 결합법칙, 분배법칙, 드모르간의 법칙, 흡수 법칙 등을 이용하여회로를 쉽게 간소화할 수 있다. 4. 불 함수(논리식)의 대수적 간소화불 대수의 기본 공식을 이용해서 논리식을 간소화한다. 1) 합의 곱 표현을 곱의 합표현으로 변환한다. 합의 곱: (A + B)(C + D) 곱의 합: AC + AD + BC + BD 2) 공통 인수를 뽑아서 묶는다.3) 기본 공식 형태로 유도해서 식을 줄여 나간다.항 결합 X + X&#39; = 1이라는 성질을 이용한다. 문자 소거","categories":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/"},{"name":"전자계산기 구조","slug":"정보처리기사/전자계산기-구조","permalink":"https://JihyeHwang09.github.io/categories/정보처리기사/전자계산기-구조/"}],"tags":[{"name":"정보처리기사","slug":"정보처리기사","permalink":"https://JihyeHwang09.github.io/tags/정보처리기사/"},{"name":"전자계산기 구조","slug":"전자계산기-구조","permalink":"https://JihyeHwang09.github.io/tags/전자계산기-구조/"},{"name":"논리회로","slug":"논리회로","permalink":"https://JihyeHwang09.github.io/tags/논리회로/"},{"name":"boole","slug":"boole","permalink":"https://JihyeHwang09.github.io/tags/boole/"},{"name":"boolean algebra","slug":"boolean-algebra","permalink":"https://JihyeHwang09.github.io/tags/boolean-algebra/"}]},{"title":"Hexo를 이용한 블로그 만들기","slug":"hexo-blog","date":"2019-01-03T09:09:51.675Z","updated":"2019-01-06T14:35:43.749Z","comments":true,"path":"2019/01/03/hexo-blog/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/03/hexo-blog/","excerpt":"","text":"지난 포스트에서 정적블로그 플랫폼의 종류와 차이에 대해 소개했습니다.이번에는 Hexo를 이용한 블로그 만드는 방법에 대해 정리해봅시다. 1. Git, Nods.js 설치하기Hexo 블로그를 만들기 전, Git과 Node.js가 설치되어 있어야 합니다.Git과 Node.js가 이미 설치되어 있으신 분들은 2번부터 읽으시면 됩니다:) 1) Git 설치Git 다운로드 페이지 2) Node.js 설치Node.js 다운로드 페이지 2. GitHub 프로젝트(Repository) 만들기블로그의 포스트를 관리할 GitHub Repository를 만드는 과정입니다. GitHub 홈페이지 GitHub에 회원가입 후, 로그인을 합니다. 로그인 후, 우측 상단에 있는 초록색의 New를 눌러줍니다. Repository name에는 GitHub 계정명과 동일한 username을 사용하여 username.github.io로 작성한 후, Create repository 버튼을 누릅니다. 3. Hexo 설치하기 Git을 설치하면,Git Bash가 있으실 겁니다. 1) Git Bash를 실행시킵니다. 2) 터미널 화면에 $를 제외한 부분을 작성하고 Enter를 누르면,Hexo가 설치됩니다.1$ npm install -g hexo-cli 3) 블로그를 만들고 싶은 폴더 위치로 이동합니다. 그 후, 아래 코드를 입력합니다.blog 자리에 자신이 원하는 블로그 이름을 넣습니다.1$ hexo init blog 4) 자신이 원하는 폴더 위치에 blog 이름으로 된 폴더가 생성됩니다.현재 위치에서 블로그 이름으로 된 폴더로 이동합니다.1$ cd blog 5) npm을 설치합니다.1$ npm install 4. Hexo 실행해보기1$ hexo server 로컬서버인 http://localhost:4000로 접속하면, Hexo 블로그가 만들어진 것을 확인할 수 있습니다. Hexo 서버를 종료하려면, Ctrl + C를 눌러줍니다. Tip! 코드를 복사하고 싶은 경우에는 Ctrl + C가 아닌, Ctrl+Ins를 눌러줍니다. 5. Hexo 포스트 작성하기위와 같이 Hexo 설치가 완료되었다면, 이제 포스트를 작성해볼까요? 기본 명령어와 축약 명령어 중에 편하신 명령어를 입력해 줍니다. hexo new나 hexo n 뒤에는 포스트 제목을 적어줍니다. 1234$ hexo new firstpost// 기본 명령어$ hexo n firstpost// 축약 명령어 위의 명령어를 실행하여, firstpost.md라는 마크다운 파일을 생성합니다. 1$ code . 현재 생성된 firstpost.md파일을 Visual Studio Code로 열어줍니다. 위와 같은 디렉토리에 firstpost.md이라는 마크다운 파일이 생성된 것을 확인할 수 있습니다. firstpost.md 파일을 열면, 다음과 같이 작성되어 있습니다. 12345---title: firstpostdate: 2019-01-03 19:42:59tags:--- title은 자동으로 파일명과 똑같이 설정됩니다. 원하는 title로 수정한 후,아래의 ---의 다음 줄부터 마크다운 문법을 이용하여 글을 작성하시면 됩니다. 글 작성시, 실시간으로 포스팅한 모습을 확인하고 싶을 때는 터미널에 아래와 같은 명령어를 입력해줍니다. 1234$ hexo server// 기본 명령어$ hexo s// 축약 명령어 웹 브라우저에서 localhost:4000 경로로 접속하시면, 블로그의 모습을 실시간으로 확인할 수 있습니다. 포스트를 작성한 후, 실제로 서버에 올라갈 정적 페이지를 생성해줍니다. 1234$ hexo generate// 기본 명령어$ hexo g// 축약 명령어 터미널에서 위 코드를 실행하면, blog/public/ 디렉토리 아래에 실제 서버에 올라갈 웹페이지가 생성된 것을 확인할 수 있습니다. 6. GitHub과 Hexo를 연결해주기 로컬 외에 외부에서도 볼 수 있도록 서버에 올립니다. 1) GitHub에 Deploy 해 줄 플러그인을 설치합니다.1$ npm install --save hexo-deployer-git 2) Hexo 설정파일인 _config.yml를 열어서 #URL부분과 #Deployment부분을 수정해 줍니다. #URL부분을 위와 같이 수정해줍니다. #Deployment부분 역시 위와 같이 수정해줍니다. 3) GitHub 서버에 파일 올리기 터미널에서 명령어를 실행하여, GitHub 서버에 블로그 파일을 올려줍니다. 1234$ hexo deployment// 기본 명령어$ hexo d// 축약 명령어 Tip! 정적 페이지 생성과 배포를 함께 하고 싶다면, 아래 코드를 입력해줍니다.1$ hexo g -d 포스트 작성시 참고한 링크 [블로그 프레임워크 Hexo]:https://mechanickim.github.io/2018/03/17/20180317_blog_hexo/index.html [Github pages와 Hexo를 이용하여 블로그 만들기]:http://blog.lattecom.xyz/2016/06/28/hexo-blog-github-pages [GitLab Pages에 Hexo 블로그 설치하기]:http://inote.gitlab.io/2017/GitLab%EC%97%90%EC%84%9C%20Hexo%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0 [Hexo 블로그 만들기 1]:https://wonheesoo.github.io/2018/01/13/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-1-%EC%84%9C%EB%A1%A0-Hexo%EC%99%80-Github-Page-%EC%A1%B0%ED%95%A9%ED%95%98%EA%B8%B0 [Hexo, 정말 쉬운 블로그 프레임워크]:https://m.blog.naver.com/future_creator/220722153999 [Hexo로 Github 블로그 만들기]:https://medium.com/@dongmi.public/why-hexo-67070b1e0cc3 Reference [Hexo 공식 홈페이지 문서(한글)]:https://hexo.io/ko/docs/ [마크다운 문서 작성법]:https://gist.github.com/ihoneymon/652be052a0727ad59601","categories":[{"name":"Blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/categories/blog/"},{"name":"Hexo","slug":"blog/hexo","permalink":"https://JihyeHwang09.github.io/categories/blog/hexo/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/tags/blog/"},{"name":"framework","slug":"framework","permalink":"https://JihyeHwang09.github.io/tags/framework/"},{"name":"platform","slug":"platform","permalink":"https://JihyeHwang09.github.io/tags/platform/"},{"name":"hexo","slug":"hexo","permalink":"https://JihyeHwang09.github.io/tags/hexo/"},{"name":"Static Web Generator","slug":"static-web-generator","permalink":"https://JihyeHwang09.github.io/tags/static-web-generator/"},{"name":"git","slug":"git","permalink":"https://JihyeHwang09.github.io/tags/git/"},{"name":"node.js","slug":"node-js","permalink":"https://JihyeHwang09.github.io/tags/node-js/"}]},{"title":"정적블로그 플랫폼(Static Web Generator)의 비교","slug":"blog-platform","date":"2019-01-02T08:09:11.680Z","updated":"2019-01-06T14:38:26.538Z","comments":true,"path":"2019/01/02/blog-platform/","link":"","permalink":"https://JihyeHwang09.github.io/2019/01/02/blog-platform/","excerpt":"","text":"정적 블로그 플랫폼 설명에 앞서,정적 웹페이지와 동적 웹페이지란 무엇이며 어떤 차이가 있는지를 살펴봅시다. 정적 페이지 VS 동적 페이지정적(static) 페이지 단순히 사이트 관리자가 미리 만들어놓은 웹 페이지를 볼 수 있는 사이트 데이터베이스(DB)를 사용하지 않음 Jekyll, Hexo, Hugo 등 동적(dynamic) 페이지 컨텐츠 내용이 서버에 있는 DB에 저장-&gt; 그 결과가 웹페이지에 반영되는 형태로 동작 일반적인 게시판 형태의 사이트들이 사용하는 방식 티스토리, 네이버 블로그 등 정적블로그 플랫폼(Static Web Generator)의 비교(Jekyll, Hexo, Hugo) Jekyll 특징 Ruby 기반 Github Page에 Git History 충돌 없이 포스트 버전관리 가능 GitHub Page는 Jekyll에 최적화되어 있음 한글 레퍼런스가 가장 많음 현재 가장 많은 사용자를 보유(Github 별 개수가 가장 많음) 단점 Ruby기반으로 초기 구축에 어려움이 있음(Ruby를 모르면, 플러그인 등 커스터마이징 하는데 불편할 수 있음) 윈도우 공식 지원 안됨 컴파일 속도가 느림 Hugo 특징 Golang 기반 컴파일 속도가 빠름(Jekyll, Hexo와 비교시 가장 빠름) 문서화가 잘 되어 있음 단점: 한글 레퍼런스가 거의 없음 Hexo 특징 자바스크립트(node.js) 기반 Node.js가 설치되어 있어야 하며, 기본적인 npm 사용 방법을 알아야 함 마크다운 문서로 만든 포스팅을 하는 방법이 간단함 윈도우 지원됨 컴파일 속도가 빠름 단점 Git으로 포스트 버전관리가 불가능함-&gt; 버전 관리를 위해서는 두 가지 브랜치를 따서 관리해야 함 Node.js의 템플릿 엔진을 그대로 사용 불가능(Github Page에는 Jekyll이 내장되어 있기 때문) 영어보다는 중국어로 된 질의응답이 많음 결론 앞서 살펴보았듯이 블로그 플랫폼 각각이 장단점을 가지고 있기 때문에우위를 따질 수는 없는 것 같습니다. 다만, 각 플랫폼의 장단점을 고려한 후, 본인에게 맞는 블로그 플랫폼을 선택하시는 게 좋겠죠:) 저는 비교적 익숙한 언어인 JavaScript 기반인 Hexo로 블로그를 시작하고, 차후에 Hugo로 이전을 고려해보는 방향으로 가닥을 잡았습니다. 포스트 작성시 참고한 링크 [정적 웹페이지 vs 동적 웹페이지]: http://snowdeer.github.io/blog/2016/03/21/static-dynamic-webpage [jekyll 블로그 프레임워크 비교, 왜 지킬인가? (feat. jekyll, hexo, hugo)]: https://qvil.github.io/blog/why-jekyll/#what [hugo + github 블로그 만들기 (feat. hugo &amp; github page)]: https://github.com/Integerous/Integerous.github.io [깃헙을 이용하여 호스팅하기]: https://www.slideshare.net/ssuser458523/ss-77033329 [정적 블로그, hexo 설치]: https://engineering.huiseoul.com/%EC%A0%95%EC%A0%81-%EB%B8%94%EB%A1%9C%EA%B7%B8-hexo-%EC%84%A4%EC%B9%98-f8df865a693a [웹의 이해 정적 페이지,동적 페이지 ]: http://coashanee5.blogspot.com/2017/07/blog-post_25.html","categories":[{"name":"Blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/categories/blog/"},{"name":"Hexo","slug":"blog/hexo","permalink":"https://JihyeHwang09.github.io/categories/blog/hexo/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://JihyeHwang09.github.io/tags/blog/"},{"name":"framework","slug":"framework","permalink":"https://JihyeHwang09.github.io/tags/framework/"},{"name":"platform","slug":"platform","permalink":"https://JihyeHwang09.github.io/tags/platform/"},{"name":"hexo","slug":"hexo","permalink":"https://JihyeHwang09.github.io/tags/hexo/"},{"name":"Static Web Generator","slug":"static-web-generator","permalink":"https://JihyeHwang09.github.io/tags/static-web-generator/"},{"name":"Jekyll","slug":"jekyll","permalink":"https://JihyeHwang09.github.io/tags/jekyll/"},{"name":"Hugo","slug":"hugo","permalink":"https://JihyeHwang09.github.io/tags/hugo/"}]}]}